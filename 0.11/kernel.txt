
kernel.sym:     file format elf32-i386


Disassembly of section .text:

00000000 <pg_dir>:
.text
.globl idt,gdt,pg_dir,tmp_floppy_area
pg_dir:
.globl startup_32
startup_32:
	movl $0x10,%eax
       0:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
       5:	8e d8                	mov    %eax,%ds
	mov %ax,%es
       7:	8e c0                	mov    %eax,%es
	mov %ax,%fs
       9:	8e e0                	mov    %eax,%fs
	mov %ax,%gs
       b:	8e e8                	mov    %eax,%gs
	lss stack_start,%esp
       d:	0f b2 25 60 f2 01 00 	lss    0x1f260,%esp
	call setup_idt
      14:	e8 58 00 00 00       	call   71 <setup_idt>
	call setup_gdt
      19:	e8 83 00 00 00       	call   a1 <setup_gdt>
	movl $0x10,%eax		# reload all the segment registers
      1e:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds		# after changing gdt. CS was already
      23:	8e d8                	mov    %eax,%ds
	mov %ax,%es		# reloaded in 'setup_gdt'
      25:	8e c0                	mov    %eax,%es
	mov %ax,%fs
      27:	8e e0                	mov    %eax,%fs
	mov %ax,%gs
      29:	8e e8                	mov    %eax,%gs
	lss stack_start,%esp
      2b:	0f b2 25 60 f2 01 00 	lss    0x1f260,%esp
	xorl %eax,%eax
      32:	31 c0                	xor    %eax,%eax
1:	incl %eax		# check that A20 really IS enabled
      34:	40                   	inc    %eax
	movl %eax,0x000000	# loop forever if it isn't
      35:	a3 00 00 00 00       	mov    %eax,0x0
	cmpl %eax,0x100000
      3a:	39 05 00 00 10 00    	cmp    %eax,0x100000
	je 1b
      40:	74 f2                	je     34 <OLDSS+0x8>
 * NOTE! 486 should set bit 16, to check for write-protect in supervisor
 * mode. Then it would be unnecessary with the "verify_area()"-calls.
 * 486 users probably want to set the NE (#5) bit also, so as to use
 * int 16 for math errors.
 */
	movl %cr0,%eax		# check math chip
      42:	0f 20 c0             	mov    %cr0,%eax
	andl $0x80000011,%eax	# Save PG,PE,ET
      45:	25 11 00 00 80       	and    $0x80000011,%eax
/* "orl $0x10020,%eax" here for 486 might be good */
	orl $2,%eax		# set MP
      4a:	83 c8 02             	or     $0x2,%eax
	movl %eax,%cr0
      4d:	0f 22 c0             	mov    %eax,%cr0
	call check_x87
      50:	e8 05 00 00 00       	call   5a <check_x87>
	jmp after_page_tables
      55:	e9 a6 53 00 00       	jmp    5400 <after_page_tables>

0000005a <check_x87>:

/*
 * We depend on ET to be correct. This checks for 287/387.
 */
check_x87:
	fninit
      5a:	db e3                	fninit 
	fstsw %ax
      5c:	9b df e0             	fstsw  %ax
	cmpb $0,%al
      5f:	3c 00                	cmp    $0x0,%al
	je 1f			/* no coprocessor: have to set bits */
      61:	74 0b                	je     6e <check_x87+0x14>
	movl %cr0,%eax
      63:	0f 20 c0             	mov    %cr0,%eax
	xorl $6,%eax		/* reset MP, set EM */
      66:	83 f0 06             	xor    $0x6,%eax
	movl %eax,%cr0
      69:	0f 22 c0             	mov    %eax,%cr0
	ret
      6c:	c3                   	ret    
      6d:	90                   	nop
      6e:	db e4                	fnsetpm(287 only) 
.align 2
1:	.byte 0xDB,0xE4		/* fsetpm for 287, ignored by 387 */
	ret
      70:	c3                   	ret    

00000071 <setup_idt>:
 *  are enabled elsewhere, when we can be relatively
 *  sure everything is ok. This routine will be over-
 *  written by the page tables.
 */
setup_idt:
	lea ignore_int,%edx
      71:	8d 15 28 54 00 00    	lea    0x5428,%edx
	movl $0x00080000,%eax
      77:	b8 00 00 08 00       	mov    $0x80000,%eax
	movw %dx,%ax		/* selector = 0x0008 = cs */
      7c:	66 89 d0             	mov    %dx,%ax
	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */
      7f:	66 ba 00 8e          	mov    $0x8e00,%dx

	lea idt,%edi
      83:	8d 3d b8 54 00 00    	lea    0x54b8,%edi
	mov $256,%ecx
      89:	b9 00 01 00 00       	mov    $0x100,%ecx

0000008e <rp_sidt>:
rp_sidt:
	movl %eax,(%edi)
      8e:	89 07                	mov    %eax,(%edi)
	movl %edx,4(%edi)
      90:	89 57 04             	mov    %edx,0x4(%edi)
	addl $8,%edi
      93:	83 c7 08             	add    $0x8,%edi
	dec %ecx
      96:	49                   	dec    %ecx
	jne rp_sidt
      97:	75 f5                	jne    8e <rp_sidt>
	lidt idt_descr
      99:	0f 01 1d aa 54 00 00 	lidtl  0x54aa
	ret
      a0:	c3                   	ret    

000000a1 <setup_gdt>:
 *  is VERY complicated at two whole lines, so this
 *  rather long comment is certainly needed :-).
 *  This routine will beoverwritten by the page tables.
 */
setup_gdt:
	lgdt gdt_descr
      a1:	0f 01 15 b2 54 00 00 	lgdtl  0x54b2
	ret
      a8:	c3                   	ret    
	...

00001000 <pg0>:
	...

00002000 <pg1>:
	...

00003000 <pg2>:
	...

00004000 <pg3>:
	...

00005000 <tmp_floppy_area>:
	...

00005400 <after_page_tables>:
 */
tmp_floppy_area:
	.fill 1024,1,0

after_page_tables:
	pushl $0		# These are the parameters to main :-)
    5400:	6a 00                	push   $0x0
	pushl $0
    5402:	6a 00                	push   $0x0
	pushl $0
    5404:	6a 00                	push   $0x0
	pushl $L6		# return address for main, if it decides to.
    5406:	68 12 54 00 00       	push   $0x5412
	pushl $main
    540b:	68 41 67 00 00       	push   $0x6741
	jmp setup_paging
    5410:	eb 3c                	jmp    544e <setup_paging>

00005412 <L6>:
L6:
	jmp L6			# main should never return here, but
    5412:	eb fe                	jmp    5412 <L6>

00005414 <int_msg>:
    5414:	55                   	push   %ebp
    5415:	6e                   	outsb  %ds:(%esi),(%dx)
    5416:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
    541a:	6e                   	outsb  %ds:(%esi),(%dx)
    541b:	20 69 6e             	and    %ch,0x6e(%ecx)
    541e:	74 65                	je     5485 <setup_paging+0x37>
    5420:	72 72                	jb     5494 <setup_paging+0x46>
    5422:	75 70                	jne    5494 <setup_paging+0x46>
    5424:	74 0a                	je     5430 <ignore_int+0x8>
    5426:	0d                   	.byte 0xd
	...

00005428 <ignore_int>:
/* This is the default interrupt "handler" :-) */
int_msg:
	.asciz "Unknown interrupt\n\r"
.align 2
ignore_int:
	pushl %eax
    5428:	50                   	push   %eax
	pushl %ecx
    5429:	51                   	push   %ecx
	pushl %edx
    542a:	52                   	push   %edx
	push %ds
    542b:	1e                   	push   %ds
	push %es
    542c:	06                   	push   %es
	push %fs
    542d:	0f a0                	push   %fs
	movl $0x10,%eax
    542f:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
    5434:	8e d8                	mov    %eax,%ds
	mov %ax,%es
    5436:	8e c0                	mov    %eax,%es
	mov %ax,%fs
    5438:	8e e0                	mov    %eax,%fs
	pushl $int_msg
    543a:	68 14 54 00 00       	push   $0x5414
	call printk
    543f:	e8 c9 33 00 00       	call   880d <printk>
	popl %eax
    5444:	58                   	pop    %eax
	pop %fs
    5445:	0f a1                	pop    %fs
	pop %es
    5447:	07                   	pop    %es
	pop %ds
    5448:	1f                   	pop    %ds
	popl %edx
    5449:	5a                   	pop    %edx
	popl %ecx
    544a:	59                   	pop    %ecx
	popl %eax
    544b:	58                   	pop    %eax
	iret
    544c:	cf                   	iret   
    544d:	90                   	nop

0000544e <setup_paging>:
 * some kind of marker at them (search for "16Mb"), but I
 * won't guarantee that's all :-( )
 */
.align 2
setup_paging:
	movl $1024*5,%ecx		/* 5 pages - pg_dir+4 page tables */
    544e:	b9 00 14 00 00       	mov    $0x1400,%ecx
	xorl %eax,%eax
    5453:	31 c0                	xor    %eax,%eax
	xorl %edi,%edi			/* pg_dir is at 0x000 */
    5455:	31 ff                	xor    %edi,%edi
	cld;rep;stosl
    5457:	fc                   	cld    
    5458:	f3 ab                	rep stos %eax,%es:(%edi)
	movl $pg0+7,pg_dir		/* set present bit/user r/w */
    545a:	c7 05 00 00 00 00 07 	movl   $0x1007,0x0
    5461:	10 00 00 
	movl $pg1+7,pg_dir+4		/*  --------- " " --------- */
    5464:	c7 05 04 00 00 00 07 	movl   $0x2007,0x4
    546b:	20 00 00 
	movl $pg2+7,pg_dir+8		/*  --------- " " --------- */
    546e:	c7 05 08 00 00 00 07 	movl   $0x3007,0x8
    5475:	30 00 00 
	movl $pg3+7,pg_dir+12		/*  --------- " " --------- */
    5478:	c7 05 0c 00 00 00 07 	movl   $0x4007,0xc
    547f:	40 00 00 
	movl $pg3+4092,%edi
    5482:	bf fc 4f 00 00       	mov    $0x4ffc,%edi
	movl $0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) */
    5487:	b8 07 f0 ff 00       	mov    $0xfff007,%eax
	std
    548c:	fd                   	std    
1:	stosl			/* fill pages backwards - more efficient :-) */
    548d:	ab                   	stos   %eax,%es:(%edi)
	subl $0x1000,%eax
    548e:	2d 00 10 00 00       	sub    $0x1000,%eax
	jge 1b
    5493:	7d f8                	jge    548d <setup_paging+0x3f>
	cld
    5495:	fc                   	cld    
	xorl %eax,%eax		/* pg_dir is at 0x0000 */
    5496:	31 c0                	xor    %eax,%eax
	movl %eax,%cr3		/* cr3 - page directory start */
    5498:	0f 22 d8             	mov    %eax,%cr3
	movl %cr0,%eax
    549b:	0f 20 c0             	mov    %cr0,%eax
	orl $0x80000000,%eax
    549e:	0d 00 00 00 80       	or     $0x80000000,%eax
	movl %eax,%cr0		/* set paging (PG) bit */
    54a3:	0f 22 c0             	mov    %eax,%cr0
	ret			/* this also flushes prefetch-queue */
    54a6:	c3                   	ret    
    54a7:	90                   	nop
	...

000054aa <idt_descr>:
    54aa:	ff 07                	incl   (%edi)
    54ac:	b8 54 00 00 00       	mov    $0x54,%eax
	...

000054b2 <gdt_descr>:
    54b2:	ff 07                	incl   (%edi)
    54b4:	b8                   	.byte 0xb8
    54b5:	5c                   	pop    %esp
	...

000054b8 <idt>:
	...

00005cb8 <gdt>:
	...
    5cc0:	ff 0f                	decl   (%edi)
    5cc2:	00 00                	add    %al,(%eax)
    5cc4:	00 9a c0 00 ff 0f    	add    %bl,0xfff00c0(%edx)
    5cca:	00 00                	add    %al,(%eax)
    5ccc:	00 92 c0 00 00 00    	add    %dl,0xc0(%edx)
	...

000064b8 <setup>:
 */
static inline int fork(void) __attribute__((always_inline));
static inline int pause(void) __attribute__((always_inline));
static inline _syscall0(int,fork)
static inline _syscall0(int,pause)
static inline _syscall1(int,setup,void *,BIOS)
    64b8:	53                   	push   %ebx
    64b9:	83 ec 10             	sub    $0x10,%esp
    64bc:	8b 54 24 18          	mov    0x18(%esp),%edx
    64c0:	b8 00 00 00 00       	mov    $0x0,%eax
    64c5:	89 d3                	mov    %edx,%ebx
    64c7:	cd 80                	int    $0x80
    64c9:	89 44 24 0c          	mov    %eax,0xc(%esp)
    64cd:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    64d2:	78 06                	js     64da <setup+0x22>
    64d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    64d8:	eb 10                	jmp    64ea <setup+0x32>
    64da:	8b 44 24 0c          	mov    0xc(%esp),%eax
    64de:	f7 d8                	neg    %eax
    64e0:	a3 68 5f 02 00       	mov    %eax,0x25f68
    64e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    64ea:	83 c4 10             	add    $0x10,%esp
    64ed:	5b                   	pop    %ebx
    64ee:	c3                   	ret    

000064ef <sync>:
static inline _syscall0(int,sync)
    64ef:	83 ec 10             	sub    $0x10,%esp
    64f2:	b8 24 00 00 00       	mov    $0x24,%eax
    64f7:	cd 80                	int    $0x80
    64f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
    64fd:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    6502:	78 06                	js     650a <sync+0x1b>
    6504:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6508:	eb 10                	jmp    651a <sync+0x2b>
    650a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    650e:	f7 d8                	neg    %eax
    6510:	a3 68 5f 02 00       	mov    %eax,0x25f68
    6515:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    651a:	83 c4 10             	add    $0x10,%esp
    651d:	c3                   	ret    

0000651e <time_init>:
})

#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)

static void time_init(void)
{
    651e:	83 ec 3c             	sub    $0x3c,%esp
	struct tm time;

	do {
		time.tm_sec = CMOS_READ(0);
    6521:	b8 80 00 00 00       	mov    $0x80,%eax
    6526:	ba 70 00 00 00       	mov    $0x70,%edx
    652b:	ee                   	out    %al,(%dx)
    652c:	eb 00                	jmp    652e <time_init+0x10>
    652e:	eb 00                	jmp    6530 <time_init+0x12>
    6530:	b8 71 00 00 00       	mov    $0x71,%eax
    6535:	89 c2                	mov    %eax,%edx
    6537:	ec                   	in     (%dx),%al
    6538:	eb 00                	jmp    653a <time_init+0x1c>
    653a:	eb 00                	jmp    653c <time_init+0x1e>
    653c:	88 44 24 2f          	mov    %al,0x2f(%esp)
    6540:	0f b6 44 24 2f       	movzbl 0x2f(%esp),%eax
    6545:	0f b6 c0             	movzbl %al,%eax
    6548:	89 44 24 04          	mov    %eax,0x4(%esp)
		time.tm_min = CMOS_READ(2);
    654c:	b8 82 00 00 00       	mov    $0x82,%eax
    6551:	ba 70 00 00 00       	mov    $0x70,%edx
    6556:	ee                   	out    %al,(%dx)
    6557:	eb 00                	jmp    6559 <time_init+0x3b>
    6559:	eb 00                	jmp    655b <time_init+0x3d>
    655b:	b8 71 00 00 00       	mov    $0x71,%eax
    6560:	89 c2                	mov    %eax,%edx
    6562:	ec                   	in     (%dx),%al
    6563:	eb 00                	jmp    6565 <time_init+0x47>
    6565:	eb 00                	jmp    6567 <time_init+0x49>
    6567:	88 44 24 2e          	mov    %al,0x2e(%esp)
    656b:	0f b6 44 24 2e       	movzbl 0x2e(%esp),%eax
    6570:	0f b6 c0             	movzbl %al,%eax
    6573:	89 44 24 08          	mov    %eax,0x8(%esp)
		time.tm_hour = CMOS_READ(4);
    6577:	b8 84 00 00 00       	mov    $0x84,%eax
    657c:	ba 70 00 00 00       	mov    $0x70,%edx
    6581:	ee                   	out    %al,(%dx)
    6582:	eb 00                	jmp    6584 <time_init+0x66>
    6584:	eb 00                	jmp    6586 <time_init+0x68>
    6586:	b8 71 00 00 00       	mov    $0x71,%eax
    658b:	89 c2                	mov    %eax,%edx
    658d:	ec                   	in     (%dx),%al
    658e:	eb 00                	jmp    6590 <time_init+0x72>
    6590:	eb 00                	jmp    6592 <time_init+0x74>
    6592:	88 44 24 2d          	mov    %al,0x2d(%esp)
    6596:	0f b6 44 24 2d       	movzbl 0x2d(%esp),%eax
    659b:	0f b6 c0             	movzbl %al,%eax
    659e:	89 44 24 0c          	mov    %eax,0xc(%esp)
		time.tm_mday = CMOS_READ(7);
    65a2:	b8 87 00 00 00       	mov    $0x87,%eax
    65a7:	ba 70 00 00 00       	mov    $0x70,%edx
    65ac:	ee                   	out    %al,(%dx)
    65ad:	eb 00                	jmp    65af <time_init+0x91>
    65af:	eb 00                	jmp    65b1 <time_init+0x93>
    65b1:	b8 71 00 00 00       	mov    $0x71,%eax
    65b6:	89 c2                	mov    %eax,%edx
    65b8:	ec                   	in     (%dx),%al
    65b9:	eb 00                	jmp    65bb <time_init+0x9d>
    65bb:	eb 00                	jmp    65bd <time_init+0x9f>
    65bd:	88 44 24 2c          	mov    %al,0x2c(%esp)
    65c1:	0f b6 44 24 2c       	movzbl 0x2c(%esp),%eax
    65c6:	0f b6 c0             	movzbl %al,%eax
    65c9:	89 44 24 10          	mov    %eax,0x10(%esp)
		time.tm_mon = CMOS_READ(8);
    65cd:	b8 88 00 00 00       	mov    $0x88,%eax
    65d2:	ba 70 00 00 00       	mov    $0x70,%edx
    65d7:	ee                   	out    %al,(%dx)
    65d8:	eb 00                	jmp    65da <time_init+0xbc>
    65da:	eb 00                	jmp    65dc <time_init+0xbe>
    65dc:	b8 71 00 00 00       	mov    $0x71,%eax
    65e1:	89 c2                	mov    %eax,%edx
    65e3:	ec                   	in     (%dx),%al
    65e4:	eb 00                	jmp    65e6 <time_init+0xc8>
    65e6:	eb 00                	jmp    65e8 <time_init+0xca>
    65e8:	88 44 24 2b          	mov    %al,0x2b(%esp)
    65ec:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
    65f1:	0f b6 c0             	movzbl %al,%eax
    65f4:	89 44 24 14          	mov    %eax,0x14(%esp)
		time.tm_year = CMOS_READ(9);
    65f8:	b8 89 00 00 00       	mov    $0x89,%eax
    65fd:	ba 70 00 00 00       	mov    $0x70,%edx
    6602:	ee                   	out    %al,(%dx)
    6603:	eb 00                	jmp    6605 <time_init+0xe7>
    6605:	eb 00                	jmp    6607 <time_init+0xe9>
    6607:	b8 71 00 00 00       	mov    $0x71,%eax
    660c:	89 c2                	mov    %eax,%edx
    660e:	ec                   	in     (%dx),%al
    660f:	eb 00                	jmp    6611 <time_init+0xf3>
    6611:	eb 00                	jmp    6613 <time_init+0xf5>
    6613:	88 44 24 2a          	mov    %al,0x2a(%esp)
    6617:	0f b6 44 24 2a       	movzbl 0x2a(%esp),%eax
    661c:	0f b6 c0             	movzbl %al,%eax
    661f:	89 44 24 18          	mov    %eax,0x18(%esp)
	} while (time.tm_sec != CMOS_READ(0));
    6623:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    6627:	b8 80 00 00 00       	mov    $0x80,%eax
    662c:	ba 70 00 00 00       	mov    $0x70,%edx
    6631:	ee                   	out    %al,(%dx)
    6632:	eb 00                	jmp    6634 <time_init+0x116>
    6634:	eb 00                	jmp    6636 <time_init+0x118>
    6636:	b8 71 00 00 00       	mov    $0x71,%eax
    663b:	89 c2                	mov    %eax,%edx
    663d:	ec                   	in     (%dx),%al
    663e:	eb 00                	jmp    6640 <time_init+0x122>
    6640:	eb 00                	jmp    6642 <time_init+0x124>
    6642:	88 44 24 29          	mov    %al,0x29(%esp)
    6646:	0f b6 44 24 29       	movzbl 0x29(%esp),%eax
    664b:	0f b6 c0             	movzbl %al,%eax
    664e:	39 c1                	cmp    %eax,%ecx
    6650:	0f 85 cb fe ff ff    	jne    6521 <time_init+0x3>
	BCD_TO_BIN(time.tm_sec);
    6656:	8b 44 24 04          	mov    0x4(%esp),%eax
    665a:	83 e0 0f             	and    $0xf,%eax
    665d:	89 c1                	mov    %eax,%ecx
    665f:	8b 44 24 04          	mov    0x4(%esp),%eax
    6663:	c1 f8 04             	sar    $0x4,%eax
    6666:	89 c2                	mov    %eax,%edx
    6668:	89 d0                	mov    %edx,%eax
    666a:	c1 e0 02             	shl    $0x2,%eax
    666d:	01 d0                	add    %edx,%eax
    666f:	01 c0                	add    %eax,%eax
    6671:	01 c8                	add    %ecx,%eax
    6673:	89 44 24 04          	mov    %eax,0x4(%esp)
	BCD_TO_BIN(time.tm_min);
    6677:	8b 44 24 08          	mov    0x8(%esp),%eax
    667b:	83 e0 0f             	and    $0xf,%eax
    667e:	89 c1                	mov    %eax,%ecx
    6680:	8b 44 24 08          	mov    0x8(%esp),%eax
    6684:	c1 f8 04             	sar    $0x4,%eax
    6687:	89 c2                	mov    %eax,%edx
    6689:	89 d0                	mov    %edx,%eax
    668b:	c1 e0 02             	shl    $0x2,%eax
    668e:	01 d0                	add    %edx,%eax
    6690:	01 c0                	add    %eax,%eax
    6692:	01 c8                	add    %ecx,%eax
    6694:	89 44 24 08          	mov    %eax,0x8(%esp)
	BCD_TO_BIN(time.tm_hour);
    6698:	8b 44 24 0c          	mov    0xc(%esp),%eax
    669c:	83 e0 0f             	and    $0xf,%eax
    669f:	89 c1                	mov    %eax,%ecx
    66a1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    66a5:	c1 f8 04             	sar    $0x4,%eax
    66a8:	89 c2                	mov    %eax,%edx
    66aa:	89 d0                	mov    %edx,%eax
    66ac:	c1 e0 02             	shl    $0x2,%eax
    66af:	01 d0                	add    %edx,%eax
    66b1:	01 c0                	add    %eax,%eax
    66b3:	01 c8                	add    %ecx,%eax
    66b5:	89 44 24 0c          	mov    %eax,0xc(%esp)
	BCD_TO_BIN(time.tm_mday);
    66b9:	8b 44 24 10          	mov    0x10(%esp),%eax
    66bd:	83 e0 0f             	and    $0xf,%eax
    66c0:	89 c1                	mov    %eax,%ecx
    66c2:	8b 44 24 10          	mov    0x10(%esp),%eax
    66c6:	c1 f8 04             	sar    $0x4,%eax
    66c9:	89 c2                	mov    %eax,%edx
    66cb:	89 d0                	mov    %edx,%eax
    66cd:	c1 e0 02             	shl    $0x2,%eax
    66d0:	01 d0                	add    %edx,%eax
    66d2:	01 c0                	add    %eax,%eax
    66d4:	01 c8                	add    %ecx,%eax
    66d6:	89 44 24 10          	mov    %eax,0x10(%esp)
	BCD_TO_BIN(time.tm_mon);
    66da:	8b 44 24 14          	mov    0x14(%esp),%eax
    66de:	83 e0 0f             	and    $0xf,%eax
    66e1:	89 c1                	mov    %eax,%ecx
    66e3:	8b 44 24 14          	mov    0x14(%esp),%eax
    66e7:	c1 f8 04             	sar    $0x4,%eax
    66ea:	89 c2                	mov    %eax,%edx
    66ec:	89 d0                	mov    %edx,%eax
    66ee:	c1 e0 02             	shl    $0x2,%eax
    66f1:	01 d0                	add    %edx,%eax
    66f3:	01 c0                	add    %eax,%eax
    66f5:	01 c8                	add    %ecx,%eax
    66f7:	89 44 24 14          	mov    %eax,0x14(%esp)
	BCD_TO_BIN(time.tm_year);
    66fb:	8b 44 24 18          	mov    0x18(%esp),%eax
    66ff:	83 e0 0f             	and    $0xf,%eax
    6702:	89 c1                	mov    %eax,%ecx
    6704:	8b 44 24 18          	mov    0x18(%esp),%eax
    6708:	c1 f8 04             	sar    $0x4,%eax
    670b:	89 c2                	mov    %eax,%edx
    670d:	89 d0                	mov    %edx,%eax
    670f:	c1 e0 02             	shl    $0x2,%eax
    6712:	01 d0                	add    %edx,%eax
    6714:	01 c0                	add    %eax,%eax
    6716:	01 c8                	add    %ecx,%eax
    6718:	89 44 24 18          	mov    %eax,0x18(%esp)
	time.tm_mon--;
    671c:	8b 44 24 14          	mov    0x14(%esp),%eax
    6720:	83 e8 01             	sub    $0x1,%eax
    6723:	89 44 24 14          	mov    %eax,0x14(%esp)
	startup_time = kernel_mktime(&time);
    6727:	83 ec 0c             	sub    $0xc,%esp
    672a:	8d 44 24 10          	lea    0x10(%esp),%eax
    672e:	50                   	push   %eax
    672f:	e8 4e 3b 00 00       	call   a282 <kernel_mktime>
    6734:	83 c4 10             	add    $0x10,%esp
    6737:	a3 e4 1e 02 00       	mov    %eax,0x21ee4
}
    673c:	90                   	nop
    673d:	83 c4 3c             	add    $0x3c,%esp
    6740:	c3                   	ret    

00006741 <main>:
static long main_memory_start = 0;

struct drive_info { char dummy[32]; } drive_info;

void main(void)		/* This really IS void, no error here. */
{			/* The startup routine assumes (well, ...) this */
    6741:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    6745:	83 e4 f0             	and    $0xfffffff0,%esp
    6748:	ff 71 fc             	pushl  -0x4(%ecx)
    674b:	55                   	push   %ebp
    674c:	89 e5                	mov    %esp,%ebp
    674e:	51                   	push   %ecx
    674f:	83 ec 14             	sub    $0x14,%esp
/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */

 	ROOT_DEV = ORIG_ROOT_DEV;
    6752:	b8 fc 01 09 00       	mov    $0x901fc,%eax
    6757:	0f b7 00             	movzwl (%eax),%eax
    675a:	0f b7 c0             	movzwl %ax,%eax
    675d:	a3 6c 3c 02 00       	mov    %eax,0x23c6c
 	drive_info = DRIVE_INFO;
    6762:	b8 80 00 09 00       	mov    $0x90080,%eax
    6767:	8b 10                	mov    (%eax),%edx
    6769:	89 15 80 3e 02 00    	mov    %edx,0x23e80
    676f:	8b 50 04             	mov    0x4(%eax),%edx
    6772:	89 15 84 3e 02 00    	mov    %edx,0x23e84
    6778:	8b 50 08             	mov    0x8(%eax),%edx
    677b:	89 15 88 3e 02 00    	mov    %edx,0x23e88
    6781:	8b 50 0c             	mov    0xc(%eax),%edx
    6784:	89 15 8c 3e 02 00    	mov    %edx,0x23e8c
    678a:	8b 50 10             	mov    0x10(%eax),%edx
    678d:	89 15 90 3e 02 00    	mov    %edx,0x23e90
    6793:	8b 50 14             	mov    0x14(%eax),%edx
    6796:	89 15 94 3e 02 00    	mov    %edx,0x23e94
    679c:	8b 50 18             	mov    0x18(%eax),%edx
    679f:	89 15 98 3e 02 00    	mov    %edx,0x23e98
    67a5:	8b 40 1c             	mov    0x1c(%eax),%eax
    67a8:	a3 9c 3e 02 00       	mov    %eax,0x23e9c
	memory_end = (1<<20) + (EXT_MEM_K<<10);
    67ad:	b8 02 00 09 00       	mov    $0x90002,%eax
    67b2:	0f b7 00             	movzwl (%eax),%eax
    67b5:	0f b7 c0             	movzwl %ax,%eax
    67b8:	c1 e0 0a             	shl    $0xa,%eax
    67bb:	05 00 00 10 00       	add    $0x100000,%eax
    67c0:	a3 c0 1e 02 00       	mov    %eax,0x21ec0
	memory_end &= 0xfffff000;
    67c5:	a1 c0 1e 02 00       	mov    0x21ec0,%eax
    67ca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    67cf:	a3 c0 1e 02 00       	mov    %eax,0x21ec0
	if (memory_end > 16*1024*1024)
    67d4:	a1 c0 1e 02 00       	mov    0x21ec0,%eax
    67d9:	3d 00 00 00 01       	cmp    $0x1000000,%eax
    67de:	7e 0a                	jle    67ea <main+0xa9>
		memory_end = 16*1024*1024;
    67e0:	c7 05 c0 1e 02 00 00 	movl   $0x1000000,0x21ec0
    67e7:	00 00 01 
	if (memory_end > 12*1024*1024) 
    67ea:	a1 c0 1e 02 00       	mov    0x21ec0,%eax
    67ef:	3d 00 00 c0 00       	cmp    $0xc00000,%eax
    67f4:	7e 0c                	jle    6802 <main+0xc1>
		buffer_memory_end = 4*1024*1024;
    67f6:	c7 05 c4 1e 02 00 00 	movl   $0x400000,0x21ec4
    67fd:	00 40 00 
    6800:	eb 22                	jmp    6824 <main+0xe3>
	else if (memory_end > 6*1024*1024)
    6802:	a1 c0 1e 02 00       	mov    0x21ec0,%eax
    6807:	3d 00 00 60 00       	cmp    $0x600000,%eax
    680c:	7e 0c                	jle    681a <main+0xd9>
		buffer_memory_end = 2*1024*1024;
    680e:	c7 05 c4 1e 02 00 00 	movl   $0x200000,0x21ec4
    6815:	00 20 00 
    6818:	eb 0a                	jmp    6824 <main+0xe3>
	else
		buffer_memory_end = 1*1024*1024;
    681a:	c7 05 c4 1e 02 00 00 	movl   $0x100000,0x21ec4
    6821:	00 10 00 
	main_memory_start = buffer_memory_end;
    6824:	a1 c4 1e 02 00       	mov    0x21ec4,%eax
    6829:	a3 c8 1e 02 00       	mov    %eax,0x21ec8
#ifdef RAMDISK_SIZE
	main_memory_start += rd_init(main_memory_start, RAMDISK_SIZE*1024);
    682e:	a1 c8 1e 02 00       	mov    0x21ec8,%eax
    6833:	83 ec 08             	sub    $0x8,%esp
    6836:	68 00 04 10 00       	push   $0x100400
    683b:	50                   	push   %eax
    683c:	e8 85 e1 00 00       	call   149c6 <rd_init>
    6841:	83 c4 10             	add    $0x10,%esp
    6844:	89 c2                	mov    %eax,%edx
    6846:	a1 c8 1e 02 00       	mov    0x21ec8,%eax
    684b:	01 d0                	add    %edx,%eax
    684d:	a3 c8 1e 02 00       	mov    %eax,0x21ec8
#endif
	mem_init(main_memory_start,memory_end);
    6852:	8b 15 c0 1e 02 00    	mov    0x21ec0,%edx
    6858:	a1 c8 1e 02 00       	mov    0x21ec8,%eax
    685d:	83 ec 08             	sub    $0x8,%esp
    6860:	52                   	push   %edx
    6861:	50                   	push   %eax
    6862:	e8 a5 44 00 00       	call   ad0c <mem_init>
    6867:	83 c4 10             	add    $0x10,%esp
	trap_init();
    686a:	e8 46 14 00 00       	call   7cb5 <trap_init>
	blk_dev_init();
    686f:	e8 27 c5 00 00       	call   12d9b <blk_dev_init>
	chr_dev_init();
    6874:	e8 3b f1 00 00       	call   159b4 <chr_dev_init>
	tty_init();
    6879:	e8 1b e4 00 00       	call   14c99 <tty_init>
	time_init();
    687e:	e8 9b fc ff ff       	call   651e <time_init>
	sched_init();
    6883:	e8 37 0c 00 00       	call   74bf <sched_init>
	buffer_init(buffer_memory_end);
    6888:	a1 c4 1e 02 00       	mov    0x21ec4,%eax
    688d:	83 ec 0c             	sub    $0xc,%esp
    6890:	50                   	push   %eax
    6891:	e8 07 6a 00 00       	call   d29d <buffer_init>
    6896:	83 c4 10             	add    $0x10,%esp
	hd_init();
    6899:	e8 64 de 00 00       	call   14702 <hd_init>
	floppy_init();
    689e:	e8 c0 d1 00 00       	call   13a63 <floppy_init>
	sti();
    68a3:	fb                   	sti    
	move_to_user_mode();
    68a4:	89 e0                	mov    %esp,%eax
    68a6:	6a 17                	push   $0x17
    68a8:	50                   	push   %eax
    68a9:	9c                   	pushf  
    68aa:	6a 0f                	push   $0xf
    68ac:	68 b2 68 00 00       	push   $0x68b2
    68b1:	cf                   	iret   
    68b2:	b8 17 00 00 00       	mov    $0x17,%eax
    68b7:	8e d8                	mov    %eax,%ds
    68b9:	8e c0                	mov    %eax,%es
    68bb:	8e e0                	mov    %eax,%fs
    68bd:	8e e8                	mov    %eax,%gs
 * won't be any messing with the stack from main(), but we define
 * some others too.
 */
static inline int fork(void) __attribute__((always_inline));
static inline int pause(void) __attribute__((always_inline));
static inline _syscall0(int,fork)
    68bf:	b8 02 00 00 00       	mov    $0x2,%eax
    68c4:	cd 80                	int    $0x80
    68c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    68c9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    68cd:	78 05                	js     68d4 <main+0x193>
    68cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    68d2:	eb 0f                	jmp    68e3 <main+0x1a2>
    68d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    68d7:	f7 d8                	neg    %eax
    68d9:	a3 68 5f 02 00       	mov    %eax,0x25f68
    68de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	buffer_init(buffer_memory_end);
	hd_init();
	floppy_init();
	sti();
	move_to_user_mode();
	if (!fork()) {		/* we count on this going ok */
    68e3:	85 c0                	test   %eax,%eax
    68e5:	75 05                	jne    68ec <main+0x1ab>
		init();
    68e7:	e8 62 00 00 00       	call   694e <init>
 * some others too.
 */
static inline int fork(void) __attribute__((always_inline));
static inline int pause(void) __attribute__((always_inline));
static inline _syscall0(int,fork)
static inline _syscall0(int,pause)
    68ec:	b8 1d 00 00 00       	mov    $0x1d,%eax
    68f1:	cd 80                	int    $0x80
    68f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    68f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    68fa:	79 f0                	jns    68ec <main+0x1ab>
    68fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    68ff:	f7 d8                	neg    %eax
    6901:	a3 68 5f 02 00       	mov    %eax,0x25f68
 * signal to awaken, but task0 is the sole exception (see 'schedule()')
 * as task 0 gets activated at every idle moment (when no other tasks
 * can run). For task0 'pause()' just means we go check if some other
 * task can run, and if not we return here.
 */
	for(;;) pause();
    6906:	eb e4                	jmp    68ec <main+0x1ab>

00006908 <printf>:
}

static int printf(const char *fmt, ...)
{
    6908:	83 ec 1c             	sub    $0x1c,%esp
	va_list args;
	int i;

	va_start(args, fmt);
    690b:	8d 44 24 24          	lea    0x24(%esp),%eax
    690f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	write(1,printbuf,i=vsprintf(printbuf, fmt, args));
    6913:	8b 44 24 20          	mov    0x20(%esp),%eax
    6917:	83 ec 04             	sub    $0x4,%esp
    691a:	ff 74 24 10          	pushl  0x10(%esp)
    691e:	50                   	push   %eax
    691f:	68 c0 1a 02 00       	push   $0x21ac0
    6924:	e8 38 22 00 00       	call   8b61 <vsprintf>
    6929:	83 c4 10             	add    $0x10,%esp
    692c:	89 44 24 08          	mov    %eax,0x8(%esp)
    6930:	83 ec 04             	sub    $0x4,%esp
    6933:	ff 74 24 0c          	pushl  0xc(%esp)
    6937:	68 c0 1a 02 00       	push   $0x21ac0
    693c:	6a 01                	push   $0x1
    693e:	e8 7c 15 01 00       	call   17ebf <write>
    6943:	83 c4 10             	add    $0x10,%esp
	va_end(args);
	return i;
    6946:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    694a:	83 c4 1c             	add    $0x1c,%esp
    694d:	c3                   	ret    

0000694e <init>:

static char * argv[] = { "-/bin/sh",NULL };
static char * envp[] = { "HOME=/usr/root", NULL };

void init(void)
{
    694e:	83 ec 1c             	sub    $0x1c,%esp
	int pid,i;

	setup((void *) &drive_info);
    6951:	68 80 3e 02 00       	push   $0x23e80
    6956:	e8 5d fb ff ff       	call   64b8 <setup>
    695b:	83 c4 04             	add    $0x4,%esp
	(void) open("/dev/tty0",O_RDWR,0);
    695e:	83 ec 04             	sub    $0x4,%esp
    6961:	6a 00                	push   $0x0
    6963:	6a 02                	push   $0x2
    6965:	68 17 80 01 00       	push   $0x18017
    696a:	e8 d0 14 01 00       	call   17e3f <open>
    696f:	83 c4 10             	add    $0x10,%esp
	(void) dup(0);
    6972:	83 ec 0c             	sub    $0xc,%esp
    6975:	6a 00                	push   $0x0
    6977:	e8 80 15 01 00       	call   17efc <dup>
    697c:	83 c4 10             	add    $0x10,%esp
	(void) dup(0);
    697f:	83 ec 0c             	sub    $0xc,%esp
    6982:	6a 00                	push   $0x0
    6984:	e8 73 15 01 00       	call   17efc <dup>
    6989:	83 c4 10             	add    $0x10,%esp
	printf("%d buffers = %d bytes buffer space\n\r",NR_BUFFERS,
    698c:	a1 60 3c 02 00       	mov    0x23c60,%eax
    6991:	c1 e0 0a             	shl    $0xa,%eax
    6994:	89 c2                	mov    %eax,%edx
    6996:	a1 60 3c 02 00       	mov    0x23c60,%eax
    699b:	83 ec 04             	sub    $0x4,%esp
    699e:	52                   	push   %edx
    699f:	50                   	push   %eax
    69a0:	68 24 80 01 00       	push   $0x18024
    69a5:	e8 5e ff ff ff       	call   6908 <printf>
    69aa:	83 c4 10             	add    $0x10,%esp
		NR_BUFFERS*BLOCK_SIZE);
	printf("Free mem: %d bytes\n\r",memory_end-main_memory_start);
    69ad:	8b 15 c0 1e 02 00    	mov    0x21ec0,%edx
    69b3:	a1 c8 1e 02 00       	mov    0x21ec8,%eax
    69b8:	29 c2                	sub    %eax,%edx
    69ba:	89 d0                	mov    %edx,%eax
    69bc:	83 ec 08             	sub    $0x8,%esp
    69bf:	50                   	push   %eax
    69c0:	68 49 80 01 00       	push   $0x18049
    69c5:	e8 3e ff ff ff       	call   6908 <printf>
    69ca:	83 c4 10             	add    $0x10,%esp
 * won't be any messing with the stack from main(), but we define
 * some others too.
 */
static inline int fork(void) __attribute__((always_inline));
static inline int pause(void) __attribute__((always_inline));
static inline _syscall0(int,fork)
    69cd:	b8 02 00 00 00       	mov    $0x2,%eax
    69d2:	cd 80                	int    $0x80
    69d4:	89 44 24 04          	mov    %eax,0x4(%esp)
    69d8:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    69dd:	78 06                	js     69e5 <init+0x97>
    69df:	8b 44 24 04          	mov    0x4(%esp),%eax
    69e3:	eb 10                	jmp    69f5 <init+0xa7>
    69e5:	8b 44 24 04          	mov    0x4(%esp),%eax
    69e9:	f7 d8                	neg    %eax
    69eb:	a3 68 5f 02 00       	mov    %eax,0x25f68
    69f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	(void) dup(0);
	(void) dup(0);
	printf("%d buffers = %d bytes buffer space\n\r",NR_BUFFERS,
		NR_BUFFERS*BLOCK_SIZE);
	printf("Free mem: %d bytes\n\r",memory_end-main_memory_start);
	if (!(pid=fork())) {
    69f5:	89 44 24 08          	mov    %eax,0x8(%esp)
    69f9:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    69fe:	75 59                	jne    6a59 <init+0x10b>
		close(0);
    6a00:	83 ec 0c             	sub    $0xc,%esp
    6a03:	6a 00                	push   $0x0
    6a05:	e8 7e 14 01 00       	call   17e88 <close>
    6a0a:	83 c4 10             	add    $0x10,%esp
		if (open("/etc/rc",O_RDONLY,0))
    6a0d:	83 ec 04             	sub    $0x4,%esp
    6a10:	6a 00                	push   $0x0
    6a12:	6a 00                	push   $0x0
    6a14:	68 5e 80 01 00       	push   $0x1805e
    6a19:	e8 21 14 01 00       	call   17e3f <open>
    6a1e:	83 c4 10             	add    $0x10,%esp
    6a21:	85 c0                	test   %eax,%eax
    6a23:	74 0d                	je     6a32 <init+0xe4>
			_exit(1);
    6a25:	83 ec 0c             	sub    $0xc,%esp
    6a28:	6a 01                	push   $0x1
    6a2a:	e8 ff 13 01 00       	call   17e2e <_exit>
    6a2f:	83 c4 10             	add    $0x10,%esp
		execve("/bin/sh",argv_rc,envp_rc);
    6a32:	83 ec 04             	sub    $0x4,%esp
    6a35:	68 08 e0 01 00       	push   $0x1e008
    6a3a:	68 00 e0 01 00       	push   $0x1e000
    6a3f:	68 f0 7f 01 00       	push   $0x17ff0
    6a44:	e8 19 15 01 00       	call   17f62 <execve>
    6a49:	83 c4 10             	add    $0x10,%esp
		_exit(2);
    6a4c:	83 ec 0c             	sub    $0xc,%esp
    6a4f:	6a 02                	push   $0x2
    6a51:	e8 d8 13 01 00       	call   17e2e <_exit>
    6a56:	83 c4 10             	add    $0x10,%esp
	}
	if (pid>0)
    6a59:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    6a5e:	7e 17                	jle    6a77 <init+0x129>
		while (pid != wait(&i))
    6a60:	90                   	nop
    6a61:	83 ec 0c             	sub    $0xc,%esp
    6a64:	8d 44 24 0c          	lea    0xc(%esp),%eax
    6a68:	50                   	push   %eax
    6a69:	e8 6e 15 01 00       	call   17fdc <wait>
    6a6e:	83 c4 10             	add    $0x10,%esp
    6a71:	3b 44 24 08          	cmp    0x8(%esp),%eax
    6a75:	75 ea                	jne    6a61 <init+0x113>
 * won't be any messing with the stack from main(), but we define
 * some others too.
 */
static inline int fork(void) __attribute__((always_inline));
static inline int pause(void) __attribute__((always_inline));
static inline _syscall0(int,fork)
    6a77:	b8 02 00 00 00       	mov    $0x2,%eax
    6a7c:	cd 80                	int    $0x80
    6a7e:	89 44 24 0c          	mov    %eax,0xc(%esp)
    6a82:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    6a87:	78 06                	js     6a8f <init+0x141>
    6a89:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6a8d:	eb 10                	jmp    6a9f <init+0x151>
    6a8f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6a93:	f7 d8                	neg    %eax
    6a95:	a3 68 5f 02 00       	mov    %eax,0x25f68
    6a9a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
	if (pid>0)
		while (pid != wait(&i))
			/* nothing */;
	while (1) {
		if ((pid=fork())<0) {
    6a9f:	89 44 24 08          	mov    %eax,0x8(%esp)
    6aa3:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    6aa8:	79 15                	jns    6abf <init+0x171>
			printf("Fork failed in init\r\n");
    6aaa:	83 ec 0c             	sub    $0xc,%esp
    6aad:	68 66 80 01 00       	push   $0x18066
    6ab2:	e8 51 fe ff ff       	call   6908 <printf>
    6ab7:	83 c4 10             	add    $0x10,%esp
			continue;
    6aba:	e9 c1 00 00 00       	jmp    6b80 <init+0x232>
		}
		if (!pid) {
    6abf:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    6ac4:	0f 85 80 00 00 00    	jne    6b4a <init+0x1fc>
			close(0);close(1);close(2);
    6aca:	83 ec 0c             	sub    $0xc,%esp
    6acd:	6a 00                	push   $0x0
    6acf:	e8 b4 13 01 00       	call   17e88 <close>
    6ad4:	83 c4 10             	add    $0x10,%esp
    6ad7:	83 ec 0c             	sub    $0xc,%esp
    6ada:	6a 01                	push   $0x1
    6adc:	e8 a7 13 01 00       	call   17e88 <close>
    6ae1:	83 c4 10             	add    $0x10,%esp
    6ae4:	83 ec 0c             	sub    $0xc,%esp
    6ae7:	6a 02                	push   $0x2
    6ae9:	e8 9a 13 01 00       	call   17e88 <close>
    6aee:	83 c4 10             	add    $0x10,%esp
			setsid();
    6af1:	e8 3d 14 01 00       	call   17f33 <setsid>
			(void) open("/dev/tty0",O_RDWR,0);
    6af6:	83 ec 04             	sub    $0x4,%esp
    6af9:	6a 00                	push   $0x0
    6afb:	6a 02                	push   $0x2
    6afd:	68 17 80 01 00       	push   $0x18017
    6b02:	e8 38 13 01 00       	call   17e3f <open>
    6b07:	83 c4 10             	add    $0x10,%esp
			(void) dup(0);
    6b0a:	83 ec 0c             	sub    $0xc,%esp
    6b0d:	6a 00                	push   $0x0
    6b0f:	e8 e8 13 01 00       	call   17efc <dup>
    6b14:	83 c4 10             	add    $0x10,%esp
			(void) dup(0);
    6b17:	83 ec 0c             	sub    $0xc,%esp
    6b1a:	6a 00                	push   $0x0
    6b1c:	e8 db 13 01 00       	call   17efc <dup>
    6b21:	83 c4 10             	add    $0x10,%esp
			_exit(execve("/bin/sh",argv,envp));
    6b24:	83 ec 04             	sub    $0x4,%esp
    6b27:	68 18 e0 01 00       	push   $0x1e018
    6b2c:	68 10 e0 01 00       	push   $0x1e010
    6b31:	68 f0 7f 01 00       	push   $0x17ff0
    6b36:	e8 27 14 01 00       	call   17f62 <execve>
    6b3b:	83 c4 10             	add    $0x10,%esp
    6b3e:	83 ec 0c             	sub    $0xc,%esp
    6b41:	50                   	push   %eax
    6b42:	e8 e7 12 01 00       	call   17e2e <_exit>
    6b47:	83 c4 10             	add    $0x10,%esp
		}
		while (1)
			if (pid == wait(&i))
    6b4a:	83 ec 0c             	sub    $0xc,%esp
    6b4d:	8d 44 24 0c          	lea    0xc(%esp),%eax
    6b51:	50                   	push   %eax
    6b52:	e8 85 14 01 00       	call   17fdc <wait>
    6b57:	83 c4 10             	add    $0x10,%esp
    6b5a:	3b 44 24 08          	cmp    0x8(%esp),%eax
    6b5e:	74 02                	je     6b62 <init+0x214>
				break;
		printf("\n\rchild %d died with code %04x\n\r",pid,i);
    6b60:	eb e8                	jmp    6b4a <init+0x1fc>
			(void) dup(0);
			_exit(execve("/bin/sh",argv,envp));
		}
		while (1)
			if (pid == wait(&i))
				break;
    6b62:	90                   	nop
		printf("\n\rchild %d died with code %04x\n\r",pid,i);
    6b63:	8b 04 24             	mov    (%esp),%eax
    6b66:	83 ec 04             	sub    $0x4,%esp
    6b69:	50                   	push   %eax
    6b6a:	ff 74 24 10          	pushl  0x10(%esp)
    6b6e:	68 7c 80 01 00       	push   $0x1807c
    6b73:	e8 90 fd ff ff       	call   6908 <printf>
    6b78:	83 c4 10             	add    $0x10,%esp
		sync();
    6b7b:	e8 6f f9 ff ff       	call   64ef <sync>
	}
    6b80:	e9 f2 fe ff ff       	jmp    6a77 <init+0x129>
    6b85:	90                   	nop

00006b86 <show_task>:

#define _S(nr) (1<<((nr)-1))
#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))

void show_task(int nr,struct task_struct * p)
{
    6b86:	83 ec 1c             	sub    $0x1c,%esp
	int i,j = 4096-sizeof(struct task_struct);
    6b89:	c7 44 24 08 44 0c 00 	movl   $0xc44,0x8(%esp)
    6b90:	00 

	printk("%d: pid=%d, state=%d, ",nr,p->pid,p->state);
    6b91:	8b 44 24 24          	mov    0x24(%esp),%eax
    6b95:	8b 10                	mov    (%eax),%edx
    6b97:	8b 44 24 24          	mov    0x24(%esp),%eax
    6b9b:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    6ba1:	52                   	push   %edx
    6ba2:	50                   	push   %eax
    6ba3:	ff 74 24 28          	pushl  0x28(%esp)
    6ba7:	68 a0 80 01 00       	push   $0x180a0
    6bac:	e8 5c 1c 00 00       	call   880d <printk>
    6bb1:	83 c4 10             	add    $0x10,%esp
	i=0;
    6bb4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    6bbb:	00 
	while (i<j && !((char *)(p+1))[i])
    6bbc:	eb 05                	jmp    6bc3 <show_task+0x3d>
		i++;
    6bbe:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
{
	int i,j = 4096-sizeof(struct task_struct);

	printk("%d: pid=%d, state=%d, ",nr,p->pid,p->state);
	i=0;
	while (i<j && !((char *)(p+1))[i])
    6bc3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6bc7:	3b 44 24 08          	cmp    0x8(%esp),%eax
    6bcb:	7d 17                	jge    6be4 <show_task+0x5e>
    6bcd:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6bd1:	8d 90 bc 03 00 00    	lea    0x3bc(%eax),%edx
    6bd7:	8b 44 24 24          	mov    0x24(%esp),%eax
    6bdb:	01 d0                	add    %edx,%eax
    6bdd:	0f b6 00             	movzbl (%eax),%eax
    6be0:	84 c0                	test   %al,%al
    6be2:	74 da                	je     6bbe <show_task+0x38>
		i++;
	printk("%d (of %d) chars free in kernel stack\n\r",i,j);
    6be4:	83 ec 04             	sub    $0x4,%esp
    6be7:	ff 74 24 0c          	pushl  0xc(%esp)
    6beb:	ff 74 24 14          	pushl  0x14(%esp)
    6bef:	68 b8 80 01 00       	push   $0x180b8
    6bf4:	e8 14 1c 00 00       	call   880d <printk>
    6bf9:	83 c4 10             	add    $0x10,%esp
}
    6bfc:	90                   	nop
    6bfd:	83 c4 1c             	add    $0x1c,%esp
    6c00:	c3                   	ret    

00006c01 <show_stat>:

void show_stat(void)
{
    6c01:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	for (i=0;i<NR_TASKS;i++)
    6c04:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    6c0b:	00 
    6c0c:	eb 2f                	jmp    6c3d <show_stat+0x3c>
		if (task[i])
    6c0e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6c12:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    6c19:	85 c0                	test   %eax,%eax
    6c1b:	74 1b                	je     6c38 <show_stat+0x37>
			show_task(i,task[i]);
    6c1d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6c21:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    6c28:	83 ec 08             	sub    $0x8,%esp
    6c2b:	50                   	push   %eax
    6c2c:	ff 74 24 18          	pushl  0x18(%esp)
    6c30:	e8 51 ff ff ff       	call   6b86 <show_task>
    6c35:	83 c4 10             	add    $0x10,%esp

void show_stat(void)
{
	int i;

	for (i=0;i<NR_TASKS;i++)
    6c38:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    6c3d:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    6c42:	7e ca                	jle    6c0e <show_stat+0xd>
		if (task[i])
			show_task(i,task[i]);
}
    6c44:	90                   	nop
    6c45:	83 c4 1c             	add    $0x1c,%esp
    6c48:	c3                   	ret    

00006c49 <math_state_restore>:
 *  'math_state_restore()' saves the current math information in the
 * old math state array, and gets the new ones from the current task
 */
void math_state_restore()
{
	if (last_task_used_math == current)
    6c49:	8b 15 e8 1e 02 00    	mov    0x21ee8,%edx
    6c4f:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6c54:	39 c2                	cmp    %eax,%edx
    6c56:	74 4f                	je     6ca7 <math_state_restore+0x5e>
		return;
	__asm__("fwait");
    6c58:	9b                   	fwait
	if (last_task_used_math) {
    6c59:	a1 e8 1e 02 00       	mov    0x21ee8,%eax
    6c5e:	85 c0                	test   %eax,%eax
    6c60:	74 0b                	je     6c6d <math_state_restore+0x24>
		__asm__("fnsave %0"::"m" (last_task_used_math->tss.i387));
    6c62:	a1 e8 1e 02 00       	mov    0x21ee8,%eax
    6c67:	dd b0 50 03 00 00    	fnsave 0x350(%eax)
	}
	last_task_used_math=current;
    6c6d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6c72:	a3 e8 1e 02 00       	mov    %eax,0x21ee8
	if (current->used_math) {
    6c77:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6c7c:	0f b7 80 64 02 00 00 	movzwl 0x264(%eax),%eax
    6c83:	66 85 c0             	test   %ax,%ax
    6c86:	74 0d                	je     6c95 <math_state_restore+0x4c>
		__asm__("frstor %0"::"m" (current->tss.i387));
    6c88:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6c8d:	dd a0 50 03 00 00    	frstor 0x350(%eax)
    6c93:	eb 13                	jmp    6ca8 <math_state_restore+0x5f>
	} else {
		__asm__("fninit"::);
    6c95:	db e3                	fninit 
		current->used_math=1;
    6c97:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6c9c:	66 c7 80 64 02 00 00 	movw   $0x1,0x264(%eax)
    6ca3:	01 00 
    6ca5:	eb 01                	jmp    6ca8 <math_state_restore+0x5f>
 * old math state array, and gets the new ones from the current task
 */
void math_state_restore()
{
	if (last_task_used_math == current)
		return;
    6ca7:	90                   	nop
		__asm__("frstor %0"::"m" (current->tss.i387));
	} else {
		__asm__("fninit"::);
		current->used_math=1;
	}
}
    6ca8:	c3                   	ret    

00006ca9 <schedule>:
 *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other
 * tasks can run. It can not be killed, and it cannot sleep. The 'state'
 * information in task[0] is never used.
 */
void schedule(void)
{
    6ca9:	83 ec 20             	sub    $0x20,%esp
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6cac:	c7 44 24 10 5c f2 01 	movl   $0x1f25c,0x10(%esp)
    6cb3:	00 
    6cb4:	e9 98 00 00 00       	jmp    6d51 <schedule+0xa8>
		if (*p) {
    6cb9:	8b 44 24 10          	mov    0x10(%esp),%eax
    6cbd:	8b 00                	mov    (%eax),%eax
    6cbf:	85 c0                	test   %eax,%eax
    6cc1:	0f 84 85 00 00 00    	je     6d4c <schedule+0xa3>
			if ((*p)->alarm && (*p)->alarm < jiffies) {
    6cc7:	8b 44 24 10          	mov    0x10(%esp),%eax
    6ccb:	8b 00                	mov    (%eax),%eax
    6ccd:	8b 80 4c 02 00 00    	mov    0x24c(%eax),%eax
    6cd3:	85 c0                	test   %eax,%eax
    6cd5:	74 3a                	je     6d11 <schedule+0x68>
    6cd7:	8b 44 24 10          	mov    0x10(%esp),%eax
    6cdb:	8b 00                	mov    (%eax),%eax
    6cdd:	8b 90 4c 02 00 00    	mov    0x24c(%eax),%edx
    6ce3:	a1 e0 1e 02 00       	mov    0x21ee0,%eax
    6ce8:	39 c2                	cmp    %eax,%edx
    6cea:	7d 25                	jge    6d11 <schedule+0x68>
					(*p)->signal |= (1<<(SIGALRM-1));
    6cec:	8b 44 24 10          	mov    0x10(%esp),%eax
    6cf0:	8b 00                	mov    (%eax),%eax
    6cf2:	8b 54 24 10          	mov    0x10(%esp),%edx
    6cf6:	8b 12                	mov    (%edx),%edx
    6cf8:	8b 52 0c             	mov    0xc(%edx),%edx
    6cfb:	80 ce 20             	or     $0x20,%dh
    6cfe:	89 50 0c             	mov    %edx,0xc(%eax)
					(*p)->alarm = 0;
    6d01:	8b 44 24 10          	mov    0x10(%esp),%eax
    6d05:	8b 00                	mov    (%eax),%eax
    6d07:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%eax)
    6d0e:	00 00 00 
				}
			if (((*p)->signal & (_BLOCKABLE & ~(*p)->blocked)) &&
    6d11:	8b 44 24 10          	mov    0x10(%esp),%eax
    6d15:	8b 00                	mov    (%eax),%eax
    6d17:	8b 50 0c             	mov    0xc(%eax),%edx
    6d1a:	8b 44 24 10          	mov    0x10(%esp),%eax
    6d1e:	8b 00                	mov    (%eax),%eax
    6d20:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
    6d26:	f7 d0                	not    %eax
    6d28:	25 ff fe fb ff       	and    $0xfffbfeff,%eax
    6d2d:	21 d0                	and    %edx,%eax
    6d2f:	85 c0                	test   %eax,%eax
    6d31:	74 19                	je     6d4c <schedule+0xa3>
			(*p)->state==TASK_INTERRUPTIBLE)
    6d33:	8b 44 24 10          	mov    0x10(%esp),%eax
    6d37:	8b 00                	mov    (%eax),%eax
    6d39:	8b 00                	mov    (%eax),%eax
		if (*p) {
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));
					(*p)->alarm = 0;
				}
			if (((*p)->signal & (_BLOCKABLE & ~(*p)->blocked)) &&
    6d3b:	83 f8 01             	cmp    $0x1,%eax
    6d3e:	75 0c                	jne    6d4c <schedule+0xa3>
			(*p)->state==TASK_INTERRUPTIBLE)
				(*p)->state=TASK_RUNNING;
    6d40:	8b 44 24 10          	mov    0x10(%esp),%eax
    6d44:	8b 00                	mov    (%eax),%eax
    6d46:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6d4c:	83 6c 24 10 04       	subl   $0x4,0x10(%esp)
    6d51:	81 7c 24 10 60 f1 01 	cmpl   $0x1f160,0x10(%esp)
    6d58:	00 
    6d59:	0f 87 5a ff ff ff    	ja     6cb9 <schedule+0x10>
		}

/* this is the scheduler proper: */

	while (1) {
		c = -1;
    6d5f:	c7 44 24 14 ff ff ff 	movl   $0xffffffff,0x14(%esp)
    6d66:	ff 
		next = 0;
    6d67:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    6d6e:	00 
		i = NR_TASKS;
    6d6f:	c7 44 24 1c 40 00 00 	movl   $0x40,0x1c(%esp)
    6d76:	00 
		p = &task[NR_TASKS];
    6d77:	c7 44 24 10 60 f2 01 	movl   $0x1f260,0x10(%esp)
    6d7e:	00 
		while (--i) {
    6d7f:	eb 41                	jmp    6dc2 <schedule+0x119>
			if (!*--p)
    6d81:	83 6c 24 10 04       	subl   $0x4,0x10(%esp)
    6d86:	8b 44 24 10          	mov    0x10(%esp),%eax
    6d8a:	8b 00                	mov    (%eax),%eax
    6d8c:	85 c0                	test   %eax,%eax
    6d8e:	75 02                	jne    6d92 <schedule+0xe9>
				continue;
    6d90:	eb 30                	jmp    6dc2 <schedule+0x119>
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
    6d92:	8b 44 24 10          	mov    0x10(%esp),%eax
    6d96:	8b 00                	mov    (%eax),%eax
    6d98:	8b 00                	mov    (%eax),%eax
    6d9a:	85 c0                	test   %eax,%eax
    6d9c:	75 24                	jne    6dc2 <schedule+0x119>
    6d9e:	8b 44 24 10          	mov    0x10(%esp),%eax
    6da2:	8b 00                	mov    (%eax),%eax
    6da4:	8b 40 04             	mov    0x4(%eax),%eax
    6da7:	3b 44 24 14          	cmp    0x14(%esp),%eax
    6dab:	7e 15                	jle    6dc2 <schedule+0x119>
				c = (*p)->counter, next = i;
    6dad:	8b 44 24 10          	mov    0x10(%esp),%eax
    6db1:	8b 00                	mov    (%eax),%eax
    6db3:	8b 40 04             	mov    0x4(%eax),%eax
    6db6:	89 44 24 14          	mov    %eax,0x14(%esp)
    6dba:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    6dbe:	89 44 24 18          	mov    %eax,0x18(%esp)
	while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
    6dc2:	83 6c 24 1c 01       	subl   $0x1,0x1c(%esp)
    6dc7:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    6dcc:	75 b3                	jne    6d81 <schedule+0xd8>
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
    6dce:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    6dd3:	75 49                	jne    6e1e <schedule+0x175>
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6dd5:	c7 44 24 10 5c f2 01 	movl   $0x1f25c,0x10(%esp)
    6ddc:	00 
    6ddd:	eb 30                	jmp    6e0f <schedule+0x166>
			if (*p)
    6ddf:	8b 44 24 10          	mov    0x10(%esp),%eax
    6de3:	8b 00                	mov    (%eax),%eax
    6de5:	85 c0                	test   %eax,%eax
    6de7:	74 21                	je     6e0a <schedule+0x161>
				(*p)->counter = ((*p)->counter >> 1) +
    6de9:	8b 44 24 10          	mov    0x10(%esp),%eax
    6ded:	8b 00                	mov    (%eax),%eax
    6def:	8b 54 24 10          	mov    0x10(%esp),%edx
    6df3:	8b 12                	mov    (%edx),%edx
    6df5:	8b 52 04             	mov    0x4(%edx),%edx
    6df8:	89 d1                	mov    %edx,%ecx
    6dfa:	d1 f9                	sar    %ecx
						(*p)->priority;
    6dfc:	8b 54 24 10          	mov    0x10(%esp),%edx
    6e00:	8b 12                	mov    (%edx),%edx
    6e02:	8b 52 08             	mov    0x8(%edx),%edx
				c = (*p)->counter, next = i;
		}
		if (c) break;
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
    6e05:	01 ca                	add    %ecx,%edx
    6e07:	89 50 04             	mov    %edx,0x4(%eax)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6e0a:	83 6c 24 10 04       	subl   $0x4,0x10(%esp)
    6e0f:	81 7c 24 10 60 f1 01 	cmpl   $0x1f160,0x10(%esp)
    6e16:	00 
    6e17:	77 c6                	ja     6ddf <schedule+0x136>
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
    6e19:	e9 41 ff ff ff       	jmp    6d5f <schedule+0xb6>
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
    6e1e:	90                   	nop
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
	switch_to(next);
    6e1f:	8b 44 24 18          	mov    0x18(%esp),%eax
    6e23:	c1 e0 04             	shl    $0x4,%eax
    6e26:	8d 50 20             	lea    0x20(%eax),%edx
    6e29:	8b 44 24 18          	mov    0x18(%esp),%eax
    6e2d:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    6e34:	89 c1                	mov    %eax,%ecx
    6e36:	39 0d 40 f1 01 00    	cmp    %ecx,0x1f140
    6e3c:	74 19                	je     6e57 <schedule+0x1ae>
    6e3e:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
    6e43:	87 0d 40 f1 01 00    	xchg   %ecx,0x1f140
    6e49:	ff 6c 24 08          	ljmp   *0x8(%esp)
    6e4d:	39 0d e8 1e 02 00    	cmp    %ecx,0x21ee8
    6e53:	75 02                	jne    6e57 <schedule+0x1ae>
    6e55:	0f 06                	clts   
}
    6e57:	90                   	nop
    6e58:	83 c4 20             	add    $0x20,%esp
    6e5b:	c3                   	ret    

00006e5c <sys_pause>:

int sys_pause(void)
{
	current->state = TASK_INTERRUPTIBLE;
    6e5c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6e61:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	schedule();
    6e67:	e8 3d fe ff ff       	call   6ca9 <schedule>
	return 0;
    6e6c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6e71:	c3                   	ret    

00006e72 <sleep_on>:

void sleep_on(struct task_struct **p)
{
    6e72:	83 ec 1c             	sub    $0x1c,%esp
	struct task_struct *tmp;

	if (!p)
    6e75:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    6e7a:	74 5f                	je     6edb <sleep_on+0x69>
		return;
	if (current == &(init_task.task))
    6e7c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6e81:	3d 40 e1 01 00       	cmp    $0x1e140,%eax
    6e86:	75 10                	jne    6e98 <sleep_on+0x26>
		panic("task[0] trying to sleep");
    6e88:	83 ec 0c             	sub    $0xc,%esp
    6e8b:	68 e0 80 01 00       	push   $0x180e0
    6e90:	e8 39 19 00 00       	call   87ce <panic>
    6e95:	83 c4 10             	add    $0x10,%esp
	tmp = *p;
    6e98:	8b 44 24 20          	mov    0x20(%esp),%eax
    6e9c:	8b 00                	mov    (%eax),%eax
    6e9e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	*p = current;
    6ea2:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    6ea8:	8b 44 24 20          	mov    0x20(%esp),%eax
    6eac:	89 10                	mov    %edx,(%eax)
	current->state = TASK_UNINTERRUPTIBLE;
    6eae:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6eb3:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	schedule();
    6eb9:	e8 eb fd ff ff       	call   6ca9 <schedule>
	*p = tmp;
    6ebe:	8b 44 24 20          	mov    0x20(%esp),%eax
    6ec2:	8b 54 24 0c          	mov    0xc(%esp),%edx
    6ec6:	89 10                	mov    %edx,(%eax)
	if (tmp)
    6ec8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    6ecd:	74 0d                	je     6edc <sleep_on+0x6a>
		tmp->state=TASK_RUNNING;
    6ecf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6ed3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    6ed9:	eb 01                	jmp    6edc <sleep_on+0x6a>
void sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
    6edb:	90                   	nop
	current->state = TASK_UNINTERRUPTIBLE;
	schedule();
	*p = tmp;
	if (tmp)
		tmp->state=TASK_RUNNING;
}
    6edc:	83 c4 1c             	add    $0x1c,%esp
    6edf:	c3                   	ret    

00006ee0 <interruptible_sleep_on>:

void interruptible_sleep_on(struct task_struct **p)
{
    6ee0:	83 ec 1c             	sub    $0x1c,%esp
	struct task_struct *tmp;

	if (!p)
    6ee3:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    6ee8:	0f 84 86 00 00 00    	je     6f74 <interruptible_sleep_on+0x94>
		return;
	if (current == &(init_task.task))
    6eee:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6ef3:	3d 40 e1 01 00       	cmp    $0x1e140,%eax
    6ef8:	75 10                	jne    6f0a <interruptible_sleep_on+0x2a>
		panic("task[0] trying to sleep");
    6efa:	83 ec 0c             	sub    $0xc,%esp
    6efd:	68 e0 80 01 00       	push   $0x180e0
    6f02:	e8 c7 18 00 00       	call   87ce <panic>
    6f07:	83 c4 10             	add    $0x10,%esp
	tmp=*p;
    6f0a:	8b 44 24 20          	mov    0x20(%esp),%eax
    6f0e:	8b 00                	mov    (%eax),%eax
    6f10:	89 44 24 0c          	mov    %eax,0xc(%esp)
	*p=current;
    6f14:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    6f1a:	8b 44 24 20          	mov    0x20(%esp),%eax
    6f1e:	89 10                	mov    %edx,(%eax)
repeat:	current->state = TASK_INTERRUPTIBLE;
    6f20:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6f25:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	schedule();
    6f2b:	e8 79 fd ff ff       	call   6ca9 <schedule>
	if (*p && *p != current) {
    6f30:	8b 44 24 20          	mov    0x20(%esp),%eax
    6f34:	8b 00                	mov    (%eax),%eax
    6f36:	85 c0                	test   %eax,%eax
    6f38:	74 1d                	je     6f57 <interruptible_sleep_on+0x77>
    6f3a:	8b 44 24 20          	mov    0x20(%esp),%eax
    6f3e:	8b 10                	mov    (%eax),%edx
    6f40:	a1 40 f1 01 00       	mov    0x1f140,%eax
    6f45:	39 c2                	cmp    %eax,%edx
    6f47:	74 0e                	je     6f57 <interruptible_sleep_on+0x77>
		(*p)->state = TASK_RUNNING;
    6f49:	8b 44 24 20          	mov    0x20(%esp),%eax
    6f4d:	8b 00                	mov    (%eax),%eax
    6f4f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		goto repeat;
    6f55:	eb c9                	jmp    6f20 <interruptible_sleep_on+0x40>
	}
	*p = tmp;
    6f57:	8b 44 24 20          	mov    0x20(%esp),%eax
    6f5b:	8b 54 24 0c          	mov    0xc(%esp),%edx
    6f5f:	89 10                	mov    %edx,(%eax)
	if (tmp)
    6f61:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    6f66:	74 0d                	je     6f75 <interruptible_sleep_on+0x95>
		tmp->state = TASK_RUNNING;
    6f68:	8b 44 24 0c          	mov    0xc(%esp),%eax
    6f6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    6f72:	eb 01                	jmp    6f75 <interruptible_sleep_on+0x95>
void interruptible_sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
    6f74:	90                   	nop
		goto repeat;
	}
	*p = tmp;
	if (tmp)
		tmp->state = TASK_RUNNING;
}
    6f75:	83 c4 1c             	add    $0x1c,%esp
    6f78:	c3                   	ret    

00006f79 <wake_up>:

void wake_up(struct task_struct **p)
{
	if (p && *p) {
    6f79:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    6f7e:	74 20                	je     6fa0 <wake_up+0x27>
    6f80:	8b 44 24 04          	mov    0x4(%esp),%eax
    6f84:	8b 00                	mov    (%eax),%eax
    6f86:	85 c0                	test   %eax,%eax
    6f88:	74 16                	je     6fa0 <wake_up+0x27>
		(*p)->state = TASK_RUNNING;
    6f8a:	8b 44 24 04          	mov    0x4(%esp),%eax
    6f8e:	8b 00                	mov    (%eax),%eax
    6f90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		*p = NULL;
    6f96:	8b 44 24 04          	mov    0x4(%esp),%eax
    6f9a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
}
    6fa0:	90                   	nop
    6fa1:	c3                   	ret    

00006fa2 <ticks_to_floppy_on>:
static int  mon_timer[4]={0,0,0,0};
static int moff_timer[4]={0,0,0,0};
unsigned char current_DOR = 0x0C;

int ticks_to_floppy_on(unsigned int nr)
{
    6fa2:	83 ec 1c             	sub    $0x1c,%esp
	extern unsigned char selected;
	unsigned char mask = 0x10 << nr;
    6fa5:	8b 44 24 20          	mov    0x20(%esp),%eax
    6fa9:	ba 10 00 00 00       	mov    $0x10,%edx
    6fae:	89 c1                	mov    %eax,%ecx
    6fb0:	d3 e2                	shl    %cl,%edx
    6fb2:	89 d0                	mov    %edx,%eax
    6fb4:	88 44 24 0f          	mov    %al,0xf(%esp)

	if (nr>3)
    6fb8:	83 7c 24 20 03       	cmpl   $0x3,0x20(%esp)
    6fbd:	76 10                	jbe    6fcf <ticks_to_floppy_on+0x2d>
		panic("floppy_on: nr>3");
    6fbf:	83 ec 0c             	sub    $0xc,%esp
    6fc2:	68 f8 80 01 00       	push   $0x180f8
    6fc7:	e8 02 18 00 00       	call   87ce <panic>
    6fcc:	83 c4 10             	add    $0x10,%esp
	moff_timer[nr]=10000;		/* 100 s = very big :-) */
    6fcf:	8b 44 24 20          	mov    0x20(%esp),%eax
    6fd3:	c7 04 85 0c 1f 02 00 	movl   $0x2710,0x21f0c(,%eax,4)
    6fda:	10 27 00 00 
	cli();				/* use floppy_off to turn it off */
    6fde:	fa                   	cli    
	mask |= current_DOR;
    6fdf:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
    6fe6:	08 44 24 0f          	or     %al,0xf(%esp)
	if (!selected) {
    6fea:	0f b6 05 dc 3c 02 00 	movzbl 0x23cdc,%eax
    6ff1:	84 c0                	test   %al,%al
    6ff3:	75 0d                	jne    7002 <ticks_to_floppy_on+0x60>
		mask &= 0xFC;
    6ff5:	80 64 24 0f fc       	andb   $0xfc,0xf(%esp)
		mask |= nr;
    6ffa:	8b 44 24 20          	mov    0x20(%esp),%eax
    6ffe:	08 44 24 0f          	or     %al,0xf(%esp)
	}
	if (mask != current_DOR) {
    7002:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
    7009:	38 44 24 0f          	cmp    %al,0xf(%esp)
    700d:	74 5c                	je     706b <ticks_to_floppy_on+0xc9>
		outb(mask,FD_DOR);
    700f:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
    7014:	ba f2 03 00 00       	mov    $0x3f2,%edx
    7019:	ee                   	out    %al,(%dx)
		if ((mask ^ current_DOR) & 0xf0)
    701a:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
    7021:	32 44 24 0f          	xor    0xf(%esp),%al
    7025:	0f b6 c0             	movzbl %al,%eax
    7028:	25 f0 00 00 00       	and    $0xf0,%eax
    702d:	85 c0                	test   %eax,%eax
    702f:	74 11                	je     7042 <ticks_to_floppy_on+0xa0>
			mon_timer[nr] = HZ/2;
    7031:	8b 44 24 20          	mov    0x20(%esp),%eax
    7035:	c7 04 85 fc 1e 02 00 	movl   $0x32,0x21efc(,%eax,4)
    703c:	32 00 00 00 
    7040:	eb 1f                	jmp    7061 <ticks_to_floppy_on+0xbf>
		else if (mon_timer[nr] < 2)
    7042:	8b 44 24 20          	mov    0x20(%esp),%eax
    7046:	8b 04 85 fc 1e 02 00 	mov    0x21efc(,%eax,4),%eax
    704d:	83 f8 01             	cmp    $0x1,%eax
    7050:	7f 0f                	jg     7061 <ticks_to_floppy_on+0xbf>
			mon_timer[nr] = 2;
    7052:	8b 44 24 20          	mov    0x20(%esp),%eax
    7056:	c7 04 85 fc 1e 02 00 	movl   $0x2,0x21efc(,%eax,4)
    705d:	02 00 00 00 
		current_DOR = mask;
    7061:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
    7066:	a2 68 f2 01 00       	mov    %al,0x1f268
	}
	sti();
    706b:	fb                   	sti    
	return mon_timer[nr];
    706c:	8b 44 24 20          	mov    0x20(%esp),%eax
    7070:	8b 04 85 fc 1e 02 00 	mov    0x21efc(,%eax,4),%eax
}
    7077:	83 c4 1c             	add    $0x1c,%esp
    707a:	c3                   	ret    

0000707b <floppy_on>:

void floppy_on(unsigned int nr)
{
    707b:	83 ec 0c             	sub    $0xc,%esp
	cli();
    707e:	fa                   	cli    
	while (ticks_to_floppy_on(nr))
    707f:	eb 18                	jmp    7099 <floppy_on+0x1e>
		sleep_on(nr+wait_motor);
    7081:	8b 44 24 10          	mov    0x10(%esp),%eax
    7085:	c1 e0 02             	shl    $0x2,%eax
    7088:	05 ec 1e 02 00       	add    $0x21eec,%eax
    708d:	83 ec 0c             	sub    $0xc,%esp
    7090:	50                   	push   %eax
    7091:	e8 dc fd ff ff       	call   6e72 <sleep_on>
    7096:	83 c4 10             	add    $0x10,%esp
}

void floppy_on(unsigned int nr)
{
	cli();
	while (ticks_to_floppy_on(nr))
    7099:	83 ec 0c             	sub    $0xc,%esp
    709c:	ff 74 24 1c          	pushl  0x1c(%esp)
    70a0:	e8 fd fe ff ff       	call   6fa2 <ticks_to_floppy_on>
    70a5:	83 c4 10             	add    $0x10,%esp
    70a8:	85 c0                	test   %eax,%eax
    70aa:	75 d5                	jne    7081 <floppy_on+0x6>
		sleep_on(nr+wait_motor);
	sti();
    70ac:	fb                   	sti    
}
    70ad:	90                   	nop
    70ae:	83 c4 0c             	add    $0xc,%esp
    70b1:	c3                   	ret    

000070b2 <floppy_off>:

void floppy_off(unsigned int nr)
{
	moff_timer[nr]=3*HZ;
    70b2:	8b 44 24 04          	mov    0x4(%esp),%eax
    70b6:	c7 04 85 0c 1f 02 00 	movl   $0x12c,0x21f0c(,%eax,4)
    70bd:	2c 01 00 00 
}
    70c1:	90                   	nop
    70c2:	c3                   	ret    

000070c3 <do_floppy_timer>:

void do_floppy_timer(void)
{
    70c3:	83 ec 10             	sub    $0x10,%esp
	int i;
	unsigned char mask = 0x10;
    70c6:	c6 44 24 0b 10       	movb   $0x10,0xb(%esp)

	for (i=0 ; i<4 ; i++,mask <<= 1) {
    70cb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    70d2:	00 
    70d3:	e9 bb 00 00 00       	jmp    7193 <do_floppy_timer+0xd0>
		if (!(mask & current_DOR))
    70d8:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
    70df:	22 44 24 0b          	and    0xb(%esp),%al
    70e3:	84 c0                	test   %al,%al
    70e5:	0f 84 9e 00 00 00    	je     7189 <do_floppy_timer+0xc6>
			continue;
		if (mon_timer[i]) {
    70eb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    70ef:	8b 04 85 fc 1e 02 00 	mov    0x21efc(,%eax,4),%eax
    70f6:	85 c0                	test   %eax,%eax
    70f8:	74 3f                	je     7139 <do_floppy_timer+0x76>
			if (!--mon_timer[i])
    70fa:	8b 44 24 0c          	mov    0xc(%esp),%eax
    70fe:	8b 04 85 fc 1e 02 00 	mov    0x21efc(,%eax,4),%eax
    7105:	8d 50 ff             	lea    -0x1(%eax),%edx
    7108:	8b 44 24 0c          	mov    0xc(%esp),%eax
    710c:	89 14 85 fc 1e 02 00 	mov    %edx,0x21efc(,%eax,4)
    7113:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7117:	8b 04 85 fc 1e 02 00 	mov    0x21efc(,%eax,4),%eax
    711e:	85 c0                	test   %eax,%eax
    7120:	75 68                	jne    718a <do_floppy_timer+0xc7>
				wake_up(i+wait_motor);
    7122:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7126:	c1 e0 02             	shl    $0x2,%eax
    7129:	05 ec 1e 02 00       	add    $0x21eec,%eax
    712e:	50                   	push   %eax
    712f:	e8 45 fe ff ff       	call   6f79 <wake_up>
    7134:	83 c4 04             	add    $0x4,%esp
    7137:	eb 51                	jmp    718a <do_floppy_timer+0xc7>
		} else if (!moff_timer[i]) {
    7139:	8b 44 24 0c          	mov    0xc(%esp),%eax
    713d:	8b 04 85 0c 1f 02 00 	mov    0x21f0c(,%eax,4),%eax
    7144:	85 c0                	test   %eax,%eax
    7146:	75 26                	jne    716e <do_floppy_timer+0xab>
			current_DOR &= ~mask;
    7148:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
    714d:	f7 d0                	not    %eax
    714f:	89 c2                	mov    %eax,%edx
    7151:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
    7158:	21 d0                	and    %edx,%eax
    715a:	a2 68 f2 01 00       	mov    %al,0x1f268
			outb(current_DOR,FD_DOR);
    715f:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
    7166:	ba f2 03 00 00       	mov    $0x3f2,%edx
    716b:	ee                   	out    %al,(%dx)
    716c:	eb 1c                	jmp    718a <do_floppy_timer+0xc7>
		} else
			moff_timer[i]--;
    716e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7172:	8b 04 85 0c 1f 02 00 	mov    0x21f0c(,%eax,4),%eax
    7179:	8d 50 ff             	lea    -0x1(%eax),%edx
    717c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7180:	89 14 85 0c 1f 02 00 	mov    %edx,0x21f0c(,%eax,4)
    7187:	eb 01                	jmp    718a <do_floppy_timer+0xc7>
	int i;
	unsigned char mask = 0x10;

	for (i=0 ; i<4 ; i++,mask <<= 1) {
		if (!(mask & current_DOR))
			continue;
    7189:	90                   	nop
void do_floppy_timer(void)
{
	int i;
	unsigned char mask = 0x10;

	for (i=0 ; i<4 ; i++,mask <<= 1) {
    718a:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    718f:	d0 64 24 0b          	shlb   0xb(%esp)
    7193:	83 7c 24 0c 03       	cmpl   $0x3,0xc(%esp)
    7198:	0f 8e 3a ff ff ff    	jle    70d8 <do_floppy_timer+0x15>
			current_DOR &= ~mask;
			outb(current_DOR,FD_DOR);
		} else
			moff_timer[i]--;
	}
}
    719e:	90                   	nop
    719f:	83 c4 10             	add    $0x10,%esp
    71a2:	c3                   	ret    

000071a3 <add_timer>:
	void (*fn)();
	struct timer_list * next;
} timer_list[TIME_REQUESTS], * next_timer = NULL;

void add_timer(long jiffies, void (*fn)(void))
{
    71a3:	83 ec 1c             	sub    $0x1c,%esp
	struct timer_list * p;

	if (!fn)
    71a6:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    71ab:	0f 84 1a 01 00 00    	je     72cb <add_timer+0x128>
		return;
	cli();
    71b1:	fa                   	cli    
	if (jiffies <= 0)
    71b2:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    71b7:	7f 0b                	jg     71c4 <add_timer+0x21>
		(fn)();
    71b9:	8b 44 24 24          	mov    0x24(%esp),%eax
    71bd:	ff d0                	call   *%eax
    71bf:	e9 04 01 00 00       	jmp    72c8 <add_timer+0x125>
	else {
		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
    71c4:	c7 44 24 0c 20 1f 02 	movl   $0x21f20,0xc(%esp)
    71cb:	00 
    71cc:	eb 10                	jmp    71de <add_timer+0x3b>
			if (!p->fn)
    71ce:	8b 44 24 0c          	mov    0xc(%esp),%eax
    71d2:	8b 40 04             	mov    0x4(%eax),%eax
    71d5:	85 c0                	test   %eax,%eax
    71d7:	74 12                	je     71eb <add_timer+0x48>
		return;
	cli();
	if (jiffies <= 0)
		(fn)();
	else {
		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
    71d9:	83 44 24 0c 0c       	addl   $0xc,0xc(%esp)
    71de:	b8 20 22 02 00       	mov    $0x22220,%eax
    71e3:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    71e7:	72 e5                	jb     71ce <add_timer+0x2b>
    71e9:	eb 01                	jmp    71ec <add_timer+0x49>
			if (!p->fn)
				break;
    71eb:	90                   	nop
		if (p >= timer_list + TIME_REQUESTS)
    71ec:	b8 20 22 02 00       	mov    $0x22220,%eax
    71f1:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    71f5:	72 10                	jb     7207 <add_timer+0x64>
			panic("No more time requests free");
    71f7:	83 ec 0c             	sub    $0xc,%esp
    71fa:	68 08 81 01 00       	push   $0x18108
    71ff:	e8 ca 15 00 00       	call   87ce <panic>
    7204:	83 c4 10             	add    $0x10,%esp
		p->fn = fn;
    7207:	8b 44 24 0c          	mov    0xc(%esp),%eax
    720b:	8b 54 24 24          	mov    0x24(%esp),%edx
    720f:	89 50 04             	mov    %edx,0x4(%eax)
		p->jiffies = jiffies;
    7212:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7216:	8b 54 24 20          	mov    0x20(%esp),%edx
    721a:	89 10                	mov    %edx,(%eax)
		p->next = next_timer;
    721c:	8b 15 20 22 02 00    	mov    0x22220,%edx
    7222:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7226:	89 50 08             	mov    %edx,0x8(%eax)
		next_timer = p;
    7229:	8b 44 24 0c          	mov    0xc(%esp),%eax
    722d:	a3 20 22 02 00       	mov    %eax,0x22220
		while (p->next && p->next->jiffies < p->jiffies) {
    7232:	eb 72                	jmp    72a6 <add_timer+0x103>
			p->jiffies -= p->next->jiffies;
    7234:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7238:	8b 10                	mov    (%eax),%edx
    723a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    723e:	8b 40 08             	mov    0x8(%eax),%eax
    7241:	8b 00                	mov    (%eax),%eax
    7243:	29 c2                	sub    %eax,%edx
    7245:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7249:	89 10                	mov    %edx,(%eax)
			fn = p->fn;
    724b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    724f:	8b 40 04             	mov    0x4(%eax),%eax
    7252:	89 44 24 24          	mov    %eax,0x24(%esp)
			p->fn = p->next->fn;
    7256:	8b 44 24 0c          	mov    0xc(%esp),%eax
    725a:	8b 40 08             	mov    0x8(%eax),%eax
    725d:	8b 50 04             	mov    0x4(%eax),%edx
    7260:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7264:	89 50 04             	mov    %edx,0x4(%eax)
			p->next->fn = fn;
    7267:	8b 44 24 0c          	mov    0xc(%esp),%eax
    726b:	8b 40 08             	mov    0x8(%eax),%eax
    726e:	8b 54 24 24          	mov    0x24(%esp),%edx
    7272:	89 50 04             	mov    %edx,0x4(%eax)
			jiffies = p->jiffies;
    7275:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7279:	8b 00                	mov    (%eax),%eax
    727b:	89 44 24 20          	mov    %eax,0x20(%esp)
			p->jiffies = p->next->jiffies;
    727f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7283:	8b 40 08             	mov    0x8(%eax),%eax
    7286:	8b 10                	mov    (%eax),%edx
    7288:	8b 44 24 0c          	mov    0xc(%esp),%eax
    728c:	89 10                	mov    %edx,(%eax)
			p->next->jiffies = jiffies;
    728e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7292:	8b 40 08             	mov    0x8(%eax),%eax
    7295:	8b 54 24 20          	mov    0x20(%esp),%edx
    7299:	89 10                	mov    %edx,(%eax)
			p = p->next;
    729b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    729f:	8b 40 08             	mov    0x8(%eax),%eax
    72a2:	89 44 24 0c          	mov    %eax,0xc(%esp)
			panic("No more time requests free");
		p->fn = fn;
		p->jiffies = jiffies;
		p->next = next_timer;
		next_timer = p;
		while (p->next && p->next->jiffies < p->jiffies) {
    72a6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    72aa:	8b 40 08             	mov    0x8(%eax),%eax
    72ad:	85 c0                	test   %eax,%eax
    72af:	74 17                	je     72c8 <add_timer+0x125>
    72b1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    72b5:	8b 40 08             	mov    0x8(%eax),%eax
    72b8:	8b 10                	mov    (%eax),%edx
    72ba:	8b 44 24 0c          	mov    0xc(%esp),%eax
    72be:	8b 00                	mov    (%eax),%eax
    72c0:	39 c2                	cmp    %eax,%edx
    72c2:	0f 8c 6c ff ff ff    	jl     7234 <add_timer+0x91>
			p->jiffies = p->next->jiffies;
			p->next->jiffies = jiffies;
			p = p->next;
		}
	}
	sti();
    72c8:	fb                   	sti    
    72c9:	eb 01                	jmp    72cc <add_timer+0x129>
void add_timer(long jiffies, void (*fn)(void))
{
	struct timer_list * p;

	if (!fn)
		return;
    72cb:	90                   	nop
			p->next->jiffies = jiffies;
			p = p->next;
		}
	}
	sti();
}
    72cc:	83 c4 1c             	add    $0x1c,%esp
    72cf:	c3                   	ret    

000072d0 <do_timer>:

void do_timer(long cpl)
{
    72d0:	83 ec 1c             	sub    $0x1c,%esp
	extern int beepcount;
	extern void sysbeepstop(void);

	if (beepcount)
    72d3:	a1 c0 3d 02 00       	mov    0x23dc0,%eax
    72d8:	85 c0                	test   %eax,%eax
    72da:	74 1b                	je     72f7 <do_timer+0x27>
		if (!--beepcount)
    72dc:	a1 c0 3d 02 00       	mov    0x23dc0,%eax
    72e1:	83 e8 01             	sub    $0x1,%eax
    72e4:	a3 c0 3d 02 00       	mov    %eax,0x23dc0
    72e9:	a1 c0 3d 02 00       	mov    0x23dc0,%eax
    72ee:	85 c0                	test   %eax,%eax
    72f0:	75 05                	jne    72f7 <do_timer+0x27>
			sysbeepstop();
    72f2:	e8 3b f9 00 00       	call   16c32 <sysbeepstop>

	if (cpl)
    72f7:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    72fc:	74 16                	je     7314 <do_timer+0x44>
		current->utime++;
    72fe:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7303:	8b 90 50 02 00 00    	mov    0x250(%eax),%edx
    7309:	83 c2 01             	add    $0x1,%edx
    730c:	89 90 50 02 00 00    	mov    %edx,0x250(%eax)
    7312:	eb 14                	jmp    7328 <do_timer+0x58>
	else
		current->stime++;
    7314:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7319:	8b 90 54 02 00 00    	mov    0x254(%eax),%edx
    731f:	83 c2 01             	add    $0x1,%edx
    7322:	89 90 54 02 00 00    	mov    %edx,0x254(%eax)

	if (next_timer) {
    7328:	a1 20 22 02 00       	mov    0x22220,%eax
    732d:	85 c0                	test   %eax,%eax
    732f:	74 4d                	je     737e <do_timer+0xae>
		next_timer->jiffies--;
    7331:	a1 20 22 02 00       	mov    0x22220,%eax
    7336:	8b 10                	mov    (%eax),%edx
    7338:	83 ea 01             	sub    $0x1,%edx
    733b:	89 10                	mov    %edx,(%eax)
		while (next_timer && next_timer->jiffies <= 0) {
    733d:	eb 2b                	jmp    736a <do_timer+0x9a>
			void (*fn)(void);
			
			fn = next_timer->fn;
    733f:	a1 20 22 02 00       	mov    0x22220,%eax
    7344:	8b 40 04             	mov    0x4(%eax),%eax
    7347:	89 44 24 0c          	mov    %eax,0xc(%esp)
			next_timer->fn = NULL;
    734b:	a1 20 22 02 00       	mov    0x22220,%eax
    7350:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			next_timer = next_timer->next;
    7357:	a1 20 22 02 00       	mov    0x22220,%eax
    735c:	8b 40 08             	mov    0x8(%eax),%eax
    735f:	a3 20 22 02 00       	mov    %eax,0x22220
			(fn)();
    7364:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7368:	ff d0                	call   *%eax
	else
		current->stime++;

	if (next_timer) {
		next_timer->jiffies--;
		while (next_timer && next_timer->jiffies <= 0) {
    736a:	a1 20 22 02 00       	mov    0x22220,%eax
    736f:	85 c0                	test   %eax,%eax
    7371:	74 0b                	je     737e <do_timer+0xae>
    7373:	a1 20 22 02 00       	mov    0x22220,%eax
    7378:	8b 00                	mov    (%eax),%eax
    737a:	85 c0                	test   %eax,%eax
    737c:	7e c1                	jle    733f <do_timer+0x6f>
			next_timer->fn = NULL;
			next_timer = next_timer->next;
			(fn)();
		}
	}
	if (current_DOR & 0xf0)
    737e:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
    7385:	0f b6 c0             	movzbl %al,%eax
    7388:	25 f0 00 00 00       	and    $0xf0,%eax
    738d:	85 c0                	test   %eax,%eax
    738f:	74 05                	je     7396 <do_timer+0xc6>
		do_floppy_timer();
    7391:	e8 2d fd ff ff       	call   70c3 <do_floppy_timer>
	if ((--current->counter)>0) return;
    7396:	a1 40 f1 01 00       	mov    0x1f140,%eax
    739b:	8b 50 04             	mov    0x4(%eax),%edx
    739e:	83 ea 01             	sub    $0x1,%edx
    73a1:	89 50 04             	mov    %edx,0x4(%eax)
    73a4:	8b 40 04             	mov    0x4(%eax),%eax
    73a7:	85 c0                	test   %eax,%eax
    73a9:	7f 1a                	jg     73c5 <do_timer+0xf5>
	current->counter=0;
    73ab:	a1 40 f1 01 00       	mov    0x1f140,%eax
    73b0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	if (!cpl) return;
    73b7:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    73bc:	74 0a                	je     73c8 <do_timer+0xf8>
	schedule();
    73be:	e8 e6 f8 ff ff       	call   6ca9 <schedule>
    73c3:	eb 04                	jmp    73c9 <do_timer+0xf9>
			(fn)();
		}
	}
	if (current_DOR & 0xf0)
		do_floppy_timer();
	if ((--current->counter)>0) return;
    73c5:	90                   	nop
    73c6:	eb 01                	jmp    73c9 <do_timer+0xf9>
	current->counter=0;
	if (!cpl) return;
    73c8:	90                   	nop
	schedule();
}
    73c9:	83 c4 1c             	add    $0x1c,%esp
    73cc:	c3                   	ret    

000073cd <sys_alarm>:

int sys_alarm(long seconds)
{
    73cd:	83 ec 10             	sub    $0x10,%esp
	int old = current->alarm;
    73d0:	a1 40 f1 01 00       	mov    0x1f140,%eax
    73d5:	8b 80 4c 02 00 00    	mov    0x24c(%eax),%eax
    73db:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if (old)
    73df:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    73e4:	74 26                	je     740c <sys_alarm+0x3f>
		old = (old - jiffies) / HZ;
    73e6:	a1 e0 1e 02 00       	mov    0x21ee0,%eax
    73eb:	8b 54 24 0c          	mov    0xc(%esp),%edx
    73ef:	89 d1                	mov    %edx,%ecx
    73f1:	29 c1                	sub    %eax,%ecx
    73f3:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    73f8:	89 c8                	mov    %ecx,%eax
    73fa:	f7 ea                	imul   %edx
    73fc:	c1 fa 05             	sar    $0x5,%edx
    73ff:	89 c8                	mov    %ecx,%eax
    7401:	c1 f8 1f             	sar    $0x1f,%eax
    7404:	29 c2                	sub    %eax,%edx
    7406:	89 d0                	mov    %edx,%eax
    7408:	89 44 24 0c          	mov    %eax,0xc(%esp)
	current->alarm = (seconds>0)?(jiffies+HZ*seconds):0;
    740c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7411:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    7416:	7e 11                	jle    7429 <sys_alarm+0x5c>
    7418:	8b 54 24 14          	mov    0x14(%esp),%edx
    741c:	6b ca 64             	imul   $0x64,%edx,%ecx
    741f:	8b 15 e0 1e 02 00    	mov    0x21ee0,%edx
    7425:	01 ca                	add    %ecx,%edx
    7427:	eb 05                	jmp    742e <sys_alarm+0x61>
    7429:	ba 00 00 00 00       	mov    $0x0,%edx
    742e:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
	return (old);
    7434:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    7438:	83 c4 10             	add    $0x10,%esp
    743b:	c3                   	ret    

0000743c <sys_getpid>:

int sys_getpid(void)
{
	return current->pid;
    743c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7441:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
}
    7447:	c3                   	ret    

00007448 <sys_getppid>:

int sys_getppid(void)
{
	return current->father;
    7448:	a1 40 f1 01 00       	mov    0x1f140,%eax
    744d:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
}
    7453:	c3                   	ret    

00007454 <sys_getuid>:

int sys_getuid(void)
{
	return current->uid;
    7454:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7459:	0f b7 80 40 02 00 00 	movzwl 0x240(%eax),%eax
    7460:	0f b7 c0             	movzwl %ax,%eax
}
    7463:	c3                   	ret    

00007464 <sys_geteuid>:

int sys_geteuid(void)
{
	return current->euid;
    7464:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7469:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    7470:	0f b7 c0             	movzwl %ax,%eax
}
    7473:	c3                   	ret    

00007474 <sys_getgid>:

int sys_getgid(void)
{
	return current->gid;
    7474:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7479:	0f b7 80 46 02 00 00 	movzwl 0x246(%eax),%eax
    7480:	0f b7 c0             	movzwl %ax,%eax
}
    7483:	c3                   	ret    

00007484 <sys_getegid>:

int sys_getegid(void)
{
	return current->egid;
    7484:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7489:	0f b7 80 48 02 00 00 	movzwl 0x248(%eax),%eax
    7490:	0f b7 c0             	movzwl %ax,%eax
}
    7493:	c3                   	ret    

00007494 <sys_nice>:

int sys_nice(long increment)
{
	if (current->priority-increment>0)
    7494:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7499:	8b 40 08             	mov    0x8(%eax),%eax
    749c:	2b 44 24 04          	sub    0x4(%esp),%eax
    74a0:	85 c0                	test   %eax,%eax
    74a2:	7e 15                	jle    74b9 <sys_nice+0x25>
		current->priority -= increment;
    74a4:	a1 40 f1 01 00       	mov    0x1f140,%eax
    74a9:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    74af:	8b 52 08             	mov    0x8(%edx),%edx
    74b2:	2b 54 24 04          	sub    0x4(%esp),%edx
    74b6:	89 50 08             	mov    %edx,0x8(%eax)
	return 0;
    74b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    74be:	c3                   	ret    

000074bf <sched_init>:

void sched_init(void)
{
    74bf:	55                   	push   %ebp
    74c0:	57                   	push   %edi
    74c1:	56                   	push   %esi
    74c2:	53                   	push   %ebx
    74c3:	83 ec 10             	sub    $0x10,%esp
	int i;
	struct desc_struct * p;

	if (sizeof(struct sigaction) != 16)
		panic("Struct sigaction MUST be 16 bytes");
	set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
    74c6:	b8 28 e4 01 00       	mov    $0x1e428,%eax
    74cb:	ba d8 5c 00 00       	mov    $0x5cd8,%edx
    74d0:	b9 da 5c 00 00       	mov    $0x5cda,%ecx
    74d5:	bb dc 5c 00 00       	mov    $0x5cdc,%ebx
    74da:	be dd 5c 00 00       	mov    $0x5cdd,%esi
    74df:	bf de 5c 00 00       	mov    $0x5cde,%edi
    74e4:	bd df 5c 00 00       	mov    $0x5cdf,%ebp
    74e9:	66 c7 02 68 00       	movw   $0x68,(%edx)
    74ee:	66 89 01             	mov    %ax,(%ecx)
    74f1:	c1 c8 10             	ror    $0x10,%eax
    74f4:	88 03                	mov    %al,(%ebx)
    74f6:	c6 06 89             	movb   $0x89,(%esi)
    74f9:	c6 07 00             	movb   $0x0,(%edi)
    74fc:	88 65 00             	mov    %ah,0x0(%ebp)
    74ff:	c1 c8 10             	ror    $0x10,%eax
	set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
    7502:	b8 10 e4 01 00       	mov    $0x1e410,%eax
    7507:	ba e0 5c 00 00       	mov    $0x5ce0,%edx
    750c:	b9 e2 5c 00 00       	mov    $0x5ce2,%ecx
    7511:	bb e4 5c 00 00       	mov    $0x5ce4,%ebx
    7516:	be e5 5c 00 00       	mov    $0x5ce5,%esi
    751b:	bf e6 5c 00 00       	mov    $0x5ce6,%edi
    7520:	bd e7 5c 00 00       	mov    $0x5ce7,%ebp
    7525:	66 c7 02 68 00       	movw   $0x68,(%edx)
    752a:	66 89 01             	mov    %ax,(%ecx)
    752d:	c1 c8 10             	ror    $0x10,%eax
    7530:	88 03                	mov    %al,(%ebx)
    7532:	c6 06 82             	movb   $0x82,(%esi)
    7535:	c6 07 00             	movb   $0x0,(%edi)
    7538:	88 65 00             	mov    %ah,0x0(%ebp)
    753b:	c1 c8 10             	ror    $0x10,%eax
	p = gdt+2+FIRST_TSS_ENTRY;
    753e:	c7 44 24 08 e8 5c 00 	movl   $0x5ce8,0x8(%esp)
    7545:	00 
	for(i=1;i<NR_TASKS;i++) {
    7546:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    754d:	00 
    754e:	eb 4e                	jmp    759e <sched_init+0xdf>
		task[i] = NULL;
    7550:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7554:	c7 04 85 60 f1 01 00 	movl   $0x0,0x1f160(,%eax,4)
    755b:	00 00 00 00 
		p->a=p->b=0;
    755f:	8b 44 24 08          	mov    0x8(%esp),%eax
    7563:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    756a:	8b 44 24 08          	mov    0x8(%esp),%eax
    756e:	8b 50 04             	mov    0x4(%eax),%edx
    7571:	8b 44 24 08          	mov    0x8(%esp),%eax
    7575:	89 10                	mov    %edx,(%eax)
		p++;
    7577:	83 44 24 08 08       	addl   $0x8,0x8(%esp)
		p->a=p->b=0;
    757c:	8b 44 24 08          	mov    0x8(%esp),%eax
    7580:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    7587:	8b 44 24 08          	mov    0x8(%esp),%eax
    758b:	8b 50 04             	mov    0x4(%eax),%edx
    758e:	8b 44 24 08          	mov    0x8(%esp),%eax
    7592:	89 10                	mov    %edx,(%eax)
		p++;
    7594:	83 44 24 08 08       	addl   $0x8,0x8(%esp)
	if (sizeof(struct sigaction) != 16)
		panic("Struct sigaction MUST be 16 bytes");
	set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
	set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
	p = gdt+2+FIRST_TSS_ENTRY;
	for(i=1;i<NR_TASKS;i++) {
    7599:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    759e:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    75a3:	7e ab                	jle    7550 <sched_init+0x91>
		p++;
		p->a=p->b=0;
		p++;
	}
/* Clear NT, so that we won't have troubles with that later on */
	__asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
    75a5:	9c                   	pushf  
    75a6:	81 24 24 ff bf ff ff 	andl   $0xffffbfff,(%esp)
    75ad:	9d                   	popf   
	ltr(0);
    75ae:	b8 20 00 00 00       	mov    $0x20,%eax
    75b3:	0f 00 d8             	ltr    %ax
	lldt(0);
    75b6:	b8 28 00 00 00       	mov    $0x28,%eax
    75bb:	0f 00 d0             	lldt   %ax
	outb_p(0x36,0x43);		/* binary, mode 3, LSB/MSB, ch 0 */
    75be:	b8 36 00 00 00       	mov    $0x36,%eax
    75c3:	ba 43 00 00 00       	mov    $0x43,%edx
    75c8:	ee                   	out    %al,(%dx)
    75c9:	eb 00                	jmp    75cb <sched_init+0x10c>
    75cb:	eb 00                	jmp    75cd <sched_init+0x10e>
	outb_p(LATCH & 0xff , 0x40);	/* LSB */
    75cd:	b8 9b 00 00 00       	mov    $0x9b,%eax
    75d2:	ba 40 00 00 00       	mov    $0x40,%edx
    75d7:	ee                   	out    %al,(%dx)
    75d8:	eb 00                	jmp    75da <sched_init+0x11b>
    75da:	eb 00                	jmp    75dc <sched_init+0x11d>
	outb(LATCH >> 8 , 0x40);	/* MSB */
    75dc:	b8 2e 00 00 00       	mov    $0x2e,%eax
    75e1:	ba 40 00 00 00       	mov    $0x40,%edx
    75e6:	ee                   	out    %al,(%dx)
	set_intr_gate(0x20,&timer_interrupt);
    75e7:	b9 b8 55 00 00       	mov    $0x55b8,%ecx
    75ec:	bb bc 55 00 00       	mov    $0x55bc,%ebx
    75f1:	ba 36 77 00 00       	mov    $0x7736,%edx
    75f6:	b8 00 00 08 00       	mov    $0x80000,%eax
    75fb:	66 89 d0             	mov    %dx,%ax
    75fe:	66 ba 00 8e          	mov    $0x8e00,%dx
    7602:	89 01                	mov    %eax,(%ecx)
    7604:	89 13                	mov    %edx,(%ebx)
	outb(inb_p(0x21)&~0x01,0x21);
    7606:	b8 21 00 00 00       	mov    $0x21,%eax
    760b:	89 c2                	mov    %eax,%edx
    760d:	ec                   	in     (%dx),%al
    760e:	eb 00                	jmp    7610 <sched_init+0x151>
    7610:	eb 00                	jmp    7612 <sched_init+0x153>
    7612:	88 44 24 07          	mov    %al,0x7(%esp)
    7616:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
    761b:	0f b6 c0             	movzbl %al,%eax
    761e:	83 e0 fe             	and    $0xfffffffe,%eax
    7621:	ba 21 00 00 00       	mov    $0x21,%edx
    7626:	ee                   	out    %al,(%dx)
	set_system_gate(0x80,&system_call);
    7627:	b9 b8 58 00 00       	mov    $0x58b8,%ecx
    762c:	bb bc 58 00 00       	mov    $0x58bc,%ebx
    7631:	ba 60 76 00 00       	mov    $0x7660,%edx
    7636:	b8 00 00 08 00       	mov    $0x80000,%eax
    763b:	66 89 d0             	mov    %dx,%ax
    763e:	66 ba 00 ef          	mov    $0xef00,%dx
    7642:	89 01                	mov    %eax,(%ecx)
    7644:	89 13                	mov    %edx,(%ebx)
}
    7646:	90                   	nop
    7647:	83 c4 10             	add    $0x10,%esp
    764a:	5b                   	pop    %ebx
    764b:	5e                   	pop    %esi
    764c:	5f                   	pop    %edi
    764d:	5d                   	pop    %ebp
    764e:	c3                   	ret    
    764f:	90                   	nop

00007650 <bad_sys_call>:
.globl hd_interrupt,floppy_interrupt,parallel_interrupt
.globl device_not_available, coprocessor_error

.align 2
bad_sys_call:
	movl $-1,%eax
    7650:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	iret
    7655:	cf                   	iret   

00007656 <reschedule>:
.align 2
reschedule:
	pushl $ret_from_sys_call
    7656:	68 94 76 00 00       	push   $0x7694
	jmp schedule
    765b:	e9 49 f6 ff ff       	jmp    6ca9 <schedule>

00007660 <system_call>:
.align 2
system_call:
	cmpl $nr_system_calls-1,%eax
    7660:	83 f8 47             	cmp    $0x47,%eax
	ja bad_sys_call
    7663:	77 eb                	ja     7650 <bad_sys_call>
	push %ds
    7665:	1e                   	push   %ds
	push %es
    7666:	06                   	push   %es
	push %fs
    7667:	0f a0                	push   %fs
	pushl %edx
    7669:	52                   	push   %edx
	pushl %ecx		# push %ebx,%ecx,%edx as parameters
    766a:	51                   	push   %ecx
	pushl %ebx		# to the system call
    766b:	53                   	push   %ebx
	movl $0x10,%edx		# set up ds,es to kernel space
    766c:	ba 10 00 00 00       	mov    $0x10,%edx
	mov %dx,%ds
    7671:	8e da                	mov    %edx,%ds
	mov %dx,%es
    7673:	8e c2                	mov    %edx,%es
	movl $0x17,%edx		# fs points to local data space
    7675:	ba 17 00 00 00       	mov    $0x17,%edx
	mov %dx,%fs
    767a:	8e e2                	mov    %edx,%fs
	call *sys_call_table(,%eax,4)
    767c:	ff 14 85 20 e0 01 00 	call   *0x1e020(,%eax,4)
	pushl %eax
    7683:	50                   	push   %eax
	movl current,%eax
    7684:	a1 40 f1 01 00       	mov    0x1f140,%eax
	cmpl $0,state(%eax)		# state
    7689:	83 38 00             	cmpl   $0x0,(%eax)
	jne reschedule
    768c:	75 c8                	jne    7656 <reschedule>
	cmpl $0,counter(%eax)		# counter
    768e:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
	je reschedule
    7692:	74 c2                	je     7656 <reschedule>

00007694 <ret_from_sys_call>:
ret_from_sys_call:
	movl current,%eax		# task[0] cannot have signals
    7694:	a1 40 f1 01 00       	mov    0x1f140,%eax
	cmpl task,%eax
    7699:	3b 05 60 f1 01 00    	cmp    0x1f160,%eax
	je 3f
    769f:	74 30                	je     76d1 <ret_from_sys_call+0x3d>
	cmpw $0x0f,CS(%esp)		# was old code segment supervisor ?
    76a1:	66 83 7c 24 20 0f    	cmpw   $0xf,0x20(%esp)
	jne 3f
    76a7:	75 28                	jne    76d1 <ret_from_sys_call+0x3d>
	cmpw $0x17,OLDSS(%esp)		# was stack segment = 0x17 ?
    76a9:	66 83 7c 24 2c 17    	cmpw   $0x17,0x2c(%esp)
	jne 3f
    76af:	75 20                	jne    76d1 <ret_from_sys_call+0x3d>
	movl signal(%eax),%ebx
    76b1:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl blocked(%eax),%ecx
    76b4:	8b 88 10 02 00 00    	mov    0x210(%eax),%ecx
	notl %ecx
    76ba:	f7 d1                	not    %ecx
	andl %ebx,%ecx
    76bc:	21 d9                	and    %ebx,%ecx
	bsfl %ecx,%ecx
    76be:	0f bc c9             	bsf    %ecx,%ecx
	je 3f
    76c1:	74 0e                	je     76d1 <ret_from_sys_call+0x3d>
	btrl %ecx,%ebx
    76c3:	0f b3 cb             	btr    %ecx,%ebx
	movl %ebx,signal(%eax)
    76c6:	89 58 0c             	mov    %ebx,0xc(%eax)
	incl %ecx
    76c9:	41                   	inc    %ecx
	pushl %ecx
    76ca:	51                   	push   %ecx
	call do_signal
    76cb:	e8 ad 29 00 00       	call   a07d <do_signal>
	popl %eax
    76d0:	58                   	pop    %eax
3:	popl %eax
    76d1:	58                   	pop    %eax
	popl %ebx
    76d2:	5b                   	pop    %ebx
	popl %ecx
    76d3:	59                   	pop    %ecx
	popl %edx
    76d4:	5a                   	pop    %edx
	pop %fs
    76d5:	0f a1                	pop    %fs
	pop %es
    76d7:	07                   	pop    %es
	pop %ds
    76d8:	1f                   	pop    %ds
	iret
    76d9:	cf                   	iret   

000076da <coprocessor_error>:

.align 2
coprocessor_error:
	push %ds
    76da:	1e                   	push   %ds
	push %es
    76db:	06                   	push   %es
	push %fs
    76dc:	0f a0                	push   %fs
	pushl %edx
    76de:	52                   	push   %edx
	pushl %ecx
    76df:	51                   	push   %ecx
	pushl %ebx
    76e0:	53                   	push   %ebx
	pushl %eax
    76e1:	50                   	push   %eax
	movl $0x10,%eax
    76e2:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
    76e7:	8e d8                	mov    %eax,%ds
	mov %ax,%es
    76e9:	8e c0                	mov    %eax,%es
	movl $0x17,%eax
    76eb:	b8 17 00 00 00       	mov    $0x17,%eax
	mov %ax,%fs
    76f0:	8e e0                	mov    %eax,%fs
	pushl $ret_from_sys_call
    76f2:	68 94 76 00 00       	push   $0x7694
	jmp math_error
    76f7:	e9 11 07 01 00       	jmp    17e0d <math_error>

000076fc <device_not_available>:

.align 2
device_not_available:
	push %ds
    76fc:	1e                   	push   %ds
	push %es
    76fd:	06                   	push   %es
	push %fs
    76fe:	0f a0                	push   %fs
	pushl %edx
    7700:	52                   	push   %edx
	pushl %ecx
    7701:	51                   	push   %ecx
	pushl %ebx
    7702:	53                   	push   %ebx
	pushl %eax
    7703:	50                   	push   %eax
	movl $0x10,%eax
    7704:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
    7709:	8e d8                	mov    %eax,%ds
	mov %ax,%es
    770b:	8e c0                	mov    %eax,%es
	movl $0x17,%eax
    770d:	b8 17 00 00 00       	mov    $0x17,%eax
	mov %ax,%fs
    7712:	8e e0                	mov    %eax,%fs
	pushl $ret_from_sys_call
    7714:	68 94 76 00 00       	push   $0x7694
	clts				# clear TS so that we can use math
    7719:	0f 06                	clts   
	movl %cr0,%eax
    771b:	0f 20 c0             	mov    %cr0,%eax
	testl $0x4,%eax			# EM (math emulation bit)
    771e:	a9 04 00 00 00       	test   $0x4,%eax
	je math_state_restore
    7723:	0f 84 20 f5 ff ff    	je     6c49 <math_state_restore>
	pushl %ebp
    7729:	55                   	push   %ebp
	pushl %esi
    772a:	56                   	push   %esi
	pushl %edi
    772b:	57                   	push   %edi
	call math_emulate
    772c:	e8 fc 05 01 00       	call   17d2d <math_emulate>
	popl %edi
    7731:	5f                   	pop    %edi
	popl %esi
    7732:	5e                   	pop    %esi
	popl %ebp
    7733:	5d                   	pop    %ebp
	ret
    7734:	c3                   	ret    
    7735:	90                   	nop

00007736 <timer_interrupt>:

.align 2
timer_interrupt:
	push %ds		# save ds,es and put kernel data space
    7736:	1e                   	push   %ds
	push %es		# into them. %fs is used by _system_call
    7737:	06                   	push   %es
	push %fs
    7738:	0f a0                	push   %fs
	pushl %edx		# we save %eax,%ecx,%edx as gcc doesn't
    773a:	52                   	push   %edx
	pushl %ecx		# save those across function calls. %ebx
    773b:	51                   	push   %ecx
	pushl %ebx		# is saved as we use that in ret_sys_call
    773c:	53                   	push   %ebx
	pushl %eax
    773d:	50                   	push   %eax
	movl $0x10,%eax
    773e:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
    7743:	8e d8                	mov    %eax,%ds
	mov %ax,%es
    7745:	8e c0                	mov    %eax,%es
	movl $0x17,%eax
    7747:	b8 17 00 00 00       	mov    $0x17,%eax
	mov %ax,%fs
    774c:	8e e0                	mov    %eax,%fs
	incl jiffies
    774e:	ff 05 e0 1e 02 00    	incl   0x21ee0
	movb $0x20,%al		# EOI to interrupt controller #1
    7754:	b0 20                	mov    $0x20,%al
	outb %al,$0x20
    7756:	e6 20                	out    %al,$0x20
	movl CS(%esp),%eax
    7758:	8b 44 24 20          	mov    0x20(%esp),%eax
	andl $3,%eax		# %eax is CPL (0 or 3, 0=supervisor)
    775c:	83 e0 03             	and    $0x3,%eax
	pushl %eax
    775f:	50                   	push   %eax
	call do_timer		# 'do_timer(long CPL)' does everything from
    7760:	e8 6b fb ff ff       	call   72d0 <do_timer>
	addl $4,%esp		# task switching to accounting ...
    7765:	83 c4 04             	add    $0x4,%esp
	jmp ret_from_sys_call
    7768:	e9 27 ff ff ff       	jmp    7694 <ret_from_sys_call>
    776d:	90                   	nop

0000776e <sys_execve>:

.align 2
sys_execve:
	lea EIP(%esp),%eax
    776e:	8d 44 24 1c          	lea    0x1c(%esp),%eax
	pushl %eax
    7772:	50                   	push   %eax
	call do_execve
    7773:	e8 38 77 00 00       	call   eeb0 <do_execve>
	addl $4,%esp
    7778:	83 c4 04             	add    $0x4,%esp
	ret
    777b:	c3                   	ret    

0000777c <sys_fork>:

.align 2
sys_fork:
	call find_empty_process
    777c:	e8 b5 0f 00 00       	call   8736 <find_empty_process>
	testl %eax,%eax
    7781:	85 c0                	test   %eax,%eax
	js 1f
    7783:	78 0e                	js     7793 <sys_fork+0x17>
	push %gs
    7785:	0f a8                	push   %gs
	pushl %esi
    7787:	56                   	push   %esi
	pushl %edi
    7788:	57                   	push   %edi
	pushl %ebp
    7789:	55                   	push   %ebp
	pushl %eax
    778a:	50                   	push   %eax
	call copy_process
    778b:	e8 ed 0a 00 00       	call   827d <copy_process>
	addl $20,%esp
    7790:	83 c4 14             	add    $0x14,%esp
1:	ret
    7793:	c3                   	ret    

00007794 <hd_interrupt>:

hd_interrupt:
	pushl %eax
    7794:	50                   	push   %eax
	pushl %ecx
    7795:	51                   	push   %ecx
	pushl %edx
    7796:	52                   	push   %edx
	push %ds
    7797:	1e                   	push   %ds
	push %es
    7798:	06                   	push   %es
	push %fs
    7799:	0f a0                	push   %fs
	movl $0x10,%eax
    779b:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
    77a0:	8e d8                	mov    %eax,%ds
	mov %ax,%es
    77a2:	8e c0                	mov    %eax,%es
	movl $0x17,%eax
    77a4:	b8 17 00 00 00       	mov    $0x17,%eax
	mov %ax,%fs
    77a9:	8e e0                	mov    %eax,%fs
	movb $0x20,%al
    77ab:	b0 20                	mov    $0x20,%al
	outb %al,$0xA0		# EOI to interrupt controller #1
    77ad:	e6 a0                	out    %al,$0xa0
	jmp 1f			# give port chance to breathe
    77af:	eb 00                	jmp    77b1 <hd_interrupt+0x1d>
1:	jmp 1f
    77b1:	eb 00                	jmp    77b3 <hd_interrupt+0x1f>
1:	xorl %edx,%edx
    77b3:	31 d2                	xor    %edx,%edx
	xchgl do_hd,%edx
    77b5:	87 15 00 3d 02 00    	xchg   %edx,0x23d00
	testl %edx,%edx
    77bb:	85 d2                	test   %edx,%edx
	jne 1f
    77bd:	75 05                	jne    77c4 <hd_interrupt+0x30>
	movl $unexpected_hd_interrupt,%edx
    77bf:	ba 7e 42 01 00       	mov    $0x1427e,%edx
1:	outb %al,$0x20
    77c4:	e6 20                	out    %al,$0x20
	call *%edx		# "interesting" way of handling intr.
    77c6:	ff d2                	call   *%edx
	pop %fs
    77c8:	0f a1                	pop    %fs
	pop %es
    77ca:	07                   	pop    %es
	pop %ds
    77cb:	1f                   	pop    %ds
	popl %edx
    77cc:	5a                   	pop    %edx
	popl %ecx
    77cd:	59                   	pop    %ecx
	popl %eax
    77ce:	58                   	pop    %eax
	iret
    77cf:	cf                   	iret   

000077d0 <floppy_interrupt>:

floppy_interrupt:
	pushl %eax
    77d0:	50                   	push   %eax
	pushl %ecx
    77d1:	51                   	push   %ecx
	pushl %edx
    77d2:	52                   	push   %edx
	push %ds
    77d3:	1e                   	push   %ds
	push %es
    77d4:	06                   	push   %es
	push %fs
    77d5:	0f a0                	push   %fs
	movl $0x10,%eax
    77d7:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
    77dc:	8e d8                	mov    %eax,%ds
	mov %ax,%es
    77de:	8e c0                	mov    %eax,%es
	movl $0x17,%eax
    77e0:	b8 17 00 00 00       	mov    $0x17,%eax
	mov %ax,%fs
    77e5:	8e e0                	mov    %eax,%fs
	movb $0x20,%al
    77e7:	b0 20                	mov    $0x20,%al
	outb %al,$0x20		# EOI to interrupt controller #1
    77e9:	e6 20                	out    %al,$0x20
	xorl %eax,%eax
    77eb:	31 c0                	xor    %eax,%eax
	xchgl do_floppy,%eax
    77ed:	87 05 d8 3c 02 00    	xchg   %eax,0x23cd8
	testl %eax,%eax
    77f3:	85 c0                	test   %eax,%eax
	jne 1f
    77f5:	75 05                	jne    77fc <floppy_interrupt+0x2c>
	movl $unexpected_floppy_interrupt,%eax
    77f7:	b8 3c 36 01 00       	mov    $0x1363c,%eax
1:	call *%eax		# "interesting" way of handling intr.
    77fc:	ff d0                	call   *%eax
	pop %fs
    77fe:	0f a1                	pop    %fs
	pop %es
    7800:	07                   	pop    %es
	pop %ds
    7801:	1f                   	pop    %ds
	popl %edx
    7802:	5a                   	pop    %edx
	popl %ecx
    7803:	59                   	pop    %ecx
	popl %eax
    7804:	58                   	pop    %eax
	iret
    7805:	cf                   	iret   

00007806 <parallel_interrupt>:

parallel_interrupt:
	pushl %eax
    7806:	50                   	push   %eax
	movb $0x20,%al
    7807:	b0 20                	mov    $0x20,%al
	outb %al,$0x20
    7809:	e6 20                	out    %al,$0x20
	popl %eax
    780b:	58                   	pop    %eax
	iret
    780c:	cf                   	iret   

0000780d <_get_base>:
        :"memory"); \
__base;})
**/

static inline unsigned long _get_base(char * addr)
{
    780d:	53                   	push   %ebx
    780e:	83 ec 10             	sub    $0x10,%esp
         __asm__("movb %3,%%dh\n\t"
                 "movb %2,%%dl\n\t"
                 "shll $16,%%edx\n\t"
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
    7811:	8b 44 24 18          	mov    0x18(%esp),%eax
    7815:	83 c0 02             	add    $0x2,%eax
                  "m" (*((addr)+4)),
    7818:	8b 54 24 18          	mov    0x18(%esp),%edx
    781c:	8d 5a 04             	lea    0x4(%edx),%ebx
                  "m" (*((addr)+7)));
    781f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    7823:	83 c1 07             	add    $0x7,%ecx
**/

static inline unsigned long _get_base(char * addr)
{
         unsigned long __base;
         __asm__("movb %3,%%dh\n\t"
    7826:	8a 31                	mov    (%ecx),%dh
    7828:	8a 13                	mov    (%ebx),%dl
    782a:	c1 e2 10             	shl    $0x10,%edx
    782d:	66 8b 10             	mov    (%eax),%dx
    7830:	89 d0                	mov    %edx,%eax
    7832:	89 44 24 0c          	mov    %eax,0xc(%esp)
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
                  "m" (*((addr)+4)),
                  "m" (*((addr)+7)));
         return __base;
    7836:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    783a:	83 c4 10             	add    $0x10,%esp
    783d:	5b                   	pop    %ebx
    783e:	c3                   	ret    

0000783f <die>:
void reserved(void);
void parallel_interrupt(void);
void irq13(void);

static void die(char * str,long esp_ptr,long nr)
{
    783f:	56                   	push   %esi
    7840:	53                   	push   %ebx
    7841:	83 ec 14             	sub    $0x14,%esp
	long * esp = (long *) esp_ptr;
    7844:	8b 44 24 24          	mov    0x24(%esp),%eax
    7848:	89 44 24 08          	mov    %eax,0x8(%esp)
	int i;

	printk("%s: %04x\n\r",str,nr&0xffff);
    784c:	8b 44 24 28          	mov    0x28(%esp),%eax
    7850:	0f b7 c0             	movzwl %ax,%eax
    7853:	83 ec 04             	sub    $0x4,%esp
    7856:	50                   	push   %eax
    7857:	ff 74 24 28          	pushl  0x28(%esp)
    785b:	68 24 81 01 00       	push   $0x18124
    7860:	e8 a8 0f 00 00       	call   880d <printk>
    7865:	83 c4 10             	add    $0x10,%esp
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
		esp[1],esp[0],esp[2],esp[4],esp[3]);
    7868:	8b 44 24 08          	mov    0x8(%esp),%eax
    786c:	83 c0 0c             	add    $0xc,%eax
{
	long * esp = (long *) esp_ptr;
	int i;

	printk("%s: %04x\n\r",str,nr&0xffff);
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    786f:	8b 30                	mov    (%eax),%esi
		esp[1],esp[0],esp[2],esp[4],esp[3]);
    7871:	8b 44 24 08          	mov    0x8(%esp),%eax
    7875:	83 c0 10             	add    $0x10,%eax
{
	long * esp = (long *) esp_ptr;
	int i;

	printk("%s: %04x\n\r",str,nr&0xffff);
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7878:	8b 18                	mov    (%eax),%ebx
		esp[1],esp[0],esp[2],esp[4],esp[3]);
    787a:	8b 44 24 08          	mov    0x8(%esp),%eax
    787e:	83 c0 08             	add    $0x8,%eax
{
	long * esp = (long *) esp_ptr;
	int i;

	printk("%s: %04x\n\r",str,nr&0xffff);
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7881:	8b 08                	mov    (%eax),%ecx
    7883:	8b 44 24 08          	mov    0x8(%esp),%eax
    7887:	8b 10                	mov    (%eax),%edx
		esp[1],esp[0],esp[2],esp[4],esp[3]);
    7889:	8b 44 24 08          	mov    0x8(%esp),%eax
    788d:	83 c0 04             	add    $0x4,%eax
{
	long * esp = (long *) esp_ptr;
	int i;

	printk("%s: %04x\n\r",str,nr&0xffff);
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7890:	8b 00                	mov    (%eax),%eax
    7892:	83 ec 08             	sub    $0x8,%esp
    7895:	56                   	push   %esi
    7896:	53                   	push   %ebx
    7897:	51                   	push   %ecx
    7898:	52                   	push   %edx
    7899:	50                   	push   %eax
    789a:	68 30 81 01 00       	push   $0x18130
    789f:	e8 69 0f 00 00       	call   880d <printk>
    78a4:	83 c4 20             	add    $0x20,%esp
		esp[1],esp[0],esp[2],esp[4],esp[3]);
	printk("fs: %04x\n",_fs());
    78a7:	66 8c e0             	mov    %fs,%ax
    78aa:	89 c3                	mov    %eax,%ebx
    78ac:	89 d8                	mov    %ebx,%eax
    78ae:	0f b7 c0             	movzwl %ax,%eax
    78b1:	83 ec 08             	sub    $0x8,%esp
    78b4:	50                   	push   %eax
    78b5:	68 56 81 01 00       	push   $0x18156
    78ba:	e8 4e 0f 00 00       	call   880d <printk>
    78bf:	83 c4 10             	add    $0x10,%esp
	printk("base: %p, limit: %p\n",get_base(current->ldt[1]),get_limit(0x17));
    78c2:	b8 17 00 00 00       	mov    $0x17,%eax
    78c7:	0f 03 c0             	lsl    %ax,%eax
    78ca:	40                   	inc    %eax
    78cb:	89 44 24 04          	mov    %eax,0x4(%esp)
    78cf:	8b 5c 24 04          	mov    0x4(%esp),%ebx
    78d3:	a1 40 f1 01 00       	mov    0x1f140,%eax
    78d8:	05 d8 02 00 00       	add    $0x2d8,%eax
    78dd:	83 ec 0c             	sub    $0xc,%esp
    78e0:	50                   	push   %eax
    78e1:	e8 27 ff ff ff       	call   780d <_get_base>
    78e6:	83 c4 10             	add    $0x10,%esp
    78e9:	83 ec 04             	sub    $0x4,%esp
    78ec:	53                   	push   %ebx
    78ed:	50                   	push   %eax
    78ee:	68 60 81 01 00       	push   $0x18160
    78f3:	e8 15 0f 00 00       	call   880d <printk>
    78f8:	83 c4 10             	add    $0x10,%esp
	if (esp[4] == 0x17) {
    78fb:	8b 44 24 08          	mov    0x8(%esp),%eax
    78ff:	83 c0 10             	add    $0x10,%eax
    7902:	8b 00                	mov    (%eax),%eax
    7904:	83 f8 17             	cmp    $0x17,%eax
    7907:	75 71                	jne    797a <die+0x13b>
		printk("Stack: ");
    7909:	83 ec 0c             	sub    $0xc,%esp
    790c:	68 75 81 01 00       	push   $0x18175
    7911:	e8 f7 0e 00 00       	call   880d <printk>
    7916:	83 c4 10             	add    $0x10,%esp
		for (i=0;i<4;i++)
    7919:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    7920:	00 
    7921:	eb 40                	jmp    7963 <die+0x124>
			printk("%p ",get_seg_long(0x17,i+(long *)esp[3]));
    7923:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7927:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    792e:	8b 44 24 08          	mov    0x8(%esp),%eax
    7932:	83 c0 0c             	add    $0xc,%eax
    7935:	8b 00                	mov    (%eax),%eax
    7937:	01 d0                	add    %edx,%eax
    7939:	89 c2                	mov    %eax,%edx
    793b:	b8 17 00 00 00       	mov    $0x17,%eax
    7940:	0f a0                	push   %fs
    7942:	8e e0                	mov    %eax,%fs
    7944:	64 8b 02             	mov    %fs:(%edx),%eax
    7947:	0f a1                	pop    %fs
    7949:	89 c3                	mov    %eax,%ebx
    794b:	89 d8                	mov    %ebx,%eax
    794d:	83 ec 08             	sub    $0x8,%esp
    7950:	50                   	push   %eax
    7951:	68 7d 81 01 00       	push   $0x1817d
    7956:	e8 b2 0e 00 00       	call   880d <printk>
    795b:	83 c4 10             	add    $0x10,%esp
		esp[1],esp[0],esp[2],esp[4],esp[3]);
	printk("fs: %04x\n",_fs());
	printk("base: %p, limit: %p\n",get_base(current->ldt[1]),get_limit(0x17));
	if (esp[4] == 0x17) {
		printk("Stack: ");
		for (i=0;i<4;i++)
    795e:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    7963:	83 7c 24 0c 03       	cmpl   $0x3,0xc(%esp)
    7968:	7e b9                	jle    7923 <die+0xe4>
			printk("%p ",get_seg_long(0x17,i+(long *)esp[3]));
		printk("\n");
    796a:	83 ec 0c             	sub    $0xc,%esp
    796d:	68 81 81 01 00       	push   $0x18181
    7972:	e8 96 0e 00 00       	call   880d <printk>
    7977:	83 c4 10             	add    $0x10,%esp
	}
	str(i);
    797a:	b8 00 00 00 00       	mov    $0x0,%eax
    797f:	66 0f 00 c8          	str    %ax
    7983:	83 e8 20             	sub    $0x20,%eax
    7986:	c1 e8 04             	shr    $0x4,%eax
    7989:	89 44 24 0c          	mov    %eax,0xc(%esp)
	printk("Pid: %d, process nr: %d\n\r",current->pid,0xffff & i);
    798d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7991:	0f b7 d0             	movzwl %ax,%edx
    7994:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7999:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    799f:	83 ec 04             	sub    $0x4,%esp
    79a2:	52                   	push   %edx
    79a3:	50                   	push   %eax
    79a4:	68 83 81 01 00       	push   $0x18183
    79a9:	e8 5f 0e 00 00       	call   880d <printk>
    79ae:	83 c4 10             	add    $0x10,%esp
	for(i=0;i<10;i++)
    79b1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    79b8:	00 
    79b9:	eb 40                	jmp    79fb <die+0x1bc>
		printk("%02x ",0xff & get_seg_byte(esp[1],(i+(char *)esp[0])));
    79bb:	8b 44 24 08          	mov    0x8(%esp),%eax
    79bf:	83 c0 04             	add    $0x4,%eax
    79c2:	8b 00                	mov    (%eax),%eax
    79c4:	8b 54 24 08          	mov    0x8(%esp),%edx
    79c8:	8b 12                	mov    (%edx),%edx
    79ca:	89 d1                	mov    %edx,%ecx
    79cc:	8b 54 24 0c          	mov    0xc(%esp),%edx
    79d0:	01 ca                	add    %ecx,%edx
    79d2:	0f a0                	push   %fs
    79d4:	8e e0                	mov    %eax,%fs
    79d6:	64 8a 02             	mov    %fs:(%edx),%al
    79d9:	0f a1                	pop    %fs
    79db:	89 c3                	mov    %eax,%ebx
    79dd:	89 d8                	mov    %ebx,%eax
    79df:	0f be c0             	movsbl %al,%eax
    79e2:	0f b6 c0             	movzbl %al,%eax
    79e5:	83 ec 08             	sub    $0x8,%esp
    79e8:	50                   	push   %eax
    79e9:	68 9d 81 01 00       	push   $0x1819d
    79ee:	e8 1a 0e 00 00       	call   880d <printk>
    79f3:	83 c4 10             	add    $0x10,%esp
			printk("%p ",get_seg_long(0x17,i+(long *)esp[3]));
		printk("\n");
	}
	str(i);
	printk("Pid: %d, process nr: %d\n\r",current->pid,0xffff & i);
	for(i=0;i<10;i++)
    79f6:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    79fb:	83 7c 24 0c 09       	cmpl   $0x9,0xc(%esp)
    7a00:	7e b9                	jle    79bb <die+0x17c>
		printk("%02x ",0xff & get_seg_byte(esp[1],(i+(char *)esp[0])));
	printk("\n\r");
    7a02:	83 ec 0c             	sub    $0xc,%esp
    7a05:	68 a3 81 01 00       	push   $0x181a3
    7a0a:	e8 fe 0d 00 00       	call   880d <printk>
    7a0f:	83 c4 10             	add    $0x10,%esp
	do_exit(11);		/* play segment exception */
    7a12:	83 ec 0c             	sub    $0xc,%esp
    7a15:	6a 0b                	push   $0xb
    7a17:	e8 23 1f 00 00       	call   993f <do_exit>
    7a1c:	83 c4 10             	add    $0x10,%esp
}
    7a1f:	90                   	nop
    7a20:	83 c4 14             	add    $0x14,%esp
    7a23:	5b                   	pop    %ebx
    7a24:	5e                   	pop    %esi
    7a25:	c3                   	ret    

00007a26 <do_double_fault>:

void do_double_fault(long esp, long error_code)
{
    7a26:	83 ec 0c             	sub    $0xc,%esp
	die("double fault",esp,error_code);
    7a29:	83 ec 04             	sub    $0x4,%esp
    7a2c:	ff 74 24 18          	pushl  0x18(%esp)
    7a30:	ff 74 24 18          	pushl  0x18(%esp)
    7a34:	68 a6 81 01 00       	push   $0x181a6
    7a39:	e8 01 fe ff ff       	call   783f <die>
    7a3e:	83 c4 10             	add    $0x10,%esp
}
    7a41:	90                   	nop
    7a42:	83 c4 0c             	add    $0xc,%esp
    7a45:	c3                   	ret    

00007a46 <do_general_protection>:

void do_general_protection(long esp, long error_code)
{
    7a46:	83 ec 0c             	sub    $0xc,%esp
	die("general protection",esp,error_code);
    7a49:	83 ec 04             	sub    $0x4,%esp
    7a4c:	ff 74 24 18          	pushl  0x18(%esp)
    7a50:	ff 74 24 18          	pushl  0x18(%esp)
    7a54:	68 b3 81 01 00       	push   $0x181b3
    7a59:	e8 e1 fd ff ff       	call   783f <die>
    7a5e:	83 c4 10             	add    $0x10,%esp
}
    7a61:	90                   	nop
    7a62:	83 c4 0c             	add    $0xc,%esp
    7a65:	c3                   	ret    

00007a66 <do_divide_error>:

void do_divide_error(long esp, long error_code)
{
    7a66:	83 ec 0c             	sub    $0xc,%esp
	die("divide error",esp,error_code);
    7a69:	83 ec 04             	sub    $0x4,%esp
    7a6c:	ff 74 24 18          	pushl  0x18(%esp)
    7a70:	ff 74 24 18          	pushl  0x18(%esp)
    7a74:	68 c6 81 01 00       	push   $0x181c6
    7a79:	e8 c1 fd ff ff       	call   783f <die>
    7a7e:	83 c4 10             	add    $0x10,%esp
}
    7a81:	90                   	nop
    7a82:	83 c4 0c             	add    $0xc,%esp
    7a85:	c3                   	ret    

00007a86 <do_int3>:

void do_int3(long * esp, long error_code,
		long fs,long es,long ds,
		long ebp,long esi,long edi,
		long edx,long ecx,long ebx,long eax)
{
    7a86:	83 ec 1c             	sub    $0x1c,%esp
	int tr;

	__asm__("str %%ax":"=a" (tr):"0" (0));
    7a89:	b8 00 00 00 00       	mov    $0x0,%eax
    7a8e:	66 0f 00 c8          	str    %ax
    7a92:	89 44 24 0c          	mov    %eax,0xc(%esp)
	printk("eax\t\tebx\t\tecx\t\tedx\n\r%8x\t%8x\t%8x\t%8x\n\r",
    7a96:	83 ec 0c             	sub    $0xc,%esp
    7a99:	ff 74 24 4c          	pushl  0x4c(%esp)
    7a9d:	ff 74 24 54          	pushl  0x54(%esp)
    7aa1:	ff 74 24 5c          	pushl  0x5c(%esp)
    7aa5:	ff 74 24 64          	pushl  0x64(%esp)
    7aa9:	68 d4 81 01 00       	push   $0x181d4
    7aae:	e8 5a 0d 00 00       	call   880d <printk>
    7ab3:	83 c4 20             	add    $0x20,%esp
		eax,ebx,ecx,edx);
	printk("esi\t\tedi\t\tebp\t\tesp\n\r%8x\t%8x\t%8x\t%8x\n\r",
    7ab6:	8b 44 24 20          	mov    0x20(%esp),%eax
    7aba:	83 ec 0c             	sub    $0xc,%esp
    7abd:	50                   	push   %eax
    7abe:	ff 74 24 44          	pushl  0x44(%esp)
    7ac2:	ff 74 24 50          	pushl  0x50(%esp)
    7ac6:	ff 74 24 50          	pushl  0x50(%esp)
    7aca:	68 fc 81 01 00       	push   $0x181fc
    7acf:	e8 39 0d 00 00       	call   880d <printk>
    7ad4:	83 c4 20             	add    $0x20,%esp
		esi,edi,ebp,(long) esp);
	printk("\n\rds\tes\tfs\ttr\n\r%4x\t%4x\t%4x\t%4x\n\r",
    7ad7:	83 ec 0c             	sub    $0xc,%esp
    7ada:	ff 74 24 18          	pushl  0x18(%esp)
    7ade:	ff 74 24 38          	pushl  0x38(%esp)
    7ae2:	ff 74 24 40          	pushl  0x40(%esp)
    7ae6:	ff 74 24 48          	pushl  0x48(%esp)
    7aea:	68 24 82 01 00       	push   $0x18224
    7aef:	e8 19 0d 00 00       	call   880d <printk>
    7af4:	83 c4 20             	add    $0x20,%esp
		ds,es,fs,tr);
	printk("EIP: %8x   CS: %4x  EFLAGS: %8x\n\r",esp[0],esp[1],esp[2]);
    7af7:	8b 44 24 20          	mov    0x20(%esp),%eax
    7afb:	83 c0 08             	add    $0x8,%eax
    7afe:	8b 08                	mov    (%eax),%ecx
    7b00:	8b 44 24 20          	mov    0x20(%esp),%eax
    7b04:	83 c0 04             	add    $0x4,%eax
    7b07:	8b 10                	mov    (%eax),%edx
    7b09:	8b 44 24 20          	mov    0x20(%esp),%eax
    7b0d:	8b 00                	mov    (%eax),%eax
    7b0f:	51                   	push   %ecx
    7b10:	52                   	push   %edx
    7b11:	50                   	push   %eax
    7b12:	68 48 82 01 00       	push   $0x18248
    7b17:	e8 f1 0c 00 00       	call   880d <printk>
    7b1c:	83 c4 10             	add    $0x10,%esp
}
    7b1f:	90                   	nop
    7b20:	83 c4 1c             	add    $0x1c,%esp
    7b23:	c3                   	ret    

00007b24 <do_nmi>:

void do_nmi(long esp, long error_code)
{
    7b24:	83 ec 0c             	sub    $0xc,%esp
	die("nmi",esp,error_code);
    7b27:	83 ec 04             	sub    $0x4,%esp
    7b2a:	ff 74 24 18          	pushl  0x18(%esp)
    7b2e:	ff 74 24 18          	pushl  0x18(%esp)
    7b32:	68 6a 82 01 00       	push   $0x1826a
    7b37:	e8 03 fd ff ff       	call   783f <die>
    7b3c:	83 c4 10             	add    $0x10,%esp
}
    7b3f:	90                   	nop
    7b40:	83 c4 0c             	add    $0xc,%esp
    7b43:	c3                   	ret    

00007b44 <do_debug>:

void do_debug(long esp, long error_code)
{
    7b44:	83 ec 0c             	sub    $0xc,%esp
	die("debug",esp,error_code);
    7b47:	83 ec 04             	sub    $0x4,%esp
    7b4a:	ff 74 24 18          	pushl  0x18(%esp)
    7b4e:	ff 74 24 18          	pushl  0x18(%esp)
    7b52:	68 6e 82 01 00       	push   $0x1826e
    7b57:	e8 e3 fc ff ff       	call   783f <die>
    7b5c:	83 c4 10             	add    $0x10,%esp
}
    7b5f:	90                   	nop
    7b60:	83 c4 0c             	add    $0xc,%esp
    7b63:	c3                   	ret    

00007b64 <do_overflow>:

void do_overflow(long esp, long error_code)
{
    7b64:	83 ec 0c             	sub    $0xc,%esp
	die("overflow",esp,error_code);
    7b67:	83 ec 04             	sub    $0x4,%esp
    7b6a:	ff 74 24 18          	pushl  0x18(%esp)
    7b6e:	ff 74 24 18          	pushl  0x18(%esp)
    7b72:	68 74 82 01 00       	push   $0x18274
    7b77:	e8 c3 fc ff ff       	call   783f <die>
    7b7c:	83 c4 10             	add    $0x10,%esp
}
    7b7f:	90                   	nop
    7b80:	83 c4 0c             	add    $0xc,%esp
    7b83:	c3                   	ret    

00007b84 <do_bounds>:

void do_bounds(long esp, long error_code)
{
    7b84:	83 ec 0c             	sub    $0xc,%esp
	die("bounds",esp,error_code);
    7b87:	83 ec 04             	sub    $0x4,%esp
    7b8a:	ff 74 24 18          	pushl  0x18(%esp)
    7b8e:	ff 74 24 18          	pushl  0x18(%esp)
    7b92:	68 7d 82 01 00       	push   $0x1827d
    7b97:	e8 a3 fc ff ff       	call   783f <die>
    7b9c:	83 c4 10             	add    $0x10,%esp
}
    7b9f:	90                   	nop
    7ba0:	83 c4 0c             	add    $0xc,%esp
    7ba3:	c3                   	ret    

00007ba4 <do_invalid_op>:

void do_invalid_op(long esp, long error_code)
{
    7ba4:	83 ec 0c             	sub    $0xc,%esp
	die("invalid operand",esp,error_code);
    7ba7:	83 ec 04             	sub    $0x4,%esp
    7baa:	ff 74 24 18          	pushl  0x18(%esp)
    7bae:	ff 74 24 18          	pushl  0x18(%esp)
    7bb2:	68 84 82 01 00       	push   $0x18284
    7bb7:	e8 83 fc ff ff       	call   783f <die>
    7bbc:	83 c4 10             	add    $0x10,%esp
}
    7bbf:	90                   	nop
    7bc0:	83 c4 0c             	add    $0xc,%esp
    7bc3:	c3                   	ret    

00007bc4 <do_device_not_available>:

void do_device_not_available(long esp, long error_code)
{
    7bc4:	83 ec 0c             	sub    $0xc,%esp
	die("device not available",esp,error_code);
    7bc7:	83 ec 04             	sub    $0x4,%esp
    7bca:	ff 74 24 18          	pushl  0x18(%esp)
    7bce:	ff 74 24 18          	pushl  0x18(%esp)
    7bd2:	68 94 82 01 00       	push   $0x18294
    7bd7:	e8 63 fc ff ff       	call   783f <die>
    7bdc:	83 c4 10             	add    $0x10,%esp
}
    7bdf:	90                   	nop
    7be0:	83 c4 0c             	add    $0xc,%esp
    7be3:	c3                   	ret    

00007be4 <do_coprocessor_segment_overrun>:

void do_coprocessor_segment_overrun(long esp, long error_code)
{
    7be4:	83 ec 0c             	sub    $0xc,%esp
	die("coprocessor segment overrun",esp,error_code);
    7be7:	83 ec 04             	sub    $0x4,%esp
    7bea:	ff 74 24 18          	pushl  0x18(%esp)
    7bee:	ff 74 24 18          	pushl  0x18(%esp)
    7bf2:	68 a9 82 01 00       	push   $0x182a9
    7bf7:	e8 43 fc ff ff       	call   783f <die>
    7bfc:	83 c4 10             	add    $0x10,%esp
}
    7bff:	90                   	nop
    7c00:	83 c4 0c             	add    $0xc,%esp
    7c03:	c3                   	ret    

00007c04 <do_invalid_TSS>:

void do_invalid_TSS(long esp,long error_code)
{
    7c04:	83 ec 0c             	sub    $0xc,%esp
	die("invalid TSS",esp,error_code);
    7c07:	83 ec 04             	sub    $0x4,%esp
    7c0a:	ff 74 24 18          	pushl  0x18(%esp)
    7c0e:	ff 74 24 18          	pushl  0x18(%esp)
    7c12:	68 c5 82 01 00       	push   $0x182c5
    7c17:	e8 23 fc ff ff       	call   783f <die>
    7c1c:	83 c4 10             	add    $0x10,%esp
}
    7c1f:	90                   	nop
    7c20:	83 c4 0c             	add    $0xc,%esp
    7c23:	c3                   	ret    

00007c24 <do_segment_not_present>:

void do_segment_not_present(long esp,long error_code)
{
    7c24:	83 ec 0c             	sub    $0xc,%esp
	die("segment not present",esp,error_code);
    7c27:	83 ec 04             	sub    $0x4,%esp
    7c2a:	ff 74 24 18          	pushl  0x18(%esp)
    7c2e:	ff 74 24 18          	pushl  0x18(%esp)
    7c32:	68 d1 82 01 00       	push   $0x182d1
    7c37:	e8 03 fc ff ff       	call   783f <die>
    7c3c:	83 c4 10             	add    $0x10,%esp
}
    7c3f:	90                   	nop
    7c40:	83 c4 0c             	add    $0xc,%esp
    7c43:	c3                   	ret    

00007c44 <do_stack_segment>:

void do_stack_segment(long esp,long error_code)
{
    7c44:	83 ec 0c             	sub    $0xc,%esp
	die("stack segment",esp,error_code);
    7c47:	83 ec 04             	sub    $0x4,%esp
    7c4a:	ff 74 24 18          	pushl  0x18(%esp)
    7c4e:	ff 74 24 18          	pushl  0x18(%esp)
    7c52:	68 e5 82 01 00       	push   $0x182e5
    7c57:	e8 e3 fb ff ff       	call   783f <die>
    7c5c:	83 c4 10             	add    $0x10,%esp
}
    7c5f:	90                   	nop
    7c60:	83 c4 0c             	add    $0xc,%esp
    7c63:	c3                   	ret    

00007c64 <do_coprocessor_error>:

void do_coprocessor_error(long esp, long error_code)
{
    7c64:	83 ec 0c             	sub    $0xc,%esp
	if (last_task_used_math != current)
    7c67:	8b 15 e8 1e 02 00    	mov    0x21ee8,%edx
    7c6d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    7c72:	39 c2                	cmp    %eax,%edx
    7c74:	75 1a                	jne    7c90 <do_coprocessor_error+0x2c>
		return;
	die("coprocessor error",esp,error_code);
    7c76:	83 ec 04             	sub    $0x4,%esp
    7c79:	ff 74 24 18          	pushl  0x18(%esp)
    7c7d:	ff 74 24 18          	pushl  0x18(%esp)
    7c81:	68 f3 82 01 00       	push   $0x182f3
    7c86:	e8 b4 fb ff ff       	call   783f <die>
    7c8b:	83 c4 10             	add    $0x10,%esp
    7c8e:	eb 01                	jmp    7c91 <do_coprocessor_error+0x2d>
}

void do_coprocessor_error(long esp, long error_code)
{
	if (last_task_used_math != current)
		return;
    7c90:	90                   	nop
	die("coprocessor error",esp,error_code);
}
    7c91:	83 c4 0c             	add    $0xc,%esp
    7c94:	c3                   	ret    

00007c95 <do_reserved>:

void do_reserved(long esp, long error_code)
{
    7c95:	83 ec 0c             	sub    $0xc,%esp
	die("reserved (15,17-47) error",esp,error_code);
    7c98:	83 ec 04             	sub    $0x4,%esp
    7c9b:	ff 74 24 18          	pushl  0x18(%esp)
    7c9f:	ff 74 24 18          	pushl  0x18(%esp)
    7ca3:	68 05 83 01 00       	push   $0x18305
    7ca8:	e8 92 fb ff ff       	call   783f <die>
    7cad:	83 c4 10             	add    $0x10,%esp
}
    7cb0:	90                   	nop
    7cb1:	83 c4 0c             	add    $0xc,%esp
    7cb4:	c3                   	ret    

00007cb5 <trap_init>:

void trap_init(void)
{
    7cb5:	53                   	push   %ebx
    7cb6:	83 ec 10             	sub    $0x10,%esp
	int i;

	set_trap_gate(0,&divide_error);
    7cb9:	b9 b8 54 00 00       	mov    $0x54b8,%ecx
    7cbe:	bb bc 54 00 00       	mov    $0x54bc,%ebx
    7cc3:	ba 9d 7f 00 00       	mov    $0x7f9d,%edx
    7cc8:	b8 00 00 08 00       	mov    $0x80000,%eax
    7ccd:	66 89 d0             	mov    %dx,%ax
    7cd0:	66 ba 00 8f          	mov    $0x8f00,%dx
    7cd4:	89 01                	mov    %eax,(%ecx)
    7cd6:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(1,&debug);
    7cd8:	b9 c0 54 00 00       	mov    $0x54c0,%ecx
    7cdd:	bb c4 54 00 00       	mov    $0x54c4,%ebx
    7ce2:	ba d2 7f 00 00       	mov    $0x7fd2,%edx
    7ce7:	b8 00 00 08 00       	mov    $0x80000,%eax
    7cec:	66 89 d0             	mov    %dx,%ax
    7cef:	66 ba 00 8f          	mov    $0x8f00,%dx
    7cf3:	89 01                	mov    %eax,(%ecx)
    7cf5:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(2,&nmi);
    7cf7:	b9 c8 54 00 00       	mov    $0x54c8,%ecx
    7cfc:	bb cc 54 00 00       	mov    $0x54cc,%ebx
    7d01:	ba d9 7f 00 00       	mov    $0x7fd9,%edx
    7d06:	b8 00 00 08 00       	mov    $0x80000,%eax
    7d0b:	66 89 d0             	mov    %dx,%ax
    7d0e:	66 ba 00 8f          	mov    $0x8f00,%dx
    7d12:	89 01                	mov    %eax,(%ecx)
    7d14:	89 13                	mov    %edx,(%ebx)
	set_system_gate(3,&int3);	/* int3-5 can be called from all */
    7d16:	b9 d0 54 00 00       	mov    $0x54d0,%ecx
    7d1b:	bb d4 54 00 00       	mov    $0x54d4,%ebx
    7d20:	ba e0 7f 00 00       	mov    $0x7fe0,%edx
    7d25:	b8 00 00 08 00       	mov    $0x80000,%eax
    7d2a:	66 89 d0             	mov    %dx,%ax
    7d2d:	66 ba 00 ef          	mov    $0xef00,%dx
    7d31:	89 01                	mov    %eax,(%ecx)
    7d33:	89 13                	mov    %edx,(%ebx)
	set_system_gate(4,&overflow);
    7d35:	b9 d8 54 00 00       	mov    $0x54d8,%ecx
    7d3a:	bb dc 54 00 00       	mov    $0x54dc,%ebx
    7d3f:	ba e7 7f 00 00       	mov    $0x7fe7,%edx
    7d44:	b8 00 00 08 00       	mov    $0x80000,%eax
    7d49:	66 89 d0             	mov    %dx,%ax
    7d4c:	66 ba 00 ef          	mov    $0xef00,%dx
    7d50:	89 01                	mov    %eax,(%ecx)
    7d52:	89 13                	mov    %edx,(%ebx)
	set_system_gate(5,&bounds);
    7d54:	b9 e0 54 00 00       	mov    $0x54e0,%ecx
    7d59:	bb e4 54 00 00       	mov    $0x54e4,%ebx
    7d5e:	ba ee 7f 00 00       	mov    $0x7fee,%edx
    7d63:	b8 00 00 08 00       	mov    $0x80000,%eax
    7d68:	66 89 d0             	mov    %dx,%ax
    7d6b:	66 ba 00 ef          	mov    $0xef00,%dx
    7d6f:	89 01                	mov    %eax,(%ecx)
    7d71:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(6,&invalid_op);
    7d73:	b9 e8 54 00 00       	mov    $0x54e8,%ecx
    7d78:	bb ec 54 00 00       	mov    $0x54ec,%ebx
    7d7d:	ba f5 7f 00 00       	mov    $0x7ff5,%edx
    7d82:	b8 00 00 08 00       	mov    $0x80000,%eax
    7d87:	66 89 d0             	mov    %dx,%ax
    7d8a:	66 ba 00 8f          	mov    $0x8f00,%dx
    7d8e:	89 01                	mov    %eax,(%ecx)
    7d90:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(7,&device_not_available);
    7d92:	b9 f0 54 00 00       	mov    $0x54f0,%ecx
    7d97:	bb f4 54 00 00       	mov    $0x54f4,%ebx
    7d9c:	ba fc 76 00 00       	mov    $0x76fc,%edx
    7da1:	b8 00 00 08 00       	mov    $0x80000,%eax
    7da6:	66 89 d0             	mov    %dx,%ax
    7da9:	66 ba 00 8f          	mov    $0x8f00,%dx
    7dad:	89 01                	mov    %eax,(%ecx)
    7daf:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(8,&double_fault);
    7db1:	b9 f8 54 00 00       	mov    $0x54f8,%ecx
    7db6:	bb fc 54 00 00       	mov    $0x54fc,%ebx
    7dbb:	ba 1f 80 00 00       	mov    $0x801f,%edx
    7dc0:	b8 00 00 08 00       	mov    $0x80000,%eax
    7dc5:	66 89 d0             	mov    %dx,%ax
    7dc8:	66 ba 00 8f          	mov    $0x8f00,%dx
    7dcc:	89 01                	mov    %eax,(%ecx)
    7dce:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(9,&coprocessor_segment_overrun);
    7dd0:	b9 00 55 00 00       	mov    $0x5500,%ecx
    7dd5:	bb 04 55 00 00       	mov    $0x5504,%ebx
    7dda:	ba fc 7f 00 00       	mov    $0x7ffc,%edx
    7ddf:	b8 00 00 08 00       	mov    $0x80000,%eax
    7de4:	66 89 d0             	mov    %dx,%ax
    7de7:	66 ba 00 8f          	mov    $0x8f00,%dx
    7deb:	89 01                	mov    %eax,(%ecx)
    7ded:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(10,&invalid_TSS);
    7def:	b9 08 55 00 00       	mov    $0x5508,%ecx
    7df4:	bb 0c 55 00 00       	mov    $0x550c,%ebx
    7df9:	ba 56 80 00 00       	mov    $0x8056,%edx
    7dfe:	b8 00 00 08 00       	mov    $0x80000,%eax
    7e03:	66 89 d0             	mov    %dx,%ax
    7e06:	66 ba 00 8f          	mov    $0x8f00,%dx
    7e0a:	89 01                	mov    %eax,(%ecx)
    7e0c:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(11,&segment_not_present);
    7e0e:	b9 10 55 00 00       	mov    $0x5510,%ecx
    7e13:	bb 14 55 00 00       	mov    $0x5514,%ebx
    7e18:	ba 5d 80 00 00       	mov    $0x805d,%edx
    7e1d:	b8 00 00 08 00       	mov    $0x80000,%eax
    7e22:	66 89 d0             	mov    %dx,%ax
    7e25:	66 ba 00 8f          	mov    $0x8f00,%dx
    7e29:	89 01                	mov    %eax,(%ecx)
    7e2b:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(12,&stack_segment);
    7e2d:	b9 18 55 00 00       	mov    $0x5518,%ecx
    7e32:	bb 1c 55 00 00       	mov    $0x551c,%ebx
    7e37:	ba 64 80 00 00       	mov    $0x8064,%edx
    7e3c:	b8 00 00 08 00       	mov    $0x80000,%eax
    7e41:	66 89 d0             	mov    %dx,%ax
    7e44:	66 ba 00 8f          	mov    $0x8f00,%dx
    7e48:	89 01                	mov    %eax,(%ecx)
    7e4a:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(13,&general_protection);
    7e4c:	b9 20 55 00 00       	mov    $0x5520,%ecx
    7e51:	bb 24 55 00 00       	mov    $0x5524,%ebx
    7e56:	ba 6b 80 00 00       	mov    $0x806b,%edx
    7e5b:	b8 00 00 08 00       	mov    $0x80000,%eax
    7e60:	66 89 d0             	mov    %dx,%ax
    7e63:	66 ba 00 8f          	mov    $0x8f00,%dx
    7e67:	89 01                	mov    %eax,(%ecx)
    7e69:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(14,&page_fault);
    7e6b:	b9 28 55 00 00       	mov    $0x5528,%ecx
    7e70:	bb 2c 55 00 00       	mov    $0x552c,%ebx
    7e75:	ba 77 ae 00 00       	mov    $0xae77,%edx
    7e7a:	b8 00 00 08 00       	mov    $0x80000,%eax
    7e7f:	66 89 d0             	mov    %dx,%ax
    7e82:	66 ba 00 8f          	mov    $0x8f00,%dx
    7e86:	89 01                	mov    %eax,(%ecx)
    7e88:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(15,&reserved);
    7e8a:	b9 30 55 00 00       	mov    $0x5530,%ecx
    7e8f:	bb 34 55 00 00       	mov    $0x5534,%ebx
    7e94:	ba 03 80 00 00       	mov    $0x8003,%edx
    7e99:	b8 00 00 08 00       	mov    $0x80000,%eax
    7e9e:	66 89 d0             	mov    %dx,%ax
    7ea1:	66 ba 00 8f          	mov    $0x8f00,%dx
    7ea5:	89 01                	mov    %eax,(%ecx)
    7ea7:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(16,&coprocessor_error);
    7ea9:	b9 38 55 00 00       	mov    $0x5538,%ecx
    7eae:	bb 3c 55 00 00       	mov    $0x553c,%ebx
    7eb3:	ba da 76 00 00       	mov    $0x76da,%edx
    7eb8:	b8 00 00 08 00       	mov    $0x80000,%eax
    7ebd:	66 89 d0             	mov    %dx,%ax
    7ec0:	66 ba 00 8f          	mov    $0x8f00,%dx
    7ec4:	89 01                	mov    %eax,(%ecx)
    7ec6:	89 13                	mov    %edx,(%ebx)
	for (i=17;i<48;i++)
    7ec8:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
    7ecf:	00 
    7ed0:	eb 36                	jmp    7f08 <trap_init+0x253>
		set_trap_gate(i,&reserved);
    7ed2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7ed6:	c1 e0 03             	shl    $0x3,%eax
    7ed9:	8d 88 b8 54 00 00    	lea    0x54b8(%eax),%ecx
    7edf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    7ee3:	c1 e0 03             	shl    $0x3,%eax
    7ee6:	05 b8 54 00 00       	add    $0x54b8,%eax
    7eeb:	8d 58 04             	lea    0x4(%eax),%ebx
    7eee:	ba 03 80 00 00       	mov    $0x8003,%edx
    7ef3:	b8 00 00 08 00       	mov    $0x80000,%eax
    7ef8:	66 89 d0             	mov    %dx,%ax
    7efb:	66 ba 00 8f          	mov    $0x8f00,%dx
    7eff:	89 01                	mov    %eax,(%ecx)
    7f01:	89 13                	mov    %edx,(%ebx)
	set_trap_gate(12,&stack_segment);
	set_trap_gate(13,&general_protection);
	set_trap_gate(14,&page_fault);
	set_trap_gate(15,&reserved);
	set_trap_gate(16,&coprocessor_error);
	for (i=17;i<48;i++)
    7f03:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    7f08:	83 7c 24 0c 2f       	cmpl   $0x2f,0xc(%esp)
    7f0d:	7e c3                	jle    7ed2 <trap_init+0x21d>
		set_trap_gate(i,&reserved);
	set_trap_gate(45,&irq13);
    7f0f:	b9 20 56 00 00       	mov    $0x5620,%ecx
    7f14:	bb 24 56 00 00       	mov    $0x5624,%ebx
    7f19:	ba 0a 80 00 00       	mov    $0x800a,%edx
    7f1e:	b8 00 00 08 00       	mov    $0x80000,%eax
    7f23:	66 89 d0             	mov    %dx,%ax
    7f26:	66 ba 00 8f          	mov    $0x8f00,%dx
    7f2a:	89 01                	mov    %eax,(%ecx)
    7f2c:	89 13                	mov    %edx,(%ebx)
	outb_p(inb_p(0x21)&0xfb,0x21);
    7f2e:	b8 21 00 00 00       	mov    $0x21,%eax
    7f33:	89 c2                	mov    %eax,%edx
    7f35:	ec                   	in     (%dx),%al
    7f36:	eb 00                	jmp    7f38 <trap_init+0x283>
    7f38:	eb 00                	jmp    7f3a <trap_init+0x285>
    7f3a:	88 44 24 0b          	mov    %al,0xb(%esp)
    7f3e:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
    7f43:	0f b6 c0             	movzbl %al,%eax
    7f46:	25 fb 00 00 00       	and    $0xfb,%eax
    7f4b:	ba 21 00 00 00       	mov    $0x21,%edx
    7f50:	ee                   	out    %al,(%dx)
    7f51:	eb 00                	jmp    7f53 <trap_init+0x29e>
    7f53:	eb 00                	jmp    7f55 <trap_init+0x2a0>
	outb(inb_p(0xA1)&0xdf,0xA1);
    7f55:	b8 a1 00 00 00       	mov    $0xa1,%eax
    7f5a:	89 c2                	mov    %eax,%edx
    7f5c:	ec                   	in     (%dx),%al
    7f5d:	eb 00                	jmp    7f5f <trap_init+0x2aa>
    7f5f:	eb 00                	jmp    7f61 <trap_init+0x2ac>
    7f61:	88 44 24 0a          	mov    %al,0xa(%esp)
    7f65:	0f b6 44 24 0a       	movzbl 0xa(%esp),%eax
    7f6a:	0f b6 c0             	movzbl %al,%eax
    7f6d:	25 df 00 00 00       	and    $0xdf,%eax
    7f72:	ba a1 00 00 00       	mov    $0xa1,%edx
    7f77:	ee                   	out    %al,(%dx)
	set_trap_gate(39,&parallel_interrupt);
    7f78:	b9 f0 55 00 00       	mov    $0x55f0,%ecx
    7f7d:	bb f4 55 00 00       	mov    $0x55f4,%ebx
    7f82:	ba 06 78 00 00       	mov    $0x7806,%edx
    7f87:	b8 00 00 08 00       	mov    $0x80000,%eax
    7f8c:	66 89 d0             	mov    %dx,%ax
    7f8f:	66 ba 00 8f          	mov    $0x8f00,%dx
    7f93:	89 01                	mov    %eax,(%ecx)
    7f95:	89 13                	mov    %edx,(%ebx)
}
    7f97:	90                   	nop
    7f98:	83 c4 10             	add    $0x10,%esp
    7f9b:	5b                   	pop    %ebx
    7f9c:	c3                   	ret    

00007f9d <divide_error>:
.globl double_fault,coprocessor_segment_overrun
.globl invalid_TSS,segment_not_present,stack_segment
.globl general_protection,coprocessor_error,irq13,reserved

divide_error:
	pushl $do_divide_error
    7f9d:	68 66 7a 00 00       	push   $0x7a66

00007fa2 <no_error_code>:
no_error_code:
	xchgl %eax,(%esp)
    7fa2:	87 04 24             	xchg   %eax,(%esp)
	pushl %ebx
    7fa5:	53                   	push   %ebx
	pushl %ecx
    7fa6:	51                   	push   %ecx
	pushl %edx
    7fa7:	52                   	push   %edx
	pushl %edi
    7fa8:	57                   	push   %edi
	pushl %esi
    7fa9:	56                   	push   %esi
	pushl %ebp
    7faa:	55                   	push   %ebp
	push %ds
    7fab:	1e                   	push   %ds
	push %es
    7fac:	06                   	push   %es
	push %fs
    7fad:	0f a0                	push   %fs
	pushl $0		# "error code"
    7faf:	6a 00                	push   $0x0
	lea 44(%esp),%edx
    7fb1:	8d 54 24 2c          	lea    0x2c(%esp),%edx
	pushl %edx
    7fb5:	52                   	push   %edx
	movl $0x10,%edx
    7fb6:	ba 10 00 00 00       	mov    $0x10,%edx
	mov %dx,%ds
    7fbb:	8e da                	mov    %edx,%ds
	mov %dx,%es
    7fbd:	8e c2                	mov    %edx,%es
	mov %dx,%fs
    7fbf:	8e e2                	mov    %edx,%fs
	call *%eax
    7fc1:	ff d0                	call   *%eax
	addl $8,%esp
    7fc3:	83 c4 08             	add    $0x8,%esp
	pop %fs
    7fc6:	0f a1                	pop    %fs
	pop %es
    7fc8:	07                   	pop    %es
	pop %ds
    7fc9:	1f                   	pop    %ds
	popl %ebp
    7fca:	5d                   	pop    %ebp
	popl %esi
    7fcb:	5e                   	pop    %esi
	popl %edi
    7fcc:	5f                   	pop    %edi
	popl %edx
    7fcd:	5a                   	pop    %edx
	popl %ecx
    7fce:	59                   	pop    %ecx
	popl %ebx
    7fcf:	5b                   	pop    %ebx
	popl %eax
    7fd0:	58                   	pop    %eax
	iret
    7fd1:	cf                   	iret   

00007fd2 <debug>:

debug:
	pushl $do_int3		# _do_debug
    7fd2:	68 86 7a 00 00       	push   $0x7a86
	jmp no_error_code
    7fd7:	eb c9                	jmp    7fa2 <no_error_code>

00007fd9 <nmi>:

nmi:
	pushl $do_nmi
    7fd9:	68 24 7b 00 00       	push   $0x7b24
	jmp no_error_code
    7fde:	eb c2                	jmp    7fa2 <no_error_code>

00007fe0 <int3>:

int3:
	pushl $do_int3
    7fe0:	68 86 7a 00 00       	push   $0x7a86
	jmp no_error_code
    7fe5:	eb bb                	jmp    7fa2 <no_error_code>

00007fe7 <overflow>:

overflow:
	pushl $do_overflow
    7fe7:	68 64 7b 00 00       	push   $0x7b64
	jmp no_error_code
    7fec:	eb b4                	jmp    7fa2 <no_error_code>

00007fee <bounds>:

bounds:
	pushl $do_bounds
    7fee:	68 84 7b 00 00       	push   $0x7b84
	jmp no_error_code
    7ff3:	eb ad                	jmp    7fa2 <no_error_code>

00007ff5 <invalid_op>:

invalid_op:
	pushl $do_invalid_op
    7ff5:	68 a4 7b 00 00       	push   $0x7ba4
	jmp no_error_code
    7ffa:	eb a6                	jmp    7fa2 <no_error_code>

00007ffc <coprocessor_segment_overrun>:

coprocessor_segment_overrun:
	pushl $do_coprocessor_segment_overrun
    7ffc:	68 e4 7b 00 00       	push   $0x7be4
	jmp no_error_code
    8001:	eb 9f                	jmp    7fa2 <no_error_code>

00008003 <reserved>:

reserved:
	pushl $do_reserved
    8003:	68 95 7c 00 00       	push   $0x7c95
	jmp no_error_code
    8008:	eb 98                	jmp    7fa2 <no_error_code>

0000800a <irq13>:

irq13:
	pushl %eax
    800a:	50                   	push   %eax
	xorb %al,%al
    800b:	30 c0                	xor    %al,%al
	outb %al,$0xF0
    800d:	e6 f0                	out    %al,$0xf0
	movb $0x20,%al
    800f:	b0 20                	mov    $0x20,%al
	outb %al,$0x20
    8011:	e6 20                	out    %al,$0x20
	jmp 1f
    8013:	eb 00                	jmp    8015 <irq13+0xb>
1:	jmp 1f
    8015:	eb 00                	jmp    8017 <irq13+0xd>
1:	outb %al,$0xA0
    8017:	e6 a0                	out    %al,$0xa0
	popl %eax
    8019:	58                   	pop    %eax
	jmp coprocessor_error
    801a:	e9 bb f6 ff ff       	jmp    76da <coprocessor_error>

0000801f <double_fault>:

double_fault:
	pushl $do_double_fault
    801f:	68 26 7a 00 00       	push   $0x7a26

00008024 <error_code>:
error_code:
	xchgl %eax,4(%esp)		# error code <-> %eax
    8024:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl %ebx,(%esp)		# &function <-> %ebx
    8028:	87 1c 24             	xchg   %ebx,(%esp)
	pushl %ecx
    802b:	51                   	push   %ecx
	pushl %edx
    802c:	52                   	push   %edx
	pushl %edi
    802d:	57                   	push   %edi
	pushl %esi
    802e:	56                   	push   %esi
	pushl %ebp
    802f:	55                   	push   %ebp
	push %ds
    8030:	1e                   	push   %ds
	push %es
    8031:	06                   	push   %es
	push %fs
    8032:	0f a0                	push   %fs
	pushl %eax			# error code
    8034:	50                   	push   %eax
	lea 44(%esp),%eax		# offset
    8035:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl %eax
    8039:	50                   	push   %eax
	movl $0x10,%eax
    803a:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
    803f:	8e d8                	mov    %eax,%ds
	mov %ax,%es
    8041:	8e c0                	mov    %eax,%es
	mov %ax,%fs
    8043:	8e e0                	mov    %eax,%fs
	call *%ebx
    8045:	ff d3                	call   *%ebx
	addl $8,%esp
    8047:	83 c4 08             	add    $0x8,%esp
	pop %fs
    804a:	0f a1                	pop    %fs
	pop %es
    804c:	07                   	pop    %es
	pop %ds
    804d:	1f                   	pop    %ds
	popl %ebp
    804e:	5d                   	pop    %ebp
	popl %esi
    804f:	5e                   	pop    %esi
	popl %edi
    8050:	5f                   	pop    %edi
	popl %edx
    8051:	5a                   	pop    %edx
	popl %ecx
    8052:	59                   	pop    %ecx
	popl %ebx
    8053:	5b                   	pop    %ebx
	popl %eax
    8054:	58                   	pop    %eax
	iret
    8055:	cf                   	iret   

00008056 <invalid_TSS>:

invalid_TSS:
	pushl $do_invalid_TSS
    8056:	68 04 7c 00 00       	push   $0x7c04
	jmp error_code
    805b:	eb c7                	jmp    8024 <error_code>

0000805d <segment_not_present>:

segment_not_present:
	pushl $do_segment_not_present
    805d:	68 24 7c 00 00       	push   $0x7c24
	jmp error_code
    8062:	eb c0                	jmp    8024 <error_code>

00008064 <stack_segment>:

stack_segment:
	pushl $do_stack_segment
    8064:	68 44 7c 00 00       	push   $0x7c44
	jmp error_code
    8069:	eb b9                	jmp    8024 <error_code>

0000806b <general_protection>:

general_protection:
	pushl $do_general_protection
    806b:	68 46 7a 00 00       	push   $0x7a46
	jmp error_code
    8070:	eb b2                	jmp    8024 <error_code>

00008072 <_get_base>:
        :"memory"); \
__base;})
**/

static inline unsigned long _get_base(char * addr)
{
    8072:	53                   	push   %ebx
    8073:	83 ec 10             	sub    $0x10,%esp
         __asm__("movb %3,%%dh\n\t"
                 "movb %2,%%dl\n\t"
                 "shll $16,%%edx\n\t"
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
    8076:	8b 44 24 18          	mov    0x18(%esp),%eax
    807a:	83 c0 02             	add    $0x2,%eax
                  "m" (*((addr)+4)),
    807d:	8b 54 24 18          	mov    0x18(%esp),%edx
    8081:	8d 5a 04             	lea    0x4(%edx),%ebx
                  "m" (*((addr)+7)));
    8084:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    8088:	83 c1 07             	add    $0x7,%ecx
**/

static inline unsigned long _get_base(char * addr)
{
         unsigned long __base;
         __asm__("movb %3,%%dh\n\t"
    808b:	8a 31                	mov    (%ecx),%dh
    808d:	8a 13                	mov    (%ebx),%dl
    808f:	c1 e2 10             	shl    $0x10,%edx
    8092:	66 8b 10             	mov    (%eax),%dx
    8095:	89 d0                	mov    %edx,%eax
    8097:	89 44 24 0c          	mov    %eax,0xc(%esp)
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
                  "m" (*((addr)+4)),
                  "m" (*((addr)+7)));
         return __base;
    809b:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    809f:	83 c4 10             	add    $0x10,%esp
    80a2:	5b                   	pop    %ebx
    80a3:	c3                   	ret    

000080a4 <verify_area>:
extern void write_verify(unsigned long address);

long last_pid=0;

void verify_area(void * addr,int size)
{
    80a4:	83 ec 1c             	sub    $0x1c,%esp
	unsigned long start;

	start = (unsigned long) addr;
    80a7:	8b 44 24 20          	mov    0x20(%esp),%eax
    80ab:	89 44 24 0c          	mov    %eax,0xc(%esp)
	size += start & 0xfff;
    80af:	8b 44 24 0c          	mov    0xc(%esp),%eax
    80b3:	25 ff 0f 00 00       	and    $0xfff,%eax
    80b8:	89 c2                	mov    %eax,%edx
    80ba:	8b 44 24 24          	mov    0x24(%esp),%eax
    80be:	01 d0                	add    %edx,%eax
    80c0:	89 44 24 24          	mov    %eax,0x24(%esp)
	start &= 0xfffff000;
    80c4:	81 64 24 0c 00 f0 ff 	andl   $0xfffff000,0xc(%esp)
    80cb:	ff 
	start += get_base(current->ldt[2]);
    80cc:	a1 40 f1 01 00       	mov    0x1f140,%eax
    80d1:	05 e0 02 00 00       	add    $0x2e0,%eax
    80d6:	50                   	push   %eax
    80d7:	e8 96 ff ff ff       	call   8072 <_get_base>
    80dc:	83 c4 04             	add    $0x4,%esp
    80df:	01 44 24 0c          	add    %eax,0xc(%esp)
	while (size>0) {
    80e3:	eb 1f                	jmp    8104 <verify_area+0x60>
		size -= 4096;
    80e5:	81 6c 24 24 00 10 00 	subl   $0x1000,0x24(%esp)
    80ec:	00 
		write_verify(start);
    80ed:	83 ec 0c             	sub    $0xc,%esp
    80f0:	ff 74 24 18          	pushl  0x18(%esp)
    80f4:	e8 b1 27 00 00       	call   a8aa <write_verify>
    80f9:	83 c4 10             	add    $0x10,%esp
		start += 4096;
    80fc:	81 44 24 0c 00 10 00 	addl   $0x1000,0xc(%esp)
    8103:	00 

	start = (unsigned long) addr;
	size += start & 0xfff;
	start &= 0xfffff000;
	start += get_base(current->ldt[2]);
	while (size>0) {
    8104:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    8109:	7f da                	jg     80e5 <verify_area+0x41>
		size -= 4096;
		write_verify(start);
		start += 4096;
	}
}
    810b:	90                   	nop
    810c:	83 c4 1c             	add    $0x1c,%esp
    810f:	c3                   	ret    

00008110 <copy_mem>:

int copy_mem(int nr,struct task_struct * p)
{
    8110:	56                   	push   %esi
    8111:	53                   	push   %ebx
    8112:	83 ec 24             	sub    $0x24,%esp
	unsigned long old_data_base,new_data_base,data_limit;
	unsigned long old_code_base,new_code_base,code_limit;

	code_limit=get_limit(0x0f);
    8115:	b8 0f 00 00 00       	mov    $0xf,%eax
    811a:	0f 03 c0             	lsl    %ax,%eax
    811d:	40                   	inc    %eax
    811e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    8122:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    8126:	89 44 24 18          	mov    %eax,0x18(%esp)
	data_limit=get_limit(0x17);
    812a:	b8 17 00 00 00       	mov    $0x17,%eax
    812f:	0f 03 c0             	lsl    %ax,%eax
    8132:	40                   	inc    %eax
    8133:	89 44 24 14          	mov    %eax,0x14(%esp)
    8137:	8b 44 24 14          	mov    0x14(%esp),%eax
    813b:	89 44 24 10          	mov    %eax,0x10(%esp)
	old_code_base = get_base(current->ldt[1]);
    813f:	a1 40 f1 01 00       	mov    0x1f140,%eax
    8144:	05 d8 02 00 00       	add    $0x2d8,%eax
    8149:	50                   	push   %eax
    814a:	e8 23 ff ff ff       	call   8072 <_get_base>
    814f:	83 c4 04             	add    $0x4,%esp
    8152:	89 44 24 0c          	mov    %eax,0xc(%esp)
	old_data_base = get_base(current->ldt[2]);
    8156:	a1 40 f1 01 00       	mov    0x1f140,%eax
    815b:	05 e0 02 00 00       	add    $0x2e0,%eax
    8160:	50                   	push   %eax
    8161:	e8 0c ff ff ff       	call   8072 <_get_base>
    8166:	83 c4 04             	add    $0x4,%esp
    8169:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (old_data_base != old_code_base)
    816d:	8b 44 24 08          	mov    0x8(%esp),%eax
    8171:	3b 44 24 0c          	cmp    0xc(%esp),%eax
    8175:	74 10                	je     8187 <copy_mem+0x77>
		panic("We don't support separate I&D");
    8177:	83 ec 0c             	sub    $0xc,%esp
    817a:	68 20 83 01 00       	push   $0x18320
    817f:	e8 4a 06 00 00       	call   87ce <panic>
    8184:	83 c4 10             	add    $0x10,%esp
	if (data_limit < code_limit)
    8187:	8b 44 24 10          	mov    0x10(%esp),%eax
    818b:	3b 44 24 18          	cmp    0x18(%esp),%eax
    818f:	73 10                	jae    81a1 <copy_mem+0x91>
		panic("Bad data_limit");
    8191:	83 ec 0c             	sub    $0xc,%esp
    8194:	68 3e 83 01 00       	push   $0x1833e
    8199:	e8 30 06 00 00       	call   87ce <panic>
    819e:	83 c4 10             	add    $0x10,%esp
	new_data_base = new_code_base = nr * 0x4000000;
    81a1:	8b 44 24 30          	mov    0x30(%esp),%eax
    81a5:	c1 e0 1a             	shl    $0x1a,%eax
    81a8:	89 44 24 04          	mov    %eax,0x4(%esp)
    81ac:	8b 44 24 04          	mov    0x4(%esp),%eax
    81b0:	89 04 24             	mov    %eax,(%esp)
	p->start_code = new_code_base;
    81b3:	8b 44 24 34          	mov    0x34(%esp),%eax
    81b7:	8b 54 24 04          	mov    0x4(%esp),%edx
    81bb:	89 90 18 02 00 00    	mov    %edx,0x218(%eax)
	set_base(p->ldt[1],new_code_base);
    81c1:	8b 44 24 34          	mov    0x34(%esp),%eax
    81c5:	05 d8 02 00 00       	add    $0x2d8,%eax
    81ca:	8d 48 02             	lea    0x2(%eax),%ecx
    81cd:	8b 44 24 34          	mov    0x34(%esp),%eax
    81d1:	05 d8 02 00 00       	add    $0x2d8,%eax
    81d6:	8d 58 04             	lea    0x4(%eax),%ebx
    81d9:	8b 44 24 34          	mov    0x34(%esp),%eax
    81dd:	05 d8 02 00 00       	add    $0x2d8,%eax
    81e2:	8d 70 07             	lea    0x7(%eax),%esi
    81e5:	8b 44 24 04          	mov    0x4(%esp),%eax
    81e9:	89 c2                	mov    %eax,%edx
    81eb:	52                   	push   %edx
    81ec:	66 89 11             	mov    %dx,(%ecx)
    81ef:	c1 ca 10             	ror    $0x10,%edx
    81f2:	88 13                	mov    %dl,(%ebx)
    81f4:	88 36                	mov    %dh,(%esi)
    81f6:	5a                   	pop    %edx
	set_base(p->ldt[2],new_data_base);
    81f7:	8b 44 24 34          	mov    0x34(%esp),%eax
    81fb:	05 e0 02 00 00       	add    $0x2e0,%eax
    8200:	8d 48 02             	lea    0x2(%eax),%ecx
    8203:	8b 44 24 34          	mov    0x34(%esp),%eax
    8207:	05 e0 02 00 00       	add    $0x2e0,%eax
    820c:	8d 58 04             	lea    0x4(%eax),%ebx
    820f:	8b 44 24 34          	mov    0x34(%esp),%eax
    8213:	05 e0 02 00 00       	add    $0x2e0,%eax
    8218:	8d 70 07             	lea    0x7(%eax),%esi
    821b:	8b 04 24             	mov    (%esp),%eax
    821e:	89 c2                	mov    %eax,%edx
    8220:	52                   	push   %edx
    8221:	66 89 11             	mov    %dx,(%ecx)
    8224:	c1 ca 10             	ror    $0x10,%edx
    8227:	88 13                	mov    %dl,(%ebx)
    8229:	88 36                	mov    %dh,(%esi)
    822b:	5a                   	pop    %edx
	if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
    822c:	8b 44 24 10          	mov    0x10(%esp),%eax
    8230:	83 ec 04             	sub    $0x4,%esp
    8233:	50                   	push   %eax
    8234:	ff 74 24 08          	pushl  0x8(%esp)
    8238:	ff 74 24 14          	pushl  0x14(%esp)
    823c:	e8 04 23 00 00       	call   a545 <copy_page_tables>
    8241:	83 c4 10             	add    $0x10,%esp
    8244:	85 c0                	test   %eax,%eax
    8246:	74 2a                	je     8272 <copy_mem+0x162>
		printk("free_page_tables: from copy_mem\n");
    8248:	83 ec 0c             	sub    $0xc,%esp
    824b:	68 50 83 01 00       	push   $0x18350
    8250:	e8 b8 05 00 00       	call   880d <printk>
    8255:	83 c4 10             	add    $0x10,%esp
		free_page_tables(new_data_base,data_limit);
    8258:	83 ec 08             	sub    $0x8,%esp
    825b:	ff 74 24 18          	pushl  0x18(%esp)
    825f:	ff 74 24 0c          	pushl  0xc(%esp)
    8263:	e8 cc 21 00 00       	call   a434 <free_page_tables>
    8268:	83 c4 10             	add    $0x10,%esp
		return -ENOMEM;
    826b:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    8270:	eb 05                	jmp    8277 <copy_mem+0x167>
	}
	return 0;
    8272:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8277:	83 c4 24             	add    $0x24,%esp
    827a:	5b                   	pop    %ebx
    827b:	5e                   	pop    %esi
    827c:	c3                   	ret    

0000827d <copy_process>:
 */
int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
		long ebx,long ecx,long edx,
		long fs,long es,long ds,
		long eip,long cs,long eflags,long esp,long ss)
{
    827d:	55                   	push   %ebp
    827e:	57                   	push   %edi
    827f:	56                   	push   %esi
    8280:	53                   	push   %ebx
    8281:	83 ec 2c             	sub    $0x2c,%esp
	struct task_struct *p;
	int i;
	struct file *f;

	p = (struct task_struct *) get_free_page();
    8284:	e8 f5 20 00 00       	call   a37e <get_free_page>
    8289:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!p)
    828d:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    8292:	75 0a                	jne    829e <copy_process+0x21>
		return -EAGAIN;
    8294:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    8299:	e9 90 04 00 00       	jmp    872e <copy_process+0x4b1>
	task[nr] = p;
    829e:	8b 44 24 40          	mov    0x40(%esp),%eax
    82a2:	8b 54 24 18          	mov    0x18(%esp),%edx
    82a6:	89 14 85 60 f1 01 00 	mov    %edx,0x1f160(,%eax,4)
	
	// NOTE!: the following statement now work with gcc 4.3.2 now, and you
	// must compile _THIS_ memcpy without no -O of gcc.#ifndef GCC4_3
	*p = *current;	/* NOTE! this doesn't copy the supervisor stack */
    82ad:	a1 40 f1 01 00       	mov    0x1f140,%eax
    82b2:	8b 54 24 18          	mov    0x18(%esp),%edx
    82b6:	89 c3                	mov    %eax,%ebx
    82b8:	b8 ef 00 00 00       	mov    $0xef,%eax
    82bd:	89 d7                	mov    %edx,%edi
    82bf:	89 de                	mov    %ebx,%esi
    82c1:	89 c1                	mov    %eax,%ecx
    82c3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	p->state = TASK_UNINTERRUPTIBLE;
    82c5:	8b 44 24 18          	mov    0x18(%esp),%eax
    82c9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	p->pid = last_pid;
    82cf:	8b 15 24 22 02 00    	mov    0x22224,%edx
    82d5:	8b 44 24 18          	mov    0x18(%esp),%eax
    82d9:	89 90 2c 02 00 00    	mov    %edx,0x22c(%eax)
	p->father = current->pid;
    82df:	a1 40 f1 01 00       	mov    0x1f140,%eax
    82e4:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    82ea:	8b 44 24 18          	mov    0x18(%esp),%eax
    82ee:	89 90 30 02 00 00    	mov    %edx,0x230(%eax)
	p->counter = p->priority;
    82f4:	8b 44 24 18          	mov    0x18(%esp),%eax
    82f8:	8b 50 08             	mov    0x8(%eax),%edx
    82fb:	8b 44 24 18          	mov    0x18(%esp),%eax
    82ff:	89 50 04             	mov    %edx,0x4(%eax)
	p->signal = 0;
    8302:	8b 44 24 18          	mov    0x18(%esp),%eax
    8306:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	p->alarm = 0;
    830d:	8b 44 24 18          	mov    0x18(%esp),%eax
    8311:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%eax)
    8318:	00 00 00 
	p->leader = 0;		/* process leadership doesn't inherit */
    831b:	8b 44 24 18          	mov    0x18(%esp),%eax
    831f:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%eax)
    8326:	00 00 00 
	p->utime = p->stime = 0;
    8329:	8b 44 24 18          	mov    0x18(%esp),%eax
    832d:	c7 80 54 02 00 00 00 	movl   $0x0,0x254(%eax)
    8334:	00 00 00 
    8337:	8b 44 24 18          	mov    0x18(%esp),%eax
    833b:	8b 90 54 02 00 00    	mov    0x254(%eax),%edx
    8341:	8b 44 24 18          	mov    0x18(%esp),%eax
    8345:	89 90 50 02 00 00    	mov    %edx,0x250(%eax)
	p->cutime = p->cstime = 0;
    834b:	8b 44 24 18          	mov    0x18(%esp),%eax
    834f:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%eax)
    8356:	00 00 00 
    8359:	8b 44 24 18          	mov    0x18(%esp),%eax
    835d:	8b 90 5c 02 00 00    	mov    0x25c(%eax),%edx
    8363:	8b 44 24 18          	mov    0x18(%esp),%eax
    8367:	89 90 58 02 00 00    	mov    %edx,0x258(%eax)
	p->start_time = jiffies;
    836d:	8b 15 e0 1e 02 00    	mov    0x21ee0,%edx
    8373:	8b 44 24 18          	mov    0x18(%esp),%eax
    8377:	89 90 60 02 00 00    	mov    %edx,0x260(%eax)
	p->tss.back_link = 0;
    837d:	8b 44 24 18          	mov    0x18(%esp),%eax
    8381:	c7 80 e8 02 00 00 00 	movl   $0x0,0x2e8(%eax)
    8388:	00 00 00 
	p->tss.esp0 = PAGE_SIZE + (long) p;
    838b:	8b 44 24 18          	mov    0x18(%esp),%eax
    838f:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
    8395:	8b 44 24 18          	mov    0x18(%esp),%eax
    8399:	89 90 ec 02 00 00    	mov    %edx,0x2ec(%eax)
	p->tss.ss0 = 0x10;
    839f:	8b 44 24 18          	mov    0x18(%esp),%eax
    83a3:	c7 80 f0 02 00 00 10 	movl   $0x10,0x2f0(%eax)
    83aa:	00 00 00 
	p->tss.eip = eip;
    83ad:	8b 44 24 18          	mov    0x18(%esp),%eax
    83b1:	8b 54 24 70          	mov    0x70(%esp),%edx
    83b5:	89 90 08 03 00 00    	mov    %edx,0x308(%eax)
	p->tss.eflags = eflags;
    83bb:	8b 44 24 18          	mov    0x18(%esp),%eax
    83bf:	8b 54 24 78          	mov    0x78(%esp),%edx
    83c3:	89 90 0c 03 00 00    	mov    %edx,0x30c(%eax)
	p->tss.eax = 0;
    83c9:	8b 44 24 18          	mov    0x18(%esp),%eax
    83cd:	c7 80 10 03 00 00 00 	movl   $0x0,0x310(%eax)
    83d4:	00 00 00 
	p->tss.ecx = ecx;
    83d7:	8b 44 24 18          	mov    0x18(%esp),%eax
    83db:	8b 54 24 5c          	mov    0x5c(%esp),%edx
    83df:	89 90 14 03 00 00    	mov    %edx,0x314(%eax)
	p->tss.edx = edx;
    83e5:	8b 44 24 18          	mov    0x18(%esp),%eax
    83e9:	8b 54 24 60          	mov    0x60(%esp),%edx
    83ed:	89 90 18 03 00 00    	mov    %edx,0x318(%eax)
	p->tss.ebx = ebx;
    83f3:	8b 44 24 18          	mov    0x18(%esp),%eax
    83f7:	8b 54 24 58          	mov    0x58(%esp),%edx
    83fb:	89 90 1c 03 00 00    	mov    %edx,0x31c(%eax)
	p->tss.esp = esp;
    8401:	8b 44 24 18          	mov    0x18(%esp),%eax
    8405:	8b 54 24 7c          	mov    0x7c(%esp),%edx
    8409:	89 90 20 03 00 00    	mov    %edx,0x320(%eax)
	p->tss.ebp = ebp;
    840f:	8b 44 24 18          	mov    0x18(%esp),%eax
    8413:	8b 54 24 44          	mov    0x44(%esp),%edx
    8417:	89 90 24 03 00 00    	mov    %edx,0x324(%eax)
	p->tss.esi = esi;
    841d:	8b 44 24 18          	mov    0x18(%esp),%eax
    8421:	8b 54 24 4c          	mov    0x4c(%esp),%edx
    8425:	89 90 28 03 00 00    	mov    %edx,0x328(%eax)
	p->tss.edi = edi;
    842b:	8b 44 24 18          	mov    0x18(%esp),%eax
    842f:	8b 54 24 48          	mov    0x48(%esp),%edx
    8433:	89 90 2c 03 00 00    	mov    %edx,0x32c(%eax)
	p->tss.es = es & 0xffff;
    8439:	8b 44 24 68          	mov    0x68(%esp),%eax
    843d:	0f b7 d0             	movzwl %ax,%edx
    8440:	8b 44 24 18          	mov    0x18(%esp),%eax
    8444:	89 90 30 03 00 00    	mov    %edx,0x330(%eax)
	p->tss.cs = cs & 0xffff;
    844a:	8b 44 24 74          	mov    0x74(%esp),%eax
    844e:	0f b7 d0             	movzwl %ax,%edx
    8451:	8b 44 24 18          	mov    0x18(%esp),%eax
    8455:	89 90 34 03 00 00    	mov    %edx,0x334(%eax)
	p->tss.ss = ss & 0xffff;
    845b:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
    8462:	0f b7 d0             	movzwl %ax,%edx
    8465:	8b 44 24 18          	mov    0x18(%esp),%eax
    8469:	89 90 38 03 00 00    	mov    %edx,0x338(%eax)
	p->tss.ds = ds & 0xffff;
    846f:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    8473:	0f b7 d0             	movzwl %ax,%edx
    8476:	8b 44 24 18          	mov    0x18(%esp),%eax
    847a:	89 90 3c 03 00 00    	mov    %edx,0x33c(%eax)
	p->tss.fs = fs & 0xffff;
    8480:	8b 44 24 64          	mov    0x64(%esp),%eax
    8484:	0f b7 d0             	movzwl %ax,%edx
    8487:	8b 44 24 18          	mov    0x18(%esp),%eax
    848b:	89 90 40 03 00 00    	mov    %edx,0x340(%eax)
	p->tss.gs = gs & 0xffff;
    8491:	8b 44 24 50          	mov    0x50(%esp),%eax
    8495:	0f b7 d0             	movzwl %ax,%edx
    8498:	8b 44 24 18          	mov    0x18(%esp),%eax
    849c:	89 90 44 03 00 00    	mov    %edx,0x344(%eax)
	p->tss.ldt = _LDT(nr);
    84a2:	8b 44 24 40          	mov    0x40(%esp),%eax
    84a6:	c1 e0 04             	shl    $0x4,%eax
    84a9:	83 c0 28             	add    $0x28,%eax
    84ac:	89 c2                	mov    %eax,%edx
    84ae:	8b 44 24 18          	mov    0x18(%esp),%eax
    84b2:	89 90 48 03 00 00    	mov    %edx,0x348(%eax)
	p->tss.trace_bitmap = 0x80000000;
    84b8:	8b 44 24 18          	mov    0x18(%esp),%eax
    84bc:	c7 80 4c 03 00 00 00 	movl   $0x80000000,0x34c(%eax)
    84c3:	00 00 80 
	if (last_task_used_math == current)
    84c6:	8b 15 e8 1e 02 00    	mov    0x21ee8,%edx
    84cc:	a1 40 f1 01 00       	mov    0x1f140,%eax
    84d1:	39 c2                	cmp    %eax,%edx
    84d3:	75 0c                	jne    84e1 <copy_process+0x264>
		__asm__("clts ; fnsave %0"::"m" (p->tss.i387));
    84d5:	8b 44 24 18          	mov    0x18(%esp),%eax
    84d9:	0f 06                	clts   
    84db:	dd b0 50 03 00 00    	fnsave 0x350(%eax)
	if (copy_mem(nr,p)) {
    84e1:	83 ec 08             	sub    $0x8,%esp
    84e4:	ff 74 24 20          	pushl  0x20(%esp)
    84e8:	ff 74 24 4c          	pushl  0x4c(%esp)
    84ec:	e8 1f fc ff ff       	call   8110 <copy_mem>
    84f1:	83 c4 10             	add    $0x10,%esp
    84f4:	85 c0                	test   %eax,%eax
    84f6:	74 29                	je     8521 <copy_process+0x2a4>
		task[nr] = NULL;
    84f8:	8b 44 24 40          	mov    0x40(%esp),%eax
    84fc:	c7 04 85 60 f1 01 00 	movl   $0x0,0x1f160(,%eax,4)
    8503:	00 00 00 00 
		free_page((long) p);
    8507:	8b 44 24 18          	mov    0x18(%esp),%eax
    850b:	83 ec 0c             	sub    $0xc,%esp
    850e:	50                   	push   %eax
    850f:	e8 a6 1e 00 00       	call   a3ba <free_page>
    8514:	83 c4 10             	add    $0x10,%esp
		return -EAGAIN;
    8517:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    851c:	e9 0d 02 00 00       	jmp    872e <copy_process+0x4b1>
	}
	for (i=0; i<NR_OPEN;i++)
    8521:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    8528:	00 
    8529:	eb 34                	jmp    855f <copy_process+0x2e2>
		if ((f=p->filp[i]))
    852b:	8b 44 24 18          	mov    0x18(%esp),%eax
    852f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    8533:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    8539:	8b 04 90             	mov    (%eax,%edx,4),%eax
    853c:	89 44 24 14          	mov    %eax,0x14(%esp)
    8540:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    8545:	74 13                	je     855a <copy_process+0x2dd>
			f->f_count++;
    8547:	8b 44 24 14          	mov    0x14(%esp),%eax
    854b:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    854f:	8d 50 01             	lea    0x1(%eax),%edx
    8552:	8b 44 24 14          	mov    0x14(%esp),%eax
    8556:	66 89 50 04          	mov    %dx,0x4(%eax)
	if (copy_mem(nr,p)) {
		task[nr] = NULL;
		free_page((long) p);
		return -EAGAIN;
	}
	for (i=0; i<NR_OPEN;i++)
    855a:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    855f:	83 7c 24 1c 13       	cmpl   $0x13,0x1c(%esp)
    8564:	7e c5                	jle    852b <copy_process+0x2ae>
		if ((f=p->filp[i]))
			f->f_count++;
	if (current->pwd)
    8566:	a1 40 f1 01 00       	mov    0x1f140,%eax
    856b:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
    8571:	85 c0                	test   %eax,%eax
    8573:	74 16                	je     858b <copy_process+0x30e>
		current->pwd->i_count++;
    8575:	a1 40 f1 01 00       	mov    0x1f140,%eax
    857a:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
    8580:	0f b7 50 30          	movzwl 0x30(%eax),%edx
    8584:	83 c2 01             	add    $0x1,%edx
    8587:	66 89 50 30          	mov    %dx,0x30(%eax)
	if (current->root)
    858b:	a1 40 f1 01 00       	mov    0x1f140,%eax
    8590:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
    8596:	85 c0                	test   %eax,%eax
    8598:	74 16                	je     85b0 <copy_process+0x333>
		current->root->i_count++;
    859a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    859f:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
    85a5:	0f b7 50 30          	movzwl 0x30(%eax),%edx
    85a9:	83 c2 01             	add    $0x1,%edx
    85ac:	66 89 50 30          	mov    %dx,0x30(%eax)
	if (current->executable)
    85b0:	a1 40 f1 01 00       	mov    0x1f140,%eax
    85b5:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    85bb:	85 c0                	test   %eax,%eax
    85bd:	74 16                	je     85d5 <copy_process+0x358>
		current->executable->i_count++;
    85bf:	a1 40 f1 01 00       	mov    0x1f140,%eax
    85c4:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    85ca:	0f b7 50 30          	movzwl 0x30(%eax),%edx
    85ce:	83 c2 01             	add    $0x1,%edx
    85d1:	66 89 50 30          	mov    %dx,0x30(%eax)
	set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
    85d5:	8b 44 24 18          	mov    0x18(%esp),%eax
    85d9:	05 e8 02 00 00       	add    $0x2e8,%eax
    85de:	89 44 24 0c          	mov    %eax,0xc(%esp)
    85e2:	8b 44 24 40          	mov    0x40(%esp),%eax
    85e6:	01 c0                	add    %eax,%eax
    85e8:	83 c0 04             	add    $0x4,%eax
    85eb:	c1 e0 03             	shl    $0x3,%eax
    85ee:	8d 90 b8 5c 00 00    	lea    0x5cb8(%eax),%edx
    85f4:	8b 44 24 40          	mov    0x40(%esp),%eax
    85f8:	01 c0                	add    %eax,%eax
    85fa:	83 c0 04             	add    $0x4,%eax
    85fd:	c1 e0 03             	shl    $0x3,%eax
    8600:	83 c0 02             	add    $0x2,%eax
    8603:	8d 88 b8 5c 00 00    	lea    0x5cb8(%eax),%ecx
    8609:	8b 44 24 40          	mov    0x40(%esp),%eax
    860d:	01 c0                	add    %eax,%eax
    860f:	83 c0 04             	add    $0x4,%eax
    8612:	c1 e0 03             	shl    $0x3,%eax
    8615:	83 c0 04             	add    $0x4,%eax
    8618:	8d 98 b8 5c 00 00    	lea    0x5cb8(%eax),%ebx
    861e:	8b 44 24 40          	mov    0x40(%esp),%eax
    8622:	01 c0                	add    %eax,%eax
    8624:	83 c0 04             	add    $0x4,%eax
    8627:	c1 e0 03             	shl    $0x3,%eax
    862a:	83 c0 05             	add    $0x5,%eax
    862d:	8d b0 b8 5c 00 00    	lea    0x5cb8(%eax),%esi
    8633:	8b 44 24 40          	mov    0x40(%esp),%eax
    8637:	01 c0                	add    %eax,%eax
    8639:	83 c0 04             	add    $0x4,%eax
    863c:	c1 e0 03             	shl    $0x3,%eax
    863f:	83 c0 06             	add    $0x6,%eax
    8642:	8d b8 b8 5c 00 00    	lea    0x5cb8(%eax),%edi
    8648:	8b 44 24 40          	mov    0x40(%esp),%eax
    864c:	01 c0                	add    %eax,%eax
    864e:	83 c0 04             	add    $0x4,%eax
    8651:	c1 e0 03             	shl    $0x3,%eax
    8654:	83 c0 07             	add    $0x7,%eax
    8657:	8d a8 b8 5c 00 00    	lea    0x5cb8(%eax),%ebp
    865d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8661:	66 c7 02 68 00       	movw   $0x68,(%edx)
    8666:	66 89 01             	mov    %ax,(%ecx)
    8669:	c1 c8 10             	ror    $0x10,%eax
    866c:	88 03                	mov    %al,(%ebx)
    866e:	c6 06 89             	movb   $0x89,(%esi)
    8671:	c6 07 00             	movb   $0x0,(%edi)
    8674:	88 65 00             	mov    %ah,0x0(%ebp)
    8677:	c1 c8 10             	ror    $0x10,%eax
	set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
    867a:	8b 44 24 18          	mov    0x18(%esp),%eax
    867e:	05 d0 02 00 00       	add    $0x2d0,%eax
    8683:	89 44 24 0c          	mov    %eax,0xc(%esp)
    8687:	8b 44 24 40          	mov    0x40(%esp),%eax
    868b:	01 c0                	add    %eax,%eax
    868d:	83 c0 05             	add    $0x5,%eax
    8690:	c1 e0 03             	shl    $0x3,%eax
    8693:	8d 90 b8 5c 00 00    	lea    0x5cb8(%eax),%edx
    8699:	8b 44 24 40          	mov    0x40(%esp),%eax
    869d:	01 c0                	add    %eax,%eax
    869f:	83 c0 05             	add    $0x5,%eax
    86a2:	c1 e0 03             	shl    $0x3,%eax
    86a5:	83 c0 02             	add    $0x2,%eax
    86a8:	8d 88 b8 5c 00 00    	lea    0x5cb8(%eax),%ecx
    86ae:	8b 44 24 40          	mov    0x40(%esp),%eax
    86b2:	01 c0                	add    %eax,%eax
    86b4:	83 c0 05             	add    $0x5,%eax
    86b7:	c1 e0 03             	shl    $0x3,%eax
    86ba:	83 c0 04             	add    $0x4,%eax
    86bd:	8d 98 b8 5c 00 00    	lea    0x5cb8(%eax),%ebx
    86c3:	8b 44 24 40          	mov    0x40(%esp),%eax
    86c7:	01 c0                	add    %eax,%eax
    86c9:	83 c0 05             	add    $0x5,%eax
    86cc:	c1 e0 03             	shl    $0x3,%eax
    86cf:	83 c0 05             	add    $0x5,%eax
    86d2:	8d b0 b8 5c 00 00    	lea    0x5cb8(%eax),%esi
    86d8:	8b 44 24 40          	mov    0x40(%esp),%eax
    86dc:	01 c0                	add    %eax,%eax
    86de:	83 c0 05             	add    $0x5,%eax
    86e1:	c1 e0 03             	shl    $0x3,%eax
    86e4:	83 c0 06             	add    $0x6,%eax
    86e7:	8d b8 b8 5c 00 00    	lea    0x5cb8(%eax),%edi
    86ed:	8b 44 24 40          	mov    0x40(%esp),%eax
    86f1:	01 c0                	add    %eax,%eax
    86f3:	83 c0 05             	add    $0x5,%eax
    86f6:	c1 e0 03             	shl    $0x3,%eax
    86f9:	83 c0 07             	add    $0x7,%eax
    86fc:	8d a8 b8 5c 00 00    	lea    0x5cb8(%eax),%ebp
    8702:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8706:	66 c7 02 68 00       	movw   $0x68,(%edx)
    870b:	66 89 01             	mov    %ax,(%ecx)
    870e:	c1 c8 10             	ror    $0x10,%eax
    8711:	88 03                	mov    %al,(%ebx)
    8713:	c6 06 82             	movb   $0x82,(%esi)
    8716:	c6 07 00             	movb   $0x0,(%edi)
    8719:	88 65 00             	mov    %ah,0x0(%ebp)
    871c:	c1 c8 10             	ror    $0x10,%eax
	p->state = TASK_RUNNING;	/* do this last, just in case */
    871f:	8b 44 24 18          	mov    0x18(%esp),%eax
    8723:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return last_pid;
    8729:	a1 24 22 02 00       	mov    0x22224,%eax
}
    872e:	83 c4 2c             	add    $0x2c,%esp
    8731:	5b                   	pop    %ebx
    8732:	5e                   	pop    %esi
    8733:	5f                   	pop    %edi
    8734:	5d                   	pop    %ebp
    8735:	c3                   	ret    

00008736 <find_empty_process>:

int find_empty_process(void)
{
    8736:	83 ec 10             	sub    $0x10,%esp
	int i;

	repeat:
		if ((++last_pid)<0) last_pid=1;
    8739:	a1 24 22 02 00       	mov    0x22224,%eax
    873e:	83 c0 01             	add    $0x1,%eax
    8741:	a3 24 22 02 00       	mov    %eax,0x22224
    8746:	a1 24 22 02 00       	mov    0x22224,%eax
    874b:	85 c0                	test   %eax,%eax
    874d:	79 0a                	jns    8759 <find_empty_process+0x23>
    874f:	c7 05 24 22 02 00 01 	movl   $0x1,0x22224
    8756:	00 00 00 
		for(i=0 ; i<NR_TASKS ; i++)
    8759:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    8760:	00 
    8761:	eb 30                	jmp    8793 <find_empty_process+0x5d>
			if (task[i] && task[i]->pid == last_pid) goto repeat;
    8763:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8767:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    876e:	85 c0                	test   %eax,%eax
    8770:	74 1c                	je     878e <find_empty_process+0x58>
    8772:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8776:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    877d:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    8783:	a1 24 22 02 00       	mov    0x22224,%eax
    8788:	39 c2                	cmp    %eax,%edx
    878a:	75 02                	jne    878e <find_empty_process+0x58>
    878c:	eb ab                	jmp    8739 <find_empty_process+0x3>
{
	int i;

	repeat:
		if ((++last_pid)<0) last_pid=1;
		for(i=0 ; i<NR_TASKS ; i++)
    878e:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    8793:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    8798:	7e c9                	jle    8763 <find_empty_process+0x2d>
			if (task[i] && task[i]->pid == last_pid) goto repeat;
	for(i=1 ; i<NR_TASKS ; i++)
    879a:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    87a1:	00 
    87a2:	eb 1a                	jmp    87be <find_empty_process+0x88>
		if (!task[i])
    87a4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    87a8:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    87af:	85 c0                	test   %eax,%eax
    87b1:	75 06                	jne    87b9 <find_empty_process+0x83>
			return i;
    87b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    87b7:	eb 11                	jmp    87ca <find_empty_process+0x94>

	repeat:
		if ((++last_pid)<0) last_pid=1;
		for(i=0 ; i<NR_TASKS ; i++)
			if (task[i] && task[i]->pid == last_pid) goto repeat;
	for(i=1 ; i<NR_TASKS ; i++)
    87b9:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    87be:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    87c3:	7e df                	jle    87a4 <find_empty_process+0x6e>
		if (!task[i])
			return i;
	return -EAGAIN;
    87c5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
    87ca:	83 c4 10             	add    $0x10,%esp
    87cd:	c3                   	ret    

000087ce <panic>:
#include <linux/sched.h>

void sys_sync(void);	/* it's really int */

void panic(const char * s)
{
    87ce:	83 ec 0c             	sub    $0xc,%esp
	printk("Kernel panic: %s\n\r",s);
    87d1:	83 ec 08             	sub    $0x8,%esp
    87d4:	ff 74 24 18          	pushl  0x18(%esp)
    87d8:	68 74 83 01 00       	push   $0x18374
    87dd:	e8 2b 00 00 00       	call   880d <printk>
    87e2:	83 c4 10             	add    $0x10,%esp
	if (current == task[0])
    87e5:	8b 15 60 f1 01 00    	mov    0x1f160,%edx
    87eb:	a1 40 f1 01 00       	mov    0x1f140,%eax
    87f0:	39 c2                	cmp    %eax,%edx
    87f2:	75 12                	jne    8806 <panic+0x38>
		printk("In swapper task - not syncing\n\r");
    87f4:	83 ec 0c             	sub    $0xc,%esp
    87f7:	68 88 83 01 00       	push   $0x18388
    87fc:	e8 0c 00 00 00       	call   880d <printk>
    8801:	83 c4 10             	add    $0x10,%esp
    8804:	eb 05                	jmp    880b <panic+0x3d>
	else
		sys_sync();
    8806:	e8 59 40 00 00       	call   c864 <sys_sync>
	for(;;);
    880b:	eb fe                	jmp    880b <panic+0x3d>

0000880d <printk>:
static char buf[1024];

extern int vsprintf(char * buf, const char * fmt, va_list args);

int printk(const char *fmt, ...)
{
    880d:	53                   	push   %ebx
    880e:	83 ec 18             	sub    $0x18,%esp
	va_list args;
	int i;

	va_start(args, fmt);
    8811:	8d 44 24 24          	lea    0x24(%esp),%eax
    8815:	89 44 24 0c          	mov    %eax,0xc(%esp)
	i=vsprintf(buf,fmt,args);
    8819:	8b 44 24 20          	mov    0x20(%esp),%eax
    881d:	83 ec 04             	sub    $0x4,%esp
    8820:	ff 74 24 10          	pushl  0x10(%esp)
    8824:	50                   	push   %eax
    8825:	68 40 22 02 00       	push   $0x22240
    882a:	e8 32 03 00 00       	call   8b61 <vsprintf>
    882f:	83 c4 10             	add    $0x10,%esp
    8832:	89 44 24 08          	mov    %eax,0x8(%esp)
	va_end(args);
	__asm__("push %%fs\n\t"
    8836:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    883a:	0f a0                	push   %fs
    883c:	1e                   	push   %ds
    883d:	0f a1                	pop    %fs
    883f:	53                   	push   %ebx
    8840:	68 40 22 02 00       	push   $0x22240
    8845:	6a 00                	push   $0x0
    8847:	e8 1e cf 00 00       	call   1576a <tty_write>
    884c:	83 c4 08             	add    $0x8,%esp
    884f:	5b                   	pop    %ebx
    8850:	0f a1                	pop    %fs
		"call tty_write\n\t"
		"addl $8,%%esp\n\t"
		"popl %0\n\t"
		"pop %%fs"
		::"r" (i):"ax","cx","dx");
	return i;
    8852:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    8856:	83 c4 18             	add    $0x18,%esp
    8859:	5b                   	pop    %ebx
    885a:	c3                   	ret    

0000885b <strlen>:
	);
return __res;
}

static inline int strlen(const char * s)
{
    885b:	57                   	push   %edi
    885c:	53                   	push   %ebx
register int __res ;
__asm__("cld\n\t"
    885d:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
    8861:	b8 00 00 00 00       	mov    $0x0,%eax
    8866:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    886b:	89 d1                	mov    %edx,%ecx
    886d:	89 df                	mov    %ebx,%edi
    886f:	fc                   	cld    
    8870:	f2 ae                	repnz scas %es:(%edi),%al
    8872:	f7 d1                	not    %ecx
    8874:	49                   	dec    %ecx
    8875:	89 ca                	mov    %ecx,%edx
    8877:	89 d3                	mov    %edx,%ebx
	"repne\n\t"
	"scasb\n\t"
	"notl %0\n\t"
	"decl %0"
	:"=c" (__res):"D" (s),"a" (0),"0" (0xffffffff));
return __res;
    8879:	89 d8                	mov    %ebx,%eax
}
    887b:	5b                   	pop    %ebx
    887c:	5f                   	pop    %edi
    887d:	c3                   	ret    

0000887e <skip_atoi>:

/* we use this so that we can do without the ctype library */
#define is_digit(c)	((c) >= '0' && (c) <= '9')

static int skip_atoi(const char **s)
{
    887e:	53                   	push   %ebx
    887f:	83 ec 10             	sub    $0x10,%esp
	int i=0;
    8882:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    8889:	00 

	while (is_digit(**s))
    888a:	eb 2d                	jmp    88b9 <skip_atoi+0x3b>
		i = i*10 + *((*s)++) - '0';
    888c:	8b 54 24 0c          	mov    0xc(%esp),%edx
    8890:	89 d0                	mov    %edx,%eax
    8892:	c1 e0 02             	shl    $0x2,%eax
    8895:	01 d0                	add    %edx,%eax
    8897:	01 c0                	add    %eax,%eax
    8899:	89 c3                	mov    %eax,%ebx
    889b:	8b 44 24 18          	mov    0x18(%esp),%eax
    889f:	8b 00                	mov    (%eax),%eax
    88a1:	8d 48 01             	lea    0x1(%eax),%ecx
    88a4:	8b 54 24 18          	mov    0x18(%esp),%edx
    88a8:	89 0a                	mov    %ecx,(%edx)
    88aa:	0f b6 00             	movzbl (%eax),%eax
    88ad:	0f be c0             	movsbl %al,%eax
    88b0:	01 d8                	add    %ebx,%eax
    88b2:	83 e8 30             	sub    $0x30,%eax
    88b5:	89 44 24 0c          	mov    %eax,0xc(%esp)

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
    88b9:	8b 44 24 18          	mov    0x18(%esp),%eax
    88bd:	8b 00                	mov    (%eax),%eax
    88bf:	0f b6 00             	movzbl (%eax),%eax
    88c2:	3c 2f                	cmp    $0x2f,%al
    88c4:	7e 0d                	jle    88d3 <skip_atoi+0x55>
    88c6:	8b 44 24 18          	mov    0x18(%esp),%eax
    88ca:	8b 00                	mov    (%eax),%eax
    88cc:	0f b6 00             	movzbl (%eax),%eax
    88cf:	3c 39                	cmp    $0x39,%al
    88d1:	7e b9                	jle    888c <skip_atoi+0xe>
		i = i*10 + *((*s)++) - '0';
	return i;
    88d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    88d7:	83 c4 10             	add    $0x10,%esp
    88da:	5b                   	pop    %ebx
    88db:	c3                   	ret    

000088dc <number>:
__asm__("divl %4":"=a" (n),"=d" (__res):"0" (n),"1" (0),"r" (base)); \
__res; })

static char * number(char * str, int num, int base, int size, int precision
	,int type)
{
    88dc:	53                   	push   %ebx
    88dd:	83 ec 40             	sub    $0x40,%esp
	char c,sign,tmp[36];
	const char *digits="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    88e0:	c7 44 24 38 a8 83 01 	movl   $0x183a8,0x38(%esp)
    88e7:	00 
	int i;

	if (type&SMALL) digits="0123456789abcdefghijklmnopqrstuvwxyz";
    88e8:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    88ec:	83 e0 40             	and    $0x40,%eax
    88ef:	85 c0                	test   %eax,%eax
    88f1:	74 08                	je     88fb <number+0x1f>
    88f3:	c7 44 24 38 d0 83 01 	movl   $0x183d0,0x38(%esp)
    88fa:	00 
	if (type&LEFT) type &= ~ZEROPAD;
    88fb:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    88ff:	83 e0 10             	and    $0x10,%eax
    8902:	85 c0                	test   %eax,%eax
    8904:	74 05                	je     890b <number+0x2f>
    8906:	83 64 24 5c fe       	andl   $0xfffffffe,0x5c(%esp)
	if (base<2 || base>36)
    890b:	83 7c 24 50 01       	cmpl   $0x1,0x50(%esp)
    8910:	7e 07                	jle    8919 <number+0x3d>
    8912:	83 7c 24 50 24       	cmpl   $0x24,0x50(%esp)
    8917:	7e 0a                	jle    8923 <number+0x47>
		return 0;
    8919:	b8 00 00 00 00       	mov    $0x0,%eax
    891e:	e9 39 02 00 00       	jmp    8b5c <number+0x280>
	c = (type & ZEROPAD) ? '0' : ' ' ;
    8923:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    8927:	83 e0 01             	and    $0x1,%eax
    892a:	85 c0                	test   %eax,%eax
    892c:	74 07                	je     8935 <number+0x59>
    892e:	b8 30 00 00 00       	mov    $0x30,%eax
    8933:	eb 05                	jmp    893a <number+0x5e>
    8935:	b8 20 00 00 00       	mov    $0x20,%eax
    893a:	88 44 24 33          	mov    %al,0x33(%esp)
	if (type&SIGN && num<0) {
    893e:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    8942:	83 e0 02             	and    $0x2,%eax
    8945:	85 c0                	test   %eax,%eax
    8947:	74 12                	je     895b <number+0x7f>
    8949:	83 7c 24 4c 00       	cmpl   $0x0,0x4c(%esp)
    894e:	79 0b                	jns    895b <number+0x7f>
		sign='-';
    8950:	c6 44 24 3f 2d       	movb   $0x2d,0x3f(%esp)
		num = -num;
    8955:	f7 5c 24 4c          	negl   0x4c(%esp)
    8959:	eb 2d                	jmp    8988 <number+0xac>
	} else
		sign=(type&PLUS) ? '+' : ((type&SPACE) ? ' ' : 0);
    895b:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    895f:	83 e0 04             	and    $0x4,%eax
    8962:	85 c0                	test   %eax,%eax
    8964:	75 19                	jne    897f <number+0xa3>
    8966:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    896a:	83 e0 08             	and    $0x8,%eax
    896d:	85 c0                	test   %eax,%eax
    896f:	74 07                	je     8978 <number+0x9c>
    8971:	b8 20 00 00 00       	mov    $0x20,%eax
    8976:	eb 0c                	jmp    8984 <number+0xa8>
    8978:	b8 00 00 00 00       	mov    $0x0,%eax
    897d:	eb 05                	jmp    8984 <number+0xa8>
    897f:	b8 2b 00 00 00       	mov    $0x2b,%eax
    8984:	88 44 24 3f          	mov    %al,0x3f(%esp)
	if (sign) size--;
    8988:	80 7c 24 3f 00       	cmpb   $0x0,0x3f(%esp)
    898d:	74 05                	je     8994 <number+0xb8>
    898f:	83 6c 24 54 01       	subl   $0x1,0x54(%esp)
	if (type&SPECIAL) {
    8994:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    8998:	83 e0 20             	and    $0x20,%eax
    899b:	85 c0                	test   %eax,%eax
    899d:	74 1a                	je     89b9 <number+0xdd>
		if (base==16) size -= 2;
    899f:	83 7c 24 50 10       	cmpl   $0x10,0x50(%esp)
    89a4:	75 07                	jne    89ad <number+0xd1>
    89a6:	83 6c 24 54 02       	subl   $0x2,0x54(%esp)
    89ab:	eb 0c                	jmp    89b9 <number+0xdd>
		else if (base==8) size--;
    89ad:	83 7c 24 50 08       	cmpl   $0x8,0x50(%esp)
    89b2:	75 05                	jne    89b9 <number+0xdd>
    89b4:	83 6c 24 54 01       	subl   $0x1,0x54(%esp)
	}
	i=0;
    89b9:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
    89c0:	00 
	if (num==0)
    89c1:	83 7c 24 4c 00       	cmpl   $0x0,0x4c(%esp)
    89c6:	75 47                	jne    8a0f <number+0x133>
		tmp[i++]='0';
    89c8:	8b 44 24 34          	mov    0x34(%esp),%eax
    89cc:	8d 50 01             	lea    0x1(%eax),%edx
    89cf:	89 54 24 34          	mov    %edx,0x34(%esp)
    89d3:	c6 44 04 08 30       	movb   $0x30,0x8(%esp,%eax,1)
    89d8:	eb 3c                	jmp    8a16 <number+0x13a>
	else while (num!=0)
		tmp[i++]=digits[do_div(num,base)];
    89da:	8b 4c 24 34          	mov    0x34(%esp),%ecx
    89de:	8d 41 01             	lea    0x1(%ecx),%eax
    89e1:	89 44 24 34          	mov    %eax,0x34(%esp)
    89e5:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    89e9:	ba 00 00 00 00       	mov    $0x0,%edx
    89ee:	8b 5c 24 50          	mov    0x50(%esp),%ebx
    89f2:	f7 f3                	div    %ebx
    89f4:	89 44 24 4c          	mov    %eax,0x4c(%esp)
    89f8:	89 54 24 2c          	mov    %edx,0x2c(%esp)
    89fc:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    8a00:	89 c2                	mov    %eax,%edx
    8a02:	8b 44 24 38          	mov    0x38(%esp),%eax
    8a06:	01 d0                	add    %edx,%eax
    8a08:	0f b6 00             	movzbl (%eax),%eax
    8a0b:	88 44 0c 08          	mov    %al,0x8(%esp,%ecx,1)
		else if (base==8) size--;
	}
	i=0;
	if (num==0)
		tmp[i++]='0';
	else while (num!=0)
    8a0f:	83 7c 24 4c 00       	cmpl   $0x0,0x4c(%esp)
    8a14:	75 c4                	jne    89da <number+0xfe>
		tmp[i++]=digits[do_div(num,base)];
	if (i>precision) precision=i;
    8a16:	8b 44 24 34          	mov    0x34(%esp),%eax
    8a1a:	3b 44 24 58          	cmp    0x58(%esp),%eax
    8a1e:	7e 08                	jle    8a28 <number+0x14c>
    8a20:	8b 44 24 34          	mov    0x34(%esp),%eax
    8a24:	89 44 24 58          	mov    %eax,0x58(%esp)
	size -= precision;
    8a28:	8b 44 24 58          	mov    0x58(%esp),%eax
    8a2c:	29 44 24 54          	sub    %eax,0x54(%esp)
	if (!(type&(ZEROPAD+LEFT)))
    8a30:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    8a34:	83 e0 11             	and    $0x11,%eax
    8a37:	85 c0                	test   %eax,%eax
    8a39:	75 1f                	jne    8a5a <number+0x17e>
		while(size-->0)
    8a3b:	eb 0e                	jmp    8a4b <number+0x16f>
			*str++ = ' ';
    8a3d:	8b 44 24 48          	mov    0x48(%esp),%eax
    8a41:	8d 50 01             	lea    0x1(%eax),%edx
    8a44:	89 54 24 48          	mov    %edx,0x48(%esp)
    8a48:	c6 00 20             	movb   $0x20,(%eax)
	else while (num!=0)
		tmp[i++]=digits[do_div(num,base)];
	if (i>precision) precision=i;
	size -= precision;
	if (!(type&(ZEROPAD+LEFT)))
		while(size-->0)
    8a4b:	8b 44 24 54          	mov    0x54(%esp),%eax
    8a4f:	8d 50 ff             	lea    -0x1(%eax),%edx
    8a52:	89 54 24 54          	mov    %edx,0x54(%esp)
    8a56:	85 c0                	test   %eax,%eax
    8a58:	7f e3                	jg     8a3d <number+0x161>
			*str++ = ' ';
	if (sign)
    8a5a:	80 7c 24 3f 00       	cmpb   $0x0,0x3f(%esp)
    8a5f:	74 12                	je     8a73 <number+0x197>
		*str++ = sign;
    8a61:	8b 44 24 48          	mov    0x48(%esp),%eax
    8a65:	8d 50 01             	lea    0x1(%eax),%edx
    8a68:	89 54 24 48          	mov    %edx,0x48(%esp)
    8a6c:	0f b6 54 24 3f       	movzbl 0x3f(%esp),%edx
    8a71:	88 10                	mov    %dl,(%eax)
	if (type&SPECIAL) {
    8a73:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    8a77:	83 e0 20             	and    $0x20,%eax
    8a7a:	85 c0                	test   %eax,%eax
    8a7c:	74 41                	je     8abf <number+0x1e3>
		if (base==8)
    8a7e:	83 7c 24 50 08       	cmpl   $0x8,0x50(%esp)
    8a83:	75 10                	jne    8a95 <number+0x1b9>
			*str++ = '0';
    8a85:	8b 44 24 48          	mov    0x48(%esp),%eax
    8a89:	8d 50 01             	lea    0x1(%eax),%edx
    8a8c:	89 54 24 48          	mov    %edx,0x48(%esp)
    8a90:	c6 00 30             	movb   $0x30,(%eax)
    8a93:	eb 2a                	jmp    8abf <number+0x1e3>
		else if (base==16) {
    8a95:	83 7c 24 50 10       	cmpl   $0x10,0x50(%esp)
    8a9a:	75 23                	jne    8abf <number+0x1e3>
			*str++ = '0';
    8a9c:	8b 44 24 48          	mov    0x48(%esp),%eax
    8aa0:	8d 50 01             	lea    0x1(%eax),%edx
    8aa3:	89 54 24 48          	mov    %edx,0x48(%esp)
    8aa7:	c6 00 30             	movb   $0x30,(%eax)
			*str++ = digits[33];
    8aaa:	8b 44 24 48          	mov    0x48(%esp),%eax
    8aae:	8d 50 01             	lea    0x1(%eax),%edx
    8ab1:	89 54 24 48          	mov    %edx,0x48(%esp)
    8ab5:	8b 54 24 38          	mov    0x38(%esp),%edx
    8ab9:	0f b6 52 21          	movzbl 0x21(%edx),%edx
    8abd:	88 10                	mov    %dl,(%eax)
		}
	}
	if (!(type&LEFT))
    8abf:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    8ac3:	83 e0 10             	and    $0x10,%eax
    8ac6:	85 c0                	test   %eax,%eax
    8ac8:	75 33                	jne    8afd <number+0x221>
		while(size-->0)
    8aca:	eb 12                	jmp    8ade <number+0x202>
			*str++ = c;
    8acc:	8b 44 24 48          	mov    0x48(%esp),%eax
    8ad0:	8d 50 01             	lea    0x1(%eax),%edx
    8ad3:	89 54 24 48          	mov    %edx,0x48(%esp)
    8ad7:	0f b6 54 24 33       	movzbl 0x33(%esp),%edx
    8adc:	88 10                	mov    %dl,(%eax)
			*str++ = '0';
			*str++ = digits[33];
		}
	}
	if (!(type&LEFT))
		while(size-->0)
    8ade:	8b 44 24 54          	mov    0x54(%esp),%eax
    8ae2:	8d 50 ff             	lea    -0x1(%eax),%edx
    8ae5:	89 54 24 54          	mov    %edx,0x54(%esp)
    8ae9:	85 c0                	test   %eax,%eax
    8aeb:	7f df                	jg     8acc <number+0x1f0>
			*str++ = c;
	while(i<precision--)
    8aed:	eb 0e                	jmp    8afd <number+0x221>
		*str++ = '0';
    8aef:	8b 44 24 48          	mov    0x48(%esp),%eax
    8af3:	8d 50 01             	lea    0x1(%eax),%edx
    8af6:	89 54 24 48          	mov    %edx,0x48(%esp)
    8afa:	c6 00 30             	movb   $0x30,(%eax)
		}
	}
	if (!(type&LEFT))
		while(size-->0)
			*str++ = c;
	while(i<precision--)
    8afd:	8b 44 24 58          	mov    0x58(%esp),%eax
    8b01:	8d 50 ff             	lea    -0x1(%eax),%edx
    8b04:	89 54 24 58          	mov    %edx,0x58(%esp)
    8b08:	3b 44 24 34          	cmp    0x34(%esp),%eax
    8b0c:	7f e1                	jg     8aef <number+0x213>
		*str++ = '0';
	while(i-->0)
    8b0e:	eb 1a                	jmp    8b2a <number+0x24e>
		*str++ = tmp[i];
    8b10:	8b 44 24 48          	mov    0x48(%esp),%eax
    8b14:	8d 50 01             	lea    0x1(%eax),%edx
    8b17:	89 54 24 48          	mov    %edx,0x48(%esp)
    8b1b:	8d 4c 24 08          	lea    0x8(%esp),%ecx
    8b1f:	8b 54 24 34          	mov    0x34(%esp),%edx
    8b23:	01 ca                	add    %ecx,%edx
    8b25:	0f b6 12             	movzbl (%edx),%edx
    8b28:	88 10                	mov    %dl,(%eax)
	if (!(type&LEFT))
		while(size-->0)
			*str++ = c;
	while(i<precision--)
		*str++ = '0';
	while(i-->0)
    8b2a:	8b 44 24 34          	mov    0x34(%esp),%eax
    8b2e:	8d 50 ff             	lea    -0x1(%eax),%edx
    8b31:	89 54 24 34          	mov    %edx,0x34(%esp)
    8b35:	85 c0                	test   %eax,%eax
    8b37:	7f d7                	jg     8b10 <number+0x234>
		*str++ = tmp[i];
	while(size-->0)
    8b39:	eb 0e                	jmp    8b49 <number+0x26d>
		*str++ = ' ';
    8b3b:	8b 44 24 48          	mov    0x48(%esp),%eax
    8b3f:	8d 50 01             	lea    0x1(%eax),%edx
    8b42:	89 54 24 48          	mov    %edx,0x48(%esp)
    8b46:	c6 00 20             	movb   $0x20,(%eax)
			*str++ = c;
	while(i<precision--)
		*str++ = '0';
	while(i-->0)
		*str++ = tmp[i];
	while(size-->0)
    8b49:	8b 44 24 54          	mov    0x54(%esp),%eax
    8b4d:	8d 50 ff             	lea    -0x1(%eax),%edx
    8b50:	89 54 24 54          	mov    %edx,0x54(%esp)
    8b54:	85 c0                	test   %eax,%eax
    8b56:	7f e3                	jg     8b3b <number+0x25f>
		*str++ = ' ';
	return str;
    8b58:	8b 44 24 48          	mov    0x48(%esp),%eax
}
    8b5c:	83 c4 40             	add    $0x40,%esp
    8b5f:	5b                   	pop    %ebx
    8b60:	c3                   	ret    

00008b61 <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
    8b61:	83 ec 30             	sub    $0x30,%esp
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
    8b64:	8b 44 24 34          	mov    0x34(%esp),%eax
    8b68:	89 44 24 24          	mov    %eax,0x24(%esp)
    8b6c:	e9 4a 04 00 00       	jmp    8fbb <vsprintf+0x45a>
		if (*fmt != '%') {
    8b71:	8b 44 24 38          	mov    0x38(%esp),%eax
    8b75:	0f b6 00             	movzbl (%eax),%eax
    8b78:	3c 25                	cmp    $0x25,%al
    8b7a:	74 19                	je     8b95 <vsprintf+0x34>
			*str++ = *fmt;
    8b7c:	8b 44 24 24          	mov    0x24(%esp),%eax
    8b80:	8d 50 01             	lea    0x1(%eax),%edx
    8b83:	89 54 24 24          	mov    %edx,0x24(%esp)
    8b87:	8b 54 24 38          	mov    0x38(%esp),%edx
    8b8b:	0f b6 12             	movzbl (%edx),%edx
    8b8e:	88 10                	mov    %dl,(%eax)
			continue;
    8b90:	e9 1b 04 00 00       	jmp    8fb0 <vsprintf+0x44f>
		}
			
		/* process flags */
		flags = 0;
    8b95:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    8b9c:	00 
		repeat:
			++fmt;		/* this also skips first '%' */
    8b9d:	8b 44 24 38          	mov    0x38(%esp),%eax
    8ba1:	83 c0 01             	add    $0x1,%eax
    8ba4:	89 44 24 38          	mov    %eax,0x38(%esp)
			switch (*fmt) {
    8ba8:	8b 44 24 38          	mov    0x38(%esp),%eax
    8bac:	0f b6 00             	movzbl (%eax),%eax
    8baf:	0f be c0             	movsbl %al,%eax
    8bb2:	83 e8 20             	sub    $0x20,%eax
    8bb5:	83 f8 10             	cmp    $0x10,%eax
    8bb8:	77 2c                	ja     8be6 <vsprintf+0x85>
    8bba:	8b 04 85 fc 83 01 00 	mov    0x183fc(,%eax,4),%eax
    8bc1:	ff e0                	jmp    *%eax
				case '-': flags |= LEFT; goto repeat;
    8bc3:	83 4c 24 1c 10       	orl    $0x10,0x1c(%esp)
    8bc8:	eb d3                	jmp    8b9d <vsprintf+0x3c>
				case '+': flags |= PLUS; goto repeat;
    8bca:	83 4c 24 1c 04       	orl    $0x4,0x1c(%esp)
    8bcf:	eb cc                	jmp    8b9d <vsprintf+0x3c>
				case ' ': flags |= SPACE; goto repeat;
    8bd1:	83 4c 24 1c 08       	orl    $0x8,0x1c(%esp)
    8bd6:	eb c5                	jmp    8b9d <vsprintf+0x3c>
				case '#': flags |= SPECIAL; goto repeat;
    8bd8:	83 4c 24 1c 20       	orl    $0x20,0x1c(%esp)
    8bdd:	eb be                	jmp    8b9d <vsprintf+0x3c>
				case '0': flags |= ZEROPAD; goto repeat;
    8bdf:	83 4c 24 1c 01       	orl    $0x1,0x1c(%esp)
    8be4:	eb b7                	jmp    8b9d <vsprintf+0x3c>
				}
		
		/* get field width */
		field_width = -1;
    8be6:	c7 44 24 18 ff ff ff 	movl   $0xffffffff,0x18(%esp)
    8bed:	ff 
		if (is_digit(*fmt))
    8bee:	8b 44 24 38          	mov    0x38(%esp),%eax
    8bf2:	0f b6 00             	movzbl (%eax),%eax
    8bf5:	3c 2f                	cmp    $0x2f,%al
    8bf7:	7e 1e                	jle    8c17 <vsprintf+0xb6>
    8bf9:	8b 44 24 38          	mov    0x38(%esp),%eax
    8bfd:	0f b6 00             	movzbl (%eax),%eax
    8c00:	3c 39                	cmp    $0x39,%al
    8c02:	7f 13                	jg     8c17 <vsprintf+0xb6>
			field_width = skip_atoi(&fmt);
    8c04:	8d 44 24 38          	lea    0x38(%esp),%eax
    8c08:	50                   	push   %eax
    8c09:	e8 70 fc ff ff       	call   887e <skip_atoi>
    8c0e:	83 c4 04             	add    $0x4,%esp
    8c11:	89 44 24 18          	mov    %eax,0x18(%esp)
    8c15:	eb 36                	jmp    8c4d <vsprintf+0xec>
		else if (*fmt == '*') {
    8c17:	8b 44 24 38          	mov    0x38(%esp),%eax
    8c1b:	0f b6 00             	movzbl (%eax),%eax
    8c1e:	3c 2a                	cmp    $0x2a,%al
    8c20:	75 2b                	jne    8c4d <vsprintf+0xec>
			++fmt;
    8c22:	8b 44 24 38          	mov    0x38(%esp),%eax
    8c26:	83 c0 01             	add    $0x1,%eax
    8c29:	89 44 24 38          	mov    %eax,0x38(%esp)
			/* it's the next argument */
			field_width = va_arg(args, int);
    8c2d:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8c32:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    8c36:	8b 40 fc             	mov    -0x4(%eax),%eax
    8c39:	89 44 24 18          	mov    %eax,0x18(%esp)
			if (field_width < 0) {
    8c3d:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    8c42:	79 09                	jns    8c4d <vsprintf+0xec>
				field_width = -field_width;
    8c44:	f7 5c 24 18          	negl   0x18(%esp)
				flags |= LEFT;
    8c48:	83 4c 24 1c 10       	orl    $0x10,0x1c(%esp)
			}
		}

		/* get the precision */
		precision = -1;
    8c4d:	c7 44 24 14 ff ff ff 	movl   $0xffffffff,0x14(%esp)
    8c54:	ff 
		if (*fmt == '.') {
    8c55:	8b 44 24 38          	mov    0x38(%esp),%eax
    8c59:	0f b6 00             	movzbl (%eax),%eax
    8c5c:	3c 2e                	cmp    $0x2e,%al
    8c5e:	75 69                	jne    8cc9 <vsprintf+0x168>
			++fmt;	
    8c60:	8b 44 24 38          	mov    0x38(%esp),%eax
    8c64:	83 c0 01             	add    $0x1,%eax
    8c67:	89 44 24 38          	mov    %eax,0x38(%esp)
			if (is_digit(*fmt))
    8c6b:	8b 44 24 38          	mov    0x38(%esp),%eax
    8c6f:	0f b6 00             	movzbl (%eax),%eax
    8c72:	3c 2f                	cmp    $0x2f,%al
    8c74:	7e 1e                	jle    8c94 <vsprintf+0x133>
    8c76:	8b 44 24 38          	mov    0x38(%esp),%eax
    8c7a:	0f b6 00             	movzbl (%eax),%eax
    8c7d:	3c 39                	cmp    $0x39,%al
    8c7f:	7f 13                	jg     8c94 <vsprintf+0x133>
				precision = skip_atoi(&fmt);
    8c81:	8d 44 24 38          	lea    0x38(%esp),%eax
    8c85:	50                   	push   %eax
    8c86:	e8 f3 fb ff ff       	call   887e <skip_atoi>
    8c8b:	83 c4 04             	add    $0x4,%esp
    8c8e:	89 44 24 14          	mov    %eax,0x14(%esp)
    8c92:	eb 26                	jmp    8cba <vsprintf+0x159>
			else if (*fmt == '*') {
    8c94:	8b 44 24 38          	mov    0x38(%esp),%eax
    8c98:	0f b6 00             	movzbl (%eax),%eax
    8c9b:	3c 2a                	cmp    $0x2a,%al
    8c9d:	75 1b                	jne    8cba <vsprintf+0x159>
				++fmt;
    8c9f:	8b 44 24 38          	mov    0x38(%esp),%eax
    8ca3:	83 c0 01             	add    $0x1,%eax
    8ca6:	89 44 24 38          	mov    %eax,0x38(%esp)
				/* it's the next argument */
				precision = va_arg(args, int);
    8caa:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8caf:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    8cb3:	8b 40 fc             	mov    -0x4(%eax),%eax
    8cb6:	89 44 24 14          	mov    %eax,0x14(%esp)
			}
			if (precision < 0)
    8cba:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    8cbf:	79 08                	jns    8cc9 <vsprintf+0x168>
				precision = 0;
    8cc1:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    8cc8:	00 
		}

		/* get the conversion qualifier */
		qualifier = -1;
    8cc9:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
    8cd0:	ff 
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
    8cd1:	8b 44 24 38          	mov    0x38(%esp),%eax
    8cd5:	0f b6 00             	movzbl (%eax),%eax
    8cd8:	3c 68                	cmp    $0x68,%al
    8cda:	74 16                	je     8cf2 <vsprintf+0x191>
    8cdc:	8b 44 24 38          	mov    0x38(%esp),%eax
    8ce0:	0f b6 00             	movzbl (%eax),%eax
    8ce3:	3c 6c                	cmp    $0x6c,%al
    8ce5:	74 0b                	je     8cf2 <vsprintf+0x191>
    8ce7:	8b 44 24 38          	mov    0x38(%esp),%eax
    8ceb:	0f b6 00             	movzbl (%eax),%eax
    8cee:	3c 4c                	cmp    $0x4c,%al
    8cf0:	75 19                	jne    8d0b <vsprintf+0x1aa>
			qualifier = *fmt;
    8cf2:	8b 44 24 38          	mov    0x38(%esp),%eax
    8cf6:	0f b6 00             	movzbl (%eax),%eax
    8cf9:	0f be c0             	movsbl %al,%eax
    8cfc:	89 44 24 10          	mov    %eax,0x10(%esp)
			++fmt;
    8d00:	8b 44 24 38          	mov    0x38(%esp),%eax
    8d04:	83 c0 01             	add    $0x1,%eax
    8d07:	89 44 24 38          	mov    %eax,0x38(%esp)
		}

		switch (*fmt) {
    8d0b:	8b 44 24 38          	mov    0x38(%esp),%eax
    8d0f:	0f b6 00             	movzbl (%eax),%eax
    8d12:	0f be c0             	movsbl %al,%eax
    8d15:	83 e8 58             	sub    $0x58,%eax
    8d18:	83 f8 20             	cmp    $0x20,%eax
    8d1b:	0f 87 49 02 00 00    	ja     8f6a <vsprintf+0x409>
    8d21:	8b 04 85 40 84 01 00 	mov    0x18440(,%eax,4),%eax
    8d28:	ff e0                	jmp    *%eax
		case 'c':
			if (!(flags & LEFT))
    8d2a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    8d2e:	83 e0 10             	and    $0x10,%eax
    8d31:	85 c0                	test   %eax,%eax
    8d33:	75 1c                	jne    8d51 <vsprintf+0x1f0>
				while (--field_width > 0)
    8d35:	eb 0e                	jmp    8d45 <vsprintf+0x1e4>
					*str++ = ' ';
    8d37:	8b 44 24 24          	mov    0x24(%esp),%eax
    8d3b:	8d 50 01             	lea    0x1(%eax),%edx
    8d3e:	89 54 24 24          	mov    %edx,0x24(%esp)
    8d42:	c6 00 20             	movb   $0x20,(%eax)
		}

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
    8d45:	83 6c 24 18 01       	subl   $0x1,0x18(%esp)
    8d4a:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    8d4f:	7f e6                	jg     8d37 <vsprintf+0x1d6>
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
    8d51:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8d56:	8b 44 24 24          	mov    0x24(%esp),%eax
    8d5a:	8d 50 01             	lea    0x1(%eax),%edx
    8d5d:	89 54 24 24          	mov    %edx,0x24(%esp)
    8d61:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    8d65:	83 ea 04             	sub    $0x4,%edx
    8d68:	8b 12                	mov    (%edx),%edx
    8d6a:	88 10                	mov    %dl,(%eax)
			while (--field_width > 0)
    8d6c:	eb 0e                	jmp    8d7c <vsprintf+0x21b>
				*str++ = ' ';
    8d6e:	8b 44 24 24          	mov    0x24(%esp),%eax
    8d72:	8d 50 01             	lea    0x1(%eax),%edx
    8d75:	89 54 24 24          	mov    %edx,0x24(%esp)
    8d79:	c6 00 20             	movb   $0x20,(%eax)
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
			while (--field_width > 0)
    8d7c:	83 6c 24 18 01       	subl   $0x1,0x18(%esp)
    8d81:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    8d86:	7f e6                	jg     8d6e <vsprintf+0x20d>
				*str++ = ' ';
			break;
    8d88:	e9 23 02 00 00       	jmp    8fb0 <vsprintf+0x44f>

		case 's':
			s = va_arg(args, char *);
    8d8d:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8d92:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    8d96:	8b 40 fc             	mov    -0x4(%eax),%eax
    8d99:	89 44 24 20          	mov    %eax,0x20(%esp)
			if (!s)
    8d9d:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    8da2:	75 08                	jne    8dac <vsprintf+0x24b>
				s = "<NULL>";
    8da4:	c7 44 24 20 f5 83 01 	movl   $0x183f5,0x20(%esp)
    8dab:	00 
			len = strlen(s);
    8dac:	ff 74 24 20          	pushl  0x20(%esp)
    8db0:	e8 a6 fa ff ff       	call   885b <strlen>
    8db5:	83 c4 04             	add    $0x4,%esp
    8db8:	89 44 24 2c          	mov    %eax,0x2c(%esp)
			if (precision < 0)
    8dbc:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    8dc1:	79 0a                	jns    8dcd <vsprintf+0x26c>
				precision = len;
    8dc3:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    8dc7:	89 44 24 14          	mov    %eax,0x14(%esp)
    8dcb:	eb 12                	jmp    8ddf <vsprintf+0x27e>
			else if (len > precision)
    8dcd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    8dd1:	3b 44 24 14          	cmp    0x14(%esp),%eax
    8dd5:	7e 08                	jle    8ddf <vsprintf+0x27e>
				len = precision;
    8dd7:	8b 44 24 14          	mov    0x14(%esp),%eax
    8ddb:	89 44 24 2c          	mov    %eax,0x2c(%esp)

			if (!(flags & LEFT))
    8ddf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    8de3:	83 e0 10             	and    $0x10,%eax
    8de6:	85 c0                	test   %eax,%eax
    8de8:	75 21                	jne    8e0b <vsprintf+0x2aa>
				while (len < field_width--)
    8dea:	eb 0e                	jmp    8dfa <vsprintf+0x299>
					*str++ = ' ';
    8dec:	8b 44 24 24          	mov    0x24(%esp),%eax
    8df0:	8d 50 01             	lea    0x1(%eax),%edx
    8df3:	89 54 24 24          	mov    %edx,0x24(%esp)
    8df7:	c6 00 20             	movb   $0x20,(%eax)
				precision = len;
			else if (len > precision)
				len = precision;

			if (!(flags & LEFT))
				while (len < field_width--)
    8dfa:	8b 44 24 18          	mov    0x18(%esp),%eax
    8dfe:	8d 50 ff             	lea    -0x1(%eax),%edx
    8e01:	89 54 24 18          	mov    %edx,0x18(%esp)
    8e05:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
    8e09:	7f e1                	jg     8dec <vsprintf+0x28b>
					*str++ = ' ';
			for (i = 0; i < len; ++i)
    8e0b:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    8e12:	00 
    8e13:	eb 20                	jmp    8e35 <vsprintf+0x2d4>
				*str++ = *s++;
    8e15:	8b 44 24 24          	mov    0x24(%esp),%eax
    8e19:	8d 50 01             	lea    0x1(%eax),%edx
    8e1c:	89 54 24 24          	mov    %edx,0x24(%esp)
    8e20:	8b 54 24 20          	mov    0x20(%esp),%edx
    8e24:	8d 4a 01             	lea    0x1(%edx),%ecx
    8e27:	89 4c 24 20          	mov    %ecx,0x20(%esp)
    8e2b:	0f b6 12             	movzbl (%edx),%edx
    8e2e:	88 10                	mov    %dl,(%eax)
				len = precision;

			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
    8e30:	83 44 24 28 01       	addl   $0x1,0x28(%esp)
    8e35:	8b 44 24 28          	mov    0x28(%esp),%eax
    8e39:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
    8e3d:	7c d6                	jl     8e15 <vsprintf+0x2b4>
				*str++ = *s++;
			while (len < field_width--)
    8e3f:	eb 0e                	jmp    8e4f <vsprintf+0x2ee>
				*str++ = ' ';
    8e41:	8b 44 24 24          	mov    0x24(%esp),%eax
    8e45:	8d 50 01             	lea    0x1(%eax),%edx
    8e48:	89 54 24 24          	mov    %edx,0x24(%esp)
    8e4c:	c6 00 20             	movb   $0x20,(%eax)
			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
				*str++ = *s++;
			while (len < field_width--)
    8e4f:	8b 44 24 18          	mov    0x18(%esp),%eax
    8e53:	8d 50 ff             	lea    -0x1(%eax),%edx
    8e56:	89 54 24 18          	mov    %edx,0x18(%esp)
    8e5a:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
    8e5e:	7f e1                	jg     8e41 <vsprintf+0x2e0>
				*str++ = ' ';
			break;
    8e60:	e9 4b 01 00 00       	jmp    8fb0 <vsprintf+0x44f>

		case 'o':
			str = number(str, va_arg(args, unsigned long), 8,
    8e65:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8e6a:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    8e6e:	83 e8 04             	sub    $0x4,%eax
    8e71:	8b 00                	mov    (%eax),%eax
    8e73:	ff 74 24 1c          	pushl  0x1c(%esp)
    8e77:	ff 74 24 18          	pushl  0x18(%esp)
    8e7b:	ff 74 24 20          	pushl  0x20(%esp)
    8e7f:	6a 08                	push   $0x8
    8e81:	50                   	push   %eax
    8e82:	ff 74 24 38          	pushl  0x38(%esp)
    8e86:	e8 51 fa ff ff       	call   88dc <number>
    8e8b:	83 c4 18             	add    $0x18,%esp
    8e8e:	89 44 24 24          	mov    %eax,0x24(%esp)
				field_width, precision, flags);
			break;
    8e92:	e9 19 01 00 00       	jmp    8fb0 <vsprintf+0x44f>

		case 'p':
			if (field_width == -1) {
    8e97:	83 7c 24 18 ff       	cmpl   $0xffffffff,0x18(%esp)
    8e9c:	75 0d                	jne    8eab <vsprintf+0x34a>
				field_width = 8;
    8e9e:	c7 44 24 18 08 00 00 	movl   $0x8,0x18(%esp)
    8ea5:	00 
				flags |= ZEROPAD;
    8ea6:	83 4c 24 1c 01       	orl    $0x1,0x1c(%esp)
			}
			str = number(str,
				(unsigned long) va_arg(args, void *), 16,
    8eab:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8eb0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    8eb4:	83 e8 04             	sub    $0x4,%eax
    8eb7:	8b 00                	mov    (%eax),%eax
		case 'p':
			if (field_width == -1) {
				field_width = 8;
				flags |= ZEROPAD;
			}
			str = number(str,
    8eb9:	ff 74 24 1c          	pushl  0x1c(%esp)
    8ebd:	ff 74 24 18          	pushl  0x18(%esp)
    8ec1:	ff 74 24 20          	pushl  0x20(%esp)
    8ec5:	6a 10                	push   $0x10
    8ec7:	50                   	push   %eax
    8ec8:	ff 74 24 38          	pushl  0x38(%esp)
    8ecc:	e8 0b fa ff ff       	call   88dc <number>
    8ed1:	83 c4 18             	add    $0x18,%esp
    8ed4:	89 44 24 24          	mov    %eax,0x24(%esp)
				(unsigned long) va_arg(args, void *), 16,
				field_width, precision, flags);
			break;
    8ed8:	e9 d3 00 00 00       	jmp    8fb0 <vsprintf+0x44f>

		case 'x':
			flags |= SMALL;
    8edd:	83 4c 24 1c 40       	orl    $0x40,0x1c(%esp)
		case 'X':
			str = number(str, va_arg(args, unsigned long), 16,
    8ee2:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8ee7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    8eeb:	83 e8 04             	sub    $0x4,%eax
    8eee:	8b 00                	mov    (%eax),%eax
    8ef0:	ff 74 24 1c          	pushl  0x1c(%esp)
    8ef4:	ff 74 24 18          	pushl  0x18(%esp)
    8ef8:	ff 74 24 20          	pushl  0x20(%esp)
    8efc:	6a 10                	push   $0x10
    8efe:	50                   	push   %eax
    8eff:	ff 74 24 38          	pushl  0x38(%esp)
    8f03:	e8 d4 f9 ff ff       	call   88dc <number>
    8f08:	83 c4 18             	add    $0x18,%esp
    8f0b:	89 44 24 24          	mov    %eax,0x24(%esp)
				field_width, precision, flags);
			break;
    8f0f:	e9 9c 00 00 00       	jmp    8fb0 <vsprintf+0x44f>

		case 'd':
		case 'i':
			flags |= SIGN;
    8f14:	83 4c 24 1c 02       	orl    $0x2,0x1c(%esp)
		case 'u':
			str = number(str, va_arg(args, unsigned long), 10,
    8f19:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8f1e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    8f22:	83 e8 04             	sub    $0x4,%eax
    8f25:	8b 00                	mov    (%eax),%eax
    8f27:	ff 74 24 1c          	pushl  0x1c(%esp)
    8f2b:	ff 74 24 18          	pushl  0x18(%esp)
    8f2f:	ff 74 24 20          	pushl  0x20(%esp)
    8f33:	6a 0a                	push   $0xa
    8f35:	50                   	push   %eax
    8f36:	ff 74 24 38          	pushl  0x38(%esp)
    8f3a:	e8 9d f9 ff ff       	call   88dc <number>
    8f3f:	83 c4 18             	add    $0x18,%esp
    8f42:	89 44 24 24          	mov    %eax,0x24(%esp)
				field_width, precision, flags);
			break;
    8f46:	eb 68                	jmp    8fb0 <vsprintf+0x44f>

		case 'n':
			ip = va_arg(args, int *);
    8f48:	83 44 24 3c 04       	addl   $0x4,0x3c(%esp)
    8f4d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    8f51:	8b 40 fc             	mov    -0x4(%eax),%eax
    8f54:	89 44 24 0c          	mov    %eax,0xc(%esp)
			*ip = (str - buf);
    8f58:	8b 54 24 24          	mov    0x24(%esp),%edx
    8f5c:	8b 44 24 34          	mov    0x34(%esp),%eax
    8f60:	29 c2                	sub    %eax,%edx
    8f62:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8f66:	89 10                	mov    %edx,(%eax)
			break;
    8f68:	eb 46                	jmp    8fb0 <vsprintf+0x44f>

		default:
			if (*fmt != '%')
    8f6a:	8b 44 24 38          	mov    0x38(%esp),%eax
    8f6e:	0f b6 00             	movzbl (%eax),%eax
    8f71:	3c 25                	cmp    $0x25,%al
    8f73:	74 0e                	je     8f83 <vsprintf+0x422>
				*str++ = '%';
    8f75:	8b 44 24 24          	mov    0x24(%esp),%eax
    8f79:	8d 50 01             	lea    0x1(%eax),%edx
    8f7c:	89 54 24 24          	mov    %edx,0x24(%esp)
    8f80:	c6 00 25             	movb   $0x25,(%eax)
			if (*fmt)
    8f83:	8b 44 24 38          	mov    0x38(%esp),%eax
    8f87:	0f b6 00             	movzbl (%eax),%eax
    8f8a:	84 c0                	test   %al,%al
    8f8c:	74 16                	je     8fa4 <vsprintf+0x443>
				*str++ = *fmt;
    8f8e:	8b 44 24 24          	mov    0x24(%esp),%eax
    8f92:	8d 50 01             	lea    0x1(%eax),%edx
    8f95:	89 54 24 24          	mov    %edx,0x24(%esp)
    8f99:	8b 54 24 38          	mov    0x38(%esp),%edx
    8f9d:	0f b6 12             	movzbl (%edx),%edx
    8fa0:	88 10                	mov    %dl,(%eax)
			else
				--fmt;
			break;
    8fa2:	eb 0b                	jmp    8faf <vsprintf+0x44e>
			if (*fmt != '%')
				*str++ = '%';
			if (*fmt)
				*str++ = *fmt;
			else
				--fmt;
    8fa4:	8b 44 24 38          	mov    0x38(%esp),%eax
    8fa8:	83 e8 01             	sub    $0x1,%eax
    8fab:	89 44 24 38          	mov    %eax,0x38(%esp)
			break;
    8faf:	90                   	nop
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
    8fb0:	8b 44 24 38          	mov    0x38(%esp),%eax
    8fb4:	83 c0 01             	add    $0x1,%eax
    8fb7:	89 44 24 38          	mov    %eax,0x38(%esp)
    8fbb:	8b 44 24 38          	mov    0x38(%esp),%eax
    8fbf:	0f b6 00             	movzbl (%eax),%eax
    8fc2:	84 c0                	test   %al,%al
    8fc4:	0f 85 a7 fb ff ff    	jne    8b71 <vsprintf+0x10>
			else
				--fmt;
			break;
		}
	}
	*str = '\0';
    8fca:	8b 44 24 24          	mov    0x24(%esp),%eax
    8fce:	c6 00 00             	movb   $0x0,(%eax)
	return str-buf;
    8fd1:	8b 54 24 24          	mov    0x24(%esp),%edx
    8fd5:	8b 44 24 34          	mov    0x34(%esp),%eax
    8fd9:	29 c2                	sub    %eax,%edx
    8fdb:	89 d0                	mov    %edx,%eax
}
    8fdd:	83 c4 30             	add    $0x30,%esp
    8fe0:	c3                   	ret    

00008fe1 <get_fs_long>:
	__asm__ ("movw %%fs:%1,%0":"=r" (_v):"m" (*addr));
	return _v;
}

static inline unsigned long get_fs_long(const unsigned long *addr)
{
    8fe1:	83 ec 10             	sub    $0x10,%esp
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
    8fe4:	8b 44 24 14          	mov    0x14(%esp),%eax
    8fe8:	64 8b 00             	mov    %fs:(%eax),%eax
    8feb:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
    8fef:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    8ff3:	83 c4 10             	add    $0x10,%esp
    8ff6:	c3                   	ret    

00008ff7 <put_fs_byte>:

static inline void put_fs_byte(char val,char *addr)
{
    8ff7:	83 ec 04             	sub    $0x4,%esp
    8ffa:	8b 44 24 08          	mov    0x8(%esp),%eax
    8ffe:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    9001:	0f b6 04 24          	movzbl (%esp),%eax
    9005:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9009:	64 88 02             	mov    %al,%fs:(%edx)
}
    900c:	90                   	nop
    900d:	83 c4 04             	add    $0x4,%esp
    9010:	c3                   	ret    

00009011 <put_fs_long>:
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    9011:	8b 44 24 04          	mov    0x4(%esp),%eax
    9015:	8b 54 24 08          	mov    0x8(%esp),%edx
    9019:	64 89 02             	mov    %eax,%fs:(%edx)
}
    901c:	90                   	nop
    901d:	c3                   	ret    

0000901e <sys_ftime>:
#include <sys/times.h>
#include <sys/utsname.h>

int sys_ftime()
{
	return -ENOSYS;
    901e:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9023:	c3                   	ret    

00009024 <sys_break>:

int sys_break()
{
	return -ENOSYS;
    9024:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9029:	c3                   	ret    

0000902a <sys_ptrace>:

int sys_ptrace()
{
	return -ENOSYS;
    902a:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    902f:	c3                   	ret    

00009030 <sys_stty>:

int sys_stty()
{
	return -ENOSYS;
    9030:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9035:	c3                   	ret    

00009036 <sys_gtty>:

int sys_gtty()
{
	return -ENOSYS;
    9036:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    903b:	c3                   	ret    

0000903c <sys_rename>:

int sys_rename()
{
	return -ENOSYS;
    903c:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9041:	c3                   	ret    

00009042 <sys_prof>:

int sys_prof()
{
	return -ENOSYS;
    9042:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9047:	c3                   	ret    

00009048 <sys_setregid>:

int sys_setregid(int rgid, int egid)
{
	if (rgid>0) {
    9048:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    904d:	7e 3f                	jle    908e <sys_setregid+0x46>
		if ((current->gid == rgid) || 
    904f:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9054:	0f b7 80 46 02 00 00 	movzwl 0x246(%eax),%eax
    905b:	0f b7 c0             	movzwl %ax,%eax
    905e:	3b 44 24 04          	cmp    0x4(%esp),%eax
    9062:	74 11                	je     9075 <sys_setregid+0x2d>
		    suser())
    9064:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9069:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
}

int sys_setregid(int rgid, int egid)
{
	if (rgid>0) {
		if ((current->gid == rgid) || 
    9070:	66 85 c0             	test   %ax,%ax
    9073:	75 12                	jne    9087 <sys_setregid+0x3f>
		    suser())
			current->gid = rgid;
    9075:	a1 40 f1 01 00       	mov    0x1f140,%eax
    907a:	8b 54 24 04          	mov    0x4(%esp),%edx
    907e:	66 89 90 46 02 00 00 	mov    %dx,0x246(%eax)
    9085:	eb 07                	jmp    908e <sys_setregid+0x46>
		else
			return(-EPERM);
    9087:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    908c:	eb 75                	jmp    9103 <sys_setregid+0xbb>
	}
	if (egid>0) {
    908e:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    9093:	7e 69                	jle    90fe <sys_setregid+0xb6>
		if ((current->gid == egid) ||
    9095:	a1 40 f1 01 00       	mov    0x1f140,%eax
    909a:	0f b7 80 46 02 00 00 	movzwl 0x246(%eax),%eax
    90a1:	0f b7 c0             	movzwl %ax,%eax
    90a4:	3b 44 24 08          	cmp    0x8(%esp),%eax
    90a8:	74 3b                	je     90e5 <sys_setregid+0x9d>
		    (current->egid == egid) ||
    90aa:	a1 40 f1 01 00       	mov    0x1f140,%eax
    90af:	0f b7 80 48 02 00 00 	movzwl 0x248(%eax),%eax
    90b6:	0f b7 c0             	movzwl %ax,%eax
			current->gid = rgid;
		else
			return(-EPERM);
	}
	if (egid>0) {
		if ((current->gid == egid) ||
    90b9:	3b 44 24 08          	cmp    0x8(%esp),%eax
    90bd:	74 26                	je     90e5 <sys_setregid+0x9d>
		    (current->egid == egid) ||
		    (current->sgid == egid) ||
    90bf:	a1 40 f1 01 00       	mov    0x1f140,%eax
    90c4:	0f b7 80 4a 02 00 00 	movzwl 0x24a(%eax),%eax
    90cb:	0f b7 c0             	movzwl %ax,%eax
		else
			return(-EPERM);
	}
	if (egid>0) {
		if ((current->gid == egid) ||
		    (current->egid == egid) ||
    90ce:	3b 44 24 08          	cmp    0x8(%esp),%eax
    90d2:	74 11                	je     90e5 <sys_setregid+0x9d>
		    (current->sgid == egid) ||
		    suser())
    90d4:	a1 40 f1 01 00       	mov    0x1f140,%eax
    90d9:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
			return(-EPERM);
	}
	if (egid>0) {
		if ((current->gid == egid) ||
		    (current->egid == egid) ||
		    (current->sgid == egid) ||
    90e0:	66 85 c0             	test   %ax,%ax
    90e3:	75 12                	jne    90f7 <sys_setregid+0xaf>
		    suser())
			current->egid = egid;
    90e5:	a1 40 f1 01 00       	mov    0x1f140,%eax
    90ea:	8b 54 24 08          	mov    0x8(%esp),%edx
    90ee:	66 89 90 48 02 00 00 	mov    %dx,0x248(%eax)
    90f5:	eb 07                	jmp    90fe <sys_setregid+0xb6>
		else
			return(-EPERM);
    90f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    90fc:	eb 05                	jmp    9103 <sys_setregid+0xbb>
	}
	return 0;
    90fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9103:	c3                   	ret    

00009104 <sys_setgid>:

int sys_setgid(int gid)
{
	return(sys_setregid(gid, gid));
    9104:	ff 74 24 04          	pushl  0x4(%esp)
    9108:	ff 74 24 08          	pushl  0x8(%esp)
    910c:	e8 37 ff ff ff       	call   9048 <sys_setregid>
    9111:	83 c4 08             	add    $0x8,%esp
}
    9114:	c3                   	ret    

00009115 <sys_acct>:

int sys_acct()
{
	return -ENOSYS;
    9115:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    911a:	c3                   	ret    

0000911b <sys_phys>:

int sys_phys()
{
	return -ENOSYS;
    911b:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9120:	c3                   	ret    

00009121 <sys_lock>:

int sys_lock()
{
	return -ENOSYS;
    9121:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9126:	c3                   	ret    

00009127 <sys_mpx>:

int sys_mpx()
{
	return -ENOSYS;
    9127:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    912c:	c3                   	ret    

0000912d <sys_ulimit>:

int sys_ulimit()
{
	return -ENOSYS;
    912d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    9132:	c3                   	ret    

00009133 <sys_time>:

int sys_time(long * tloc)
{
    9133:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	i = CURRENT_TIME;
    9136:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    913c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    9141:	89 c8                	mov    %ecx,%eax
    9143:	f7 ea                	imul   %edx
    9145:	c1 fa 05             	sar    $0x5,%edx
    9148:	89 c8                	mov    %ecx,%eax
    914a:	c1 f8 1f             	sar    $0x1f,%eax
    914d:	29 c2                	sub    %eax,%edx
    914f:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
    9154:	01 d0                	add    %edx,%eax
    9156:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (tloc) {
    915a:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    915f:	74 25                	je     9186 <sys_time+0x53>
		verify_area(tloc,4);
    9161:	83 ec 08             	sub    $0x8,%esp
    9164:	6a 04                	push   $0x4
    9166:	ff 74 24 2c          	pushl  0x2c(%esp)
    916a:	e8 35 ef ff ff       	call   80a4 <verify_area>
    916f:	83 c4 10             	add    $0x10,%esp
		put_fs_long(i,(unsigned long *)tloc);
    9172:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9176:	83 ec 08             	sub    $0x8,%esp
    9179:	ff 74 24 28          	pushl  0x28(%esp)
    917d:	50                   	push   %eax
    917e:	e8 8e fe ff ff       	call   9011 <put_fs_long>
    9183:	83 c4 10             	add    $0x10,%esp
	}
	return i;
    9186:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    918a:	83 c4 1c             	add    $0x1c,%esp
    918d:	c3                   	ret    

0000918e <sys_setreuid>:
/*
 * Unprivileged users may change the real user id to the effective uid
 * or vice versa.
 */
int sys_setreuid(int ruid, int euid)
{
    918e:	83 ec 10             	sub    $0x10,%esp
	int old_ruid = current->uid;
    9191:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9196:	0f b7 80 40 02 00 00 	movzwl 0x240(%eax),%eax
    919d:	0f b7 c0             	movzwl %ax,%eax
    91a0:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	if (ruid>0) {
    91a4:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    91a9:	7e 49                	jle    91f4 <sys_setreuid+0x66>
		if ((current->euid==ruid) ||
    91ab:	a1 40 f1 01 00       	mov    0x1f140,%eax
    91b0:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    91b7:	0f b7 c0             	movzwl %ax,%eax
    91ba:	3b 44 24 14          	cmp    0x14(%esp),%eax
    91be:	74 1b                	je     91db <sys_setreuid+0x4d>
    91c0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    91c4:	3b 44 24 14          	cmp    0x14(%esp),%eax
    91c8:	74 11                	je     91db <sys_setreuid+0x4d>
                    (old_ruid == ruid) ||
		    suser())
    91ca:	a1 40 f1 01 00       	mov    0x1f140,%eax
    91cf:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
{
	int old_ruid = current->uid;
	
	if (ruid>0) {
		if ((current->euid==ruid) ||
                    (old_ruid == ruid) ||
    91d6:	66 85 c0             	test   %ax,%ax
    91d9:	75 12                	jne    91ed <sys_setreuid+0x5f>
		    suser())
			current->uid = ruid;
    91db:	a1 40 f1 01 00       	mov    0x1f140,%eax
    91e0:	8b 54 24 14          	mov    0x14(%esp),%edx
    91e4:	66 89 90 40 02 00 00 	mov    %dx,0x240(%eax)
    91eb:	eb 07                	jmp    91f4 <sys_setreuid+0x66>
		else
			return(-EPERM);
    91ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    91f2:	eb 65                	jmp    9259 <sys_setreuid+0xcb>
	}
	if (euid>0) {
    91f4:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    91f9:	7e 59                	jle    9254 <sys_setreuid+0xc6>
		if ((old_ruid == euid) ||
    91fb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    91ff:	3b 44 24 18          	cmp    0x18(%esp),%eax
    9203:	74 26                	je     922b <sys_setreuid+0x9d>
                    (current->euid == euid) ||
    9205:	a1 40 f1 01 00       	mov    0x1f140,%eax
    920a:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    9211:	0f b7 c0             	movzwl %ax,%eax
			current->uid = ruid;
		else
			return(-EPERM);
	}
	if (euid>0) {
		if ((old_ruid == euid) ||
    9214:	3b 44 24 18          	cmp    0x18(%esp),%eax
    9218:	74 11                	je     922b <sys_setreuid+0x9d>
                    (current->euid == euid) ||
		    suser())
    921a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    921f:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
		else
			return(-EPERM);
	}
	if (euid>0) {
		if ((old_ruid == euid) ||
                    (current->euid == euid) ||
    9226:	66 85 c0             	test   %ax,%ax
    9229:	75 12                	jne    923d <sys_setreuid+0xaf>
		    suser())
			current->euid = euid;
    922b:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9230:	8b 54 24 18          	mov    0x18(%esp),%edx
    9234:	66 89 90 42 02 00 00 	mov    %dx,0x242(%eax)
    923b:	eb 17                	jmp    9254 <sys_setreuid+0xc6>
		else {
			current->uid = old_ruid;
    923d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9242:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9246:	66 89 90 40 02 00 00 	mov    %dx,0x240(%eax)
			return(-EPERM);
    924d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9252:	eb 05                	jmp    9259 <sys_setreuid+0xcb>
		}
	}
	return 0;
    9254:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9259:	83 c4 10             	add    $0x10,%esp
    925c:	c3                   	ret    

0000925d <sys_setuid>:

int sys_setuid(int uid)
{
	return(sys_setreuid(uid, uid));
    925d:	ff 74 24 04          	pushl  0x4(%esp)
    9261:	ff 74 24 08          	pushl  0x8(%esp)
    9265:	e8 24 ff ff ff       	call   918e <sys_setreuid>
    926a:	83 c4 08             	add    $0x8,%esp
}
    926d:	c3                   	ret    

0000926e <sys_stime>:

int sys_stime(long * tptr)
{
    926e:	53                   	push   %ebx
	if (!suser())
    926f:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9274:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    927b:	66 85 c0             	test   %ax,%ax
    927e:	74 07                	je     9287 <sys_stime+0x19>
		return -EPERM;
    9280:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9285:	eb 37                	jmp    92be <sys_stime+0x50>
	startup_time = get_fs_long((unsigned long *)tptr) - jiffies/HZ;
    9287:	ff 74 24 08          	pushl  0x8(%esp)
    928b:	e8 51 fd ff ff       	call   8fe1 <get_fs_long>
    9290:	83 c4 04             	add    $0x4,%esp
    9293:	89 c3                	mov    %eax,%ebx
    9295:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    929b:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    92a0:	89 c8                	mov    %ecx,%eax
    92a2:	f7 ea                	imul   %edx
    92a4:	c1 fa 05             	sar    $0x5,%edx
    92a7:	89 c8                	mov    %ecx,%eax
    92a9:	c1 f8 1f             	sar    $0x1f,%eax
    92ac:	29 c2                	sub    %eax,%edx
    92ae:	89 d0                	mov    %edx,%eax
    92b0:	29 c3                	sub    %eax,%ebx
    92b2:	89 d8                	mov    %ebx,%eax
    92b4:	a3 e4 1e 02 00       	mov    %eax,0x21ee4
	return 0;
    92b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    92be:	5b                   	pop    %ebx
    92bf:	c3                   	ret    

000092c0 <sys_times>:

int sys_times(struct tms * tbuf)
{
    92c0:	83 ec 0c             	sub    $0xc,%esp
	if (tbuf) {
    92c3:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    92c8:	0f 84 8b 00 00 00    	je     9359 <sys_times+0x99>
		verify_area(tbuf,sizeof *tbuf);
    92ce:	83 ec 08             	sub    $0x8,%esp
    92d1:	6a 10                	push   $0x10
    92d3:	ff 74 24 1c          	pushl  0x1c(%esp)
    92d7:	e8 c8 ed ff ff       	call   80a4 <verify_area>
    92dc:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->utime,(unsigned long *)&tbuf->tms_utime);
    92df:	8b 44 24 10          	mov    0x10(%esp),%eax
    92e3:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    92e9:	8b 92 50 02 00 00    	mov    0x250(%edx),%edx
    92ef:	83 ec 08             	sub    $0x8,%esp
    92f2:	50                   	push   %eax
    92f3:	52                   	push   %edx
    92f4:	e8 18 fd ff ff       	call   9011 <put_fs_long>
    92f9:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->stime,(unsigned long *)&tbuf->tms_stime);
    92fc:	8b 44 24 10          	mov    0x10(%esp),%eax
    9300:	8d 50 04             	lea    0x4(%eax),%edx
    9303:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9308:	8b 80 54 02 00 00    	mov    0x254(%eax),%eax
    930e:	83 ec 08             	sub    $0x8,%esp
    9311:	52                   	push   %edx
    9312:	50                   	push   %eax
    9313:	e8 f9 fc ff ff       	call   9011 <put_fs_long>
    9318:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->cutime,(unsigned long *)&tbuf->tms_cutime);
    931b:	8b 44 24 10          	mov    0x10(%esp),%eax
    931f:	8d 50 08             	lea    0x8(%eax),%edx
    9322:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9327:	8b 80 58 02 00 00    	mov    0x258(%eax),%eax
    932d:	83 ec 08             	sub    $0x8,%esp
    9330:	52                   	push   %edx
    9331:	50                   	push   %eax
    9332:	e8 da fc ff ff       	call   9011 <put_fs_long>
    9337:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->cstime,(unsigned long *)&tbuf->tms_cstime);
    933a:	8b 44 24 10          	mov    0x10(%esp),%eax
    933e:	8d 50 0c             	lea    0xc(%eax),%edx
    9341:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9346:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
    934c:	83 ec 08             	sub    $0x8,%esp
    934f:	52                   	push   %edx
    9350:	50                   	push   %eax
    9351:	e8 bb fc ff ff       	call   9011 <put_fs_long>
    9356:	83 c4 10             	add    $0x10,%esp
	}
	return jiffies;
    9359:	a1 e0 1e 02 00       	mov    0x21ee0,%eax
}
    935e:	83 c4 0c             	add    $0xc,%esp
    9361:	c3                   	ret    

00009362 <sys_brk>:

int sys_brk(unsigned long end_data_seg)
{
	if (end_data_seg >= current->end_code &&
    9362:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9367:	8b 80 1c 02 00 00    	mov    0x21c(%eax),%eax
    936d:	3b 44 24 04          	cmp    0x4(%esp),%eax
    9371:	77 25                	ja     9398 <sys_brk+0x36>
	    end_data_seg < current->start_stack - 16384)
    9373:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9378:	8b 80 28 02 00 00    	mov    0x228(%eax),%eax
    937e:	2d 00 40 00 00       	sub    $0x4000,%eax
	return jiffies;
}

int sys_brk(unsigned long end_data_seg)
{
	if (end_data_seg >= current->end_code &&
    9383:	3b 44 24 04          	cmp    0x4(%esp),%eax
    9387:	76 0f                	jbe    9398 <sys_brk+0x36>
	    end_data_seg < current->start_stack - 16384)
		current->brk = end_data_seg;
    9389:	a1 40 f1 01 00       	mov    0x1f140,%eax
    938e:	8b 54 24 04          	mov    0x4(%esp),%edx
    9392:	89 90 24 02 00 00    	mov    %edx,0x224(%eax)
	return current->brk;
    9398:	a1 40 f1 01 00       	mov    0x1f140,%eax
    939d:	8b 80 24 02 00 00    	mov    0x224(%eax),%eax
}
    93a3:	c3                   	ret    

000093a4 <sys_setpgid>:
 * This needs some heave checking ...
 * I just haven't get the stomach for it. I also don't fully
 * understand sessions/pgrp etc. Let somebody who does explain it.
 */
int sys_setpgid(int pid, int pgid)
{
    93a4:	83 ec 10             	sub    $0x10,%esp
	int i;

	if (!pid)
    93a7:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    93ac:	75 0f                	jne    93bd <sys_setpgid+0x19>
		pid = current->pid;
    93ae:	a1 40 f1 01 00       	mov    0x1f140,%eax
    93b3:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    93b9:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (!pgid)
    93bd:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    93c2:	75 0f                	jne    93d3 <sys_setpgid+0x2f>
		pgid = current->pid;
    93c4:	a1 40 f1 01 00       	mov    0x1f140,%eax
    93c9:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    93cf:	89 44 24 18          	mov    %eax,0x18(%esp)
	for (i=0 ; i<NR_TASKS ; i++)
    93d3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    93da:	00 
    93db:	e9 8a 00 00 00       	jmp    946a <sys_setpgid+0xc6>
		if (task[i] && task[i]->pid==pid) {
    93e0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    93e4:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    93eb:	85 c0                	test   %eax,%eax
    93ed:	74 76                	je     9465 <sys_setpgid+0xc1>
    93ef:	8b 44 24 0c          	mov    0xc(%esp),%eax
    93f3:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    93fa:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    9400:	3b 44 24 14          	cmp    0x14(%esp),%eax
    9404:	75 5f                	jne    9465 <sys_setpgid+0xc1>
			if (task[i]->leader)
    9406:	8b 44 24 0c          	mov    0xc(%esp),%eax
    940a:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    9411:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
    9417:	85 c0                	test   %eax,%eax
    9419:	74 07                	je     9422 <sys_setpgid+0x7e>
				return -EPERM;
    941b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9420:	eb 58                	jmp    947a <sys_setpgid+0xd6>
			if (task[i]->session != current->session)
    9422:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9426:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    942d:	8b 90 38 02 00 00    	mov    0x238(%eax),%edx
    9433:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9438:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
    943e:	39 c2                	cmp    %eax,%edx
    9440:	74 07                	je     9449 <sys_setpgid+0xa5>
				return -EPERM;
    9442:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9447:	eb 31                	jmp    947a <sys_setpgid+0xd6>
			task[i]->pgrp = pgid;
    9449:	8b 44 24 0c          	mov    0xc(%esp),%eax
    944d:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    9454:	8b 54 24 18          	mov    0x18(%esp),%edx
    9458:	89 90 34 02 00 00    	mov    %edx,0x234(%eax)
			return 0;
    945e:	b8 00 00 00 00       	mov    $0x0,%eax
    9463:	eb 15                	jmp    947a <sys_setpgid+0xd6>

	if (!pid)
		pid = current->pid;
	if (!pgid)
		pgid = current->pid;
	for (i=0 ; i<NR_TASKS ; i++)
    9465:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    946a:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    946f:	0f 8e 6b ff ff ff    	jle    93e0 <sys_setpgid+0x3c>
			if (task[i]->session != current->session)
				return -EPERM;
			task[i]->pgrp = pgid;
			return 0;
		}
	return -ESRCH;
    9475:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
    947a:	83 c4 10             	add    $0x10,%esp
    947d:	c3                   	ret    

0000947e <sys_getpgrp>:

int sys_getpgrp(void)
{
	return current->pgrp;
    947e:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9483:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
}
    9489:	c3                   	ret    

0000948a <sys_setsid>:

int sys_setsid(void)
{
	if (current->leader && !suser())
    948a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    948f:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
    9495:	85 c0                	test   %eax,%eax
    9497:	74 18                	je     94b1 <sys_setsid+0x27>
    9499:	a1 40 f1 01 00       	mov    0x1f140,%eax
    949e:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    94a5:	66 85 c0             	test   %ax,%ax
    94a8:	74 07                	je     94b1 <sys_setsid+0x27>
		return -EPERM;
    94aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    94af:	eb 52                	jmp    9503 <sys_setsid+0x79>
	current->leader = 1;
    94b1:	a1 40 f1 01 00       	mov    0x1f140,%eax
    94b6:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
    94bd:	00 00 00 
	current->session = current->pgrp = current->pid;
    94c0:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    94c6:	a1 40 f1 01 00       	mov    0x1f140,%eax
    94cb:	8b 0d 40 f1 01 00    	mov    0x1f140,%ecx
    94d1:	8b 89 2c 02 00 00    	mov    0x22c(%ecx),%ecx
    94d7:	89 88 34 02 00 00    	mov    %ecx,0x234(%eax)
    94dd:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    94e3:	89 82 38 02 00 00    	mov    %eax,0x238(%edx)
	current->tty = -1;
    94e9:	a1 40 f1 01 00       	mov    0x1f140,%eax
    94ee:	c7 80 68 02 00 00 ff 	movl   $0xffffffff,0x268(%eax)
    94f5:	ff ff ff 
	return current->pgrp;
    94f8:	a1 40 f1 01 00       	mov    0x1f140,%eax
    94fd:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
}
    9503:	c3                   	ret    

00009504 <sys_uname>:

int sys_uname(struct utsname * name)
{
    9504:	83 ec 1c             	sub    $0x1c,%esp
	static struct utsname thisname = {
		"linux .0","nodename","release ","version ","machine "
	};
	int i;

	if (!name) return -ERROR;
    9507:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    950c:	75 07                	jne    9515 <sys_uname+0x11>
    950e:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
    9513:	eb 54                	jmp    9569 <sys_uname+0x65>
	verify_area(name,sizeof *name);
    9515:	83 ec 08             	sub    $0x8,%esp
    9518:	6a 2d                	push   $0x2d
    951a:	ff 74 24 2c          	pushl  0x2c(%esp)
    951e:	e8 81 eb ff ff       	call   80a4 <verify_area>
    9523:	83 c4 10             	add    $0x10,%esp
	for(i=0;i<sizeof *name;i++)
    9526:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    952d:	00 
    952e:	eb 2b                	jmp    955b <sys_uname+0x57>
		put_fs_byte(((char *) &thisname)[i],i+(char *) name);
    9530:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9534:	8b 44 24 20          	mov    0x20(%esp),%eax
    9538:	01 c2                	add    %eax,%edx
    953a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    953e:	05 80 f2 01 00       	add    $0x1f280,%eax
    9543:	0f b6 00             	movzbl (%eax),%eax
    9546:	0f be c0             	movsbl %al,%eax
    9549:	83 ec 08             	sub    $0x8,%esp
    954c:	52                   	push   %edx
    954d:	50                   	push   %eax
    954e:	e8 a4 fa ff ff       	call   8ff7 <put_fs_byte>
    9553:	83 c4 10             	add    $0x10,%esp
	};
	int i;

	if (!name) return -ERROR;
	verify_area(name,sizeof *name);
	for(i=0;i<sizeof *name;i++)
    9556:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    955b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    955f:	83 f8 2c             	cmp    $0x2c,%eax
    9562:	76 cc                	jbe    9530 <sys_uname+0x2c>
		put_fs_byte(((char *) &thisname)[i],i+(char *) name);
	return 0;
    9564:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9569:	83 c4 1c             	add    $0x1c,%esp
    956c:	c3                   	ret    

0000956d <sys_umask>:

int sys_umask(int mask)
{
    956d:	83 ec 10             	sub    $0x10,%esp
	int old = current->umask;
    9570:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9575:	0f b7 80 6c 02 00 00 	movzwl 0x26c(%eax),%eax
    957c:	0f b7 c0             	movzwl %ax,%eax
    957f:	89 44 24 0c          	mov    %eax,0xc(%esp)

	current->umask = mask & 0777;
    9583:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9588:	8b 54 24 14          	mov    0x14(%esp),%edx
    958c:	66 81 e2 ff 01       	and    $0x1ff,%dx
    9591:	66 89 90 6c 02 00 00 	mov    %dx,0x26c(%eax)
	return (old);
    9598:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    959c:	83 c4 10             	add    $0x10,%esp
    959f:	c3                   	ret    

000095a0 <_get_base>:
        :"memory"); \
__base;})
**/

static inline unsigned long _get_base(char * addr)
{
    95a0:	53                   	push   %ebx
    95a1:	83 ec 10             	sub    $0x10,%esp
         __asm__("movb %3,%%dh\n\t"
                 "movb %2,%%dl\n\t"
                 "shll $16,%%edx\n\t"
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
    95a4:	8b 44 24 18          	mov    0x18(%esp),%eax
    95a8:	83 c0 02             	add    $0x2,%eax
                  "m" (*((addr)+4)),
    95ab:	8b 54 24 18          	mov    0x18(%esp),%edx
    95af:	8d 5a 04             	lea    0x4(%edx),%ebx
                  "m" (*((addr)+7)));
    95b2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    95b6:	83 c1 07             	add    $0x7,%ecx
**/

static inline unsigned long _get_base(char * addr)
{
         unsigned long __base;
         __asm__("movb %3,%%dh\n\t"
    95b9:	8a 31                	mov    (%ecx),%dh
    95bb:	8a 13                	mov    (%ebx),%dl
    95bd:	c1 e2 10             	shl    $0x10,%edx
    95c0:	66 8b 10             	mov    (%eax),%dx
    95c3:	89 d0                	mov    %edx,%eax
    95c5:	89 44 24 0c          	mov    %eax,0xc(%esp)
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
                  "m" (*((addr)+4)),
                  "m" (*((addr)+7)));
         return __base;
    95c9:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    95cd:	83 c4 10             	add    $0x10,%esp
    95d0:	5b                   	pop    %ebx
    95d1:	c3                   	ret    

000095d2 <put_fs_long>:
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    95d2:	8b 44 24 04          	mov    0x4(%esp),%eax
    95d6:	8b 54 24 08          	mov    0x8(%esp),%edx
    95da:	64 89 02             	mov    %eax,%fs:(%edx)
}
    95dd:	90                   	nop
    95de:	c3                   	ret    

000095df <release>:

int sys_pause(void);
int sys_close(int fd);

void release(struct task_struct * p)
{
    95df:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	if (!p)
    95e2:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    95e7:	74 5f                	je     9648 <release+0x69>
		return;
	for (i=1 ; i<NR_TASKS ; i++)
    95e9:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    95f0:	00 
    95f1:	eb 3c                	jmp    962f <release+0x50>
		if (task[i]==p) {
    95f3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    95f7:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    95fe:	3b 44 24 20          	cmp    0x20(%esp),%eax
    9602:	75 26                	jne    962a <release+0x4b>
			task[i]=NULL;
    9604:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9608:	c7 04 85 60 f1 01 00 	movl   $0x0,0x1f160(,%eax,4)
    960f:	00 00 00 00 
			free_page((long)p);
    9613:	8b 44 24 20          	mov    0x20(%esp),%eax
    9617:	83 ec 0c             	sub    $0xc,%esp
    961a:	50                   	push   %eax
    961b:	e8 9a 0d 00 00       	call   a3ba <free_page>
    9620:	83 c4 10             	add    $0x10,%esp
			schedule();
    9623:	e8 81 d6 ff ff       	call   6ca9 <schedule>
			return;
    9628:	eb 1f                	jmp    9649 <release+0x6a>
{
	int i;

	if (!p)
		return;
	for (i=1 ; i<NR_TASKS ; i++)
    962a:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    962f:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    9634:	7e bd                	jle    95f3 <release+0x14>
			task[i]=NULL;
			free_page((long)p);
			schedule();
			return;
		}
	panic("trying to release non-existent task");
    9636:	83 ec 0c             	sub    $0xc,%esp
    9639:	68 c4 84 01 00       	push   $0x184c4
    963e:	e8 8b f1 ff ff       	call   87ce <panic>
    9643:	83 c4 10             	add    $0x10,%esp
    9646:	eb 01                	jmp    9649 <release+0x6a>
void release(struct task_struct * p)
{
	int i;

	if (!p)
		return;
    9648:	90                   	nop
			free_page((long)p);
			schedule();
			return;
		}
	panic("trying to release non-existent task");
}
    9649:	83 c4 1c             	add    $0x1c,%esp
    964c:	c3                   	ret    

0000964d <send_sig>:

static inline int send_sig(long sig,struct task_struct * p,int priv)
{
    964d:	53                   	push   %ebx
	if (!p || sig<1 || sig>32)
    964e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    9653:	74 0e                	je     9663 <send_sig+0x16>
    9655:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    965a:	7e 07                	jle    9663 <send_sig+0x16>
    965c:	83 7c 24 08 20       	cmpl   $0x20,0x8(%esp)
    9661:	7e 07                	jle    966a <send_sig+0x1d>
		return -EINVAL;
    9663:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    9668:	eb 62                	jmp    96cc <send_sig+0x7f>
	if (priv || (current->euid==p->euid) || suser())
    966a:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    966f:	75 2d                	jne    969e <send_sig+0x51>
    9671:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9676:	0f b7 90 42 02 00 00 	movzwl 0x242(%eax),%edx
    967d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9681:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    9688:	66 39 c2             	cmp    %ax,%dx
    968b:	74 11                	je     969e <send_sig+0x51>
    968d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9692:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    9699:	66 85 c0             	test   %ax,%ax
    969c:	75 29                	jne    96c7 <send_sig+0x7a>
		p->signal |= (1<<(sig-1));
    969e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    96a2:	8b 40 0c             	mov    0xc(%eax),%eax
    96a5:	8b 54 24 08          	mov    0x8(%esp),%edx
    96a9:	83 ea 01             	sub    $0x1,%edx
    96ac:	bb 01 00 00 00       	mov    $0x1,%ebx
    96b1:	89 d1                	mov    %edx,%ecx
    96b3:	d3 e3                	shl    %cl,%ebx
    96b5:	89 da                	mov    %ebx,%edx
    96b7:	09 c2                	or     %eax,%edx
    96b9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    96bd:	89 50 0c             	mov    %edx,0xc(%eax)
	else
		return -EPERM;
	return 0;
    96c0:	b8 00 00 00 00       	mov    $0x0,%eax
    96c5:	eb 05                	jmp    96cc <send_sig+0x7f>
	if (!p || sig<1 || sig>32)
		return -EINVAL;
	if (priv || (current->euid==p->euid) || suser())
		p->signal |= (1<<(sig-1));
	else
		return -EPERM;
    96c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return 0;
}
    96cc:	5b                   	pop    %ebx
    96cd:	c3                   	ret    

000096ce <kill_session>:

static void kill_session(void)
{
    96ce:	83 ec 10             	sub    $0x10,%esp
	struct task_struct **p = NR_TASKS + task;
    96d1:	c7 44 24 0c 60 f2 01 	movl   $0x1f260,0xc(%esp)
    96d8:	00 
	
	while (--p > &FIRST_TASK) {
    96d9:	eb 3a                	jmp    9715 <kill_session+0x47>
		if (*p && (*p)->session == current->session)
    96db:	8b 44 24 0c          	mov    0xc(%esp),%eax
    96df:	8b 00                	mov    (%eax),%eax
    96e1:	85 c0                	test   %eax,%eax
    96e3:	74 30                	je     9715 <kill_session+0x47>
    96e5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    96e9:	8b 00                	mov    (%eax),%eax
    96eb:	8b 90 38 02 00 00    	mov    0x238(%eax),%edx
    96f1:	a1 40 f1 01 00       	mov    0x1f140,%eax
    96f6:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
    96fc:	39 c2                	cmp    %eax,%edx
    96fe:	75 15                	jne    9715 <kill_session+0x47>
			(*p)->signal |= 1<<(SIGHUP-1);
    9700:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9704:	8b 00                	mov    (%eax),%eax
    9706:	8b 54 24 0c          	mov    0xc(%esp),%edx
    970a:	8b 12                	mov    (%edx),%edx
    970c:	8b 52 0c             	mov    0xc(%edx),%edx
    970f:	83 ca 01             	or     $0x1,%edx
    9712:	89 50 0c             	mov    %edx,0xc(%eax)

static void kill_session(void)
{
	struct task_struct **p = NR_TASKS + task;
	
	while (--p > &FIRST_TASK) {
    9715:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    971a:	81 7c 24 0c 60 f1 01 	cmpl   $0x1f160,0xc(%esp)
    9721:	00 
    9722:	77 b7                	ja     96db <kill_session+0xd>
		if (*p && (*p)->session == current->session)
			(*p)->signal |= 1<<(SIGHUP-1);
	}
}
    9724:	90                   	nop
    9725:	83 c4 10             	add    $0x10,%esp
    9728:	c3                   	ret    

00009729 <sys_kill>:
/*
 * XXX need to check permissions needed to send signals to process
 * groups, etc. etc.  kill() permissions semantics are tricky!
 */
int sys_kill(int pid,int sig)
{
    9729:	83 ec 10             	sub    $0x10,%esp
	struct task_struct **p = NR_TASKS + task;
    972c:	c7 44 24 0c 60 f2 01 	movl   $0x1f260,0xc(%esp)
    9733:	00 
	int err, retval = 0;
    9734:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    973b:	00 

	if (!pid) while (--p > &FIRST_TASK) {
    973c:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    9741:	75 63                	jne    97a6 <sys_kill+0x7d>
    9743:	eb 4d                	jmp    9792 <sys_kill+0x69>
		if (*p && (*p)->pgrp == current->pid) 
    9745:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9749:	8b 00                	mov    (%eax),%eax
    974b:	85 c0                	test   %eax,%eax
    974d:	74 43                	je     9792 <sys_kill+0x69>
    974f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9753:	8b 00                	mov    (%eax),%eax
    9755:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
    975b:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9760:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    9766:	39 c2                	cmp    %eax,%edx
    9768:	75 28                	jne    9792 <sys_kill+0x69>
			if ((err=send_sig(sig,*p,1)))
    976a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    976e:	8b 00                	mov    (%eax),%eax
    9770:	6a 01                	push   $0x1
    9772:	50                   	push   %eax
    9773:	ff 74 24 20          	pushl  0x20(%esp)
    9777:	e8 d1 fe ff ff       	call   964d <send_sig>
    977c:	83 c4 0c             	add    $0xc,%esp
    977f:	89 44 24 04          	mov    %eax,0x4(%esp)
    9783:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    9788:	74 08                	je     9792 <sys_kill+0x69>
				retval = err;
    978a:	8b 44 24 04          	mov    0x4(%esp),%eax
    978e:	89 44 24 08          	mov    %eax,0x8(%esp)
int sys_kill(int pid,int sig)
{
	struct task_struct **p = NR_TASKS + task;
	int err, retval = 0;

	if (!pid) while (--p > &FIRST_TASK) {
    9792:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    9797:	81 7c 24 0c 60 f1 01 	cmpl   $0x1f160,0xc(%esp)
    979e:	00 
    979f:	77 a4                	ja     9745 <sys_kill+0x1c>
    97a1:	e9 fe 00 00 00       	jmp    98a4 <sys_kill+0x17b>
		if (*p && (*p)->pgrp == current->pid) 
			if ((err=send_sig(sig,*p,1)))
				retval = err;
	} else if (pid>0) while (--p > &FIRST_TASK) {
    97a6:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    97ab:	7e 5a                	jle    9807 <sys_kill+0xde>
    97ad:	eb 44                	jmp    97f3 <sys_kill+0xca>
		if (*p && (*p)->pid == pid) 
    97af:	8b 44 24 0c          	mov    0xc(%esp),%eax
    97b3:	8b 00                	mov    (%eax),%eax
    97b5:	85 c0                	test   %eax,%eax
    97b7:	74 3a                	je     97f3 <sys_kill+0xca>
    97b9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    97bd:	8b 00                	mov    (%eax),%eax
    97bf:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    97c5:	3b 44 24 14          	cmp    0x14(%esp),%eax
    97c9:	75 28                	jne    97f3 <sys_kill+0xca>
			if ((err=send_sig(sig,*p,0)))
    97cb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    97cf:	8b 00                	mov    (%eax),%eax
    97d1:	6a 00                	push   $0x0
    97d3:	50                   	push   %eax
    97d4:	ff 74 24 20          	pushl  0x20(%esp)
    97d8:	e8 70 fe ff ff       	call   964d <send_sig>
    97dd:	83 c4 0c             	add    $0xc,%esp
    97e0:	89 44 24 04          	mov    %eax,0x4(%esp)
    97e4:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    97e9:	74 08                	je     97f3 <sys_kill+0xca>
				retval = err;
    97eb:	8b 44 24 04          	mov    0x4(%esp),%eax
    97ef:	89 44 24 08          	mov    %eax,0x8(%esp)

	if (!pid) while (--p > &FIRST_TASK) {
		if (*p && (*p)->pgrp == current->pid) 
			if ((err=send_sig(sig,*p,1)))
				retval = err;
	} else if (pid>0) while (--p > &FIRST_TASK) {
    97f3:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    97f8:	81 7c 24 0c 60 f1 01 	cmpl   $0x1f160,0xc(%esp)
    97ff:	00 
    9800:	77 ad                	ja     97af <sys_kill+0x86>
    9802:	e9 9d 00 00 00       	jmp    98a4 <sys_kill+0x17b>
		if (*p && (*p)->pid == pid) 
			if ((err=send_sig(sig,*p,0)))
				retval = err;
	} else if (pid == -1) while (--p > &FIRST_TASK) {
    9807:	83 7c 24 14 ff       	cmpl   $0xffffffff,0x14(%esp)
    980c:	0f 85 83 00 00 00    	jne    9895 <sys_kill+0x16c>
    9812:	eb 28                	jmp    983c <sys_kill+0x113>
		if ((err = send_sig(sig,*p,0)))
    9814:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9818:	8b 00                	mov    (%eax),%eax
    981a:	6a 00                	push   $0x0
    981c:	50                   	push   %eax
    981d:	ff 74 24 20          	pushl  0x20(%esp)
    9821:	e8 27 fe ff ff       	call   964d <send_sig>
    9826:	83 c4 0c             	add    $0xc,%esp
    9829:	89 44 24 04          	mov    %eax,0x4(%esp)
    982d:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    9832:	74 08                	je     983c <sys_kill+0x113>
			retval = err;
    9834:	8b 44 24 04          	mov    0x4(%esp),%eax
    9838:	89 44 24 08          	mov    %eax,0x8(%esp)
				retval = err;
	} else if (pid>0) while (--p > &FIRST_TASK) {
		if (*p && (*p)->pid == pid) 
			if ((err=send_sig(sig,*p,0)))
				retval = err;
	} else if (pid == -1) while (--p > &FIRST_TASK) {
    983c:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    9841:	81 7c 24 0c 60 f1 01 	cmpl   $0x1f160,0xc(%esp)
    9848:	00 
    9849:	77 c9                	ja     9814 <sys_kill+0xeb>
    984b:	eb 57                	jmp    98a4 <sys_kill+0x17b>
		if ((err = send_sig(sig,*p,0)))
			retval = err;
	} else while (--p > &FIRST_TASK)
		if (*p && (*p)->pgrp == -pid)
    984d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9851:	8b 00                	mov    (%eax),%eax
    9853:	85 c0                	test   %eax,%eax
    9855:	74 3e                	je     9895 <sys_kill+0x16c>
    9857:	8b 44 24 0c          	mov    0xc(%esp),%eax
    985b:	8b 00                	mov    (%eax),%eax
    985d:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    9863:	8b 54 24 14          	mov    0x14(%esp),%edx
    9867:	f7 da                	neg    %edx
    9869:	39 d0                	cmp    %edx,%eax
    986b:	75 28                	jne    9895 <sys_kill+0x16c>
			if ((err = send_sig(sig,*p,0)))
    986d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9871:	8b 00                	mov    (%eax),%eax
    9873:	6a 00                	push   $0x0
    9875:	50                   	push   %eax
    9876:	ff 74 24 20          	pushl  0x20(%esp)
    987a:	e8 ce fd ff ff       	call   964d <send_sig>
    987f:	83 c4 0c             	add    $0xc,%esp
    9882:	89 44 24 04          	mov    %eax,0x4(%esp)
    9886:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    988b:	74 08                	je     9895 <sys_kill+0x16c>
				retval = err;
    988d:	8b 44 24 04          	mov    0x4(%esp),%eax
    9891:	89 44 24 08          	mov    %eax,0x8(%esp)
			if ((err=send_sig(sig,*p,0)))
				retval = err;
	} else if (pid == -1) while (--p > &FIRST_TASK) {
		if ((err = send_sig(sig,*p,0)))
			retval = err;
	} else while (--p > &FIRST_TASK)
    9895:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    989a:	81 7c 24 0c 60 f1 01 	cmpl   $0x1f160,0xc(%esp)
    98a1:	00 
    98a2:	77 a9                	ja     984d <sys_kill+0x124>
		if (*p && (*p)->pgrp == -pid)
			if ((err = send_sig(sig,*p,0)))
				retval = err;
	return retval;
    98a4:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    98a8:	83 c4 10             	add    $0x10,%esp
    98ab:	c3                   	ret    

000098ac <tell_father>:

static void tell_father(int pid)
{
    98ac:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	if (pid)
    98af:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    98b4:	74 64                	je     991a <tell_father+0x6e>
		for (i=0;i<NR_TASKS;i++) {
    98b6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    98bd:	00 
    98be:	eb 53                	jmp    9913 <tell_father+0x67>
			if (!task[i])
    98c0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    98c4:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    98cb:	85 c0                	test   %eax,%eax
    98cd:	74 3b                	je     990a <tell_father+0x5e>
				continue;
			if (task[i]->pid != pid)
    98cf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    98d3:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    98da:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    98e0:	3b 44 24 20          	cmp    0x20(%esp),%eax
    98e4:	75 27                	jne    990d <tell_father+0x61>
				continue;
			task[i]->signal |= (1<<(SIGCHLD-1));
    98e6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    98ea:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    98f1:	8b 54 24 0c          	mov    0xc(%esp),%edx
    98f5:	8b 14 95 60 f1 01 00 	mov    0x1f160(,%edx,4),%edx
    98fc:	8b 52 0c             	mov    0xc(%edx),%edx
    98ff:	81 ca 00 00 01 00    	or     $0x10000,%edx
    9905:	89 50 0c             	mov    %edx,0xc(%eax)
			return;
    9908:	eb 31                	jmp    993b <tell_father+0x8f>
	int i;

	if (pid)
		for (i=0;i<NR_TASKS;i++) {
			if (!task[i])
				continue;
    990a:	90                   	nop
    990b:	eb 01                	jmp    990e <tell_father+0x62>
			if (task[i]->pid != pid)
				continue;
    990d:	90                   	nop
static void tell_father(int pid)
{
	int i;

	if (pid)
		for (i=0;i<NR_TASKS;i++) {
    990e:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    9913:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    9918:	7e a6                	jle    98c0 <tell_father+0x14>
			task[i]->signal |= (1<<(SIGCHLD-1));
			return;
		}
/* if we don't find any fathers, we just release ourselves */
/* This is not really OK. Must change it to make father 1 */
	printk("BAD BAD - no father found\n\r");
    991a:	83 ec 0c             	sub    $0xc,%esp
    991d:	68 e8 84 01 00       	push   $0x184e8
    9922:	e8 e6 ee ff ff       	call   880d <printk>
    9927:	83 c4 10             	add    $0x10,%esp
	release(current);
    992a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    992f:	83 ec 0c             	sub    $0xc,%esp
    9932:	50                   	push   %eax
    9933:	e8 a7 fc ff ff       	call   95df <release>
    9938:	83 c4 10             	add    $0x10,%esp
}
    993b:	83 c4 1c             	add    $0x1c,%esp
    993e:	c3                   	ret    

0000993f <do_exit>:

int do_exit(long code)
{
    993f:	53                   	push   %ebx
    9940:	83 ec 18             	sub    $0x18,%esp
	int i;
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
    9943:	b8 0f 00 00 00       	mov    $0xf,%eax
    9948:	0f 03 c0             	lsl    %ax,%eax
    994b:	40                   	inc    %eax
    994c:	89 44 24 08          	mov    %eax,0x8(%esp)
    9950:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    9954:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9959:	05 d8 02 00 00       	add    $0x2d8,%eax
    995e:	50                   	push   %eax
    995f:	e8 3c fc ff ff       	call   95a0 <_get_base>
    9964:	83 c4 04             	add    $0x4,%esp
    9967:	83 ec 08             	sub    $0x8,%esp
    996a:	53                   	push   %ebx
    996b:	50                   	push   %eax
    996c:	e8 c3 0a 00 00       	call   a434 <free_page_tables>
    9971:	83 c4 10             	add    $0x10,%esp
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
    9974:	b8 17 00 00 00       	mov    $0x17,%eax
    9979:	0f 03 c0             	lsl    %ax,%eax
    997c:	40                   	inc    %eax
    997d:	89 44 24 04          	mov    %eax,0x4(%esp)
    9981:	8b 5c 24 04          	mov    0x4(%esp),%ebx
    9985:	a1 40 f1 01 00       	mov    0x1f140,%eax
    998a:	05 e0 02 00 00       	add    $0x2e0,%eax
    998f:	83 ec 0c             	sub    $0xc,%esp
    9992:	50                   	push   %eax
    9993:	e8 08 fc ff ff       	call   95a0 <_get_base>
    9998:	83 c4 10             	add    $0x10,%esp
    999b:	83 ec 08             	sub    $0x8,%esp
    999e:	53                   	push   %ebx
    999f:	50                   	push   %eax
    99a0:	e8 8f 0a 00 00       	call   a434 <free_page_tables>
    99a5:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<NR_TASKS ; i++)
    99a8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    99af:	00 
    99b0:	eb 70                	jmp    9a22 <do_exit+0xe3>
		if (task[i] && task[i]->father == current->pid) {
    99b2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    99b6:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    99bd:	85 c0                	test   %eax,%eax
    99bf:	74 5c                	je     9a1d <do_exit+0xde>
    99c1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    99c5:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    99cc:	8b 90 30 02 00 00    	mov    0x230(%eax),%edx
    99d2:	a1 40 f1 01 00       	mov    0x1f140,%eax
    99d7:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    99dd:	39 c2                	cmp    %eax,%edx
    99df:	75 3c                	jne    9a1d <do_exit+0xde>
			task[i]->father = 1;
    99e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    99e5:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    99ec:	c7 80 30 02 00 00 01 	movl   $0x1,0x230(%eax)
    99f3:	00 00 00 
			if (task[i]->state == TASK_ZOMBIE)
    99f6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    99fa:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    9a01:	8b 00                	mov    (%eax),%eax
    9a03:	83 f8 03             	cmp    $0x3,%eax
    9a06:	75 15                	jne    9a1d <do_exit+0xde>
				/* assumption task[1] is always init */
				(void) send_sig(SIGCHLD, task[1], 1);
    9a08:	a1 64 f1 01 00       	mov    0x1f164,%eax
    9a0d:	83 ec 04             	sub    $0x4,%esp
    9a10:	6a 01                	push   $0x1
    9a12:	50                   	push   %eax
    9a13:	6a 11                	push   $0x11
    9a15:	e8 33 fc ff ff       	call   964d <send_sig>
    9a1a:	83 c4 10             	add    $0x10,%esp
int do_exit(long code)
{
	int i;
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
	for (i=0 ; i<NR_TASKS ; i++)
    9a1d:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    9a22:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    9a27:	7e 89                	jle    99b2 <do_exit+0x73>
			task[i]->father = 1;
			if (task[i]->state == TASK_ZOMBIE)
				/* assumption task[1] is always init */
				(void) send_sig(SIGCHLD, task[1], 1);
		}
	for (i=0 ; i<NR_OPEN ; i++)
    9a29:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    9a30:	00 
    9a31:	eb 2a                	jmp    9a5d <do_exit+0x11e>
		if (current->filp[i])
    9a33:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9a38:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9a3c:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    9a42:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9a45:	85 c0                	test   %eax,%eax
    9a47:	74 0f                	je     9a58 <do_exit+0x119>
			sys_close(i);
    9a49:	83 ec 0c             	sub    $0xc,%esp
    9a4c:	ff 74 24 18          	pushl  0x18(%esp)
    9a50:	e8 f8 1a 00 00       	call   b54d <sys_close>
    9a55:	83 c4 10             	add    $0x10,%esp
			task[i]->father = 1;
			if (task[i]->state == TASK_ZOMBIE)
				/* assumption task[1] is always init */
				(void) send_sig(SIGCHLD, task[1], 1);
		}
	for (i=0 ; i<NR_OPEN ; i++)
    9a58:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    9a5d:	83 7c 24 0c 13       	cmpl   $0x13,0xc(%esp)
    9a62:	7e cf                	jle    9a33 <do_exit+0xf4>
		if (current->filp[i])
			sys_close(i);
	iput(current->pwd);
    9a64:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9a69:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
    9a6f:	83 ec 0c             	sub    $0xc,%esp
    9a72:	50                   	push   %eax
    9a73:	e8 f9 25 00 00       	call   c071 <iput>
    9a78:	83 c4 10             	add    $0x10,%esp
	current->pwd=NULL;
    9a7b:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9a80:	c7 80 70 02 00 00 00 	movl   $0x0,0x270(%eax)
    9a87:	00 00 00 
	iput(current->root);
    9a8a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9a8f:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
    9a95:	83 ec 0c             	sub    $0xc,%esp
    9a98:	50                   	push   %eax
    9a99:	e8 d3 25 00 00       	call   c071 <iput>
    9a9e:	83 c4 10             	add    $0x10,%esp
	current->root=NULL;
    9aa1:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9aa6:	c7 80 74 02 00 00 00 	movl   $0x0,0x274(%eax)
    9aad:	00 00 00 
	iput(current->executable);
    9ab0:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9ab5:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    9abb:	83 ec 0c             	sub    $0xc,%esp
    9abe:	50                   	push   %eax
    9abf:	e8 ad 25 00 00       	call   c071 <iput>
    9ac4:	83 c4 10             	add    $0x10,%esp
	current->executable=NULL;
    9ac7:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9acc:	c7 80 78 02 00 00 00 	movl   $0x0,0x278(%eax)
    9ad3:	00 00 00 
	if (current->leader && current->tty >= 0)
    9ad6:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9adb:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
    9ae1:	85 c0                	test   %eax,%eax
    9ae3:	74 2b                	je     9b10 <do_exit+0x1d1>
    9ae5:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9aea:	8b 80 68 02 00 00    	mov    0x268(%eax),%eax
    9af0:	85 c0                	test   %eax,%eax
    9af2:	78 1c                	js     9b10 <do_exit+0x1d1>
		tty_table[current->tty].pgrp = 0;
    9af4:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9af9:	8b 80 68 02 00 00    	mov    0x268(%eax),%eax
    9aff:	69 c0 60 0c 00 00    	imul   $0xc60,%eax,%eax
    9b05:	05 64 f4 01 00       	add    $0x1f464,%eax
    9b0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	if (last_task_used_math == current)
    9b10:	8b 15 e8 1e 02 00    	mov    0x21ee8,%edx
    9b16:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9b1b:	39 c2                	cmp    %eax,%edx
    9b1d:	75 0a                	jne    9b29 <do_exit+0x1ea>
		last_task_used_math = NULL;
    9b1f:	c7 05 e8 1e 02 00 00 	movl   $0x0,0x21ee8
    9b26:	00 00 00 
	if (current->leader)
    9b29:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9b2e:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
    9b34:	85 c0                	test   %eax,%eax
    9b36:	74 05                	je     9b3d <do_exit+0x1fe>
		kill_session();
    9b38:	e8 91 fb ff ff       	call   96ce <kill_session>
	current->state = TASK_ZOMBIE;
    9b3d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9b42:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	current->exit_code = code;
    9b48:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9b4d:	8b 54 24 20          	mov    0x20(%esp),%edx
    9b51:	89 90 14 02 00 00    	mov    %edx,0x214(%eax)
	tell_father(current->father);
    9b57:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9b5c:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
    9b62:	83 ec 0c             	sub    $0xc,%esp
    9b65:	50                   	push   %eax
    9b66:	e8 41 fd ff ff       	call   98ac <tell_father>
    9b6b:	83 c4 10             	add    $0x10,%esp
	schedule();
    9b6e:	e8 36 d1 ff ff       	call   6ca9 <schedule>
	return (-1);	/* just to suppress warnings */
    9b73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    9b78:	83 c4 18             	add    $0x18,%esp
    9b7b:	5b                   	pop    %ebx
    9b7c:	c3                   	ret    

00009b7d <sys_exit>:

int sys_exit(int error_code)
{
    9b7d:	83 ec 0c             	sub    $0xc,%esp
	return do_exit((error_code&0xff)<<8);
    9b80:	8b 44 24 10          	mov    0x10(%esp),%eax
    9b84:	c1 e0 08             	shl    $0x8,%eax
    9b87:	0f b7 c0             	movzwl %ax,%eax
    9b8a:	83 ec 0c             	sub    $0xc,%esp
    9b8d:	50                   	push   %eax
    9b8e:	e8 ac fd ff ff       	call   993f <do_exit>
    9b93:	83 c4 10             	add    $0x10,%esp
}
    9b96:	83 c4 0c             	add    $0xc,%esp
    9b99:	c3                   	ret    

00009b9a <sys_waitpid>:

int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)
{
    9b9a:	83 ec 1c             	sub    $0x1c,%esp
	int flag, code;
	struct task_struct ** p;

	verify_area(stat_addr,4);
    9b9d:	83 ec 08             	sub    $0x8,%esp
    9ba0:	6a 04                	push   $0x4
    9ba2:	ff 74 24 30          	pushl  0x30(%esp)
    9ba6:	e8 f9 e4 ff ff       	call   80a4 <verify_area>
    9bab:	83 c4 10             	add    $0x10,%esp
repeat:
	flag=0;
    9bae:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    9bb5:	00 
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    9bb6:	c7 44 24 08 5c f2 01 	movl   $0x1f25c,0x8(%esp)
    9bbd:	00 
    9bbe:	e9 9c 01 00 00       	jmp    9d5f <sys_waitpid+0x1c5>
		if (!*p || *p == current)
    9bc3:	8b 44 24 08          	mov    0x8(%esp),%eax
    9bc7:	8b 00                	mov    (%eax),%eax
    9bc9:	85 c0                	test   %eax,%eax
    9bcb:	0f 84 7f 01 00 00    	je     9d50 <sys_waitpid+0x1b6>
    9bd1:	8b 44 24 08          	mov    0x8(%esp),%eax
    9bd5:	8b 10                	mov    (%eax),%edx
    9bd7:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9bdc:	39 c2                	cmp    %eax,%edx
    9bde:	0f 84 6c 01 00 00    	je     9d50 <sys_waitpid+0x1b6>
			continue;
		if ((*p)->father != current->pid)
    9be4:	8b 44 24 08          	mov    0x8(%esp),%eax
    9be8:	8b 00                	mov    (%eax),%eax
    9bea:	8b 90 30 02 00 00    	mov    0x230(%eax),%edx
    9bf0:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9bf5:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    9bfb:	39 c2                	cmp    %eax,%edx
    9bfd:	0f 85 50 01 00 00    	jne    9d53 <sys_waitpid+0x1b9>
			continue;
		if (pid>0) {
    9c03:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    9c08:	7e 17                	jle    9c21 <sys_waitpid+0x87>
			if ((*p)->pid != pid)
    9c0a:	8b 44 24 08          	mov    0x8(%esp),%eax
    9c0e:	8b 00                	mov    (%eax),%eax
    9c10:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    9c16:	3b 44 24 20          	cmp    0x20(%esp),%eax
    9c1a:	74 4d                	je     9c69 <sys_waitpid+0xcf>
				continue;
    9c1c:	e9 39 01 00 00       	jmp    9d5a <sys_waitpid+0x1c0>
		} else if (!pid) {
    9c21:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    9c26:	75 20                	jne    9c48 <sys_waitpid+0xae>
			if ((*p)->pgrp != current->pgrp)
    9c28:	8b 44 24 08          	mov    0x8(%esp),%eax
    9c2c:	8b 00                	mov    (%eax),%eax
    9c2e:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
    9c34:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9c39:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    9c3f:	39 c2                	cmp    %eax,%edx
    9c41:	74 26                	je     9c69 <sys_waitpid+0xcf>
				continue;
    9c43:	e9 12 01 00 00       	jmp    9d5a <sys_waitpid+0x1c0>
		} else if (pid != -1) {
    9c48:	83 7c 24 20 ff       	cmpl   $0xffffffff,0x20(%esp)
    9c4d:	74 1a                	je     9c69 <sys_waitpid+0xcf>
			if ((*p)->pgrp != -pid)
    9c4f:	8b 44 24 08          	mov    0x8(%esp),%eax
    9c53:	8b 00                	mov    (%eax),%eax
    9c55:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    9c5b:	8b 54 24 20          	mov    0x20(%esp),%edx
    9c5f:	f7 da                	neg    %edx
    9c61:	39 d0                	cmp    %edx,%eax
    9c63:	0f 85 ed 00 00 00    	jne    9d56 <sys_waitpid+0x1bc>
				continue;
		}
		switch ((*p)->state) {
    9c69:	8b 44 24 08          	mov    0x8(%esp),%eax
    9c6d:	8b 00                	mov    (%eax),%eax
    9c6f:	8b 00                	mov    (%eax),%eax
    9c71:	83 f8 03             	cmp    $0x3,%eax
    9c74:	74 3a                	je     9cb0 <sys_waitpid+0x116>
    9c76:	83 f8 04             	cmp    $0x4,%eax
    9c79:	0f 85 c7 00 00 00    	jne    9d46 <sys_waitpid+0x1ac>
			case TASK_STOPPED:
				if (!(options & WUNTRACED))
    9c7f:	8b 44 24 28          	mov    0x28(%esp),%eax
    9c83:	83 e0 02             	and    $0x2,%eax
    9c86:	85 c0                	test   %eax,%eax
    9c88:	0f 84 cb 00 00 00    	je     9d59 <sys_waitpid+0x1bf>
					continue;
				put_fs_long(0x7f,stat_addr);
    9c8e:	83 ec 08             	sub    $0x8,%esp
    9c91:	ff 74 24 2c          	pushl  0x2c(%esp)
    9c95:	6a 7f                	push   $0x7f
    9c97:	e8 36 f9 ff ff       	call   95d2 <put_fs_long>
    9c9c:	83 c4 10             	add    $0x10,%esp
				return (*p)->pid;
    9c9f:	8b 44 24 08          	mov    0x8(%esp),%eax
    9ca3:	8b 00                	mov    (%eax),%eax
    9ca5:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    9cab:	e9 15 01 00 00       	jmp    9dc5 <sys_waitpid+0x22b>
			case TASK_ZOMBIE:
				current->cutime += (*p)->utime;
    9cb0:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9cb5:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    9cbb:	8b 8a 58 02 00 00    	mov    0x258(%edx),%ecx
    9cc1:	8b 54 24 08          	mov    0x8(%esp),%edx
    9cc5:	8b 12                	mov    (%edx),%edx
    9cc7:	8b 92 50 02 00 00    	mov    0x250(%edx),%edx
    9ccd:	01 ca                	add    %ecx,%edx
    9ccf:	89 90 58 02 00 00    	mov    %edx,0x258(%eax)
				current->cstime += (*p)->stime;
    9cd5:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9cda:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    9ce0:	8b 8a 5c 02 00 00    	mov    0x25c(%edx),%ecx
    9ce6:	8b 54 24 08          	mov    0x8(%esp),%edx
    9cea:	8b 12                	mov    (%edx),%edx
    9cec:	8b 92 54 02 00 00    	mov    0x254(%edx),%edx
    9cf2:	01 ca                	add    %ecx,%edx
    9cf4:	89 90 5c 02 00 00    	mov    %edx,0x25c(%eax)
				flag = (*p)->pid;
    9cfa:	8b 44 24 08          	mov    0x8(%esp),%eax
    9cfe:	8b 00                	mov    (%eax),%eax
    9d00:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    9d06:	89 44 24 0c          	mov    %eax,0xc(%esp)
				code = (*p)->exit_code;
    9d0a:	8b 44 24 08          	mov    0x8(%esp),%eax
    9d0e:	8b 00                	mov    (%eax),%eax
    9d10:	8b 80 14 02 00 00    	mov    0x214(%eax),%eax
    9d16:	89 44 24 04          	mov    %eax,0x4(%esp)
				release(*p);
    9d1a:	8b 44 24 08          	mov    0x8(%esp),%eax
    9d1e:	8b 00                	mov    (%eax),%eax
    9d20:	83 ec 0c             	sub    $0xc,%esp
    9d23:	50                   	push   %eax
    9d24:	e8 b6 f8 ff ff       	call   95df <release>
    9d29:	83 c4 10             	add    $0x10,%esp
				put_fs_long(code,stat_addr);
    9d2c:	8b 44 24 04          	mov    0x4(%esp),%eax
    9d30:	83 ec 08             	sub    $0x8,%esp
    9d33:	ff 74 24 2c          	pushl  0x2c(%esp)
    9d37:	50                   	push   %eax
    9d38:	e8 95 f8 ff ff       	call   95d2 <put_fs_long>
    9d3d:	83 c4 10             	add    $0x10,%esp
				return flag;
    9d40:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9d44:	eb 7f                	jmp    9dc5 <sys_waitpid+0x22b>
			default:
				flag=1;
    9d46:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    9d4d:	00 
				continue;
    9d4e:	eb 0a                	jmp    9d5a <sys_waitpid+0x1c0>
	verify_area(stat_addr,4);
repeat:
	flag=0;
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
		if (!*p || *p == current)
			continue;
    9d50:	90                   	nop
    9d51:	eb 07                	jmp    9d5a <sys_waitpid+0x1c0>
		if ((*p)->father != current->pid)
			continue;
    9d53:	90                   	nop
    9d54:	eb 04                	jmp    9d5a <sys_waitpid+0x1c0>
		} else if (!pid) {
			if ((*p)->pgrp != current->pgrp)
				continue;
		} else if (pid != -1) {
			if ((*p)->pgrp != -pid)
				continue;
    9d56:	90                   	nop
    9d57:	eb 01                	jmp    9d5a <sys_waitpid+0x1c0>
		}
		switch ((*p)->state) {
			case TASK_STOPPED:
				if (!(options & WUNTRACED))
					continue;
    9d59:	90                   	nop
	struct task_struct ** p;

	verify_area(stat_addr,4);
repeat:
	flag=0;
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    9d5a:	83 6c 24 08 04       	subl   $0x4,0x8(%esp)
    9d5f:	81 7c 24 08 60 f1 01 	cmpl   $0x1f160,0x8(%esp)
    9d66:	00 
    9d67:	0f 87 56 fe ff ff    	ja     9bc3 <sys_waitpid+0x29>
			default:
				flag=1;
				continue;
		}
	}
	if (flag) {
    9d6d:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    9d72:	74 4c                	je     9dc0 <sys_waitpid+0x226>
		if (options & WNOHANG)
    9d74:	8b 44 24 28          	mov    0x28(%esp),%eax
    9d78:	83 e0 01             	and    $0x1,%eax
    9d7b:	85 c0                	test   %eax,%eax
    9d7d:	74 07                	je     9d86 <sys_waitpid+0x1ec>
			return 0;
    9d7f:	b8 00 00 00 00       	mov    $0x0,%eax
    9d84:	eb 3f                	jmp    9dc5 <sys_waitpid+0x22b>
		current->state=TASK_INTERRUPTIBLE;
    9d86:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9d8b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		schedule();
    9d91:	e8 13 cf ff ff       	call   6ca9 <schedule>
		if (!(current->signal &= ~(1<<(SIGCHLD-1))))
    9d96:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9d9b:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    9da1:	8b 52 0c             	mov    0xc(%edx),%edx
    9da4:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
    9daa:	89 50 0c             	mov    %edx,0xc(%eax)
    9dad:	8b 40 0c             	mov    0xc(%eax),%eax
    9db0:	85 c0                	test   %eax,%eax
    9db2:	75 05                	jne    9db9 <sys_waitpid+0x21f>
			goto repeat;
    9db4:	e9 f5 fd ff ff       	jmp    9bae <sys_waitpid+0x14>
		else
			return -EINTR;
    9db9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9dbe:	eb 05                	jmp    9dc5 <sys_waitpid+0x22b>
	}
	return -ECHILD;
    9dc0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
    9dc5:	83 c4 1c             	add    $0x1c,%esp
    9dc8:	c3                   	ret    

00009dc9 <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
    9dc9:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    9dca:	8b 44 24 08          	mov    0x8(%esp),%eax
    9dce:	64 8a 00             	mov    %fs:(%eax),%al
    9dd1:	89 c3                	mov    %eax,%ebx
	return _v;
    9dd3:	89 d8                	mov    %ebx,%eax
}
    9dd5:	5b                   	pop    %ebx
    9dd6:	c3                   	ret    

00009dd7 <put_fs_byte>:
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
	return _v;
}

static inline void put_fs_byte(char val,char *addr)
{
    9dd7:	83 ec 04             	sub    $0x4,%esp
    9dda:	8b 44 24 08          	mov    0x8(%esp),%eax
    9dde:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    9de1:	0f b6 04 24          	movzbl (%esp),%eax
    9de5:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9de9:	64 88 02             	mov    %al,%fs:(%edx)
}
    9dec:	90                   	nop
    9ded:	83 c4 04             	add    $0x4,%esp
    9df0:	c3                   	ret    

00009df1 <put_fs_long>:
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    9df1:	8b 44 24 04          	mov    0x4(%esp),%eax
    9df5:	8b 54 24 08          	mov    0x8(%esp),%edx
    9df9:	64 89 02             	mov    %eax,%fs:(%edx)
}
    9dfc:	90                   	nop
    9dfd:	c3                   	ret    

00009dfe <sys_sgetmask>:

void do_exit(int error_code);

int sys_sgetmask()
{
	return current->blocked;
    9dfe:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9e03:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
}
    9e09:	c3                   	ret    

00009e0a <sys_ssetmask>:

int sys_ssetmask(int newmask)
{
    9e0a:	83 ec 10             	sub    $0x10,%esp
	int old=current->blocked;
    9e0d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9e12:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
    9e18:	89 44 24 0c          	mov    %eax,0xc(%esp)

	current->blocked = newmask & ~(1<<(SIGKILL-1));
    9e1c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9e21:	8b 54 24 14          	mov    0x14(%esp),%edx
    9e25:	80 e6 fe             	and    $0xfe,%dh
    9e28:	89 90 10 02 00 00    	mov    %edx,0x210(%eax)
	return old;
    9e2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    9e32:	83 c4 10             	add    $0x10,%esp
    9e35:	c3                   	ret    

00009e36 <save_old>:

static inline void save_old(char * from,char * to)
{
    9e36:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	verify_area(to, sizeof(struct sigaction));
    9e39:	83 ec 08             	sub    $0x8,%esp
    9e3c:	6a 10                	push   $0x10
    9e3e:	ff 74 24 30          	pushl  0x30(%esp)
    9e42:	e8 5d e2 ff ff       	call   80a4 <verify_area>
    9e47:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i< sizeof(struct sigaction) ; i++) {
    9e4a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    9e51:	00 
    9e52:	eb 29                	jmp    9e7d <save_old+0x47>
		put_fs_byte(*from,to);
    9e54:	8b 44 24 20          	mov    0x20(%esp),%eax
    9e58:	0f b6 00             	movzbl (%eax),%eax
    9e5b:	0f be c0             	movsbl %al,%eax
    9e5e:	83 ec 08             	sub    $0x8,%esp
    9e61:	ff 74 24 2c          	pushl  0x2c(%esp)
    9e65:	50                   	push   %eax
    9e66:	e8 6c ff ff ff       	call   9dd7 <put_fs_byte>
    9e6b:	83 c4 10             	add    $0x10,%esp
		from++;
    9e6e:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
		to++;
    9e73:	83 44 24 24 01       	addl   $0x1,0x24(%esp)
static inline void save_old(char * from,char * to)
{
	int i;

	verify_area(to, sizeof(struct sigaction));
	for (i=0 ; i< sizeof(struct sigaction) ; i++) {
    9e78:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    9e7d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9e81:	83 f8 0f             	cmp    $0xf,%eax
    9e84:	76 ce                	jbe    9e54 <save_old+0x1e>
		put_fs_byte(*from,to);
		from++;
		to++;
	}
}
    9e86:	90                   	nop
    9e87:	83 c4 1c             	add    $0x1c,%esp
    9e8a:	c3                   	ret    

00009e8b <get_new>:

static inline void get_new(char * from,char * to)
{
    9e8b:	53                   	push   %ebx
    9e8c:	83 ec 10             	sub    $0x10,%esp
	int i;

	for (i=0 ; i< sizeof(struct sigaction) ; i++)
    9e8f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    9e96:	00 
    9e97:	eb 26                	jmp    9ebf <get_new+0x34>
		*(to++) = get_fs_byte(from++);
    9e99:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    9e9d:	8d 43 01             	lea    0x1(%ebx),%eax
    9ea0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    9ea4:	8b 44 24 18          	mov    0x18(%esp),%eax
    9ea8:	8d 50 01             	lea    0x1(%eax),%edx
    9eab:	89 54 24 18          	mov    %edx,0x18(%esp)
    9eaf:	50                   	push   %eax
    9eb0:	e8 14 ff ff ff       	call   9dc9 <get_fs_byte>
    9eb5:	83 c4 04             	add    $0x4,%esp
    9eb8:	88 03                	mov    %al,(%ebx)

static inline void get_new(char * from,char * to)
{
	int i;

	for (i=0 ; i< sizeof(struct sigaction) ; i++)
    9eba:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    9ebf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    9ec3:	83 f8 0f             	cmp    $0xf,%eax
    9ec6:	76 d1                	jbe    9e99 <get_new+0xe>
		*(to++) = get_fs_byte(from++);
}
    9ec8:	90                   	nop
    9ec9:	83 c4 10             	add    $0x10,%esp
    9ecc:	5b                   	pop    %ebx
    9ecd:	c3                   	ret    

00009ece <sys_signal>:

int sys_signal(int signum, long handler, long restorer)
{
    9ece:	83 ec 10             	sub    $0x10,%esp
	struct sigaction tmp;

	if (signum<1 || signum>32 || signum==SIGKILL)
    9ed1:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    9ed6:	7e 0e                	jle    9ee6 <sys_signal+0x18>
    9ed8:	83 7c 24 14 20       	cmpl   $0x20,0x14(%esp)
    9edd:	7f 07                	jg     9ee6 <sys_signal+0x18>
    9edf:	83 7c 24 14 09       	cmpl   $0x9,0x14(%esp)
    9ee4:	75 07                	jne    9eed <sys_signal+0x1f>
		return -1;
    9ee6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9eeb:	eb 6b                	jmp    9f58 <sys_signal+0x8a>
	tmp.sa_handler = (void (*)(int)) handler;
    9eed:	8b 44 24 18          	mov    0x18(%esp),%eax
    9ef1:	89 04 24             	mov    %eax,(%esp)
	tmp.sa_mask = 0;
    9ef4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    9efb:	00 
	tmp.sa_flags = SA_ONESHOT | SA_NOMASK;
    9efc:	c7 44 24 08 00 00 00 	movl   $0xc0000000,0x8(%esp)
    9f03:	c0 
	tmp.sa_restorer = (void (*)(void)) restorer;
    9f04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    9f08:	89 44 24 0c          	mov    %eax,0xc(%esp)
	handler = (long) current->sigaction[signum-1].sa_handler;
    9f0c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9f11:	8b 54 24 14          	mov    0x14(%esp),%edx
    9f15:	83 ea 01             	sub    $0x1,%edx
    9f18:	83 c2 01             	add    $0x1,%edx
    9f1b:	c1 e2 04             	shl    $0x4,%edx
    9f1e:	01 d0                	add    %edx,%eax
    9f20:	8b 00                	mov    (%eax),%eax
    9f22:	89 44 24 18          	mov    %eax,0x18(%esp)
	current->sigaction[signum-1] = tmp;
    9f26:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9f2b:	8b 54 24 14          	mov    0x14(%esp),%edx
    9f2f:	83 ea 01             	sub    $0x1,%edx
    9f32:	83 c2 01             	add    $0x1,%edx
    9f35:	c1 e2 04             	shl    $0x4,%edx
    9f38:	01 d0                	add    %edx,%eax
    9f3a:	8b 14 24             	mov    (%esp),%edx
    9f3d:	89 10                	mov    %edx,(%eax)
    9f3f:	8b 54 24 04          	mov    0x4(%esp),%edx
    9f43:	89 50 04             	mov    %edx,0x4(%eax)
    9f46:	8b 54 24 08          	mov    0x8(%esp),%edx
    9f4a:	89 50 08             	mov    %edx,0x8(%eax)
    9f4d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    9f51:	89 50 0c             	mov    %edx,0xc(%eax)
	return handler;
    9f54:	8b 44 24 18          	mov    0x18(%esp),%eax
}
    9f58:	83 c4 10             	add    $0x10,%esp
    9f5b:	c3                   	ret    

00009f5c <sys_sigaction>:

int sys_sigaction(int signum, const struct sigaction * action,
	struct sigaction * oldaction)
{
    9f5c:	56                   	push   %esi
    9f5d:	53                   	push   %ebx
    9f5e:	83 ec 14             	sub    $0x14,%esp
	struct sigaction tmp;

	if (signum<1 || signum>32 || signum==SIGKILL)
    9f61:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    9f66:	7e 0e                	jle    9f76 <sys_sigaction+0x1a>
    9f68:	83 7c 24 20 20       	cmpl   $0x20,0x20(%esp)
    9f6d:	7f 07                	jg     9f76 <sys_sigaction+0x1a>
    9f6f:	83 7c 24 20 09       	cmpl   $0x9,0x20(%esp)
    9f74:	75 0a                	jne    9f80 <sys_sigaction+0x24>
		return -1;
    9f76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9f7b:	e9 f7 00 00 00       	jmp    a077 <sys_sigaction+0x11b>
	tmp = current->sigaction[signum-1];
    9f80:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9f85:	8b 54 24 20          	mov    0x20(%esp),%edx
    9f89:	83 ea 01             	sub    $0x1,%edx
    9f8c:	83 c2 01             	add    $0x1,%edx
    9f8f:	c1 e2 04             	shl    $0x4,%edx
    9f92:	01 d0                	add    %edx,%eax
    9f94:	8b 10                	mov    (%eax),%edx
    9f96:	89 14 24             	mov    %edx,(%esp)
    9f99:	8b 50 04             	mov    0x4(%eax),%edx
    9f9c:	89 54 24 04          	mov    %edx,0x4(%esp)
    9fa0:	8b 50 08             	mov    0x8(%eax),%edx
    9fa3:	89 54 24 08          	mov    %edx,0x8(%esp)
    9fa7:	8b 40 0c             	mov    0xc(%eax),%eax
    9faa:	89 44 24 0c          	mov    %eax,0xc(%esp)
	get_new((char *) action,
		(char *) (signum-1+current->sigaction));
    9fae:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9fb3:	8d 50 10             	lea    0x10(%eax),%edx
    9fb6:	8b 44 24 20          	mov    0x20(%esp),%eax
	struct sigaction tmp;

	if (signum<1 || signum>32 || signum==SIGKILL)
		return -1;
	tmp = current->sigaction[signum-1];
	get_new((char *) action,
    9fba:	05 ff ff ff 0f       	add    $0xfffffff,%eax
    9fbf:	c1 e0 04             	shl    $0x4,%eax
    9fc2:	01 d0                	add    %edx,%eax
    9fc4:	50                   	push   %eax
    9fc5:	ff 74 24 28          	pushl  0x28(%esp)
    9fc9:	e8 bd fe ff ff       	call   9e8b <get_new>
    9fce:	83 c4 08             	add    $0x8,%esp
		(char *) (signum-1+current->sigaction));
	if (oldaction)
    9fd1:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    9fd6:	74 14                	je     9fec <sys_sigaction+0x90>
		save_old((char *) &tmp,(char *) oldaction);
    9fd8:	83 ec 08             	sub    $0x8,%esp
    9fdb:	ff 74 24 30          	pushl  0x30(%esp)
    9fdf:	8d 44 24 0c          	lea    0xc(%esp),%eax
    9fe3:	50                   	push   %eax
    9fe4:	e8 4d fe ff ff       	call   9e36 <save_old>
    9fe9:	83 c4 10             	add    $0x10,%esp
	if (current->sigaction[signum-1].sa_flags & SA_NOMASK)
    9fec:	a1 40 f1 01 00       	mov    0x1f140,%eax
    9ff1:	8b 54 24 20          	mov    0x20(%esp),%edx
    9ff5:	83 ea 01             	sub    $0x1,%edx
    9ff8:	83 c2 01             	add    $0x1,%edx
    9ffb:	c1 e2 04             	shl    $0x4,%edx
    9ffe:	01 d0                	add    %edx,%eax
    a000:	83 c0 08             	add    $0x8,%eax
    a003:	8b 00                	mov    (%eax),%eax
    a005:	25 00 00 00 40       	and    $0x40000000,%eax
    a00a:	85 c0                	test   %eax,%eax
    a00c:	74 1f                	je     a02d <sys_sigaction+0xd1>
		current->sigaction[signum-1].sa_mask = 0;
    a00e:	a1 40 f1 01 00       	mov    0x1f140,%eax
    a013:	8b 54 24 20          	mov    0x20(%esp),%edx
    a017:	83 ea 01             	sub    $0x1,%edx
    a01a:	83 c2 01             	add    $0x1,%edx
    a01d:	c1 e2 04             	shl    $0x4,%edx
    a020:	01 d0                	add    %edx,%eax
    a022:	83 c0 04             	add    $0x4,%eax
    a025:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a02b:	eb 45                	jmp    a072 <sys_sigaction+0x116>
	else
		current->sigaction[signum-1].sa_mask |= (1<<(signum-1));
    a02d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    a032:	8b 54 24 20          	mov    0x20(%esp),%edx
    a036:	8d 5a ff             	lea    -0x1(%edx),%ebx
    a039:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    a03f:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    a043:	83 e9 01             	sub    $0x1,%ecx
    a046:	83 c1 01             	add    $0x1,%ecx
    a049:	c1 e1 04             	shl    $0x4,%ecx
    a04c:	01 ca                	add    %ecx,%edx
    a04e:	83 c2 04             	add    $0x4,%edx
    a051:	8b 12                	mov    (%edx),%edx
    a053:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    a057:	83 e9 01             	sub    $0x1,%ecx
    a05a:	be 01 00 00 00       	mov    $0x1,%esi
    a05f:	d3 e6                	shl    %cl,%esi
    a061:	89 f1                	mov    %esi,%ecx
    a063:	09 ca                	or     %ecx,%edx
    a065:	8d 4b 01             	lea    0x1(%ebx),%ecx
    a068:	c1 e1 04             	shl    $0x4,%ecx
    a06b:	01 c8                	add    %ecx,%eax
    a06d:	83 c0 04             	add    $0x4,%eax
    a070:	89 10                	mov    %edx,(%eax)
	return 0;
    a072:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a077:	83 c4 14             	add    $0x14,%esp
    a07a:	5b                   	pop    %ebx
    a07b:	5e                   	pop    %esi
    a07c:	c3                   	ret    

0000a07d <do_signal>:

void do_signal(long signr,long eax, long ebx, long ecx, long edx,
	long fs, long es, long ds,
	long eip, long cs, long eflags,
	unsigned long * esp, long ss)
{
    a07d:	83 ec 2c             	sub    $0x2c,%esp
	unsigned long sa_handler;
	long old_eip=eip;
    a080:	8b 44 24 50          	mov    0x50(%esp),%eax
    a084:	89 44 24 18          	mov    %eax,0x18(%esp)
	struct sigaction * sa = current->sigaction + signr - 1;
    a088:	a1 40 f1 01 00       	mov    0x1f140,%eax
    a08d:	8d 50 10             	lea    0x10(%eax),%edx
    a090:	8b 44 24 30          	mov    0x30(%esp),%eax
    a094:	05 ff ff ff 0f       	add    $0xfffffff,%eax
    a099:	c1 e0 04             	shl    $0x4,%eax
    a09c:	01 d0                	add    %edx,%eax
    a09e:	89 44 24 14          	mov    %eax,0x14(%esp)
	int longs;
	unsigned long * tmp_esp;

	sa_handler = (unsigned long) sa->sa_handler;
    a0a2:	8b 44 24 14          	mov    0x14(%esp),%eax
    a0a6:	8b 00                	mov    (%eax),%eax
    a0a8:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (sa_handler==1)
    a0ac:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
    a0b1:	0f 84 c3 01 00 00    	je     a27a <do_signal+0x1fd>
		return;
	if (!sa_handler) {
    a0b7:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    a0bc:	75 29                	jne    a0e7 <do_signal+0x6a>
		if (signr==SIGCHLD)
    a0be:	83 7c 24 30 11       	cmpl   $0x11,0x30(%esp)
    a0c3:	0f 84 b4 01 00 00    	je     a27d <do_signal+0x200>
			return;
		else
			do_exit(1<<(signr-1));
    a0c9:	8b 44 24 30          	mov    0x30(%esp),%eax
    a0cd:	83 e8 01             	sub    $0x1,%eax
    a0d0:	ba 01 00 00 00       	mov    $0x1,%edx
    a0d5:	89 c1                	mov    %eax,%ecx
    a0d7:	d3 e2                	shl    %cl,%edx
    a0d9:	89 d0                	mov    %edx,%eax
    a0db:	83 ec 0c             	sub    $0xc,%esp
    a0de:	50                   	push   %eax
    a0df:	e8 5b f8 ff ff       	call   993f <do_exit>
    a0e4:	83 c4 10             	add    $0x10,%esp
	}
	if (sa->sa_flags & SA_ONESHOT)
    a0e7:	8b 44 24 14          	mov    0x14(%esp),%eax
    a0eb:	8b 40 08             	mov    0x8(%eax),%eax
    a0ee:	85 c0                	test   %eax,%eax
    a0f0:	79 0a                	jns    a0fc <do_signal+0x7f>
		sa->sa_handler = NULL;
    a0f2:	8b 44 24 14          	mov    0x14(%esp),%eax
    a0f6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	*(&eip) = sa_handler;
    a0fc:	8b 44 24 10          	mov    0x10(%esp),%eax
    a100:	89 44 24 50          	mov    %eax,0x50(%esp)
	longs = (sa->sa_flags & SA_NOMASK)?7:8;
    a104:	8b 44 24 14          	mov    0x14(%esp),%eax
    a108:	8b 40 08             	mov    0x8(%eax),%eax
    a10b:	25 00 00 00 40       	and    $0x40000000,%eax
    a110:	85 c0                	test   %eax,%eax
    a112:	74 07                	je     a11b <do_signal+0x9e>
    a114:	b8 07 00 00 00       	mov    $0x7,%eax
    a119:	eb 05                	jmp    a120 <do_signal+0xa3>
    a11b:	b8 08 00 00 00       	mov    $0x8,%eax
    a120:	89 44 24 0c          	mov    %eax,0xc(%esp)
	*(&esp) -= longs;
    a124:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    a128:	8b 54 24 0c          	mov    0xc(%esp),%edx
    a12c:	c1 e2 02             	shl    $0x2,%edx
    a12f:	f7 da                	neg    %edx
    a131:	01 d0                	add    %edx,%eax
    a133:	89 44 24 5c          	mov    %eax,0x5c(%esp)
	verify_area(esp,longs*4);
    a137:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a13b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a142:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    a146:	83 ec 08             	sub    $0x8,%esp
    a149:	52                   	push   %edx
    a14a:	50                   	push   %eax
    a14b:	e8 54 df ff ff       	call   80a4 <verify_area>
    a150:	83 c4 10             	add    $0x10,%esp
	tmp_esp=esp;
    a153:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    a157:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	put_fs_long((long) sa->sa_restorer,tmp_esp++);
    a15b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a15f:	8d 50 04             	lea    0x4(%eax),%edx
    a162:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    a166:	8b 54 24 14          	mov    0x14(%esp),%edx
    a16a:	8b 52 0c             	mov    0xc(%edx),%edx
    a16d:	83 ec 08             	sub    $0x8,%esp
    a170:	50                   	push   %eax
    a171:	52                   	push   %edx
    a172:	e8 7a fc ff ff       	call   9df1 <put_fs_long>
    a177:	83 c4 10             	add    $0x10,%esp
	put_fs_long(signr,tmp_esp++);
    a17a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a17e:	8d 50 04             	lea    0x4(%eax),%edx
    a181:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    a185:	8b 54 24 30          	mov    0x30(%esp),%edx
    a189:	83 ec 08             	sub    $0x8,%esp
    a18c:	50                   	push   %eax
    a18d:	52                   	push   %edx
    a18e:	e8 5e fc ff ff       	call   9df1 <put_fs_long>
    a193:	83 c4 10             	add    $0x10,%esp
	if (!(sa->sa_flags & SA_NOMASK))
    a196:	8b 44 24 14          	mov    0x14(%esp),%eax
    a19a:	8b 40 08             	mov    0x8(%eax),%eax
    a19d:	25 00 00 00 40       	and    $0x40000000,%eax
    a1a2:	85 c0                	test   %eax,%eax
    a1a4:	75 24                	jne    a1ca <do_signal+0x14d>
		put_fs_long(current->blocked,tmp_esp++);
    a1a6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a1aa:	8d 50 04             	lea    0x4(%eax),%edx
    a1ad:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    a1b1:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    a1b7:	8b 92 10 02 00 00    	mov    0x210(%edx),%edx
    a1bd:	83 ec 08             	sub    $0x8,%esp
    a1c0:	50                   	push   %eax
    a1c1:	52                   	push   %edx
    a1c2:	e8 2a fc ff ff       	call   9df1 <put_fs_long>
    a1c7:	83 c4 10             	add    $0x10,%esp
	put_fs_long(eax,tmp_esp++);
    a1ca:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a1ce:	8d 50 04             	lea    0x4(%eax),%edx
    a1d1:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    a1d5:	8b 54 24 34          	mov    0x34(%esp),%edx
    a1d9:	83 ec 08             	sub    $0x8,%esp
    a1dc:	50                   	push   %eax
    a1dd:	52                   	push   %edx
    a1de:	e8 0e fc ff ff       	call   9df1 <put_fs_long>
    a1e3:	83 c4 10             	add    $0x10,%esp
	put_fs_long(ecx,tmp_esp++);
    a1e6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a1ea:	8d 50 04             	lea    0x4(%eax),%edx
    a1ed:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    a1f1:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    a1f5:	83 ec 08             	sub    $0x8,%esp
    a1f8:	50                   	push   %eax
    a1f9:	52                   	push   %edx
    a1fa:	e8 f2 fb ff ff       	call   9df1 <put_fs_long>
    a1ff:	83 c4 10             	add    $0x10,%esp
	put_fs_long(edx,tmp_esp++);
    a202:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a206:	8d 50 04             	lea    0x4(%eax),%edx
    a209:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    a20d:	8b 54 24 40          	mov    0x40(%esp),%edx
    a211:	83 ec 08             	sub    $0x8,%esp
    a214:	50                   	push   %eax
    a215:	52                   	push   %edx
    a216:	e8 d6 fb ff ff       	call   9df1 <put_fs_long>
    a21b:	83 c4 10             	add    $0x10,%esp
	put_fs_long(eflags,tmp_esp++);
    a21e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a222:	8d 50 04             	lea    0x4(%eax),%edx
    a225:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    a229:	8b 54 24 58          	mov    0x58(%esp),%edx
    a22d:	83 ec 08             	sub    $0x8,%esp
    a230:	50                   	push   %eax
    a231:	52                   	push   %edx
    a232:	e8 ba fb ff ff       	call   9df1 <put_fs_long>
    a237:	83 c4 10             	add    $0x10,%esp
	put_fs_long(old_eip,tmp_esp++);
    a23a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a23e:	8d 50 04             	lea    0x4(%eax),%edx
    a241:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    a245:	8b 54 24 18          	mov    0x18(%esp),%edx
    a249:	83 ec 08             	sub    $0x8,%esp
    a24c:	50                   	push   %eax
    a24d:	52                   	push   %edx
    a24e:	e8 9e fb ff ff       	call   9df1 <put_fs_long>
    a253:	83 c4 10             	add    $0x10,%esp
	current->blocked |= sa->sa_mask;
    a256:	a1 40 f1 01 00       	mov    0x1f140,%eax
    a25b:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    a261:	8b 92 10 02 00 00    	mov    0x210(%edx),%edx
    a267:	89 d1                	mov    %edx,%ecx
    a269:	8b 54 24 14          	mov    0x14(%esp),%edx
    a26d:	8b 52 04             	mov    0x4(%edx),%edx
    a270:	09 ca                	or     %ecx,%edx
    a272:	89 90 10 02 00 00    	mov    %edx,0x210(%eax)
    a278:	eb 04                	jmp    a27e <do_signal+0x201>
	int longs;
	unsigned long * tmp_esp;

	sa_handler = (unsigned long) sa->sa_handler;
	if (sa_handler==1)
		return;
    a27a:	90                   	nop
    a27b:	eb 01                	jmp    a27e <do_signal+0x201>
	if (!sa_handler) {
		if (signr==SIGCHLD)
			return;
    a27d:	90                   	nop
	put_fs_long(ecx,tmp_esp++);
	put_fs_long(edx,tmp_esp++);
	put_fs_long(eflags,tmp_esp++);
	put_fs_long(old_eip,tmp_esp++);
	current->blocked |= sa->sa_mask;
}
    a27e:	83 c4 2c             	add    $0x2c,%esp
    a281:	c3                   	ret    

0000a282 <kernel_mktime>:
	DAY*(31+29+31+30+31+30+31+31+30+31),
	DAY*(31+29+31+30+31+30+31+31+30+31+30)
};

long kernel_mktime(struct tm * tm)
{
    a282:	83 ec 10             	sub    $0x10,%esp
	long res;
	int year;
	if (tm->tm_year >= 70)
    a285:	8b 44 24 14          	mov    0x14(%esp),%eax
    a289:	8b 40 14             	mov    0x14(%eax),%eax
    a28c:	83 f8 45             	cmp    $0x45,%eax
    a28f:	7e 10                	jle    a2a1 <kernel_mktime+0x1f>
	  year = tm->tm_year - 70;
    a291:	8b 44 24 14          	mov    0x14(%esp),%eax
    a295:	8b 40 14             	mov    0x14(%eax),%eax
    a298:	83 e8 46             	sub    $0x46,%eax
    a29b:	89 44 24 08          	mov    %eax,0x8(%esp)
    a29f:	eb 0e                	jmp    a2af <kernel_mktime+0x2d>
	else
	  year = tm->tm_year + 100 -70; /* Y2K bug fix by hellotigercn 20110803 */
    a2a1:	8b 44 24 14          	mov    0x14(%esp),%eax
    a2a5:	8b 40 14             	mov    0x14(%eax),%eax
    a2a8:	83 c0 1e             	add    $0x1e,%eax
    a2ab:	89 44 24 08          	mov    %eax,0x8(%esp)
/* magic offsets (y+1) needed to get leapyears right.*/
	res = YEAR*year + DAY*((year+1)/4);
    a2af:	8b 44 24 08          	mov    0x8(%esp),%eax
    a2b3:	69 d0 80 33 e1 01    	imul   $0x1e13380,%eax,%edx
    a2b9:	8b 44 24 08          	mov    0x8(%esp),%eax
    a2bd:	83 c0 01             	add    $0x1,%eax
    a2c0:	8d 48 03             	lea    0x3(%eax),%ecx
    a2c3:	85 c0                	test   %eax,%eax
    a2c5:	0f 48 c1             	cmovs  %ecx,%eax
    a2c8:	c1 f8 02             	sar    $0x2,%eax
    a2cb:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
    a2d1:	01 d0                	add    %edx,%eax
    a2d3:	89 44 24 0c          	mov    %eax,0xc(%esp)
	res += month[tm->tm_mon];
    a2d7:	8b 44 24 14          	mov    0x14(%esp),%eax
    a2db:	8b 40 10             	mov    0x10(%eax),%eax
    a2de:	8b 04 85 c0 f2 01 00 	mov    0x1f2c0(,%eax,4),%eax
    a2e5:	01 44 24 0c          	add    %eax,0xc(%esp)
/* and (y+2) here. If it wasn't a leap-year, we have to adjust */
	if (tm->tm_mon>1 && ((year+2)%4))
    a2e9:	8b 44 24 14          	mov    0x14(%esp),%eax
    a2ed:	8b 40 10             	mov    0x10(%eax),%eax
    a2f0:	83 f8 01             	cmp    $0x1,%eax
    a2f3:	7e 16                	jle    a30b <kernel_mktime+0x89>
    a2f5:	8b 44 24 08          	mov    0x8(%esp),%eax
    a2f9:	83 c0 02             	add    $0x2,%eax
    a2fc:	83 e0 03             	and    $0x3,%eax
    a2ff:	85 c0                	test   %eax,%eax
    a301:	74 08                	je     a30b <kernel_mktime+0x89>
		res -= DAY;
    a303:	81 6c 24 0c 80 51 01 	subl   $0x15180,0xc(%esp)
    a30a:	00 
	res += DAY*(tm->tm_mday-1);
    a30b:	8b 44 24 14          	mov    0x14(%esp),%eax
    a30f:	8b 40 0c             	mov    0xc(%eax),%eax
    a312:	83 e8 01             	sub    $0x1,%eax
    a315:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
    a31b:	01 44 24 0c          	add    %eax,0xc(%esp)
	res += HOUR*tm->tm_hour;
    a31f:	8b 44 24 14          	mov    0x14(%esp),%eax
    a323:	8b 40 08             	mov    0x8(%eax),%eax
    a326:	69 c0 10 0e 00 00    	imul   $0xe10,%eax,%eax
    a32c:	01 44 24 0c          	add    %eax,0xc(%esp)
	res += MINUTE*tm->tm_min;
    a330:	8b 44 24 14          	mov    0x14(%esp),%eax
    a334:	8b 40 04             	mov    0x4(%eax),%eax
    a337:	c1 e0 02             	shl    $0x2,%eax
    a33a:	89 c2                	mov    %eax,%edx
    a33c:	c1 e2 04             	shl    $0x4,%edx
    a33f:	29 c2                	sub    %eax,%edx
    a341:	89 d0                	mov    %edx,%eax
    a343:	01 44 24 0c          	add    %eax,0xc(%esp)
	res += tm->tm_sec;
    a347:	8b 44 24 14          	mov    0x14(%esp),%eax
    a34b:	8b 00                	mov    (%eax),%eax
    a34d:	01 44 24 0c          	add    %eax,0xc(%esp)
	return res;
    a351:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    a355:	83 c4 10             	add    $0x10,%esp
    a358:	c3                   	ret    

0000a359 <oom>:
#include <linux/kernel.h>

void do_exit(long code);

static inline void oom(void)
{
    a359:	83 ec 0c             	sub    $0xc,%esp
	printk("out of memory\n\r");
    a35c:	83 ec 0c             	sub    $0xc,%esp
    a35f:	68 04 85 01 00       	push   $0x18504
    a364:	e8 a4 e4 ff ff       	call   880d <printk>
    a369:	83 c4 10             	add    $0x10,%esp
	do_exit(SIGSEGV);
    a36c:	83 ec 0c             	sub    $0xc,%esp
    a36f:	6a 0b                	push   $0xb
    a371:	e8 c9 f5 ff ff       	call   993f <do_exit>
    a376:	83 c4 10             	add    $0x10,%esp
}
    a379:	90                   	nop
    a37a:	83 c4 0c             	add    $0xc,%esp
    a37d:	c3                   	ret    

0000a37e <get_free_page>:
/*
 * Get physical address of first (actually last :-) free page, and mark it
 * used. If no free pages left, return 0.
 */
unsigned long get_free_page(void)
{
    a37e:	57                   	push   %edi
    a37f:	53                   	push   %ebx
	"rep ; stosl\n\t"
	" movl %%edx,%%eax\n"
	"1: cld"
	:"=a" (__res)
	:"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
	"D" (mem_map+PAGING_PAGES-1)
    a380:	bb 5f 35 02 00       	mov    $0x2355f,%ebx
 */
unsigned long get_free_page(void)
{
register unsigned long __res asm("ax");

__asm__("std ; repne ; scasb\n\t"
    a385:	b8 00 00 00 00       	mov    $0x0,%eax
    a38a:	ba 00 0f 00 00       	mov    $0xf00,%edx
    a38f:	89 d1                	mov    %edx,%ecx
    a391:	89 df                	mov    %ebx,%edi
    a393:	fd                   	std    
    a394:	f2 ae                	repnz scas %es:(%edi),%al
    a396:	75 1e                	jne    a3b6 <get_free_page+0x38>
    a398:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    a39c:	c1 e1 0c             	shl    $0xc,%ecx
    a39f:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    a3a5:	89 ca                	mov    %ecx,%edx
    a3a7:	b9 00 04 00 00       	mov    $0x400,%ecx
    a3ac:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    a3b2:	f3 ab                	rep stos %eax,%es:(%edi)
    a3b4:	89 d0                	mov    %edx,%eax
    a3b6:	fc                   	cld    
	:"=a" (__res)
	:"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
	"D" (mem_map+PAGING_PAGES-1)
	);
return __res;
}
    a3b7:	5b                   	pop    %ebx
    a3b8:	5f                   	pop    %edi
    a3b9:	c3                   	ret    

0000a3ba <free_page>:
/*
 * Free a page of memory at physical address 'addr'. Used by
 * 'free_page_tables()'
 */
void free_page(unsigned long addr)
{
    a3ba:	83 ec 0c             	sub    $0xc,%esp
	if (addr < LOW_MEM) return;
    a3bd:	81 7c 24 10 ff ff 0f 	cmpl   $0xfffff,0x10(%esp)
    a3c4:	00 
    a3c5:	76 65                	jbe    a42c <free_page+0x72>
	if (addr >= HIGH_MEMORY)
    a3c7:	a1 40 26 02 00       	mov    0x22640,%eax
    a3cc:	39 44 24 10          	cmp    %eax,0x10(%esp)
    a3d0:	72 10                	jb     a3e2 <free_page+0x28>
		panic("trying to free nonexistent page");
    a3d2:	83 ec 0c             	sub    $0xc,%esp
    a3d5:	68 14 85 01 00       	push   $0x18514
    a3da:	e8 ef e3 ff ff       	call   87ce <panic>
    a3df:	83 c4 10             	add    $0x10,%esp
	addr -= LOW_MEM;
    a3e2:	81 6c 24 10 00 00 10 	subl   $0x100000,0x10(%esp)
    a3e9:	00 
	addr >>= 12;
    a3ea:	c1 6c 24 10 0c       	shrl   $0xc,0x10(%esp)
	if (mem_map[addr]--) return;
    a3ef:	8b 44 24 10          	mov    0x10(%esp),%eax
    a3f3:	05 60 26 02 00       	add    $0x22660,%eax
    a3f8:	0f b6 00             	movzbl (%eax),%eax
    a3fb:	8d 50 ff             	lea    -0x1(%eax),%edx
    a3fe:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    a402:	81 c1 60 26 02 00    	add    $0x22660,%ecx
    a408:	88 11                	mov    %dl,(%ecx)
    a40a:	84 c0                	test   %al,%al
    a40c:	75 21                	jne    a42f <free_page+0x75>
	mem_map[addr]=0;
    a40e:	8b 44 24 10          	mov    0x10(%esp),%eax
    a412:	05 60 26 02 00       	add    $0x22660,%eax
    a417:	c6 00 00             	movb   $0x0,(%eax)
	panic("trying to free free page");
    a41a:	83 ec 0c             	sub    $0xc,%esp
    a41d:	68 34 85 01 00       	push   $0x18534
    a422:	e8 a7 e3 ff ff       	call   87ce <panic>
    a427:	83 c4 10             	add    $0x10,%esp
    a42a:	eb 04                	jmp    a430 <free_page+0x76>
 * Free a page of memory at physical address 'addr'. Used by
 * 'free_page_tables()'
 */
void free_page(unsigned long addr)
{
	if (addr < LOW_MEM) return;
    a42c:	90                   	nop
    a42d:	eb 01                	jmp    a430 <free_page+0x76>
	if (addr >= HIGH_MEMORY)
		panic("trying to free nonexistent page");
	addr -= LOW_MEM;
	addr >>= 12;
	if (mem_map[addr]--) return;
    a42f:	90                   	nop
	mem_map[addr]=0;
	panic("trying to free free page");
}
    a430:	83 c4 0c             	add    $0xc,%esp
    a433:	c3                   	ret    

0000a434 <free_page_tables>:
/*
 * This function frees a continuos block of page tables, as needed
 * by 'exit()'. As does copy_page_tables(), this handles only 4Mb blocks.
 */
int free_page_tables(unsigned long from,unsigned long size)
{
    a434:	83 ec 1c             	sub    $0x1c,%esp
	unsigned long *pg_table;
	unsigned long * dir, nr;

	if (from & 0x3fffff)
    a437:	8b 44 24 20          	mov    0x20(%esp),%eax
    a43b:	25 ff ff 3f 00       	and    $0x3fffff,%eax
    a440:	85 c0                	test   %eax,%eax
    a442:	74 10                	je     a454 <free_page_tables+0x20>
		panic("free_page_tables called with wrong alignment");
    a444:	83 ec 0c             	sub    $0xc,%esp
    a447:	68 50 85 01 00       	push   $0x18550
    a44c:	e8 7d e3 ff ff       	call   87ce <panic>
    a451:	83 c4 10             	add    $0x10,%esp
	if (!from)
    a454:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    a459:	75 10                	jne    a46b <free_page_tables+0x37>
		panic("Trying to free up swapper memory space");
    a45b:	83 ec 0c             	sub    $0xc,%esp
    a45e:	68 80 85 01 00       	push   $0x18580
    a463:	e8 66 e3 ff ff       	call   87ce <panic>
    a468:	83 c4 10             	add    $0x10,%esp
	size = (size + 0x3fffff) >> 22;
    a46b:	8b 44 24 24          	mov    0x24(%esp),%eax
    a46f:	05 ff ff 3f 00       	add    $0x3fffff,%eax
    a474:	c1 e8 16             	shr    $0x16,%eax
    a477:	89 44 24 24          	mov    %eax,0x24(%esp)
	dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
    a47b:	8b 44 24 20          	mov    0x20(%esp),%eax
    a47f:	c1 e8 14             	shr    $0x14,%eax
    a482:	25 fc 0f 00 00       	and    $0xffc,%eax
    a487:	89 44 24 08          	mov    %eax,0x8(%esp)
	for ( ; size-->0 ; dir++) {
    a48b:	e9 91 00 00 00       	jmp    a521 <free_page_tables+0xed>
		if (!(1 & *dir))
    a490:	8b 44 24 08          	mov    0x8(%esp),%eax
    a494:	8b 00                	mov    (%eax),%eax
    a496:	83 e0 01             	and    $0x1,%eax
    a499:	85 c0                	test   %eax,%eax
    a49b:	74 7e                	je     a51b <free_page_tables+0xe7>
			continue;
		pg_table = (unsigned long *) (0xfffff000 & *dir);
    a49d:	8b 44 24 08          	mov    0x8(%esp),%eax
    a4a1:	8b 00                	mov    (%eax),%eax
    a4a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a4a8:	89 44 24 0c          	mov    %eax,0xc(%esp)
		for (nr=0 ; nr<1024 ; nr++) {
    a4ac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    a4b3:	00 
    a4b4:	eb 38                	jmp    a4ee <free_page_tables+0xba>
			if (1 & *pg_table)
    a4b6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a4ba:	8b 00                	mov    (%eax),%eax
    a4bc:	83 e0 01             	and    $0x1,%eax
    a4bf:	85 c0                	test   %eax,%eax
    a4c1:	74 17                	je     a4da <free_page_tables+0xa6>
				free_page(0xfffff000 & *pg_table);
    a4c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a4c7:	8b 00                	mov    (%eax),%eax
    a4c9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a4ce:	83 ec 0c             	sub    $0xc,%esp
    a4d1:	50                   	push   %eax
    a4d2:	e8 e3 fe ff ff       	call   a3ba <free_page>
    a4d7:	83 c4 10             	add    $0x10,%esp
			*pg_table = 0;
    a4da:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a4de:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			pg_table++;
    a4e4:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)
	dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
	for ( ; size-->0 ; dir++) {
		if (!(1 & *dir))
			continue;
		pg_table = (unsigned long *) (0xfffff000 & *dir);
		for (nr=0 ; nr<1024 ; nr++) {
    a4e9:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
    a4ee:	81 7c 24 04 ff 03 00 	cmpl   $0x3ff,0x4(%esp)
    a4f5:	00 
    a4f6:	76 be                	jbe    a4b6 <free_page_tables+0x82>
			if (1 & *pg_table)
				free_page(0xfffff000 & *pg_table);
			*pg_table = 0;
			pg_table++;
		}
		free_page(0xfffff000 & *dir);
    a4f8:	8b 44 24 08          	mov    0x8(%esp),%eax
    a4fc:	8b 00                	mov    (%eax),%eax
    a4fe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a503:	83 ec 0c             	sub    $0xc,%esp
    a506:	50                   	push   %eax
    a507:	e8 ae fe ff ff       	call   a3ba <free_page>
    a50c:	83 c4 10             	add    $0x10,%esp
		*dir = 0;
    a50f:	8b 44 24 08          	mov    0x8(%esp),%eax
    a513:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a519:	eb 01                	jmp    a51c <free_page_tables+0xe8>
		panic("Trying to free up swapper memory space");
	size = (size + 0x3fffff) >> 22;
	dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
	for ( ; size-->0 ; dir++) {
		if (!(1 & *dir))
			continue;
    a51b:	90                   	nop
		panic("free_page_tables called with wrong alignment");
	if (!from)
		panic("Trying to free up swapper memory space");
	size = (size + 0x3fffff) >> 22;
	dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
	for ( ; size-->0 ; dir++) {
    a51c:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
    a521:	8b 44 24 24          	mov    0x24(%esp),%eax
    a525:	8d 50 ff             	lea    -0x1(%eax),%edx
    a528:	89 54 24 24          	mov    %edx,0x24(%esp)
    a52c:	85 c0                	test   %eax,%eax
    a52e:	0f 85 5c ff ff ff    	jne    a490 <free_page_tables+0x5c>
			pg_table++;
		}
		free_page(0xfffff000 & *dir);
		*dir = 0;
	}
	invalidate();
    a534:	b8 00 00 00 00       	mov    $0x0,%eax
    a539:	0f 22 d8             	mov    %eax,%cr3
	return 0;
    a53c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a541:	83 c4 1c             	add    $0x1c,%esp
    a544:	c3                   	ret    

0000a545 <copy_page_tables>:
 * doesn't take any more memory - we don't copy-on-write in the low
 * 1 Mb-range, so the pages can be shared with the kernel. Thus the
 * special case for nr=xxxx.
 */
int copy_page_tables(unsigned long from,unsigned long to,long size)
{
    a545:	83 ec 2c             	sub    $0x2c,%esp
	unsigned long * to_page_table;
	unsigned long this_page;
	unsigned long * from_dir, * to_dir;
	unsigned long nr;

	if ((from&0x3fffff) || (to&0x3fffff))
    a548:	8b 44 24 30          	mov    0x30(%esp),%eax
    a54c:	25 ff ff 3f 00       	and    $0x3fffff,%eax
    a551:	85 c0                	test   %eax,%eax
    a553:	75 0d                	jne    a562 <copy_page_tables+0x1d>
    a555:	8b 44 24 34          	mov    0x34(%esp),%eax
    a559:	25 ff ff 3f 00       	and    $0x3fffff,%eax
    a55e:	85 c0                	test   %eax,%eax
    a560:	74 10                	je     a572 <copy_page_tables+0x2d>
		panic("copy_page_tables called with wrong alignment");
    a562:	83 ec 0c             	sub    $0xc,%esp
    a565:	68 a8 85 01 00       	push   $0x185a8
    a56a:	e8 5f e2 ff ff       	call   87ce <panic>
    a56f:	83 c4 10             	add    $0x10,%esp
	from_dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
    a572:	8b 44 24 30          	mov    0x30(%esp),%eax
    a576:	c1 e8 14             	shr    $0x14,%eax
    a579:	25 fc 0f 00 00       	and    $0xffc,%eax
    a57e:	89 44 24 14          	mov    %eax,0x14(%esp)
	to_dir = (unsigned long *) ((to>>20) & 0xffc);
    a582:	8b 44 24 34          	mov    0x34(%esp),%eax
    a586:	c1 e8 14             	shr    $0x14,%eax
    a589:	25 fc 0f 00 00       	and    $0xffc,%eax
    a58e:	89 44 24 10          	mov    %eax,0x10(%esp)
	size = ((unsigned) (size+0x3fffff)) >> 22;
    a592:	8b 44 24 38          	mov    0x38(%esp),%eax
    a596:	05 ff ff 3f 00       	add    $0x3fffff,%eax
    a59b:	c1 e8 16             	shr    $0x16,%eax
    a59e:	89 44 24 38          	mov    %eax,0x38(%esp)
	for( ; size-->0 ; from_dir++,to_dir++) {
    a5a2:	e9 07 01 00 00       	jmp    a6ae <copy_page_tables+0x169>
		if (1 & *to_dir)
    a5a7:	8b 44 24 10          	mov    0x10(%esp),%eax
    a5ab:	8b 00                	mov    (%eax),%eax
    a5ad:	83 e0 01             	and    $0x1,%eax
    a5b0:	85 c0                	test   %eax,%eax
    a5b2:	74 10                	je     a5c4 <copy_page_tables+0x7f>
			panic("copy_page_tables: already exist");
    a5b4:	83 ec 0c             	sub    $0xc,%esp
    a5b7:	68 d8 85 01 00       	push   $0x185d8
    a5bc:	e8 0d e2 ff ff       	call   87ce <panic>
    a5c1:	83 c4 10             	add    $0x10,%esp
		if (!(1 & *from_dir))
    a5c4:	8b 44 24 14          	mov    0x14(%esp),%eax
    a5c8:	8b 00                	mov    (%eax),%eax
    a5ca:	83 e0 01             	and    $0x1,%eax
    a5cd:	85 c0                	test   %eax,%eax
    a5cf:	0f 84 ce 00 00 00    	je     a6a3 <copy_page_tables+0x15e>
			continue;
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);
    a5d5:	8b 44 24 14          	mov    0x14(%esp),%eax
    a5d9:	8b 00                	mov    (%eax),%eax
    a5db:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a5e0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if (!(to_page_table = (unsigned long *) get_free_page()))
    a5e4:	e8 95 fd ff ff       	call   a37e <get_free_page>
    a5e9:	89 44 24 18          	mov    %eax,0x18(%esp)
    a5ed:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    a5f2:	75 0a                	jne    a5fe <copy_page_tables+0xb9>
			return -1;	/* Out of memory, see freeing */
    a5f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a5f9:	e9 d0 00 00 00       	jmp    a6ce <copy_page_tables+0x189>
		*to_dir = ((unsigned long) to_page_table) | 7;
    a5fe:	8b 44 24 18          	mov    0x18(%esp),%eax
    a602:	83 c8 07             	or     $0x7,%eax
    a605:	89 c2                	mov    %eax,%edx
    a607:	8b 44 24 10          	mov    0x10(%esp),%eax
    a60b:	89 10                	mov    %edx,(%eax)
		nr = (from==0)?0xA0:1024;
    a60d:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
    a612:	75 07                	jne    a61b <copy_page_tables+0xd6>
    a614:	b8 a0 00 00 00       	mov    $0xa0,%eax
    a619:	eb 05                	jmp    a620 <copy_page_tables+0xdb>
    a61b:	b8 00 04 00 00       	mov    $0x400,%eax
    a620:	89 44 24 0c          	mov    %eax,0xc(%esp)
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
    a624:	eb 6c                	jmp    a692 <copy_page_tables+0x14d>
			this_page = *from_page_table;
    a626:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a62a:	8b 00                	mov    (%eax),%eax
    a62c:	89 44 24 08          	mov    %eax,0x8(%esp)
			if (!(1 & this_page))
    a630:	8b 44 24 08          	mov    0x8(%esp),%eax
    a634:	83 e0 01             	and    $0x1,%eax
    a637:	85 c0                	test   %eax,%eax
    a639:	74 4c                	je     a687 <copy_page_tables+0x142>
				continue;
			this_page &= ~2;
    a63b:	83 64 24 08 fd       	andl   $0xfffffffd,0x8(%esp)
			*to_page_table = this_page;
    a640:	8b 44 24 18          	mov    0x18(%esp),%eax
    a644:	8b 54 24 08          	mov    0x8(%esp),%edx
    a648:	89 10                	mov    %edx,(%eax)
			if (this_page > LOW_MEM) {
    a64a:	81 7c 24 08 00 00 10 	cmpl   $0x100000,0x8(%esp)
    a651:	00 
    a652:	76 34                	jbe    a688 <copy_page_tables+0x143>
				*from_page_table = this_page;
    a654:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a658:	8b 54 24 08          	mov    0x8(%esp),%edx
    a65c:	89 10                	mov    %edx,(%eax)
				this_page -= LOW_MEM;
    a65e:	81 6c 24 08 00 00 10 	subl   $0x100000,0x8(%esp)
    a665:	00 
				this_page >>= 12;
    a666:	c1 6c 24 08 0c       	shrl   $0xc,0x8(%esp)
				mem_map[this_page]++;
    a66b:	8b 44 24 08          	mov    0x8(%esp),%eax
    a66f:	05 60 26 02 00       	add    $0x22660,%eax
    a674:	0f b6 00             	movzbl (%eax),%eax
    a677:	8d 50 01             	lea    0x1(%eax),%edx
    a67a:	8b 44 24 08          	mov    0x8(%esp),%eax
    a67e:	05 60 26 02 00       	add    $0x22660,%eax
    a683:	88 10                	mov    %dl,(%eax)
    a685:	eb 01                	jmp    a688 <copy_page_tables+0x143>
		*to_dir = ((unsigned long) to_page_table) | 7;
		nr = (from==0)?0xA0:1024;
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
			this_page = *from_page_table;
			if (!(1 & this_page))
				continue;
    a687:	90                   	nop
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);
		if (!(to_page_table = (unsigned long *) get_free_page()))
			return -1;	/* Out of memory, see freeing */
		*to_dir = ((unsigned long) to_page_table) | 7;
		nr = (from==0)?0xA0:1024;
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
    a688:	83 44 24 1c 04       	addl   $0x4,0x1c(%esp)
    a68d:	83 44 24 18 04       	addl   $0x4,0x18(%esp)
    a692:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a696:	8d 50 ff             	lea    -0x1(%eax),%edx
    a699:	89 54 24 0c          	mov    %edx,0xc(%esp)
    a69d:	85 c0                	test   %eax,%eax
    a69f:	75 85                	jne    a626 <copy_page_tables+0xe1>
    a6a1:	eb 01                	jmp    a6a4 <copy_page_tables+0x15f>
	size = ((unsigned) (size+0x3fffff)) >> 22;
	for( ; size-->0 ; from_dir++,to_dir++) {
		if (1 & *to_dir)
			panic("copy_page_tables: already exist");
		if (!(1 & *from_dir))
			continue;
    a6a3:	90                   	nop
	if ((from&0x3fffff) || (to&0x3fffff))
		panic("copy_page_tables called with wrong alignment");
	from_dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
	to_dir = (unsigned long *) ((to>>20) & 0xffc);
	size = ((unsigned) (size+0x3fffff)) >> 22;
	for( ; size-->0 ; from_dir++,to_dir++) {
    a6a4:	83 44 24 14 04       	addl   $0x4,0x14(%esp)
    a6a9:	83 44 24 10 04       	addl   $0x4,0x10(%esp)
    a6ae:	8b 44 24 38          	mov    0x38(%esp),%eax
    a6b2:	8d 50 ff             	lea    -0x1(%eax),%edx
    a6b5:	89 54 24 38          	mov    %edx,0x38(%esp)
    a6b9:	85 c0                	test   %eax,%eax
    a6bb:	0f 8f e6 fe ff ff    	jg     a5a7 <copy_page_tables+0x62>
				this_page >>= 12;
				mem_map[this_page]++;
			}
		}
	}
	invalidate();
    a6c1:	b8 00 00 00 00       	mov    $0x0,%eax
    a6c6:	0f 22 d8             	mov    %eax,%cr3
	return 0;
    a6c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a6ce:	83 c4 2c             	add    $0x2c,%esp
    a6d1:	c3                   	ret    

0000a6d2 <put_page>:
 * It returns the physical address of the page gotten, 0 if
 * out of memory (either when trying to access page-table or
 * page.)
 */
unsigned long put_page(unsigned long page,unsigned long address)
{
    a6d2:	83 ec 1c             	sub    $0x1c,%esp
	unsigned long tmp, *page_table;

/* NOTE !!! This uses the fact that _pg_dir=0 */

	if (page < LOW_MEM || page >= HIGH_MEMORY)
    a6d5:	81 7c 24 20 ff ff 0f 	cmpl   $0xfffff,0x20(%esp)
    a6dc:	00 
    a6dd:	76 0b                	jbe    a6ea <put_page+0x18>
    a6df:	a1 40 26 02 00       	mov    0x22640,%eax
    a6e4:	39 44 24 20          	cmp    %eax,0x20(%esp)
    a6e8:	72 18                	jb     a702 <put_page+0x30>
		printk("Trying to put page %p at %p\n",page,address);
    a6ea:	83 ec 04             	sub    $0x4,%esp
    a6ed:	ff 74 24 28          	pushl  0x28(%esp)
    a6f1:	ff 74 24 28          	pushl  0x28(%esp)
    a6f5:	68 f8 85 01 00       	push   $0x185f8
    a6fa:	e8 0e e1 ff ff       	call   880d <printk>
    a6ff:	83 c4 10             	add    $0x10,%esp
	if (mem_map[(page-LOW_MEM)>>12] != 1)
    a702:	8b 44 24 20          	mov    0x20(%esp),%eax
    a706:	2d 00 00 10 00       	sub    $0x100000,%eax
    a70b:	c1 e8 0c             	shr    $0xc,%eax
    a70e:	0f b6 80 60 26 02 00 	movzbl 0x22660(%eax),%eax
    a715:	3c 01                	cmp    $0x1,%al
    a717:	74 18                	je     a731 <put_page+0x5f>
		printk("mem_map disagrees with %p at %p\n",page,address);
    a719:	83 ec 04             	sub    $0x4,%esp
    a71c:	ff 74 24 28          	pushl  0x28(%esp)
    a720:	ff 74 24 28          	pushl  0x28(%esp)
    a724:	68 18 86 01 00       	push   $0x18618
    a729:	e8 df e0 ff ff       	call   880d <printk>
    a72e:	83 c4 10             	add    $0x10,%esp
	page_table = (unsigned long *) ((address>>20) & 0xffc);
    a731:	8b 44 24 24          	mov    0x24(%esp),%eax
    a735:	c1 e8 14             	shr    $0x14,%eax
    a738:	25 fc 0f 00 00       	and    $0xffc,%eax
    a73d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if ((*page_table)&1)
    a741:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a745:	8b 00                	mov    (%eax),%eax
    a747:	83 e0 01             	and    $0x1,%eax
    a74a:	85 c0                	test   %eax,%eax
    a74c:	74 11                	je     a75f <put_page+0x8d>
		page_table = (unsigned long *) (0xfffff000 & *page_table);
    a74e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a752:	8b 00                	mov    (%eax),%eax
    a754:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a759:	89 44 24 0c          	mov    %eax,0xc(%esp)
    a75d:	eb 2e                	jmp    a78d <put_page+0xbb>
	else {
		if (!(tmp=get_free_page()))
    a75f:	e8 1a fc ff ff       	call   a37e <get_free_page>
    a764:	89 44 24 08          	mov    %eax,0x8(%esp)
    a768:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    a76d:	75 07                	jne    a776 <put_page+0xa4>
			return 0;
    a76f:	b8 00 00 00 00       	mov    $0x0,%eax
    a774:	eb 3d                	jmp    a7b3 <put_page+0xe1>
		*page_table = tmp|7;
    a776:	8b 44 24 08          	mov    0x8(%esp),%eax
    a77a:	83 c8 07             	or     $0x7,%eax
    a77d:	89 c2                	mov    %eax,%edx
    a77f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a783:	89 10                	mov    %edx,(%eax)
		page_table = (unsigned long *) tmp;
    a785:	8b 44 24 08          	mov    0x8(%esp),%eax
    a789:	89 44 24 0c          	mov    %eax,0xc(%esp)
	}
	page_table[(address>>12) & 0x3ff] = page | 7;
    a78d:	8b 44 24 24          	mov    0x24(%esp),%eax
    a791:	c1 e8 0c             	shr    $0xc,%eax
    a794:	25 ff 03 00 00       	and    $0x3ff,%eax
    a799:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    a7a0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a7a4:	01 d0                	add    %edx,%eax
    a7a6:	8b 54 24 20          	mov    0x20(%esp),%edx
    a7aa:	83 ca 07             	or     $0x7,%edx
    a7ad:	89 10                	mov    %edx,(%eax)
/* no need for invalidate */
	return page;
    a7af:	8b 44 24 20          	mov    0x20(%esp),%eax
}
    a7b3:	83 c4 1c             	add    $0x1c,%esp
    a7b6:	c3                   	ret    

0000a7b7 <un_wp_page>:

void un_wp_page(unsigned long * table_entry)
{
    a7b7:	57                   	push   %edi
    a7b8:	56                   	push   %esi
    a7b9:	83 ec 14             	sub    $0x14,%esp
	unsigned long old_page,new_page;

	old_page = 0xfffff000 & *table_entry;
    a7bc:	8b 44 24 20          	mov    0x20(%esp),%eax
    a7c0:	8b 00                	mov    (%eax),%eax
    a7c2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a7c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)]==1) {
    a7cb:	81 7c 24 0c ff ff 0f 	cmpl   $0xfffff,0xc(%esp)
    a7d2:	00 
    a7d3:	76 32                	jbe    a807 <un_wp_page+0x50>
    a7d5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a7d9:	2d 00 00 10 00       	sub    $0x100000,%eax
    a7de:	c1 e8 0c             	shr    $0xc,%eax
    a7e1:	0f b6 80 60 26 02 00 	movzbl 0x22660(%eax),%eax
    a7e8:	3c 01                	cmp    $0x1,%al
    a7ea:	75 1b                	jne    a807 <un_wp_page+0x50>
		*table_entry |= 2;
    a7ec:	8b 44 24 20          	mov    0x20(%esp),%eax
    a7f0:	8b 00                	mov    (%eax),%eax
    a7f2:	83 c8 02             	or     $0x2,%eax
    a7f5:	89 c2                	mov    %eax,%edx
    a7f7:	8b 44 24 20          	mov    0x20(%esp),%eax
    a7fb:	89 10                	mov    %edx,(%eax)
		invalidate();
    a7fd:	b8 00 00 00 00       	mov    $0x0,%eax
    a802:	0f 22 d8             	mov    %eax,%cr3
		return;
    a805:	eb 66                	jmp    a86d <un_wp_page+0xb6>
	}
	if (!(new_page=get_free_page()))
    a807:	e8 72 fb ff ff       	call   a37e <get_free_page>
    a80c:	89 44 24 08          	mov    %eax,0x8(%esp)
    a810:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    a815:	75 05                	jne    a81c <un_wp_page+0x65>
		oom();
    a817:	e8 3d fb ff ff       	call   a359 <oom>
	if (old_page >= LOW_MEM)
    a81c:	81 7c 24 0c ff ff 0f 	cmpl   $0xfffff,0xc(%esp)
    a823:	00 
    a824:	76 1c                	jbe    a842 <un_wp_page+0x8b>
		mem_map[MAP_NR(old_page)]--;
    a826:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a82a:	2d 00 00 10 00       	sub    $0x100000,%eax
    a82f:	c1 e8 0c             	shr    $0xc,%eax
    a832:	0f b6 90 60 26 02 00 	movzbl 0x22660(%eax),%edx
    a839:	83 ea 01             	sub    $0x1,%edx
    a83c:	88 90 60 26 02 00    	mov    %dl,0x22660(%eax)
	*table_entry = new_page | 7;
    a842:	8b 44 24 08          	mov    0x8(%esp),%eax
    a846:	83 c8 07             	or     $0x7,%eax
    a849:	89 c2                	mov    %eax,%edx
    a84b:	8b 44 24 20          	mov    0x20(%esp),%eax
    a84f:	89 10                	mov    %edx,(%eax)
	invalidate();
    a851:	b8 00 00 00 00       	mov    $0x0,%eax
    a856:	0f 22 d8             	mov    %eax,%cr3
	copy_page(old_page,new_page);
    a859:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a85d:	8b 54 24 08          	mov    0x8(%esp),%edx
    a861:	b9 00 04 00 00       	mov    $0x400,%ecx
    a866:	89 c6                	mov    %eax,%esi
    a868:	89 d7                	mov    %edx,%edi
    a86a:	fc                   	cld    
    a86b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}	
    a86d:	83 c4 14             	add    $0x14,%esp
    a870:	5e                   	pop    %esi
    a871:	5f                   	pop    %edi
    a872:	c3                   	ret    

0000a873 <do_wp_page>:
 * and decrementing the shared-page counter for the old page.
 *
 * If it's in code space we exit with a segment error.
 */
void do_wp_page(unsigned long error_code,unsigned long address)
{
    a873:	83 ec 0c             	sub    $0xc,%esp
/* stupid, stupid. I really want the libc.a from GNU */
	if (CODE_SPACE(address))
		do_exit(SIGSEGV);
#endif
	un_wp_page((unsigned long *)
		(((address>>10) & 0xffc) + (0xfffff000 &
    a876:	8b 44 24 14          	mov    0x14(%esp),%eax
    a87a:	c1 e8 0a             	shr    $0xa,%eax
    a87d:	25 fc 0f 00 00       	and    $0xffc,%eax
    a882:	89 c2                	mov    %eax,%edx
		*((unsigned long *) ((address>>20) &0xffc)))));
    a884:	8b 44 24 14          	mov    0x14(%esp),%eax
    a888:	c1 e8 14             	shr    $0x14,%eax
    a88b:	25 fc 0f 00 00       	and    $0xffc,%eax
    a890:	8b 00                	mov    (%eax),%eax
/* stupid, stupid. I really want the libc.a from GNU */
	if (CODE_SPACE(address))
		do_exit(SIGSEGV);
#endif
	un_wp_page((unsigned long *)
		(((address>>10) & 0xffc) + (0xfffff000 &
    a892:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a897:	01 d0                	add    %edx,%eax
/* we cannot do this yet: the estdio library writes to code space */
/* stupid, stupid. I really want the libc.a from GNU */
	if (CODE_SPACE(address))
		do_exit(SIGSEGV);
#endif
	un_wp_page((unsigned long *)
    a899:	83 ec 0c             	sub    $0xc,%esp
    a89c:	50                   	push   %eax
    a89d:	e8 15 ff ff ff       	call   a7b7 <un_wp_page>
    a8a2:	83 c4 10             	add    $0x10,%esp
		(((address>>10) & 0xffc) + (0xfffff000 &
		*((unsigned long *) ((address>>20) &0xffc)))));

}
    a8a5:	90                   	nop
    a8a6:	83 c4 0c             	add    $0xc,%esp
    a8a9:	c3                   	ret    

0000a8aa <write_verify>:

void write_verify(unsigned long address)
{
    a8aa:	83 ec 1c             	sub    $0x1c,%esp
	unsigned long page;

	if (!( (page = *((unsigned long *) ((address>>20) & 0xffc)) )&1))
    a8ad:	8b 44 24 20          	mov    0x20(%esp),%eax
    a8b1:	c1 e8 14             	shr    $0x14,%eax
    a8b4:	25 fc 0f 00 00       	and    $0xffc,%eax
    a8b9:	8b 00                	mov    (%eax),%eax
    a8bb:	89 44 24 0c          	mov    %eax,0xc(%esp)
    a8bf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a8c3:	83 e0 01             	and    $0x1,%eax
    a8c6:	85 c0                	test   %eax,%eax
    a8c8:	74 39                	je     a903 <write_verify+0x59>
		return;
	page &= 0xfffff000;
    a8ca:	81 64 24 0c 00 f0 ff 	andl   $0xfffff000,0xc(%esp)
    a8d1:	ff 
	page += ((address>>10) & 0xffc);
    a8d2:	8b 44 24 20          	mov    0x20(%esp),%eax
    a8d6:	c1 e8 0a             	shr    $0xa,%eax
    a8d9:	25 fc 0f 00 00       	and    $0xffc,%eax
    a8de:	01 44 24 0c          	add    %eax,0xc(%esp)
	if ((3 & *(unsigned long *) page) == 1)  /* non-writeable, present */
    a8e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a8e6:	8b 00                	mov    (%eax),%eax
    a8e8:	83 e0 03             	and    $0x3,%eax
    a8eb:	83 f8 01             	cmp    $0x1,%eax
    a8ee:	75 16                	jne    a906 <write_verify+0x5c>
		un_wp_page((unsigned long *) page);
    a8f0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a8f4:	83 ec 0c             	sub    $0xc,%esp
    a8f7:	50                   	push   %eax
    a8f8:	e8 ba fe ff ff       	call   a7b7 <un_wp_page>
    a8fd:	83 c4 10             	add    $0x10,%esp
	return;
    a900:	90                   	nop
    a901:	eb 03                	jmp    a906 <write_verify+0x5c>
void write_verify(unsigned long address)
{
	unsigned long page;

	if (!( (page = *((unsigned long *) ((address>>20) & 0xffc)) )&1))
		return;
    a903:	90                   	nop
    a904:	eb 01                	jmp    a907 <write_verify+0x5d>
	page &= 0xfffff000;
	page += ((address>>10) & 0xffc);
	if ((3 & *(unsigned long *) page) == 1)  /* non-writeable, present */
		un_wp_page((unsigned long *) page);
	return;
    a906:	90                   	nop
}
    a907:	83 c4 1c             	add    $0x1c,%esp
    a90a:	c3                   	ret    

0000a90b <get_empty_page>:

void get_empty_page(unsigned long address)
{
    a90b:	83 ec 1c             	sub    $0x1c,%esp
	unsigned long tmp;

	if (!(tmp=get_free_page()) || !put_page(tmp,address)) {
    a90e:	e8 6b fa ff ff       	call   a37e <get_free_page>
    a913:	89 44 24 0c          	mov    %eax,0xc(%esp)
    a917:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    a91c:	74 17                	je     a935 <get_empty_page+0x2a>
    a91e:	83 ec 08             	sub    $0x8,%esp
    a921:	ff 74 24 28          	pushl  0x28(%esp)
    a925:	ff 74 24 18          	pushl  0x18(%esp)
    a929:	e8 a4 fd ff ff       	call   a6d2 <put_page>
    a92e:	83 c4 10             	add    $0x10,%esp
    a931:	85 c0                	test   %eax,%eax
    a933:	75 14                	jne    a949 <get_empty_page+0x3e>
		free_page(tmp);		/* 0 is ok - ignored */
    a935:	83 ec 0c             	sub    $0xc,%esp
    a938:	ff 74 24 18          	pushl  0x18(%esp)
    a93c:	e8 79 fa ff ff       	call   a3ba <free_page>
    a941:	83 c4 10             	add    $0x10,%esp
		oom();
    a944:	e8 10 fa ff ff       	call   a359 <oom>
	}
}
    a949:	90                   	nop
    a94a:	83 c4 1c             	add    $0x1c,%esp
    a94d:	c3                   	ret    

0000a94e <try_to_share>:
 *
 * NOTE! This assumes we have checked that p != current, and that they
 * share the same executable.
 */
static int try_to_share(unsigned long address, struct task_struct * p)
{
    a94e:	83 ec 2c             	sub    $0x2c,%esp
	unsigned long to;
	unsigned long from_page;
	unsigned long to_page;
	unsigned long phys_addr;

	from_page = to_page = ((address>>20) & 0xffc);
    a951:	8b 44 24 30          	mov    0x30(%esp),%eax
    a955:	c1 e8 14             	shr    $0x14,%eax
    a958:	25 fc 0f 00 00       	and    $0xffc,%eax
    a95d:	89 44 24 18          	mov    %eax,0x18(%esp)
    a961:	8b 44 24 18          	mov    0x18(%esp),%eax
    a965:	89 44 24 14          	mov    %eax,0x14(%esp)
	from_page += ((p->start_code>>20) & 0xffc);
    a969:	8b 44 24 34          	mov    0x34(%esp),%eax
    a96d:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    a973:	c1 e8 14             	shr    $0x14,%eax
    a976:	25 fc 0f 00 00       	and    $0xffc,%eax
    a97b:	01 44 24 14          	add    %eax,0x14(%esp)
	to_page += ((current->start_code>>20) & 0xffc);
    a97f:	a1 40 f1 01 00       	mov    0x1f140,%eax
    a984:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    a98a:	c1 e8 14             	shr    $0x14,%eax
    a98d:	25 fc 0f 00 00       	and    $0xffc,%eax
    a992:	01 44 24 18          	add    %eax,0x18(%esp)
/* is there a page-directory at from? */
	from = *(unsigned long *) from_page;
    a996:	8b 44 24 14          	mov    0x14(%esp),%eax
    a99a:	8b 00                	mov    (%eax),%eax
    a99c:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!(from & 1))
    a9a0:	8b 44 24 10          	mov    0x10(%esp),%eax
    a9a4:	83 e0 01             	and    $0x1,%eax
    a9a7:	85 c0                	test   %eax,%eax
    a9a9:	75 0a                	jne    a9b5 <try_to_share+0x67>
		return 0;
    a9ab:	b8 00 00 00 00       	mov    $0x0,%eax
    a9b0:	e9 2c 01 00 00       	jmp    aae1 <try_to_share+0x193>
	from &= 0xfffff000;
    a9b5:	81 64 24 10 00 f0 ff 	andl   $0xfffff000,0x10(%esp)
    a9bc:	ff 
	from_page = from + ((address>>10) & 0xffc);
    a9bd:	8b 44 24 30          	mov    0x30(%esp),%eax
    a9c1:	c1 e8 0a             	shr    $0xa,%eax
    a9c4:	25 fc 0f 00 00       	and    $0xffc,%eax
    a9c9:	89 c2                	mov    %eax,%edx
    a9cb:	8b 44 24 10          	mov    0x10(%esp),%eax
    a9cf:	01 d0                	add    %edx,%eax
    a9d1:	89 44 24 14          	mov    %eax,0x14(%esp)
	phys_addr = *(unsigned long *) from_page;
    a9d5:	8b 44 24 14          	mov    0x14(%esp),%eax
    a9d9:	8b 00                	mov    (%eax),%eax
    a9db:	89 44 24 0c          	mov    %eax,0xc(%esp)
/* is the page clean and present? */
	if ((phys_addr & 0x41) != 0x01)
    a9df:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a9e3:	83 e0 41             	and    $0x41,%eax
    a9e6:	83 f8 01             	cmp    $0x1,%eax
    a9e9:	74 0a                	je     a9f5 <try_to_share+0xa7>
		return 0;
    a9eb:	b8 00 00 00 00       	mov    $0x0,%eax
    a9f0:	e9 ec 00 00 00       	jmp    aae1 <try_to_share+0x193>
	phys_addr &= 0xfffff000;
    a9f5:	81 64 24 0c 00 f0 ff 	andl   $0xfffff000,0xc(%esp)
    a9fc:	ff 
	if (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)
    a9fd:	a1 40 26 02 00       	mov    0x22640,%eax
    aa02:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    aa06:	73 0a                	jae    aa12 <try_to_share+0xc4>
    aa08:	81 7c 24 0c ff ff 0f 	cmpl   $0xfffff,0xc(%esp)
    aa0f:	00 
    aa10:	77 0a                	ja     aa1c <try_to_share+0xce>
		return 0;
    aa12:	b8 00 00 00 00       	mov    $0x0,%eax
    aa17:	e9 c5 00 00 00       	jmp    aae1 <try_to_share+0x193>
	to = *(unsigned long *) to_page;
    aa1c:	8b 44 24 18          	mov    0x18(%esp),%eax
    aa20:	8b 00                	mov    (%eax),%eax
    aa22:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!(to & 1)) {
    aa26:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    aa2a:	83 e0 01             	and    $0x1,%eax
    aa2d:	85 c0                	test   %eax,%eax
    aa2f:	75 24                	jne    aa55 <try_to_share+0x107>
		if ((to = get_free_page()))
    aa31:	e8 48 f9 ff ff       	call   a37e <get_free_page>
    aa36:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    aa3a:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    aa3f:	74 0f                	je     aa50 <try_to_share+0x102>
			*(unsigned long *) to_page = to | 7;
    aa41:	8b 44 24 18          	mov    0x18(%esp),%eax
    aa45:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    aa49:	83 ca 07             	or     $0x7,%edx
    aa4c:	89 10                	mov    %edx,(%eax)
    aa4e:	eb 05                	jmp    aa55 <try_to_share+0x107>
		else
			oom();
    aa50:	e8 04 f9 ff ff       	call   a359 <oom>
	}
	to &= 0xfffff000;
    aa55:	81 64 24 1c 00 f0 ff 	andl   $0xfffff000,0x1c(%esp)
    aa5c:	ff 
	to_page = to + ((address>>10) & 0xffc);
    aa5d:	8b 44 24 30          	mov    0x30(%esp),%eax
    aa61:	c1 e8 0a             	shr    $0xa,%eax
    aa64:	25 fc 0f 00 00       	and    $0xffc,%eax
    aa69:	89 c2                	mov    %eax,%edx
    aa6b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    aa6f:	01 d0                	add    %edx,%eax
    aa71:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (1 & *(unsigned long *) to_page)
    aa75:	8b 44 24 18          	mov    0x18(%esp),%eax
    aa79:	8b 00                	mov    (%eax),%eax
    aa7b:	83 e0 01             	and    $0x1,%eax
    aa7e:	85 c0                	test   %eax,%eax
    aa80:	74 10                	je     aa92 <try_to_share+0x144>
		panic("try_to_share: to_page already exists");
    aa82:	83 ec 0c             	sub    $0xc,%esp
    aa85:	68 3c 86 01 00       	push   $0x1863c
    aa8a:	e8 3f dd ff ff       	call   87ce <panic>
    aa8f:	83 c4 10             	add    $0x10,%esp
/* share them: write-protect */
	*(unsigned long *) from_page &= ~2;
    aa92:	8b 44 24 14          	mov    0x14(%esp),%eax
    aa96:	8b 54 24 14          	mov    0x14(%esp),%edx
    aa9a:	8b 12                	mov    (%edx),%edx
    aa9c:	83 e2 fd             	and    $0xfffffffd,%edx
    aa9f:	89 10                	mov    %edx,(%eax)
	*(unsigned long *) to_page = *(unsigned long *) from_page;
    aaa1:	8b 44 24 18          	mov    0x18(%esp),%eax
    aaa5:	8b 54 24 14          	mov    0x14(%esp),%edx
    aaa9:	8b 12                	mov    (%edx),%edx
    aaab:	89 10                	mov    %edx,(%eax)
	invalidate();
    aaad:	b8 00 00 00 00       	mov    $0x0,%eax
    aab2:	0f 22 d8             	mov    %eax,%cr3
	phys_addr -= LOW_MEM;
    aab5:	81 6c 24 0c 00 00 10 	subl   $0x100000,0xc(%esp)
    aabc:	00 
	phys_addr >>= 12;
    aabd:	c1 6c 24 0c 0c       	shrl   $0xc,0xc(%esp)
	mem_map[phys_addr]++;
    aac2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    aac6:	05 60 26 02 00       	add    $0x22660,%eax
    aacb:	0f b6 00             	movzbl (%eax),%eax
    aace:	8d 50 01             	lea    0x1(%eax),%edx
    aad1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    aad5:	05 60 26 02 00       	add    $0x22660,%eax
    aada:	88 10                	mov    %dl,(%eax)
	return 1;
    aadc:	b8 01 00 00 00       	mov    $0x1,%eax
}
    aae1:	83 c4 2c             	add    $0x2c,%esp
    aae4:	c3                   	ret    

0000aae5 <share_page>:
 *
 * We first check if it is at all feasible by checking executable->i_count.
 * It should be >1 if there are other tasks sharing this inode.
 */
static int share_page(unsigned long address)
{
    aae5:	83 ec 1c             	sub    $0x1c,%esp
	struct task_struct ** p;

	if (!current->executable)
    aae8:	a1 40 f1 01 00       	mov    0x1f140,%eax
    aaed:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    aaf3:	85 c0                	test   %eax,%eax
    aaf5:	75 0a                	jne    ab01 <share_page+0x1c>
		return 0;
    aaf7:	b8 00 00 00 00       	mov    $0x0,%eax
    aafc:	e9 96 00 00 00       	jmp    ab97 <share_page+0xb2>
	if (current->executable->i_count < 2)
    ab01:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ab06:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    ab0c:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    ab10:	66 83 f8 01          	cmp    $0x1,%ax
    ab14:	77 07                	ja     ab1d <share_page+0x38>
		return 0;
    ab16:	b8 00 00 00 00       	mov    $0x0,%eax
    ab1b:	eb 7a                	jmp    ab97 <share_page+0xb2>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    ab1d:	c7 44 24 0c 5c f2 01 	movl   $0x1f25c,0xc(%esp)
    ab24:	00 
    ab25:	eb 61                	jmp    ab88 <share_page+0xa3>
		if (!*p)
    ab27:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ab2b:	8b 00                	mov    (%eax),%eax
    ab2d:	85 c0                	test   %eax,%eax
    ab2f:	74 4b                	je     ab7c <share_page+0x97>
			continue;
		if (current == *p)
    ab31:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ab35:	8b 10                	mov    (%eax),%edx
    ab37:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ab3c:	39 c2                	cmp    %eax,%edx
    ab3e:	74 3f                	je     ab7f <share_page+0x9a>
			continue;
		if ((*p)->executable != current->executable)
    ab40:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ab44:	8b 00                	mov    (%eax),%eax
    ab46:	8b 90 78 02 00 00    	mov    0x278(%eax),%edx
    ab4c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ab51:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    ab57:	39 c2                	cmp    %eax,%edx
    ab59:	75 27                	jne    ab82 <share_page+0x9d>
			continue;
		if (try_to_share(address,*p))
    ab5b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ab5f:	8b 00                	mov    (%eax),%eax
    ab61:	83 ec 08             	sub    $0x8,%esp
    ab64:	50                   	push   %eax
    ab65:	ff 74 24 2c          	pushl  0x2c(%esp)
    ab69:	e8 e0 fd ff ff       	call   a94e <try_to_share>
    ab6e:	83 c4 10             	add    $0x10,%esp
    ab71:	85 c0                	test   %eax,%eax
    ab73:	74 0e                	je     ab83 <share_page+0x9e>
			return 1;
    ab75:	b8 01 00 00 00       	mov    $0x1,%eax
    ab7a:	eb 1b                	jmp    ab97 <share_page+0xb2>
		return 0;
	if (current->executable->i_count < 2)
		return 0;
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
		if (!*p)
			continue;
    ab7c:	90                   	nop
    ab7d:	eb 04                	jmp    ab83 <share_page+0x9e>
		if (current == *p)
			continue;
    ab7f:	90                   	nop
    ab80:	eb 01                	jmp    ab83 <share_page+0x9e>
		if ((*p)->executable != current->executable)
			continue;
    ab82:	90                   	nop

	if (!current->executable)
		return 0;
	if (current->executable->i_count < 2)
		return 0;
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    ab83:	83 6c 24 0c 04       	subl   $0x4,0xc(%esp)
    ab88:	81 7c 24 0c 60 f1 01 	cmpl   $0x1f160,0xc(%esp)
    ab8f:	00 
    ab90:	77 95                	ja     ab27 <share_page+0x42>
		if ((*p)->executable != current->executable)
			continue;
		if (try_to_share(address,*p))
			return 1;
	}
	return 0;
    ab92:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ab97:	83 c4 1c             	add    $0x1c,%esp
    ab9a:	c3                   	ret    

0000ab9b <do_no_page>:

void do_no_page(unsigned long error_code,unsigned long address)
{
    ab9b:	83 ec 2c             	sub    $0x2c,%esp
	int nr[4];
	unsigned long tmp;
	unsigned long page;
	int block,i;

	address &= 0xfffff000;
    ab9e:	81 64 24 34 00 f0 ff 	andl   $0xfffff000,0x34(%esp)
    aba5:	ff 
	tmp = address - current->start_code;
    aba6:	a1 40 f1 01 00       	mov    0x1f140,%eax
    abab:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    abb1:	8b 54 24 34          	mov    0x34(%esp),%edx
    abb5:	29 c2                	sub    %eax,%edx
    abb7:	89 d0                	mov    %edx,%eax
    abb9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!current->executable || tmp >= current->end_data) {
    abbd:	a1 40 f1 01 00       	mov    0x1f140,%eax
    abc2:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    abc8:	85 c0                	test   %eax,%eax
    abca:	74 11                	je     abdd <do_no_page+0x42>
    abcc:	a1 40 f1 01 00       	mov    0x1f140,%eax
    abd1:	8b 80 20 02 00 00    	mov    0x220(%eax),%eax
    abd7:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
    abdb:	77 14                	ja     abf1 <do_no_page+0x56>
		get_empty_page(address);
    abdd:	83 ec 0c             	sub    $0xc,%esp
    abe0:	ff 74 24 40          	pushl  0x40(%esp)
    abe4:	e8 22 fd ff ff       	call   a90b <get_empty_page>
    abe9:	83 c4 10             	add    $0x10,%esp
		return;
    abec:	e9 17 01 00 00       	jmp    ad08 <do_no_page+0x16d>
	}
	if (share_page(tmp))
    abf1:	83 ec 0c             	sub    $0xc,%esp
    abf4:	ff 74 24 28          	pushl  0x28(%esp)
    abf8:	e8 e8 fe ff ff       	call   aae5 <share_page>
    abfd:	83 c4 10             	add    $0x10,%esp
    ac00:	85 c0                	test   %eax,%eax
    ac02:	0f 85 fc 00 00 00    	jne    ad04 <do_no_page+0x169>
		return;
	if (!(page = get_free_page()))
    ac08:	e8 71 f7 ff ff       	call   a37e <get_free_page>
    ac0d:	89 44 24 10          	mov    %eax,0x10(%esp)
    ac11:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    ac16:	75 05                	jne    ac1d <do_no_page+0x82>
		oom();
    ac18:	e8 3c f7 ff ff       	call   a359 <oom>
/* remember that 1 block is used for header */
	block = 1 + tmp/BLOCK_SIZE;
    ac1d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ac21:	c1 e8 0a             	shr    $0xa,%eax
    ac24:	83 c0 01             	add    $0x1,%eax
    ac27:	89 44 24 18          	mov    %eax,0x18(%esp)
	for (i=0 ; i<4 ; block++,i++)
    ac2b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    ac32:	00 
    ac33:	eb 2e                	jmp    ac63 <do_no_page+0xc8>
		nr[i] = bmap(current->executable,block);
    ac35:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ac3a:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    ac40:	83 ec 08             	sub    $0x8,%esp
    ac43:	ff 74 24 20          	pushl  0x20(%esp)
    ac47:	50                   	push   %eax
    ac48:	e8 ec 13 00 00       	call   c039 <bmap>
    ac4d:	83 c4 10             	add    $0x10,%esp
    ac50:	89 c2                	mov    %eax,%edx
    ac52:	8b 44 24 14          	mov    0x14(%esp),%eax
    ac56:	89 14 84             	mov    %edx,(%esp,%eax,4)
		return;
	if (!(page = get_free_page()))
		oom();
/* remember that 1 block is used for header */
	block = 1 + tmp/BLOCK_SIZE;
	for (i=0 ; i<4 ; block++,i++)
    ac59:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
    ac5e:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
    ac63:	83 7c 24 14 03       	cmpl   $0x3,0x14(%esp)
    ac68:	7e cb                	jle    ac35 <do_no_page+0x9a>
		nr[i] = bmap(current->executable,block);
	bread_page(page,current->executable->i_dev,nr);
    ac6a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ac6f:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    ac75:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    ac79:	0f b7 c0             	movzwl %ax,%eax
    ac7c:	83 ec 04             	sub    $0x4,%esp
    ac7f:	8d 54 24 04          	lea    0x4(%esp),%edx
    ac83:	52                   	push   %edx
    ac84:	50                   	push   %eax
    ac85:	ff 74 24 1c          	pushl  0x1c(%esp)
    ac89:	e8 e5 23 00 00       	call   d073 <bread_page>
    ac8e:	83 c4 10             	add    $0x10,%esp
	i = tmp + 4096 - current->end_data;
    ac91:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ac96:	8b 80 20 02 00 00    	mov    0x220(%eax),%eax
    ac9c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    aca0:	29 c2                	sub    %eax,%edx
    aca2:	89 d0                	mov    %edx,%eax
    aca4:	05 00 10 00 00       	add    $0x1000,%eax
    aca9:	89 44 24 14          	mov    %eax,0x14(%esp)
	tmp = page + 4096;
    acad:	8b 44 24 10          	mov    0x10(%esp),%eax
    acb1:	05 00 10 00 00       	add    $0x1000,%eax
    acb6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	while (i-- > 0) {
    acba:	eb 0c                	jmp    acc8 <do_no_page+0x12d>
		tmp--;
    acbc:	83 6c 24 1c 01       	subl   $0x1,0x1c(%esp)
		*(char *)tmp = 0;
    acc1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    acc5:	c6 00 00             	movb   $0x0,(%eax)
	for (i=0 ; i<4 ; block++,i++)
		nr[i] = bmap(current->executable,block);
	bread_page(page,current->executable->i_dev,nr);
	i = tmp + 4096 - current->end_data;
	tmp = page + 4096;
	while (i-- > 0) {
    acc8:	8b 44 24 14          	mov    0x14(%esp),%eax
    accc:	8d 50 ff             	lea    -0x1(%eax),%edx
    accf:	89 54 24 14          	mov    %edx,0x14(%esp)
    acd3:	85 c0                	test   %eax,%eax
    acd5:	7f e5                	jg     acbc <do_no_page+0x121>
		tmp--;
		*(char *)tmp = 0;
	}
	if (put_page(page,address))
    acd7:	83 ec 08             	sub    $0x8,%esp
    acda:	ff 74 24 3c          	pushl  0x3c(%esp)
    acde:	ff 74 24 1c          	pushl  0x1c(%esp)
    ace2:	e8 eb f9 ff ff       	call   a6d2 <put_page>
    ace7:	83 c4 10             	add    $0x10,%esp
    acea:	85 c0                	test   %eax,%eax
    acec:	75 19                	jne    ad07 <do_no_page+0x16c>
		return;
	free_page(page);
    acee:	83 ec 0c             	sub    $0xc,%esp
    acf1:	ff 74 24 1c          	pushl  0x1c(%esp)
    acf5:	e8 c0 f6 ff ff       	call   a3ba <free_page>
    acfa:	83 c4 10             	add    $0x10,%esp
	oom();
    acfd:	e8 57 f6 ff ff       	call   a359 <oom>
    ad02:	eb 04                	jmp    ad08 <do_no_page+0x16d>
	if (!current->executable || tmp >= current->end_data) {
		get_empty_page(address);
		return;
	}
	if (share_page(tmp))
		return;
    ad04:	90                   	nop
    ad05:	eb 01                	jmp    ad08 <do_no_page+0x16d>
	while (i-- > 0) {
		tmp--;
		*(char *)tmp = 0;
	}
	if (put_page(page,address))
		return;
    ad07:	90                   	nop
	free_page(page);
	oom();
}
    ad08:	83 c4 2c             	add    $0x2c,%esp
    ad0b:	c3                   	ret    

0000ad0c <mem_init>:

void mem_init(long start_mem, long end_mem)
{
    ad0c:	83 ec 10             	sub    $0x10,%esp
	int i;

	HIGH_MEMORY = end_mem;
    ad0f:	8b 44 24 18          	mov    0x18(%esp),%eax
    ad13:	a3 40 26 02 00       	mov    %eax,0x22640
	for (i=0 ; i<PAGING_PAGES ; i++)
    ad18:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    ad1f:	00 
    ad20:	eb 11                	jmp    ad33 <mem_init+0x27>
		mem_map[i] = USED;
    ad22:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ad26:	05 60 26 02 00       	add    $0x22660,%eax
    ad2b:	c6 00 64             	movb   $0x64,(%eax)
void mem_init(long start_mem, long end_mem)
{
	int i;

	HIGH_MEMORY = end_mem;
	for (i=0 ; i<PAGING_PAGES ; i++)
    ad2e:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    ad33:	81 7c 24 0c ff 0e 00 	cmpl   $0xeff,0xc(%esp)
    ad3a:	00 
    ad3b:	7e e5                	jle    ad22 <mem_init+0x16>
		mem_map[i] = USED;
	i = MAP_NR(start_mem);
    ad3d:	8b 44 24 14          	mov    0x14(%esp),%eax
    ad41:	2d 00 00 10 00       	sub    $0x100000,%eax
    ad46:	c1 f8 0c             	sar    $0xc,%eax
    ad49:	89 44 24 0c          	mov    %eax,0xc(%esp)
	end_mem -= start_mem;
    ad4d:	8b 44 24 14          	mov    0x14(%esp),%eax
    ad51:	29 44 24 18          	sub    %eax,0x18(%esp)
	end_mem >>= 12;
    ad55:	c1 7c 24 18 0c       	sarl   $0xc,0x18(%esp)
	while (end_mem-->0)
    ad5a:	eb 12                	jmp    ad6e <mem_init+0x62>
		mem_map[i++]=0;
    ad5c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ad60:	8d 50 01             	lea    0x1(%eax),%edx
    ad63:	89 54 24 0c          	mov    %edx,0xc(%esp)
    ad67:	c6 80 60 26 02 00 00 	movb   $0x0,0x22660(%eax)
	for (i=0 ; i<PAGING_PAGES ; i++)
		mem_map[i] = USED;
	i = MAP_NR(start_mem);
	end_mem -= start_mem;
	end_mem >>= 12;
	while (end_mem-->0)
    ad6e:	8b 44 24 18          	mov    0x18(%esp),%eax
    ad72:	8d 50 ff             	lea    -0x1(%eax),%edx
    ad75:	89 54 24 18          	mov    %edx,0x18(%esp)
    ad79:	85 c0                	test   %eax,%eax
    ad7b:	7f df                	jg     ad5c <mem_init+0x50>
		mem_map[i++]=0;
}
    ad7d:	90                   	nop
    ad7e:	83 c4 10             	add    $0x10,%esp
    ad81:	c3                   	ret    

0000ad82 <calc_mem>:

void calc_mem(void)
{
    ad82:	83 ec 2c             	sub    $0x2c,%esp
	int i,j,k,free=0;
    ad85:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    ad8c:	00 
	long * pg_tbl;

	for(i=0 ; i<PAGING_PAGES ; i++)
    ad8d:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    ad94:	00 
    ad95:	eb 1a                	jmp    adb1 <calc_mem+0x2f>
		if (!mem_map[i]) free++;
    ad97:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ad9b:	05 60 26 02 00       	add    $0x22660,%eax
    ada0:	0f b6 00             	movzbl (%eax),%eax
    ada3:	84 c0                	test   %al,%al
    ada5:	75 05                	jne    adac <calc_mem+0x2a>
    ada7:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
void calc_mem(void)
{
	int i,j,k,free=0;
	long * pg_tbl;

	for(i=0 ; i<PAGING_PAGES ; i++)
    adac:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    adb1:	81 7c 24 1c ff 0e 00 	cmpl   $0xeff,0x1c(%esp)
    adb8:	00 
    adb9:	7e dc                	jle    ad97 <calc_mem+0x15>
		if (!mem_map[i]) free++;
	printk("%d pages free (of %d)\n\r",free,PAGING_PAGES);
    adbb:	83 ec 04             	sub    $0x4,%esp
    adbe:	68 00 0f 00 00       	push   $0xf00
    adc3:	ff 74 24 18          	pushl  0x18(%esp)
    adc7:	68 61 86 01 00       	push   $0x18661
    adcc:	e8 3c da ff ff       	call   880d <printk>
    add1:	83 c4 10             	add    $0x10,%esp
	for(i=2 ; i<1024 ; i++) {
    add4:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
    addb:	00 
    addc:	e9 83 00 00 00       	jmp    ae64 <calc_mem+0xe2>
		if (1&pg_dir[i]) {
    ade1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ade5:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
    adec:	83 e0 01             	and    $0x1,%eax
    adef:	85 c0                	test   %eax,%eax
    adf1:	74 6c                	je     ae5f <calc_mem+0xdd>
			pg_tbl=(long *) (0xfffff000 & pg_dir[i]);
    adf3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    adf7:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
    adfe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    ae03:	89 44 24 0c          	mov    %eax,0xc(%esp)
			for(j=k=0 ; j<1024 ; j++)
    ae07:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    ae0e:	00 
    ae0f:	8b 44 24 14          	mov    0x14(%esp),%eax
    ae13:	89 44 24 18          	mov    %eax,0x18(%esp)
    ae17:	eb 24                	jmp    ae3d <calc_mem+0xbb>
				if (pg_tbl[j]&1)
    ae19:	8b 44 24 18          	mov    0x18(%esp),%eax
    ae1d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ae24:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ae28:	01 d0                	add    %edx,%eax
    ae2a:	8b 00                	mov    (%eax),%eax
    ae2c:	83 e0 01             	and    $0x1,%eax
    ae2f:	85 c0                	test   %eax,%eax
    ae31:	74 05                	je     ae38 <calc_mem+0xb6>
					k++;
    ae33:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
		if (!mem_map[i]) free++;
	printk("%d pages free (of %d)\n\r",free,PAGING_PAGES);
	for(i=2 ; i<1024 ; i++) {
		if (1&pg_dir[i]) {
			pg_tbl=(long *) (0xfffff000 & pg_dir[i]);
			for(j=k=0 ; j<1024 ; j++)
    ae38:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
    ae3d:	81 7c 24 18 ff 03 00 	cmpl   $0x3ff,0x18(%esp)
    ae44:	00 
    ae45:	7e d2                	jle    ae19 <calc_mem+0x97>
				if (pg_tbl[j]&1)
					k++;
			printk("Pg-dir[%d] uses %d pages\n",i,k);
    ae47:	83 ec 04             	sub    $0x4,%esp
    ae4a:	ff 74 24 18          	pushl  0x18(%esp)
    ae4e:	ff 74 24 24          	pushl  0x24(%esp)
    ae52:	68 79 86 01 00       	push   $0x18679
    ae57:	e8 b1 d9 ff ff       	call   880d <printk>
    ae5c:	83 c4 10             	add    $0x10,%esp
	long * pg_tbl;

	for(i=0 ; i<PAGING_PAGES ; i++)
		if (!mem_map[i]) free++;
	printk("%d pages free (of %d)\n\r",free,PAGING_PAGES);
	for(i=2 ; i<1024 ; i++) {
    ae5f:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    ae64:	81 7c 24 1c ff 03 00 	cmpl   $0x3ff,0x1c(%esp)
    ae6b:	00 
    ae6c:	0f 8e 6f ff ff ff    	jle    ade1 <calc_mem+0x5f>
				if (pg_tbl[j]&1)
					k++;
			printk("Pg-dir[%d] uses %d pages\n",i,k);
		}
	}
}
    ae72:	90                   	nop
    ae73:	83 c4 2c             	add    $0x2c,%esp
    ae76:	c3                   	ret    

0000ae77 <page_fault>:
 */

.globl page_fault

page_fault:
	xchgl %eax,(%esp)
    ae77:	87 04 24             	xchg   %eax,(%esp)
	pushl %ecx
    ae7a:	51                   	push   %ecx
	pushl %edx
    ae7b:	52                   	push   %edx
	push %ds
    ae7c:	1e                   	push   %ds
	push %es
    ae7d:	06                   	push   %es
	push %fs
    ae7e:	0f a0                	push   %fs
	movl $0x10,%edx
    ae80:	ba 10 00 00 00       	mov    $0x10,%edx
	mov %dx,%ds
    ae85:	8e da                	mov    %edx,%ds
	mov %dx,%es
    ae87:	8e c2                	mov    %edx,%es
	mov %dx,%fs
    ae89:	8e e2                	mov    %edx,%fs
	movl %cr2,%edx
    ae8b:	0f 20 d2             	mov    %cr2,%edx
	pushl %edx
    ae8e:	52                   	push   %edx
	pushl %eax
    ae8f:	50                   	push   %eax
	testl $1,%eax
    ae90:	a9 01 00 00 00       	test   $0x1,%eax
	jne 1f
    ae95:	75 07                	jne    ae9e <page_fault+0x27>
	call do_no_page
    ae97:	e8 ff fc ff ff       	call   ab9b <do_no_page>
	jmp 2f
    ae9c:	eb 05                	jmp    aea3 <page_fault+0x2c>
1:	call do_wp_page
    ae9e:	e8 d0 f9 ff ff       	call   a873 <do_wp_page>
2:	addl $8,%esp
    aea3:	83 c4 08             	add    $0x8,%esp
	pop %fs
    aea6:	0f a1                	pop    %fs
	pop %es
    aea8:	07                   	pop    %es
	pop %ds
    aea9:	1f                   	pop    %ds
	popl %edx
    aeaa:	5a                   	pop    %edx
	popl %ecx
    aeab:	59                   	pop    %ecx
	popl %eax
    aeac:	58                   	pop    %eax
	iret
    aead:	cf                   	iret   

0000aeae <get_fs_long>:
	__asm__ ("movw %%fs:%1,%0":"=r" (_v):"m" (*addr));
	return _v;
}

static inline unsigned long get_fs_long(const unsigned long *addr)
{
    aeae:	83 ec 10             	sub    $0x10,%esp
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
    aeb1:	8b 44 24 14          	mov    0x14(%esp),%eax
    aeb5:	64 8b 00             	mov    %fs:(%eax),%eax
    aeb8:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
    aebc:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    aec0:	83 c4 10             	add    $0x10,%esp
    aec3:	c3                   	ret    

0000aec4 <sys_ustat>:
#include <linux/kernel.h>
#include <asm/segment.h>

int sys_ustat(int dev, struct ustat * ubuf)
{
	return -ENOSYS;
    aec4:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    aec9:	c3                   	ret    

0000aeca <sys_utime>:

int sys_utime(char * filename, struct utimbuf * times)
{
    aeca:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;
	long actime,modtime;

	if (!(inode=namei(filename)))
    aecd:	83 ec 0c             	sub    $0xc,%esp
    aed0:	ff 74 24 2c          	pushl  0x2c(%esp)
    aed4:	e8 3f 58 00 00       	call   10718 <namei>
    aed9:	83 c4 10             	add    $0x10,%esp
    aedc:	89 44 24 04          	mov    %eax,0x4(%esp)
    aee0:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    aee5:	75 0a                	jne    aef1 <sys_utime+0x27>
		return -ENOENT;
    aee7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    aeec:	e9 92 00 00 00       	jmp    af83 <sys_utime+0xb9>
	if (times) {
    aef1:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    aef6:	74 2d                	je     af25 <sys_utime+0x5b>
		actime = get_fs_long((unsigned long *) &times->actime);
    aef8:	8b 44 24 24          	mov    0x24(%esp),%eax
    aefc:	83 ec 0c             	sub    $0xc,%esp
    aeff:	50                   	push   %eax
    af00:	e8 a9 ff ff ff       	call   aeae <get_fs_long>
    af05:	83 c4 10             	add    $0x10,%esp
    af08:	89 44 24 0c          	mov    %eax,0xc(%esp)
		modtime = get_fs_long((unsigned long *) &times->modtime);
    af0c:	8b 44 24 24          	mov    0x24(%esp),%eax
    af10:	83 c0 04             	add    $0x4,%eax
    af13:	83 ec 0c             	sub    $0xc,%esp
    af16:	50                   	push   %eax
    af17:	e8 92 ff ff ff       	call   aeae <get_fs_long>
    af1c:	83 c4 10             	add    $0x10,%esp
    af1f:	89 44 24 08          	mov    %eax,0x8(%esp)
    af23:	eb 2c                	jmp    af51 <sys_utime+0x87>
	} else
		actime = modtime = CURRENT_TIME;
    af25:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    af2b:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    af30:	89 c8                	mov    %ecx,%eax
    af32:	f7 ea                	imul   %edx
    af34:	c1 fa 05             	sar    $0x5,%edx
    af37:	89 c8                	mov    %ecx,%eax
    af39:	c1 f8 1f             	sar    $0x1f,%eax
    af3c:	29 c2                	sub    %eax,%edx
    af3e:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
    af43:	01 d0                	add    %edx,%eax
    af45:	89 44 24 08          	mov    %eax,0x8(%esp)
    af49:	8b 44 24 08          	mov    0x8(%esp),%eax
    af4d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	inode->i_atime = actime;
    af51:	8b 54 24 0c          	mov    0xc(%esp),%edx
    af55:	8b 44 24 04          	mov    0x4(%esp),%eax
    af59:	89 50 24             	mov    %edx,0x24(%eax)
	inode->i_mtime = modtime;
    af5c:	8b 54 24 08          	mov    0x8(%esp),%edx
    af60:	8b 44 24 04          	mov    0x4(%esp),%eax
    af64:	89 50 08             	mov    %edx,0x8(%eax)
	inode->i_dirt = 1;
    af67:	8b 44 24 04          	mov    0x4(%esp),%eax
    af6b:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(inode);
    af6f:	83 ec 0c             	sub    $0xc,%esp
    af72:	ff 74 24 10          	pushl  0x10(%esp)
    af76:	e8 f6 10 00 00       	call   c071 <iput>
    af7b:	83 c4 10             	add    $0x10,%esp
	return 0;
    af7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    af83:	83 c4 1c             	add    $0x1c,%esp
    af86:	c3                   	ret    

0000af87 <sys_access>:
/*
 * XXX should we use the real or effective uid?  BSD uses the real uid,
 * so as to make this call useful to setuid programs.
 */
int sys_access(const char * filename,int mode)
{
    af87:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;
	int res, i_mode;

	mode &= 0007;
    af8a:	83 64 24 24 07       	andl   $0x7,0x24(%esp)
	if (!(inode=namei(filename)))
    af8f:	83 ec 0c             	sub    $0xc,%esp
    af92:	ff 74 24 2c          	pushl  0x2c(%esp)
    af96:	e8 7d 57 00 00       	call   10718 <namei>
    af9b:	83 c4 10             	add    $0x10,%esp
    af9e:	89 44 24 08          	mov    %eax,0x8(%esp)
    afa2:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    afa7:	75 0a                	jne    afb3 <sys_access+0x2c>
		return -EACCES;
    afa9:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    afae:	e9 b6 00 00 00       	jmp    b069 <sys_access+0xe2>
	i_mode = res = inode->i_mode & 0777;
    afb3:	8b 44 24 08          	mov    0x8(%esp),%eax
    afb7:	0f b7 00             	movzwl (%eax),%eax
    afba:	0f b7 c0             	movzwl %ax,%eax
    afbd:	25 ff 01 00 00       	and    $0x1ff,%eax
    afc2:	89 44 24 0c          	mov    %eax,0xc(%esp)
    afc6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    afca:	89 44 24 04          	mov    %eax,0x4(%esp)
	iput(inode);
    afce:	83 ec 0c             	sub    $0xc,%esp
    afd1:	ff 74 24 14          	pushl  0x14(%esp)
    afd5:	e8 97 10 00 00       	call   c071 <iput>
    afda:	83 c4 10             	add    $0x10,%esp
	if (current->uid == inode->i_uid)
    afdd:	a1 40 f1 01 00       	mov    0x1f140,%eax
    afe2:	0f b7 90 40 02 00 00 	movzwl 0x240(%eax),%edx
    afe9:	8b 44 24 08          	mov    0x8(%esp),%eax
    afed:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    aff1:	66 39 c2             	cmp    %ax,%dx
    aff4:	75 07                	jne    affd <sys_access+0x76>
		res >>= 6;
    aff6:	c1 7c 24 0c 06       	sarl   $0x6,0xc(%esp)
    affb:	eb 21                	jmp    b01e <sys_access+0x97>
	else if (current->gid == inode->i_gid)
    affd:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b002:	0f b7 90 46 02 00 00 	movzwl 0x246(%eax),%edx
    b009:	8b 44 24 08          	mov    0x8(%esp),%eax
    b00d:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    b011:	0f b6 c0             	movzbl %al,%eax
    b014:	66 39 c2             	cmp    %ax,%dx
    b017:	75 05                	jne    b01e <sys_access+0x97>
		res >>= 6;
    b019:	c1 7c 24 0c 06       	sarl   $0x6,0xc(%esp)
	if ((res & 0007 & mode) == mode)
    b01e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b022:	83 e0 07             	and    $0x7,%eax
    b025:	23 44 24 24          	and    0x24(%esp),%eax
    b029:	3b 44 24 24          	cmp    0x24(%esp),%eax
    b02d:	75 07                	jne    b036 <sys_access+0xaf>
		return 0;
    b02f:	b8 00 00 00 00       	mov    $0x0,%eax
    b034:	eb 33                	jmp    b069 <sys_access+0xe2>
	 * XXX we are doing this test last because we really should be
	 * swapping the effective with the real user id (temporarily),
	 * and then calling suser() routine.  If we do call the
	 * suser() routine, it needs to be called last. 
	 */
	if ((!current->uid) &&
    b036:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b03b:	0f b7 80 40 02 00 00 	movzwl 0x240(%eax),%eax
    b042:	66 85 c0             	test   %ax,%ax
    b045:	75 1d                	jne    b064 <sys_access+0xdd>
	    (!(mode & 1) || (i_mode & 0111)))
    b047:	8b 44 24 24          	mov    0x24(%esp),%eax
    b04b:	83 e0 01             	and    $0x1,%eax
	 * XXX we are doing this test last because we really should be
	 * swapping the effective with the real user id (temporarily),
	 * and then calling suser() routine.  If we do call the
	 * suser() routine, it needs to be called last. 
	 */
	if ((!current->uid) &&
    b04e:	85 c0                	test   %eax,%eax
    b050:	74 0b                	je     b05d <sys_access+0xd6>
	    (!(mode & 1) || (i_mode & 0111)))
    b052:	8b 44 24 04          	mov    0x4(%esp),%eax
    b056:	83 e0 49             	and    $0x49,%eax
    b059:	85 c0                	test   %eax,%eax
    b05b:	74 07                	je     b064 <sys_access+0xdd>
		return 0;
    b05d:	b8 00 00 00 00       	mov    $0x0,%eax
    b062:	eb 05                	jmp    b069 <sys_access+0xe2>
	return -EACCES;
    b064:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
}
    b069:	83 c4 1c             	add    $0x1c,%esp
    b06c:	c3                   	ret    

0000b06d <sys_chdir>:

int sys_chdir(const char * filename)
{
    b06d:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;

	if (!(inode = namei(filename)))
    b070:	83 ec 0c             	sub    $0xc,%esp
    b073:	ff 74 24 2c          	pushl  0x2c(%esp)
    b077:	e8 9c 56 00 00       	call   10718 <namei>
    b07c:	83 c4 10             	add    $0x10,%esp
    b07f:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b083:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b088:	75 07                	jne    b091 <sys_chdir+0x24>
		return -ENOENT;
    b08a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    b08f:	eb 57                	jmp    b0e8 <sys_chdir+0x7b>
	if (!S_ISDIR(inode->i_mode)) {
    b091:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b095:	0f b7 00             	movzwl (%eax),%eax
    b098:	0f b7 c0             	movzwl %ax,%eax
    b09b:	25 00 f0 00 00       	and    $0xf000,%eax
    b0a0:	3d 00 40 00 00       	cmp    $0x4000,%eax
    b0a5:	74 16                	je     b0bd <sys_chdir+0x50>
		iput(inode);
    b0a7:	83 ec 0c             	sub    $0xc,%esp
    b0aa:	ff 74 24 18          	pushl  0x18(%esp)
    b0ae:	e8 be 0f 00 00       	call   c071 <iput>
    b0b3:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
    b0b6:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
    b0bb:	eb 2b                	jmp    b0e8 <sys_chdir+0x7b>
	}
	iput(current->pwd);
    b0bd:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b0c2:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
    b0c8:	83 ec 0c             	sub    $0xc,%esp
    b0cb:	50                   	push   %eax
    b0cc:	e8 a0 0f 00 00       	call   c071 <iput>
    b0d1:	83 c4 10             	add    $0x10,%esp
	current->pwd = inode;
    b0d4:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b0d9:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b0dd:	89 90 70 02 00 00    	mov    %edx,0x270(%eax)
	return (0);
    b0e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b0e8:	83 c4 1c             	add    $0x1c,%esp
    b0eb:	c3                   	ret    

0000b0ec <sys_chroot>:

int sys_chroot(const char * filename)
{
    b0ec:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;

	if (!(inode=namei(filename)))
    b0ef:	83 ec 0c             	sub    $0xc,%esp
    b0f2:	ff 74 24 2c          	pushl  0x2c(%esp)
    b0f6:	e8 1d 56 00 00       	call   10718 <namei>
    b0fb:	83 c4 10             	add    $0x10,%esp
    b0fe:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b102:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b107:	75 07                	jne    b110 <sys_chroot+0x24>
		return -ENOENT;
    b109:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    b10e:	eb 57                	jmp    b167 <sys_chroot+0x7b>
	if (!S_ISDIR(inode->i_mode)) {
    b110:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b114:	0f b7 00             	movzwl (%eax),%eax
    b117:	0f b7 c0             	movzwl %ax,%eax
    b11a:	25 00 f0 00 00       	and    $0xf000,%eax
    b11f:	3d 00 40 00 00       	cmp    $0x4000,%eax
    b124:	74 16                	je     b13c <sys_chroot+0x50>
		iput(inode);
    b126:	83 ec 0c             	sub    $0xc,%esp
    b129:	ff 74 24 18          	pushl  0x18(%esp)
    b12d:	e8 3f 0f 00 00       	call   c071 <iput>
    b132:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
    b135:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
    b13a:	eb 2b                	jmp    b167 <sys_chroot+0x7b>
	}
	iput(current->root);
    b13c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b141:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
    b147:	83 ec 0c             	sub    $0xc,%esp
    b14a:	50                   	push   %eax
    b14b:	e8 21 0f 00 00       	call   c071 <iput>
    b150:	83 c4 10             	add    $0x10,%esp
	current->root = inode;
    b153:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b158:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b15c:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
	return (0);
    b162:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b167:	83 c4 1c             	add    $0x1c,%esp
    b16a:	c3                   	ret    

0000b16b <sys_chmod>:

int sys_chmod(const char * filename,int mode)
{
    b16b:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;

	if (!(inode=namei(filename)))
    b16e:	83 ec 0c             	sub    $0xc,%esp
    b171:	ff 74 24 2c          	pushl  0x2c(%esp)
    b175:	e8 9e 55 00 00       	call   10718 <namei>
    b17a:	83 c4 10             	add    $0x10,%esp
    b17d:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b181:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b186:	75 07                	jne    b18f <sys_chmod+0x24>
		return -ENOENT;
    b188:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    b18d:	eb 7c                	jmp    b20b <sys_chmod+0xa0>
	if ((current->euid != inode->i_uid) && !suser()) {
    b18f:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b194:	0f b7 90 42 02 00 00 	movzwl 0x242(%eax),%edx
    b19b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b19f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    b1a3:	66 39 c2             	cmp    %ax,%dx
    b1a6:	74 27                	je     b1cf <sys_chmod+0x64>
    b1a8:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b1ad:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    b1b4:	66 85 c0             	test   %ax,%ax
    b1b7:	74 16                	je     b1cf <sys_chmod+0x64>
		iput(inode);
    b1b9:	83 ec 0c             	sub    $0xc,%esp
    b1bc:	ff 74 24 18          	pushl  0x18(%esp)
    b1c0:	e8 ac 0e 00 00       	call   c071 <iput>
    b1c5:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    b1c8:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    b1cd:	eb 3c                	jmp    b20b <sys_chmod+0xa0>
	}
	inode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);
    b1cf:	8b 44 24 24          	mov    0x24(%esp),%eax
    b1d3:	66 25 ff 0f          	and    $0xfff,%ax
    b1d7:	89 c2                	mov    %eax,%edx
    b1d9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b1dd:	0f b7 00             	movzwl (%eax),%eax
    b1e0:	66 25 00 f0          	and    $0xf000,%ax
    b1e4:	09 d0                	or     %edx,%eax
    b1e6:	89 c2                	mov    %eax,%edx
    b1e8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b1ec:	66 89 10             	mov    %dx,(%eax)
	inode->i_dirt = 1;
    b1ef:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b1f3:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(inode);
    b1f7:	83 ec 0c             	sub    $0xc,%esp
    b1fa:	ff 74 24 18          	pushl  0x18(%esp)
    b1fe:	e8 6e 0e 00 00       	call   c071 <iput>
    b203:	83 c4 10             	add    $0x10,%esp
	return 0;
    b206:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b20b:	83 c4 1c             	add    $0x1c,%esp
    b20e:	c3                   	ret    

0000b20f <sys_chown>:

int sys_chown(const char * filename,int uid,int gid)
{
    b20f:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;

	if (!(inode=namei(filename)))
    b212:	83 ec 0c             	sub    $0xc,%esp
    b215:	ff 74 24 2c          	pushl  0x2c(%esp)
    b219:	e8 fa 54 00 00       	call   10718 <namei>
    b21e:	83 c4 10             	add    $0x10,%esp
    b221:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b225:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b22a:	75 07                	jne    b233 <sys_chown+0x24>
		return -ENOENT;
    b22c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    b231:	eb 5e                	jmp    b291 <sys_chown+0x82>
	if (!suser()) {
    b233:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b238:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    b23f:	66 85 c0             	test   %ax,%ax
    b242:	74 16                	je     b25a <sys_chown+0x4b>
		iput(inode);
    b244:	83 ec 0c             	sub    $0xc,%esp
    b247:	ff 74 24 18          	pushl  0x18(%esp)
    b24b:	e8 21 0e 00 00       	call   c071 <iput>
    b250:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    b253:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    b258:	eb 37                	jmp    b291 <sys_chown+0x82>
	}
	inode->i_uid=uid;
    b25a:	8b 44 24 24          	mov    0x24(%esp),%eax
    b25e:	89 c2                	mov    %eax,%edx
    b260:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b264:	66 89 50 02          	mov    %dx,0x2(%eax)
	inode->i_gid=gid;
    b268:	8b 44 24 28          	mov    0x28(%esp),%eax
    b26c:	89 c2                	mov    %eax,%edx
    b26e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b272:	88 50 0c             	mov    %dl,0xc(%eax)
	inode->i_dirt=1;
    b275:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b279:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(inode);
    b27d:	83 ec 0c             	sub    $0xc,%esp
    b280:	ff 74 24 18          	pushl  0x18(%esp)
    b284:	e8 e8 0d 00 00       	call   c071 <iput>
    b289:	83 c4 10             	add    $0x10,%esp
	return 0;
    b28c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b291:	83 c4 1c             	add    $0x1c,%esp
    b294:	c3                   	ret    

0000b295 <sys_open>:

int sys_open(const char * filename,int flag,int mode)
{
    b295:	56                   	push   %esi
    b296:	53                   	push   %ebx
    b297:	83 ec 14             	sub    $0x14,%esp
	struct m_inode * inode;
	struct file * f;
	int i,fd;

	mode &= 0777 & ~current->umask;
    b29a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b29f:	0f b7 80 6c 02 00 00 	movzwl 0x26c(%eax),%eax
    b2a6:	0f b7 c0             	movzwl %ax,%eax
    b2a9:	f7 d0                	not    %eax
    b2ab:	25 ff 01 00 00       	and    $0x1ff,%eax
    b2b0:	21 44 24 28          	and    %eax,0x28(%esp)
	for(fd=0 ; fd<NR_OPEN ; fd++)
    b2b4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    b2bb:	00 
    b2bc:	eb 1b                	jmp    b2d9 <sys_open+0x44>
		if (!current->filp[fd])
    b2be:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b2c3:	8b 54 24 04          	mov    0x4(%esp),%edx
    b2c7:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b2cd:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b2d0:	85 c0                	test   %eax,%eax
    b2d2:	74 0e                	je     b2e2 <sys_open+0x4d>
	struct m_inode * inode;
	struct file * f;
	int i,fd;

	mode &= 0777 & ~current->umask;
	for(fd=0 ; fd<NR_OPEN ; fd++)
    b2d4:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
    b2d9:	83 7c 24 04 13       	cmpl   $0x13,0x4(%esp)
    b2de:	7e de                	jle    b2be <sys_open+0x29>
    b2e0:	eb 01                	jmp    b2e3 <sys_open+0x4e>
		if (!current->filp[fd])
			break;
    b2e2:	90                   	nop
	if (fd>=NR_OPEN)
    b2e3:	83 7c 24 04 13       	cmpl   $0x13,0x4(%esp)
    b2e8:	7e 0a                	jle    b2f4 <sys_open+0x5f>
		return -EINVAL;
    b2ea:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b2ef:	e9 34 02 00 00       	jmp    b528 <sys_open+0x293>
	current->close_on_exec &= ~(1<<fd);
    b2f4:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b2f9:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    b2ff:	8b 9a 7c 02 00 00    	mov    0x27c(%edx),%ebx
    b305:	8b 54 24 04          	mov    0x4(%esp),%edx
    b309:	be 01 00 00 00       	mov    $0x1,%esi
    b30e:	89 d1                	mov    %edx,%ecx
    b310:	d3 e6                	shl    %cl,%esi
    b312:	89 f2                	mov    %esi,%edx
    b314:	f7 d2                	not    %edx
    b316:	21 da                	and    %ebx,%edx
    b318:	89 90 7c 02 00 00    	mov    %edx,0x27c(%eax)
	f=0+file_table;
    b31e:	c7 44 24 0c e0 56 02 	movl   $0x256e0,0xc(%esp)
    b325:	00 
	for (i=0 ; i<NR_FILE ; i++,f++)
    b326:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b32d:	00 
    b32e:	eb 17                	jmp    b347 <sys_open+0xb2>
		if (!f->f_count) break;
    b330:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b334:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    b338:	66 85 c0             	test   %ax,%ax
    b33b:	74 13                	je     b350 <sys_open+0xbb>
			break;
	if (fd>=NR_OPEN)
		return -EINVAL;
	current->close_on_exec &= ~(1<<fd);
	f=0+file_table;
	for (i=0 ; i<NR_FILE ; i++,f++)
    b33d:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    b342:	83 44 24 0c 10       	addl   $0x10,0xc(%esp)
    b347:	83 7c 24 08 3f       	cmpl   $0x3f,0x8(%esp)
    b34c:	7e e2                	jle    b330 <sys_open+0x9b>
    b34e:	eb 01                	jmp    b351 <sys_open+0xbc>
		if (!f->f_count) break;
    b350:	90                   	nop
	if (i>=NR_FILE)
    b351:	83 7c 24 08 3f       	cmpl   $0x3f,0x8(%esp)
    b356:	7e 0a                	jle    b362 <sys_open+0xcd>
		return -EINVAL;
    b358:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b35d:	e9 c6 01 00 00       	jmp    b528 <sys_open+0x293>
	(current->filp[fd]=f)->f_count++;
    b362:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b367:	8b 54 24 04          	mov    0x4(%esp),%edx
    b36b:	8d 8a a0 00 00 00    	lea    0xa0(%edx),%ecx
    b371:	8b 54 24 0c          	mov    0xc(%esp),%edx
    b375:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    b378:	8b 54 24 04          	mov    0x4(%esp),%edx
    b37c:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b382:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b385:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    b389:	83 c2 01             	add    $0x1,%edx
    b38c:	66 89 50 04          	mov    %dx,0x4(%eax)
	if ((i=open_namei(filename,flag,mode,&inode))<0) {
    b390:	89 e0                	mov    %esp,%eax
    b392:	50                   	push   %eax
    b393:	ff 74 24 2c          	pushl  0x2c(%esp)
    b397:	ff 74 24 2c          	pushl  0x2c(%esp)
    b39b:	ff 74 24 2c          	pushl  0x2c(%esp)
    b39f:	e8 8c 54 00 00       	call   10830 <open_namei>
    b3a4:	83 c4 10             	add    $0x10,%esp
    b3a7:	89 44 24 08          	mov    %eax,0x8(%esp)
    b3ab:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    b3b0:	79 29                	jns    b3db <sys_open+0x146>
		current->filp[fd]=NULL;
    b3b2:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b3b7:	8b 54 24 04          	mov    0x4(%esp),%edx
    b3bb:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b3c1:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
		f->f_count=0;
    b3c8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b3cc:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		return i;
    b3d2:	8b 44 24 08          	mov    0x8(%esp),%eax
    b3d6:	e9 4d 01 00 00       	jmp    b528 <sys_open+0x293>
	}
/* ttys are somewhat special (ttyxx major==4, tty major==5) */
	if (S_ISCHR(inode->i_mode)) {
    b3db:	8b 04 24             	mov    (%esp),%eax
    b3de:	0f b7 00             	movzwl (%eax),%eax
    b3e1:	0f b7 c0             	movzwl %ax,%eax
    b3e4:	25 00 f0 00 00       	and    $0xf000,%eax
    b3e9:	3d 00 20 00 00       	cmp    $0x2000,%eax
    b3ee:	0f 85 cb 00 00 00    	jne    b4bf <sys_open+0x22a>
		if (MAJOR(inode->i_zone[0])==4) {
    b3f4:	8b 04 24             	mov    (%esp),%eax
    b3f7:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b3fb:	66 c1 e8 08          	shr    $0x8,%ax
    b3ff:	66 83 f8 04          	cmp    $0x4,%ax
    b403:	75 64                	jne    b469 <sys_open+0x1d4>
			if (current->leader && current->tty<0) {
    b405:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b40a:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
    b410:	85 c0                	test   %eax,%eax
    b412:	0f 84 a7 00 00 00    	je     b4bf <sys_open+0x22a>
    b418:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b41d:	8b 80 68 02 00 00    	mov    0x268(%eax),%eax
    b423:	85 c0                	test   %eax,%eax
    b425:	0f 89 94 00 00 00    	jns    b4bf <sys_open+0x22a>
				current->tty = MINOR(inode->i_zone[0]);
    b42b:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b430:	8b 14 24             	mov    (%esp),%edx
    b433:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
    b437:	0f b7 d2             	movzwl %dx,%edx
    b43a:	0f b6 d2             	movzbl %dl,%edx
    b43d:	89 90 68 02 00 00    	mov    %edx,0x268(%eax)
				tty_table[current->tty].pgrp = current->pgrp;
    b443:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b448:	8b 90 68 02 00 00    	mov    0x268(%eax),%edx
    b44e:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b453:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    b459:	69 d2 60 0c 00 00    	imul   $0xc60,%edx,%edx
    b45f:	81 c2 64 f4 01 00    	add    $0x1f464,%edx
    b465:	89 02                	mov    %eax,(%edx)
    b467:	eb 56                	jmp    b4bf <sys_open+0x22a>
			}
		} else if (MAJOR(inode->i_zone[0])==5)
    b469:	8b 04 24             	mov    (%esp),%eax
    b46c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b470:	66 c1 e8 08          	shr    $0x8,%ax
    b474:	66 83 f8 05          	cmp    $0x5,%ax
    b478:	75 45                	jne    b4bf <sys_open+0x22a>
			if (current->tty<0) {
    b47a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b47f:	8b 80 68 02 00 00    	mov    0x268(%eax),%eax
    b485:	85 c0                	test   %eax,%eax
    b487:	79 36                	jns    b4bf <sys_open+0x22a>
				iput(inode);
    b489:	8b 04 24             	mov    (%esp),%eax
    b48c:	83 ec 0c             	sub    $0xc,%esp
    b48f:	50                   	push   %eax
    b490:	e8 dc 0b 00 00       	call   c071 <iput>
    b495:	83 c4 10             	add    $0x10,%esp
				current->filp[fd]=NULL;
    b498:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b49d:	8b 54 24 04          	mov    0x4(%esp),%edx
    b4a1:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b4a7:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
				f->f_count=0;
    b4ae:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b4b2:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
				return -EPERM;
    b4b8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b4bd:	eb 69                	jmp    b528 <sys_open+0x293>
			}
	}
/* Likewise with block-devices: check for floppy_change */
	if (S_ISBLK(inode->i_mode))
    b4bf:	8b 04 24             	mov    (%esp),%eax
    b4c2:	0f b7 00             	movzwl (%eax),%eax
    b4c5:	0f b7 c0             	movzwl %ax,%eax
    b4c8:	25 00 f0 00 00       	and    $0xf000,%eax
    b4cd:	3d 00 60 00 00       	cmp    $0x6000,%eax
    b4d2:	75 16                	jne    b4ea <sys_open+0x255>
		check_disk_change(inode->i_zone[0]);
    b4d4:	8b 04 24             	mov    (%esp),%eax
    b4d7:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b4db:	0f b7 c0             	movzwl %ax,%eax
    b4de:	83 ec 0c             	sub    $0xc,%esp
    b4e1:	50                   	push   %eax
    b4e2:	e8 60 15 00 00       	call   ca47 <check_disk_change>
    b4e7:	83 c4 10             	add    $0x10,%esp
	f->f_mode = inode->i_mode;
    b4ea:	8b 04 24             	mov    (%esp),%eax
    b4ed:	0f b7 10             	movzwl (%eax),%edx
    b4f0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b4f4:	66 89 10             	mov    %dx,(%eax)
	f->f_flags = flag;
    b4f7:	8b 44 24 24          	mov    0x24(%esp),%eax
    b4fb:	89 c2                	mov    %eax,%edx
    b4fd:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b501:	66 89 50 02          	mov    %dx,0x2(%eax)
	f->f_count = 1;
    b505:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b509:	66 c7 40 04 01 00    	movw   $0x1,0x4(%eax)
	f->f_inode = inode;
    b50f:	8b 14 24             	mov    (%esp),%edx
    b512:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b516:	89 50 08             	mov    %edx,0x8(%eax)
	f->f_pos = 0;
    b519:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b51d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return (fd);
    b524:	8b 44 24 04          	mov    0x4(%esp),%eax
}
    b528:	83 c4 14             	add    $0x14,%esp
    b52b:	5b                   	pop    %ebx
    b52c:	5e                   	pop    %esi
    b52d:	c3                   	ret    

0000b52e <sys_creat>:

int sys_creat(const char * pathname, int mode)
{
    b52e:	83 ec 0c             	sub    $0xc,%esp
	return sys_open(pathname, O_CREAT | O_TRUNC, mode);
    b531:	83 ec 04             	sub    $0x4,%esp
    b534:	ff 74 24 18          	pushl  0x18(%esp)
    b538:	68 40 02 00 00       	push   $0x240
    b53d:	ff 74 24 1c          	pushl  0x1c(%esp)
    b541:	e8 4f fd ff ff       	call   b295 <sys_open>
    b546:	83 c4 10             	add    $0x10,%esp
}
    b549:	83 c4 0c             	add    $0xc,%esp
    b54c:	c3                   	ret    

0000b54d <sys_close>:

int sys_close(unsigned int fd)
{	
    b54d:	56                   	push   %esi
    b54e:	53                   	push   %ebx
    b54f:	83 ec 14             	sub    $0x14,%esp
	struct file * filp;

	if (fd >= NR_OPEN)
    b552:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    b557:	76 0a                	jbe    b563 <sys_close+0x16>
		return -EINVAL;
    b559:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b55e:	e9 c0 00 00 00       	jmp    b623 <sys_close+0xd6>
	current->close_on_exec &= ~(1<<fd);
    b563:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b568:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    b56e:	8b 9a 7c 02 00 00    	mov    0x27c(%edx),%ebx
    b574:	8b 54 24 20          	mov    0x20(%esp),%edx
    b578:	be 01 00 00 00       	mov    $0x1,%esi
    b57d:	89 d1                	mov    %edx,%ecx
    b57f:	d3 e6                	shl    %cl,%esi
    b581:	89 f2                	mov    %esi,%edx
    b583:	f7 d2                	not    %edx
    b585:	21 da                	and    %ebx,%edx
    b587:	89 90 7c 02 00 00    	mov    %edx,0x27c(%eax)
	if (!(filp = current->filp[fd]))
    b58d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b592:	8b 54 24 20          	mov    0x20(%esp),%edx
    b596:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b59c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b59f:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b5a3:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b5a8:	75 07                	jne    b5b1 <sys_close+0x64>
		return -EINVAL;
    b5aa:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b5af:	eb 72                	jmp    b623 <sys_close+0xd6>
	current->filp[fd] = NULL;
    b5b1:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b5b6:	8b 54 24 20          	mov    0x20(%esp),%edx
    b5ba:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b5c0:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
	if (filp->f_count == 0)
    b5c7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5cb:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    b5cf:	66 85 c0             	test   %ax,%ax
    b5d2:	75 10                	jne    b5e4 <sys_close+0x97>
		panic("Close: file count is 0");
    b5d4:	83 ec 0c             	sub    $0xc,%esp
    b5d7:	68 94 86 01 00       	push   $0x18694
    b5dc:	e8 ed d1 ff ff       	call   87ce <panic>
    b5e1:	83 c4 10             	add    $0x10,%esp
	if (--filp->f_count)
    b5e4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5e8:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    b5ec:	8d 50 ff             	lea    -0x1(%eax),%edx
    b5ef:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5f3:	66 89 50 04          	mov    %dx,0x4(%eax)
    b5f7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5fb:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    b5ff:	66 85 c0             	test   %ax,%ax
    b602:	74 07                	je     b60b <sys_close+0xbe>
		return (0);
    b604:	b8 00 00 00 00       	mov    $0x0,%eax
    b609:	eb 18                	jmp    b623 <sys_close+0xd6>
	iput(filp->f_inode);
    b60b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b60f:	8b 40 08             	mov    0x8(%eax),%eax
    b612:	83 ec 0c             	sub    $0xc,%esp
    b615:	50                   	push   %eax
    b616:	e8 56 0a 00 00       	call   c071 <iput>
    b61b:	83 c4 10             	add    $0x10,%esp
	return (0);
    b61e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b623:	83 c4 14             	add    $0x14,%esp
    b626:	5b                   	pop    %ebx
    b627:	5e                   	pop    %esi
    b628:	c3                   	ret    

0000b629 <sys_lseek>:
		char * buf, int count);
extern int file_write(struct m_inode * inode, struct file * filp,
		char * buf, int count);

int sys_lseek(unsigned int fd,off_t offset, int origin)
{
    b629:	83 ec 10             	sub    $0x10,%esp
	struct file * file;
	int tmp;

	if (fd >= NR_OPEN || !(file=current->filp[fd]) || !(file->f_inode)
    b62c:	83 7c 24 14 13       	cmpl   $0x13,0x14(%esp)
    b631:	77 51                	ja     b684 <sys_lseek+0x5b>
    b633:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b638:	8b 54 24 14          	mov    0x14(%esp),%edx
    b63c:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b642:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b645:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b649:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b64e:	74 34                	je     b684 <sys_lseek+0x5b>
    b650:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b654:	8b 40 08             	mov    0x8(%eax),%eax
    b657:	85 c0                	test   %eax,%eax
    b659:	74 29                	je     b684 <sys_lseek+0x5b>
	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))
    b65b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b65f:	8b 40 08             	mov    0x8(%eax),%eax
    b662:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b666:	66 c1 e8 08          	shr    $0x8,%ax
    b66a:	66 85 c0             	test   %ax,%ax
    b66d:	74 15                	je     b684 <sys_lseek+0x5b>
    b66f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b673:	8b 40 08             	mov    0x8(%eax),%eax
    b676:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b67a:	66 c1 e8 08          	shr    $0x8,%ax
    b67e:	66 83 f8 03          	cmp    $0x3,%ax
    b682:	76 0a                	jbe    b68e <sys_lseek+0x65>
		return -EBADF;
    b684:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    b689:	e9 b1 00 00 00       	jmp    b73f <sys_lseek+0x116>
	if (file->f_inode->i_pipe)
    b68e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b692:	8b 40 08             	mov    0x8(%eax),%eax
    b695:	0f b6 40 34          	movzbl 0x34(%eax),%eax
    b699:	84 c0                	test   %al,%al
    b69b:	74 0a                	je     b6a7 <sys_lseek+0x7e>
		return -ESPIPE;
    b69d:	b8 e3 ff ff ff       	mov    $0xffffffe3,%eax
    b6a2:	e9 98 00 00 00       	jmp    b73f <sys_lseek+0x116>
	switch (origin) {
    b6a7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    b6ab:	83 f8 01             	cmp    $0x1,%eax
    b6ae:	74 24                	je     b6d4 <sys_lseek+0xab>
    b6b0:	83 f8 02             	cmp    $0x2,%eax
    b6b3:	74 4d                	je     b702 <sys_lseek+0xd9>
    b6b5:	85 c0                	test   %eax,%eax
    b6b7:	75 78                	jne    b731 <sys_lseek+0x108>
		case 0:
			if (offset<0) return -EINVAL;
    b6b9:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    b6be:	79 07                	jns    b6c7 <sys_lseek+0x9e>
    b6c0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b6c5:	eb 78                	jmp    b73f <sys_lseek+0x116>
			file->f_pos=offset;
    b6c7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b6cb:	8b 54 24 18          	mov    0x18(%esp),%edx
    b6cf:	89 50 0c             	mov    %edx,0xc(%eax)
			break;
    b6d2:	eb 64                	jmp    b738 <sys_lseek+0x10f>
		case 1:
			if (file->f_pos+offset<0) return -EINVAL;
    b6d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b6d8:	8b 50 0c             	mov    0xc(%eax),%edx
    b6db:	8b 44 24 18          	mov    0x18(%esp),%eax
    b6df:	01 d0                	add    %edx,%eax
    b6e1:	85 c0                	test   %eax,%eax
    b6e3:	79 07                	jns    b6ec <sys_lseek+0xc3>
    b6e5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b6ea:	eb 53                	jmp    b73f <sys_lseek+0x116>
			file->f_pos += offset;
    b6ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b6f0:	8b 50 0c             	mov    0xc(%eax),%edx
    b6f3:	8b 44 24 18          	mov    0x18(%esp),%eax
    b6f7:	01 c2                	add    %eax,%edx
    b6f9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b6fd:	89 50 0c             	mov    %edx,0xc(%eax)
			break;
    b700:	eb 36                	jmp    b738 <sys_lseek+0x10f>
		case 2:
			if ((tmp=file->f_inode->i_size+offset) < 0)
    b702:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b706:	8b 40 08             	mov    0x8(%eax),%eax
    b709:	8b 50 04             	mov    0x4(%eax),%edx
    b70c:	8b 44 24 18          	mov    0x18(%esp),%eax
    b710:	01 d0                	add    %edx,%eax
    b712:	89 44 24 08          	mov    %eax,0x8(%esp)
    b716:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    b71b:	79 07                	jns    b724 <sys_lseek+0xfb>
				return -EINVAL;
    b71d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b722:	eb 1b                	jmp    b73f <sys_lseek+0x116>
			file->f_pos = tmp;
    b724:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b728:	8b 54 24 08          	mov    0x8(%esp),%edx
    b72c:	89 50 0c             	mov    %edx,0xc(%eax)
			break;
    b72f:	eb 07                	jmp    b738 <sys_lseek+0x10f>
		default:
			return -EINVAL;
    b731:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b736:	eb 07                	jmp    b73f <sys_lseek+0x116>
	}
	return file->f_pos;
    b738:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b73c:	8b 40 0c             	mov    0xc(%eax),%eax
}
    b73f:	83 c4 10             	add    $0x10,%esp
    b742:	c3                   	ret    

0000b743 <sys_read>:

int sys_read(unsigned int fd,char * buf,int count)
{
    b743:	83 ec 1c             	sub    $0x1c,%esp
	struct file * file;
	struct m_inode * inode;

	if (fd>=NR_OPEN || count<0 || !(file=current->filp[fd]))
    b746:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    b74b:	77 24                	ja     b771 <sys_read+0x2e>
    b74d:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b752:	78 1d                	js     b771 <sys_read+0x2e>
    b754:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b759:	8b 54 24 20          	mov    0x20(%esp),%edx
    b75d:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b763:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b766:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b76a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b76f:	75 0a                	jne    b77b <sys_read+0x38>
		return -EINVAL;
    b771:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b776:	e9 99 01 00 00       	jmp    b914 <sys_read+0x1d1>
	if (!count)
    b77b:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b780:	75 0a                	jne    b78c <sys_read+0x49>
		return 0;
    b782:	b8 00 00 00 00       	mov    $0x0,%eax
    b787:	e9 88 01 00 00       	jmp    b914 <sys_read+0x1d1>
	verify_area(buf,count);
    b78c:	83 ec 08             	sub    $0x8,%esp
    b78f:	ff 74 24 30          	pushl  0x30(%esp)
    b793:	ff 74 24 30          	pushl  0x30(%esp)
    b797:	e8 08 c9 ff ff       	call   80a4 <verify_area>
    b79c:	83 c4 10             	add    $0x10,%esp
	inode = file->f_inode;
    b79f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b7a3:	8b 40 08             	mov    0x8(%eax),%eax
    b7a6:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (inode->i_pipe)
    b7aa:	8b 44 24 08          	mov    0x8(%esp),%eax
    b7ae:	0f b6 40 34          	movzbl 0x34(%eax),%eax
    b7b2:	84 c0                	test   %al,%al
    b7b4:	74 37                	je     b7ed <sys_read+0xaa>
		return (file->f_mode&1)?read_pipe(inode,buf,count):-EIO;
    b7b6:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b7ba:	0f b7 00             	movzwl (%eax),%eax
    b7bd:	0f b7 c0             	movzwl %ax,%eax
    b7c0:	83 e0 01             	and    $0x1,%eax
    b7c3:	85 c0                	test   %eax,%eax
    b7c5:	74 1c                	je     b7e3 <sys_read+0xa0>
    b7c7:	83 ec 04             	sub    $0x4,%esp
    b7ca:	ff 74 24 2c          	pushl  0x2c(%esp)
    b7ce:	ff 74 24 2c          	pushl  0x2c(%esp)
    b7d2:	ff 74 24 14          	pushl  0x14(%esp)
    b7d6:	e8 c0 41 00 00       	call   f99b <read_pipe>
    b7db:	83 c4 10             	add    $0x10,%esp
    b7de:	e9 31 01 00 00       	jmp    b914 <sys_read+0x1d1>
    b7e3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    b7e8:	e9 27 01 00 00       	jmp    b914 <sys_read+0x1d1>
	if (S_ISCHR(inode->i_mode))
    b7ed:	8b 44 24 08          	mov    0x8(%esp),%eax
    b7f1:	0f b7 00             	movzwl (%eax),%eax
    b7f4:	0f b7 c0             	movzwl %ax,%eax
    b7f7:	25 00 f0 00 00       	and    $0xf000,%eax
    b7fc:	3d 00 20 00 00       	cmp    $0x2000,%eax
    b801:	75 2e                	jne    b831 <sys_read+0xee>
		return rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);
    b803:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b807:	8d 50 0c             	lea    0xc(%eax),%edx
    b80a:	8b 44 24 08          	mov    0x8(%esp),%eax
    b80e:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b812:	0f b7 c0             	movzwl %ax,%eax
    b815:	83 ec 0c             	sub    $0xc,%esp
    b818:	52                   	push   %edx
    b819:	ff 74 24 38          	pushl  0x38(%esp)
    b81d:	ff 74 24 38          	pushl  0x38(%esp)
    b821:	50                   	push   %eax
    b822:	6a 00                	push   $0x0
    b824:	e8 d0 2a 00 00       	call   e2f9 <rw_char>
    b829:	83 c4 20             	add    $0x20,%esp
    b82c:	e9 e3 00 00 00       	jmp    b914 <sys_read+0x1d1>
	if (S_ISBLK(inode->i_mode))
    b831:	8b 44 24 08          	mov    0x8(%esp),%eax
    b835:	0f b7 00             	movzwl (%eax),%eax
    b838:	0f b7 c0             	movzwl %ax,%eax
    b83b:	25 00 f0 00 00       	and    $0xf000,%eax
    b840:	3d 00 60 00 00       	cmp    $0x6000,%eax
    b845:	75 29                	jne    b870 <sys_read+0x12d>
		return block_read(inode->i_zone[0],&file->f_pos,buf,count);
    b847:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b84b:	8d 50 0c             	lea    0xc(%eax),%edx
    b84e:	8b 44 24 08          	mov    0x8(%esp),%eax
    b852:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b856:	0f b7 c0             	movzwl %ax,%eax
    b859:	ff 74 24 28          	pushl  0x28(%esp)
    b85d:	ff 74 24 28          	pushl  0x28(%esp)
    b861:	52                   	push   %edx
    b862:	50                   	push   %eax
    b863:	e8 74 27 00 00       	call   dfdc <block_read>
    b868:	83 c4 10             	add    $0x10,%esp
    b86b:	e9 a4 00 00 00       	jmp    b914 <sys_read+0x1d1>
	if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {
    b870:	8b 44 24 08          	mov    0x8(%esp),%eax
    b874:	0f b7 00             	movzwl (%eax),%eax
    b877:	0f b7 c0             	movzwl %ax,%eax
    b87a:	25 00 f0 00 00       	and    $0xf000,%eax
    b87f:	3d 00 40 00 00       	cmp    $0x4000,%eax
    b884:	74 16                	je     b89c <sys_read+0x159>
    b886:	8b 44 24 08          	mov    0x8(%esp),%eax
    b88a:	0f b7 00             	movzwl (%eax),%eax
    b88d:	0f b7 c0             	movzwl %ax,%eax
    b890:	25 00 f0 00 00       	and    $0xf000,%eax
    b895:	3d 00 80 00 00       	cmp    $0x8000,%eax
    b89a:	75 58                	jne    b8f4 <sys_read+0x1b1>
		if (count+file->f_pos > inode->i_size)
    b89c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b8a0:	8b 50 0c             	mov    0xc(%eax),%edx
    b8a3:	8b 44 24 28          	mov    0x28(%esp),%eax
    b8a7:	01 d0                	add    %edx,%eax
    b8a9:	89 c2                	mov    %eax,%edx
    b8ab:	8b 44 24 08          	mov    0x8(%esp),%eax
    b8af:	8b 40 04             	mov    0x4(%eax),%eax
    b8b2:	39 c2                	cmp    %eax,%edx
    b8b4:	76 16                	jbe    b8cc <sys_read+0x189>
			count = inode->i_size - file->f_pos;
    b8b6:	8b 44 24 08          	mov    0x8(%esp),%eax
    b8ba:	8b 50 04             	mov    0x4(%eax),%edx
    b8bd:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b8c1:	8b 40 0c             	mov    0xc(%eax),%eax
    b8c4:	29 c2                	sub    %eax,%edx
    b8c6:	89 d0                	mov    %edx,%eax
    b8c8:	89 44 24 28          	mov    %eax,0x28(%esp)
		if (count<=0)
    b8cc:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b8d1:	7f 07                	jg     b8da <sys_read+0x197>
			return 0;
    b8d3:	b8 00 00 00 00       	mov    $0x0,%eax
    b8d8:	eb 3a                	jmp    b914 <sys_read+0x1d1>
		return file_read(inode,file,buf,count);
    b8da:	ff 74 24 28          	pushl  0x28(%esp)
    b8de:	ff 74 24 28          	pushl  0x28(%esp)
    b8e2:	ff 74 24 14          	pushl  0x14(%esp)
    b8e6:	ff 74 24 14          	pushl  0x14(%esp)
    b8ea:	e8 90 2a 00 00       	call   e37f <file_read>
    b8ef:	83 c4 10             	add    $0x10,%esp
    b8f2:	eb 20                	jmp    b914 <sys_read+0x1d1>
	}
	printk("(Read)inode->i_mode=%06o\n\r",inode->i_mode);
    b8f4:	8b 44 24 08          	mov    0x8(%esp),%eax
    b8f8:	0f b7 00             	movzwl (%eax),%eax
    b8fb:	0f b7 c0             	movzwl %ax,%eax
    b8fe:	83 ec 08             	sub    $0x8,%esp
    b901:	50                   	push   %eax
    b902:	68 ab 86 01 00       	push   $0x186ab
    b907:	e8 01 cf ff ff       	call   880d <printk>
    b90c:	83 c4 10             	add    $0x10,%esp
	return -EINVAL;
    b90f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    b914:	83 c4 1c             	add    $0x1c,%esp
    b917:	c3                   	ret    

0000b918 <sys_write>:

int sys_write(unsigned int fd,char * buf,int count)
{
    b918:	83 ec 1c             	sub    $0x1c,%esp
	struct file * file;
	struct m_inode * inode;
	
	if (fd>=NR_OPEN || count <0 || !(file=current->filp[fd]))
    b91b:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    b920:	77 24                	ja     b946 <sys_write+0x2e>
    b922:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b927:	78 1d                	js     b946 <sys_write+0x2e>
    b929:	a1 40 f1 01 00       	mov    0x1f140,%eax
    b92e:	8b 54 24 20          	mov    0x20(%esp),%edx
    b932:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    b938:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b93b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b93f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b944:	75 0a                	jne    b950 <sys_write+0x38>
		return -EINVAL;
    b946:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b94b:	e9 2f 01 00 00       	jmp    ba7f <sys_write+0x167>
	if (!count)
    b950:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b955:	75 0a                	jne    b961 <sys_write+0x49>
		return 0;
    b957:	b8 00 00 00 00       	mov    $0x0,%eax
    b95c:	e9 1e 01 00 00       	jmp    ba7f <sys_write+0x167>
	inode=file->f_inode;
    b961:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b965:	8b 40 08             	mov    0x8(%eax),%eax
    b968:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (inode->i_pipe)
    b96c:	8b 44 24 08          	mov    0x8(%esp),%eax
    b970:	0f b6 40 34          	movzbl 0x34(%eax),%eax
    b974:	84 c0                	test   %al,%al
    b976:	74 37                	je     b9af <sys_write+0x97>
		return (file->f_mode&2)?write_pipe(inode,buf,count):-EIO;
    b978:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b97c:	0f b7 00             	movzwl (%eax),%eax
    b97f:	0f b7 c0             	movzwl %ax,%eax
    b982:	83 e0 02             	and    $0x2,%eax
    b985:	85 c0                	test   %eax,%eax
    b987:	74 1c                	je     b9a5 <sys_write+0x8d>
    b989:	83 ec 04             	sub    $0x4,%esp
    b98c:	ff 74 24 2c          	pushl  0x2c(%esp)
    b990:	ff 74 24 2c          	pushl  0x2c(%esp)
    b994:	ff 74 24 14          	pushl  0x14(%esp)
    b998:	e8 67 41 00 00       	call   fb04 <write_pipe>
    b99d:	83 c4 10             	add    $0x10,%esp
    b9a0:	e9 da 00 00 00       	jmp    ba7f <sys_write+0x167>
    b9a5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    b9aa:	e9 d0 00 00 00       	jmp    ba7f <sys_write+0x167>
	if (S_ISCHR(inode->i_mode))
    b9af:	8b 44 24 08          	mov    0x8(%esp),%eax
    b9b3:	0f b7 00             	movzwl (%eax),%eax
    b9b6:	0f b7 c0             	movzwl %ax,%eax
    b9b9:	25 00 f0 00 00       	and    $0xf000,%eax
    b9be:	3d 00 20 00 00       	cmp    $0x2000,%eax
    b9c3:	75 2e                	jne    b9f3 <sys_write+0xdb>
		return rw_char(WRITE,inode->i_zone[0],buf,count,&file->f_pos);
    b9c5:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b9c9:	8d 50 0c             	lea    0xc(%eax),%edx
    b9cc:	8b 44 24 08          	mov    0x8(%esp),%eax
    b9d0:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b9d4:	0f b7 c0             	movzwl %ax,%eax
    b9d7:	83 ec 0c             	sub    $0xc,%esp
    b9da:	52                   	push   %edx
    b9db:	ff 74 24 38          	pushl  0x38(%esp)
    b9df:	ff 74 24 38          	pushl  0x38(%esp)
    b9e3:	50                   	push   %eax
    b9e4:	6a 01                	push   $0x1
    b9e6:	e8 0e 29 00 00       	call   e2f9 <rw_char>
    b9eb:	83 c4 20             	add    $0x20,%esp
    b9ee:	e9 8c 00 00 00       	jmp    ba7f <sys_write+0x167>
	if (S_ISBLK(inode->i_mode))
    b9f3:	8b 44 24 08          	mov    0x8(%esp),%eax
    b9f7:	0f b7 00             	movzwl (%eax),%eax
    b9fa:	0f b7 c0             	movzwl %ax,%eax
    b9fd:	25 00 f0 00 00       	and    $0xf000,%eax
    ba02:	3d 00 60 00 00       	cmp    $0x6000,%eax
    ba07:	75 26                	jne    ba2f <sys_write+0x117>
		return block_write(inode->i_zone[0],&file->f_pos,buf,count);
    ba09:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ba0d:	8d 50 0c             	lea    0xc(%eax),%edx
    ba10:	8b 44 24 08          	mov    0x8(%esp),%eax
    ba14:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    ba18:	0f b7 c0             	movzwl %ax,%eax
    ba1b:	ff 74 24 28          	pushl  0x28(%esp)
    ba1f:	ff 74 24 28          	pushl  0x28(%esp)
    ba23:	52                   	push   %edx
    ba24:	50                   	push   %eax
    ba25:	e8 61 24 00 00       	call   de8b <block_write>
    ba2a:	83 c4 10             	add    $0x10,%esp
    ba2d:	eb 50                	jmp    ba7f <sys_write+0x167>
	if (S_ISREG(inode->i_mode))
    ba2f:	8b 44 24 08          	mov    0x8(%esp),%eax
    ba33:	0f b7 00             	movzwl (%eax),%eax
    ba36:	0f b7 c0             	movzwl %ax,%eax
    ba39:	25 00 f0 00 00       	and    $0xf000,%eax
    ba3e:	3d 00 80 00 00       	cmp    $0x8000,%eax
    ba43:	75 1a                	jne    ba5f <sys_write+0x147>
		return file_write(inode,file,buf,count);
    ba45:	ff 74 24 28          	pushl  0x28(%esp)
    ba49:	ff 74 24 28          	pushl  0x28(%esp)
    ba4d:	ff 74 24 14          	pushl  0x14(%esp)
    ba51:	ff 74 24 14          	pushl  0x14(%esp)
    ba55:	e8 d0 2a 00 00       	call   e52a <file_write>
    ba5a:	83 c4 10             	add    $0x10,%esp
    ba5d:	eb 20                	jmp    ba7f <sys_write+0x167>
	printk("(Write)inode->i_mode=%06o\n\r",inode->i_mode);
    ba5f:	8b 44 24 08          	mov    0x8(%esp),%eax
    ba63:	0f b7 00             	movzwl (%eax),%eax
    ba66:	0f b7 c0             	movzwl %ax,%eax
    ba69:	83 ec 08             	sub    $0x8,%esp
    ba6c:	50                   	push   %eax
    ba6d:	68 c6 86 01 00       	push   $0x186c6
    ba72:	e8 96 cd ff ff       	call   880d <printk>
    ba77:	83 c4 10             	add    $0x10,%esp
	return -EINVAL;
    ba7a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    ba7f:	83 c4 1c             	add    $0x1c,%esp
    ba82:	c3                   	ret    

0000ba83 <memset>:
	);
return __res;
}

static inline void * memset(void * s,char c,int count)
{
    ba83:	57                   	push   %edi
    ba84:	83 ec 04             	sub    $0x4,%esp
    ba87:	8b 44 24 10          	mov    0x10(%esp),%eax
    ba8b:	88 04 24             	mov    %al,(%esp)
__asm__("cld\n\t"
    ba8e:	0f b6 04 24          	movzbl (%esp),%eax
    ba92:	8b 54 24 0c          	mov    0xc(%esp),%edx
    ba96:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    ba9a:	89 d7                	mov    %edx,%edi
    ba9c:	fc                   	cld    
    ba9d:	f3 aa                	rep stos %al,%es:(%edi)
	"rep\n\t"
	"stosb"
	::"a" (c),"D" (s),"c" (count)
	);
return s;
    ba9f:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    baa3:	83 c4 04             	add    $0x4,%esp
    baa6:	5f                   	pop    %edi
    baa7:	c3                   	ret    

0000baa8 <wait_on_inode>:

static void read_inode(struct m_inode * inode);
static void write_inode(struct m_inode * inode);

static inline void wait_on_inode(struct m_inode * inode)
{
    baa8:	83 ec 0c             	sub    $0xc,%esp
	cli();
    baab:	fa                   	cli    
	while (inode->i_lock)
    baac:	eb 13                	jmp    bac1 <wait_on_inode+0x19>
		sleep_on(&inode->i_wait);
    baae:	8b 44 24 10          	mov    0x10(%esp),%eax
    bab2:	83 c0 20             	add    $0x20,%eax
    bab5:	83 ec 0c             	sub    $0xc,%esp
    bab8:	50                   	push   %eax
    bab9:	e8 b4 b3 ff ff       	call   6e72 <sleep_on>
    babe:	83 c4 10             	add    $0x10,%esp
static void write_inode(struct m_inode * inode);

static inline void wait_on_inode(struct m_inode * inode)
{
	cli();
	while (inode->i_lock)
    bac1:	8b 44 24 10          	mov    0x10(%esp),%eax
    bac5:	0f b6 40 32          	movzbl 0x32(%eax),%eax
    bac9:	84 c0                	test   %al,%al
    bacb:	75 e1                	jne    baae <wait_on_inode+0x6>
		sleep_on(&inode->i_wait);
	sti();
    bacd:	fb                   	sti    
}
    bace:	90                   	nop
    bacf:	83 c4 0c             	add    $0xc,%esp
    bad2:	c3                   	ret    

0000bad3 <lock_inode>:

static inline void lock_inode(struct m_inode * inode)
{
    bad3:	83 ec 0c             	sub    $0xc,%esp
	cli();
    bad6:	fa                   	cli    
	while (inode->i_lock)
    bad7:	eb 13                	jmp    baec <lock_inode+0x19>
		sleep_on(&inode->i_wait);
    bad9:	8b 44 24 10          	mov    0x10(%esp),%eax
    badd:	83 c0 20             	add    $0x20,%eax
    bae0:	83 ec 0c             	sub    $0xc,%esp
    bae3:	50                   	push   %eax
    bae4:	e8 89 b3 ff ff       	call   6e72 <sleep_on>
    bae9:	83 c4 10             	add    $0x10,%esp
}

static inline void lock_inode(struct m_inode * inode)
{
	cli();
	while (inode->i_lock)
    baec:	8b 44 24 10          	mov    0x10(%esp),%eax
    baf0:	0f b6 40 32          	movzbl 0x32(%eax),%eax
    baf4:	84 c0                	test   %al,%al
    baf6:	75 e1                	jne    bad9 <lock_inode+0x6>
		sleep_on(&inode->i_wait);
	inode->i_lock=1;
    baf8:	8b 44 24 10          	mov    0x10(%esp),%eax
    bafc:	c6 40 32 01          	movb   $0x1,0x32(%eax)
	sti();
    bb00:	fb                   	sti    
}
    bb01:	90                   	nop
    bb02:	83 c4 0c             	add    $0xc,%esp
    bb05:	c3                   	ret    

0000bb06 <unlock_inode>:

static inline void unlock_inode(struct m_inode * inode)
{
    bb06:	83 ec 0c             	sub    $0xc,%esp
	inode->i_lock=0;
    bb09:	8b 44 24 10          	mov    0x10(%esp),%eax
    bb0d:	c6 40 32 00          	movb   $0x0,0x32(%eax)
	wake_up(&inode->i_wait);
    bb11:	8b 44 24 10          	mov    0x10(%esp),%eax
    bb15:	83 c0 20             	add    $0x20,%eax
    bb18:	83 ec 0c             	sub    $0xc,%esp
    bb1b:	50                   	push   %eax
    bb1c:	e8 58 b4 ff ff       	call   6f79 <wake_up>
    bb21:	83 c4 10             	add    $0x10,%esp
}
    bb24:	90                   	nop
    bb25:	83 c4 0c             	add    $0xc,%esp
    bb28:	c3                   	ret    

0000bb29 <invalidate_inodes>:

void invalidate_inodes(int dev)
{
    bb29:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	struct m_inode * inode;

	inode = 0+inode_table;
    bb2c:	c7 44 24 08 60 35 02 	movl   $0x23560,0x8(%esp)
    bb33:	00 
	for(i=0 ; i<NR_INODE ; i++,inode++) {
    bb34:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    bb3b:	00 
    bb3c:	eb 59                	jmp    bb97 <invalidate_inodes+0x6e>
		wait_on_inode(inode);
    bb3e:	83 ec 0c             	sub    $0xc,%esp
    bb41:	ff 74 24 14          	pushl  0x14(%esp)
    bb45:	e8 5e ff ff ff       	call   baa8 <wait_on_inode>
    bb4a:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dev == dev) {
    bb4d:	8b 44 24 08          	mov    0x8(%esp),%eax
    bb51:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bb55:	0f b7 c0             	movzwl %ax,%eax
    bb58:	3b 44 24 20          	cmp    0x20(%esp),%eax
    bb5c:	75 2f                	jne    bb8d <invalidate_inodes+0x64>
			if (inode->i_count)
    bb5e:	8b 44 24 08          	mov    0x8(%esp),%eax
    bb62:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    bb66:	66 85 c0             	test   %ax,%ax
    bb69:	74 10                	je     bb7b <invalidate_inodes+0x52>
				printk("inode in use on removed disk\n\r");
    bb6b:	83 ec 0c             	sub    $0xc,%esp
    bb6e:	68 e4 86 01 00       	push   $0x186e4
    bb73:	e8 95 cc ff ff       	call   880d <printk>
    bb78:	83 c4 10             	add    $0x10,%esp
			inode->i_dev = inode->i_dirt = 0;
    bb7b:	8b 44 24 08          	mov    0x8(%esp),%eax
    bb7f:	c6 40 33 00          	movb   $0x0,0x33(%eax)
    bb83:	8b 44 24 08          	mov    0x8(%esp),%eax
    bb87:	66 c7 40 2c 00 00    	movw   $0x0,0x2c(%eax)
{
	int i;
	struct m_inode * inode;

	inode = 0+inode_table;
	for(i=0 ; i<NR_INODE ; i++,inode++) {
    bb8d:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    bb92:	83 44 24 08 38       	addl   $0x38,0x8(%esp)
    bb97:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
    bb9c:	7e a0                	jle    bb3e <invalidate_inodes+0x15>
			if (inode->i_count)
				printk("inode in use on removed disk\n\r");
			inode->i_dev = inode->i_dirt = 0;
		}
	}
}
    bb9e:	90                   	nop
    bb9f:	83 c4 1c             	add    $0x1c,%esp
    bba2:	c3                   	ret    

0000bba3 <sync_inodes>:

void sync_inodes(void)
{
    bba3:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	struct m_inode * inode;

	inode = 0+inode_table;
    bba6:	c7 44 24 08 60 35 02 	movl   $0x23560,0x8(%esp)
    bbad:	00 
	for(i=0 ; i<NR_INODE ; i++,inode++) {
    bbae:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    bbb5:	00 
    bbb6:	eb 40                	jmp    bbf8 <sync_inodes+0x55>
		wait_on_inode(inode);
    bbb8:	83 ec 0c             	sub    $0xc,%esp
    bbbb:	ff 74 24 14          	pushl  0x14(%esp)
    bbbf:	e8 e4 fe ff ff       	call   baa8 <wait_on_inode>
    bbc4:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dirt && !inode->i_pipe)
    bbc7:	8b 44 24 08          	mov    0x8(%esp),%eax
    bbcb:	0f b6 40 33          	movzbl 0x33(%eax),%eax
    bbcf:	84 c0                	test   %al,%al
    bbd1:	74 1b                	je     bbee <sync_inodes+0x4b>
    bbd3:	8b 44 24 08          	mov    0x8(%esp),%eax
    bbd7:	0f b6 40 34          	movzbl 0x34(%eax),%eax
    bbdb:	84 c0                	test   %al,%al
    bbdd:	75 0f                	jne    bbee <sync_inodes+0x4b>
			write_inode(inode);
    bbdf:	83 ec 0c             	sub    $0xc,%esp
    bbe2:	ff 74 24 14          	pushl  0x14(%esp)
    bbe6:	e8 f3 0a 00 00       	call   c6de <write_inode>
    bbeb:	83 c4 10             	add    $0x10,%esp
{
	int i;
	struct m_inode * inode;

	inode = 0+inode_table;
	for(i=0 ; i<NR_INODE ; i++,inode++) {
    bbee:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    bbf3:	83 44 24 08 38       	addl   $0x38,0x8(%esp)
    bbf8:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
    bbfd:	7e b9                	jle    bbb8 <sync_inodes+0x15>
		wait_on_inode(inode);
		if (inode->i_dirt && !inode->i_pipe)
			write_inode(inode);
	}
}
    bbff:	90                   	nop
    bc00:	83 c4 1c             	add    $0x1c,%esp
    bc03:	c3                   	ret    

0000bc04 <_bmap>:

static int _bmap(struct m_inode * inode,int block,int create)
{
    bc04:	83 ec 1c             	sub    $0x1c,%esp
	struct buffer_head * bh;
	int i;

	if (block<0)
    bc07:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    bc0c:	79 10                	jns    bc1e <_bmap+0x1a>
		panic("_bmap: block<0");
    bc0e:	83 ec 0c             	sub    $0xc,%esp
    bc11:	68 03 87 01 00       	push   $0x18703
    bc16:	e8 b3 cb ff ff       	call   87ce <panic>
    bc1b:	83 c4 10             	add    $0x10,%esp
	if (block >= 7+512+512*512)
    bc1e:	81 7c 24 24 06 02 04 	cmpl   $0x40206,0x24(%esp)
    bc25:	00 
    bc26:	7e 10                	jle    bc38 <_bmap+0x34>
		panic("_bmap: block>big");
    bc28:	83 ec 0c             	sub    $0xc,%esp
    bc2b:	68 12 87 01 00       	push   $0x18712
    bc30:	e8 99 cb ff ff       	call   87ce <panic>
    bc35:	83 c4 10             	add    $0x10,%esp
	if (block<7) {
    bc38:	83 7c 24 24 06       	cmpl   $0x6,0x24(%esp)
    bc3d:	0f 8f 97 00 00 00    	jg     bcda <_bmap+0xd6>
		if (create && !inode->i_zone[block])
    bc43:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    bc48:	74 7b                	je     bcc5 <_bmap+0xc1>
    bc4a:	8b 44 24 20          	mov    0x20(%esp),%eax
    bc4e:	8b 54 24 24          	mov    0x24(%esp),%edx
    bc52:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
    bc57:	66 85 c0             	test   %ax,%ax
    bc5a:	75 69                	jne    bcc5 <_bmap+0xc1>
			if ((inode->i_zone[block]=new_block(inode->i_dev))) {
    bc5c:	8b 44 24 20          	mov    0x20(%esp),%eax
    bc60:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bc64:	0f b7 c0             	movzwl %ax,%eax
    bc67:	83 ec 0c             	sub    $0xc,%esp
    bc6a:	50                   	push   %eax
    bc6b:	e8 08 62 00 00       	call   11e78 <new_block>
    bc70:	83 c4 10             	add    $0x10,%esp
    bc73:	89 c1                	mov    %eax,%ecx
    bc75:	8b 44 24 20          	mov    0x20(%esp),%eax
    bc79:	8b 54 24 24          	mov    0x24(%esp),%edx
    bc7d:	66 89 4c 50 0e       	mov    %cx,0xe(%eax,%edx,2)
    bc82:	8b 44 24 20          	mov    0x20(%esp),%eax
    bc86:	8b 54 24 24          	mov    0x24(%esp),%edx
    bc8a:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
    bc8f:	66 85 c0             	test   %ax,%ax
    bc92:	74 31                	je     bcc5 <_bmap+0xc1>
				inode->i_ctime=CURRENT_TIME;
    bc94:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    bc9a:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    bc9f:	89 c8                	mov    %ecx,%eax
    bca1:	f7 ea                	imul   %edx
    bca3:	c1 fa 05             	sar    $0x5,%edx
    bca6:	89 c8                	mov    %ecx,%eax
    bca8:	c1 f8 1f             	sar    $0x1f,%eax
    bcab:	29 c2                	sub    %eax,%edx
    bcad:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
    bcb2:	01 d0                	add    %edx,%eax
    bcb4:	89 c2                	mov    %eax,%edx
    bcb6:	8b 44 24 20          	mov    0x20(%esp),%eax
    bcba:	89 50 28             	mov    %edx,0x28(%eax)
				inode->i_dirt=1;
    bcbd:	8b 44 24 20          	mov    0x20(%esp),%eax
    bcc1:	c6 40 33 01          	movb   $0x1,0x33(%eax)
			}
		return inode->i_zone[block];
    bcc5:	8b 44 24 20          	mov    0x20(%esp),%eax
    bcc9:	8b 54 24 24          	mov    0x24(%esp),%edx
    bccd:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
    bcd2:	0f b7 c0             	movzwl %ax,%eax
    bcd5:	e9 5b 03 00 00       	jmp    c035 <_bmap+0x431>
	}
	block -= 7;
    bcda:	83 6c 24 24 07       	subl   $0x7,0x24(%esp)
	if (block<512) {
    bcdf:	81 7c 24 24 ff 01 00 	cmpl   $0x1ff,0x24(%esp)
    bce6:	00 
    bce7:	0f 8f 3f 01 00 00    	jg     be2c <_bmap+0x228>
		if (create && !inode->i_zone[7])
    bced:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    bcf2:	74 6c                	je     bd60 <_bmap+0x15c>
    bcf4:	8b 44 24 20          	mov    0x20(%esp),%eax
    bcf8:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    bcfc:	66 85 c0             	test   %ax,%ax
    bcff:	75 5f                	jne    bd60 <_bmap+0x15c>
			if ((inode->i_zone[7]=new_block(inode->i_dev))) {
    bd01:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd05:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bd09:	0f b7 c0             	movzwl %ax,%eax
    bd0c:	83 ec 0c             	sub    $0xc,%esp
    bd0f:	50                   	push   %eax
    bd10:	e8 63 61 00 00       	call   11e78 <new_block>
    bd15:	83 c4 10             	add    $0x10,%esp
    bd18:	89 c2                	mov    %eax,%edx
    bd1a:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd1e:	66 89 50 1c          	mov    %dx,0x1c(%eax)
    bd22:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd26:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    bd2a:	66 85 c0             	test   %ax,%ax
    bd2d:	74 31                	je     bd60 <_bmap+0x15c>
				inode->i_dirt=1;
    bd2f:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd33:	c6 40 33 01          	movb   $0x1,0x33(%eax)
				inode->i_ctime=CURRENT_TIME;
    bd37:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    bd3d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    bd42:	89 c8                	mov    %ecx,%eax
    bd44:	f7 ea                	imul   %edx
    bd46:	c1 fa 05             	sar    $0x5,%edx
    bd49:	89 c8                	mov    %ecx,%eax
    bd4b:	c1 f8 1f             	sar    $0x1f,%eax
    bd4e:	29 c2                	sub    %eax,%edx
    bd50:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
    bd55:	01 d0                	add    %edx,%eax
    bd57:	89 c2                	mov    %eax,%edx
    bd59:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd5d:	89 50 28             	mov    %edx,0x28(%eax)
			}
		if (!inode->i_zone[7])
    bd60:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd64:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    bd68:	66 85 c0             	test   %ax,%ax
    bd6b:	75 0a                	jne    bd77 <_bmap+0x173>
			return 0;
    bd6d:	b8 00 00 00 00       	mov    $0x0,%eax
    bd72:	e9 be 02 00 00       	jmp    c035 <_bmap+0x431>
		if (!(bh = bread(inode->i_dev,inode->i_zone[7])))
    bd77:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd7b:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    bd7f:	0f b7 d0             	movzwl %ax,%edx
    bd82:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd86:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bd8a:	0f b7 c0             	movzwl %ax,%eax
    bd8d:	83 ec 08             	sub    $0x8,%esp
    bd90:	52                   	push   %edx
    bd91:	50                   	push   %eax
    bd92:	e8 4f 12 00 00       	call   cfe6 <bread>
    bd97:	83 c4 10             	add    $0x10,%esp
    bd9a:	89 44 24 08          	mov    %eax,0x8(%esp)
    bd9e:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    bda3:	75 0a                	jne    bdaf <_bmap+0x1ab>
			return 0;
    bda5:	b8 00 00 00 00       	mov    $0x0,%eax
    bdaa:	e9 86 02 00 00       	jmp    c035 <_bmap+0x431>
		i = ((unsigned short *) (bh->b_data))[block];
    bdaf:	8b 44 24 08          	mov    0x8(%esp),%eax
    bdb3:	8b 00                	mov    (%eax),%eax
    bdb5:	8b 54 24 24          	mov    0x24(%esp),%edx
    bdb9:	01 d2                	add    %edx,%edx
    bdbb:	01 d0                	add    %edx,%eax
    bdbd:	0f b7 00             	movzwl (%eax),%eax
    bdc0:	0f b7 c0             	movzwl %ax,%eax
    bdc3:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (create && !i)
    bdc7:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    bdcc:	74 46                	je     be14 <_bmap+0x210>
    bdce:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bdd3:	75 3f                	jne    be14 <_bmap+0x210>
			if ((i=new_block(inode->i_dev))) {
    bdd5:	8b 44 24 20          	mov    0x20(%esp),%eax
    bdd9:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bddd:	0f b7 c0             	movzwl %ax,%eax
    bde0:	83 ec 0c             	sub    $0xc,%esp
    bde3:	50                   	push   %eax
    bde4:	e8 8f 60 00 00       	call   11e78 <new_block>
    bde9:	83 c4 10             	add    $0x10,%esp
    bdec:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bdf0:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bdf5:	74 1d                	je     be14 <_bmap+0x210>
				((unsigned short *) (bh->b_data))[block]=i;
    bdf7:	8b 44 24 08          	mov    0x8(%esp),%eax
    bdfb:	8b 00                	mov    (%eax),%eax
    bdfd:	8b 54 24 24          	mov    0x24(%esp),%edx
    be01:	01 d2                	add    %edx,%edx
    be03:	01 d0                	add    %edx,%eax
    be05:	8b 54 24 0c          	mov    0xc(%esp),%edx
    be09:	66 89 10             	mov    %dx,(%eax)
				bh->b_dirt=1;
    be0c:	8b 44 24 08          	mov    0x8(%esp),%eax
    be10:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
			}
		brelse(bh);
    be14:	83 ec 0c             	sub    $0xc,%esp
    be17:	ff 74 24 14          	pushl  0x14(%esp)
    be1b:	e8 70 11 00 00       	call   cf90 <brelse>
    be20:	83 c4 10             	add    $0x10,%esp
		return i;
    be23:	8b 44 24 0c          	mov    0xc(%esp),%eax
    be27:	e9 09 02 00 00       	jmp    c035 <_bmap+0x431>
	}
	block -= 512;
    be2c:	81 6c 24 24 00 02 00 	subl   $0x200,0x24(%esp)
    be33:	00 
	if (create && !inode->i_zone[8])
    be34:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    be39:	74 6c                	je     bea7 <_bmap+0x2a3>
    be3b:	8b 44 24 20          	mov    0x20(%esp),%eax
    be3f:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    be43:	66 85 c0             	test   %ax,%ax
    be46:	75 5f                	jne    bea7 <_bmap+0x2a3>
		if ((inode->i_zone[8]=new_block(inode->i_dev))) {
    be48:	8b 44 24 20          	mov    0x20(%esp),%eax
    be4c:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    be50:	0f b7 c0             	movzwl %ax,%eax
    be53:	83 ec 0c             	sub    $0xc,%esp
    be56:	50                   	push   %eax
    be57:	e8 1c 60 00 00       	call   11e78 <new_block>
    be5c:	83 c4 10             	add    $0x10,%esp
    be5f:	89 c2                	mov    %eax,%edx
    be61:	8b 44 24 20          	mov    0x20(%esp),%eax
    be65:	66 89 50 1e          	mov    %dx,0x1e(%eax)
    be69:	8b 44 24 20          	mov    0x20(%esp),%eax
    be6d:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    be71:	66 85 c0             	test   %ax,%ax
    be74:	74 31                	je     bea7 <_bmap+0x2a3>
			inode->i_dirt=1;
    be76:	8b 44 24 20          	mov    0x20(%esp),%eax
    be7a:	c6 40 33 01          	movb   $0x1,0x33(%eax)
			inode->i_ctime=CURRENT_TIME;
    be7e:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    be84:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    be89:	89 c8                	mov    %ecx,%eax
    be8b:	f7 ea                	imul   %edx
    be8d:	c1 fa 05             	sar    $0x5,%edx
    be90:	89 c8                	mov    %ecx,%eax
    be92:	c1 f8 1f             	sar    $0x1f,%eax
    be95:	29 c2                	sub    %eax,%edx
    be97:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
    be9c:	01 d0                	add    %edx,%eax
    be9e:	89 c2                	mov    %eax,%edx
    bea0:	8b 44 24 20          	mov    0x20(%esp),%eax
    bea4:	89 50 28             	mov    %edx,0x28(%eax)
		}
	if (!inode->i_zone[8])
    bea7:	8b 44 24 20          	mov    0x20(%esp),%eax
    beab:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    beaf:	66 85 c0             	test   %ax,%ax
    beb2:	75 0a                	jne    bebe <_bmap+0x2ba>
		return 0;
    beb4:	b8 00 00 00 00       	mov    $0x0,%eax
    beb9:	e9 77 01 00 00       	jmp    c035 <_bmap+0x431>
	if (!(bh=bread(inode->i_dev,inode->i_zone[8])))
    bebe:	8b 44 24 20          	mov    0x20(%esp),%eax
    bec2:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    bec6:	0f b7 d0             	movzwl %ax,%edx
    bec9:	8b 44 24 20          	mov    0x20(%esp),%eax
    becd:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bed1:	0f b7 c0             	movzwl %ax,%eax
    bed4:	83 ec 08             	sub    $0x8,%esp
    bed7:	52                   	push   %edx
    bed8:	50                   	push   %eax
    bed9:	e8 08 11 00 00       	call   cfe6 <bread>
    bede:	83 c4 10             	add    $0x10,%esp
    bee1:	89 44 24 08          	mov    %eax,0x8(%esp)
    bee5:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    beea:	75 0a                	jne    bef6 <_bmap+0x2f2>
		return 0;
    beec:	b8 00 00 00 00       	mov    $0x0,%eax
    bef1:	e9 3f 01 00 00       	jmp    c035 <_bmap+0x431>
	i = ((unsigned short *)bh->b_data)[block>>9];
    bef6:	8b 44 24 08          	mov    0x8(%esp),%eax
    befa:	8b 00                	mov    (%eax),%eax
    befc:	8b 54 24 24          	mov    0x24(%esp),%edx
    bf00:	c1 fa 09             	sar    $0x9,%edx
    bf03:	01 d2                	add    %edx,%edx
    bf05:	01 d0                	add    %edx,%eax
    bf07:	0f b7 00             	movzwl (%eax),%eax
    bf0a:	0f b7 c0             	movzwl %ax,%eax
    bf0d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (create && !i)
    bf11:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    bf16:	74 49                	je     bf61 <_bmap+0x35d>
    bf18:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bf1d:	75 42                	jne    bf61 <_bmap+0x35d>
		if ((i=new_block(inode->i_dev))) {
    bf1f:	8b 44 24 20          	mov    0x20(%esp),%eax
    bf23:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bf27:	0f b7 c0             	movzwl %ax,%eax
    bf2a:	83 ec 0c             	sub    $0xc,%esp
    bf2d:	50                   	push   %eax
    bf2e:	e8 45 5f 00 00       	call   11e78 <new_block>
    bf33:	83 c4 10             	add    $0x10,%esp
    bf36:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bf3a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bf3f:	74 20                	je     bf61 <_bmap+0x35d>
			((unsigned short *) (bh->b_data))[block>>9]=i;
    bf41:	8b 44 24 08          	mov    0x8(%esp),%eax
    bf45:	8b 00                	mov    (%eax),%eax
    bf47:	8b 54 24 24          	mov    0x24(%esp),%edx
    bf4b:	c1 fa 09             	sar    $0x9,%edx
    bf4e:	01 d2                	add    %edx,%edx
    bf50:	01 d0                	add    %edx,%eax
    bf52:	8b 54 24 0c          	mov    0xc(%esp),%edx
    bf56:	66 89 10             	mov    %dx,(%eax)
			bh->b_dirt=1;
    bf59:	8b 44 24 08          	mov    0x8(%esp),%eax
    bf5d:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		}
	brelse(bh);
    bf61:	83 ec 0c             	sub    $0xc,%esp
    bf64:	ff 74 24 14          	pushl  0x14(%esp)
    bf68:	e8 23 10 00 00       	call   cf90 <brelse>
    bf6d:	83 c4 10             	add    $0x10,%esp
	if (!i)
    bf70:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bf75:	75 0a                	jne    bf81 <_bmap+0x37d>
		return 0;
    bf77:	b8 00 00 00 00       	mov    $0x0,%eax
    bf7c:	e9 b4 00 00 00       	jmp    c035 <_bmap+0x431>
	if (!(bh=bread(inode->i_dev,i)))
    bf81:	8b 44 24 20          	mov    0x20(%esp),%eax
    bf85:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bf89:	0f b7 c0             	movzwl %ax,%eax
    bf8c:	83 ec 08             	sub    $0x8,%esp
    bf8f:	ff 74 24 14          	pushl  0x14(%esp)
    bf93:	50                   	push   %eax
    bf94:	e8 4d 10 00 00       	call   cfe6 <bread>
    bf99:	83 c4 10             	add    $0x10,%esp
    bf9c:	89 44 24 08          	mov    %eax,0x8(%esp)
    bfa0:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    bfa5:	75 0a                	jne    bfb1 <_bmap+0x3ad>
		return 0;
    bfa7:	b8 00 00 00 00       	mov    $0x0,%eax
    bfac:	e9 84 00 00 00       	jmp    c035 <_bmap+0x431>
	i = ((unsigned short *)bh->b_data)[block&511];
    bfb1:	8b 44 24 08          	mov    0x8(%esp),%eax
    bfb5:	8b 00                	mov    (%eax),%eax
    bfb7:	8b 54 24 24          	mov    0x24(%esp),%edx
    bfbb:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    bfc1:	01 d2                	add    %edx,%edx
    bfc3:	01 d0                	add    %edx,%eax
    bfc5:	0f b7 00             	movzwl (%eax),%eax
    bfc8:	0f b7 c0             	movzwl %ax,%eax
    bfcb:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (create && !i)
    bfcf:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    bfd4:	74 4c                	je     c022 <_bmap+0x41e>
    bfd6:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bfdb:	75 45                	jne    c022 <_bmap+0x41e>
		if ((i=new_block(inode->i_dev))) {
    bfdd:	8b 44 24 20          	mov    0x20(%esp),%eax
    bfe1:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bfe5:	0f b7 c0             	movzwl %ax,%eax
    bfe8:	83 ec 0c             	sub    $0xc,%esp
    bfeb:	50                   	push   %eax
    bfec:	e8 87 5e 00 00       	call   11e78 <new_block>
    bff1:	83 c4 10             	add    $0x10,%esp
    bff4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bff8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bffd:	74 23                	je     c022 <_bmap+0x41e>
			((unsigned short *) (bh->b_data))[block&511]=i;
    bfff:	8b 44 24 08          	mov    0x8(%esp),%eax
    c003:	8b 00                	mov    (%eax),%eax
    c005:	8b 54 24 24          	mov    0x24(%esp),%edx
    c009:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    c00f:	01 d2                	add    %edx,%edx
    c011:	01 d0                	add    %edx,%eax
    c013:	8b 54 24 0c          	mov    0xc(%esp),%edx
    c017:	66 89 10             	mov    %dx,(%eax)
			bh->b_dirt=1;
    c01a:	8b 44 24 08          	mov    0x8(%esp),%eax
    c01e:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		}
	brelse(bh);
    c022:	83 ec 0c             	sub    $0xc,%esp
    c025:	ff 74 24 14          	pushl  0x14(%esp)
    c029:	e8 62 0f 00 00       	call   cf90 <brelse>
    c02e:	83 c4 10             	add    $0x10,%esp
	return i;
    c031:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    c035:	83 c4 1c             	add    $0x1c,%esp
    c038:	c3                   	ret    

0000c039 <bmap>:

int bmap(struct m_inode * inode,int block)
{
    c039:	83 ec 0c             	sub    $0xc,%esp
	return _bmap(inode,block,0);
    c03c:	83 ec 04             	sub    $0x4,%esp
    c03f:	6a 00                	push   $0x0
    c041:	ff 74 24 1c          	pushl  0x1c(%esp)
    c045:	ff 74 24 1c          	pushl  0x1c(%esp)
    c049:	e8 b6 fb ff ff       	call   bc04 <_bmap>
    c04e:	83 c4 10             	add    $0x10,%esp
}
    c051:	83 c4 0c             	add    $0xc,%esp
    c054:	c3                   	ret    

0000c055 <create_block>:

int create_block(struct m_inode * inode, int block)
{
    c055:	83 ec 0c             	sub    $0xc,%esp
	return _bmap(inode,block,1);
    c058:	83 ec 04             	sub    $0x4,%esp
    c05b:	6a 01                	push   $0x1
    c05d:	ff 74 24 1c          	pushl  0x1c(%esp)
    c061:	ff 74 24 1c          	pushl  0x1c(%esp)
    c065:	e8 9a fb ff ff       	call   bc04 <_bmap>
    c06a:	83 c4 10             	add    $0x10,%esp
}
    c06d:	83 c4 0c             	add    $0xc,%esp
    c070:	c3                   	ret    

0000c071 <iput>:
		
void iput(struct m_inode * inode)
{
    c071:	83 ec 0c             	sub    $0xc,%esp
	if (!inode)
    c074:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    c079:	0f 84 93 01 00 00    	je     c212 <iput+0x1a1>
		return;
	wait_on_inode(inode);
    c07f:	83 ec 0c             	sub    $0xc,%esp
    c082:	ff 74 24 1c          	pushl  0x1c(%esp)
    c086:	e8 1d fa ff ff       	call   baa8 <wait_on_inode>
    c08b:	83 c4 10             	add    $0x10,%esp
	if (!inode->i_count)
    c08e:	8b 44 24 10          	mov    0x10(%esp),%eax
    c092:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c096:	66 85 c0             	test   %ax,%ax
    c099:	75 10                	jne    c0ab <iput+0x3a>
		panic("iput: trying to free free inode");
    c09b:	83 ec 0c             	sub    $0xc,%esp
    c09e:	68 24 87 01 00       	push   $0x18724
    c0a3:	e8 26 c7 ff ff       	call   87ce <panic>
    c0a8:	83 c4 10             	add    $0x10,%esp
	if (inode->i_pipe) {
    c0ab:	8b 44 24 10          	mov    0x10(%esp),%eax
    c0af:	0f b6 40 34          	movzbl 0x34(%eax),%eax
    c0b3:	84 c0                	test   %al,%al
    c0b5:	74 69                	je     c120 <iput+0xaf>
		wake_up(&inode->i_wait);
    c0b7:	8b 44 24 10          	mov    0x10(%esp),%eax
    c0bb:	83 c0 20             	add    $0x20,%eax
    c0be:	83 ec 0c             	sub    $0xc,%esp
    c0c1:	50                   	push   %eax
    c0c2:	e8 b2 ae ff ff       	call   6f79 <wake_up>
    c0c7:	83 c4 10             	add    $0x10,%esp
		if (--inode->i_count)
    c0ca:	8b 44 24 10          	mov    0x10(%esp),%eax
    c0ce:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c0d2:	8d 50 ff             	lea    -0x1(%eax),%edx
    c0d5:	8b 44 24 10          	mov    0x10(%esp),%eax
    c0d9:	66 89 50 30          	mov    %dx,0x30(%eax)
    c0dd:	8b 44 24 10          	mov    0x10(%esp),%eax
    c0e1:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c0e5:	66 85 c0             	test   %ax,%ax
    c0e8:	0f 85 27 01 00 00    	jne    c215 <iput+0x1a4>
			return;
		free_page(inode->i_size);
    c0ee:	8b 44 24 10          	mov    0x10(%esp),%eax
    c0f2:	8b 40 04             	mov    0x4(%eax),%eax
    c0f5:	83 ec 0c             	sub    $0xc,%esp
    c0f8:	50                   	push   %eax
    c0f9:	e8 bc e2 ff ff       	call   a3ba <free_page>
    c0fe:	83 c4 10             	add    $0x10,%esp
		inode->i_count=0;
    c101:	8b 44 24 10          	mov    0x10(%esp),%eax
    c105:	66 c7 40 30 00 00    	movw   $0x0,0x30(%eax)
		inode->i_dirt=0;
    c10b:	8b 44 24 10          	mov    0x10(%esp),%eax
    c10f:	c6 40 33 00          	movb   $0x0,0x33(%eax)
		inode->i_pipe=0;
    c113:	8b 44 24 10          	mov    0x10(%esp),%eax
    c117:	c6 40 34 00          	movb   $0x0,0x34(%eax)
		return;
    c11b:	e9 f6 00 00 00       	jmp    c216 <iput+0x1a5>
	}
	if (!inode->i_dev) {
    c120:	8b 44 24 10          	mov    0x10(%esp),%eax
    c124:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    c128:	66 85 c0             	test   %ax,%ax
    c12b:	75 18                	jne    c145 <iput+0xd4>
		inode->i_count--;
    c12d:	8b 44 24 10          	mov    0x10(%esp),%eax
    c131:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c135:	8d 50 ff             	lea    -0x1(%eax),%edx
    c138:	8b 44 24 10          	mov    0x10(%esp),%eax
    c13c:	66 89 50 30          	mov    %dx,0x30(%eax)
		return;
    c140:	e9 d1 00 00 00       	jmp    c216 <iput+0x1a5>
	}
	if (S_ISBLK(inode->i_mode)) {
    c145:	8b 44 24 10          	mov    0x10(%esp),%eax
    c149:	0f b7 00             	movzwl (%eax),%eax
    c14c:	0f b7 c0             	movzwl %ax,%eax
    c14f:	25 00 f0 00 00       	and    $0xf000,%eax
    c154:	3d 00 60 00 00       	cmp    $0x6000,%eax
    c159:	75 26                	jne    c181 <iput+0x110>
		sync_dev(inode->i_zone[0]);
    c15b:	8b 44 24 10          	mov    0x10(%esp),%eax
    c15f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    c163:	0f b7 c0             	movzwl %ax,%eax
    c166:	83 ec 0c             	sub    $0xc,%esp
    c169:	50                   	push   %eax
    c16a:	e8 5a 07 00 00       	call   c8c9 <sync_dev>
    c16f:	83 c4 10             	add    $0x10,%esp
		wait_on_inode(inode);
    c172:	83 ec 0c             	sub    $0xc,%esp
    c175:	ff 74 24 1c          	pushl  0x1c(%esp)
    c179:	e8 2a f9 ff ff       	call   baa8 <wait_on_inode>
    c17e:	83 c4 10             	add    $0x10,%esp
	}
repeat:
	if (inode->i_count>1) {
    c181:	8b 44 24 10          	mov    0x10(%esp),%eax
    c185:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c189:	66 83 f8 01          	cmp    $0x1,%ax
    c18d:	76 15                	jbe    c1a4 <iput+0x133>
		inode->i_count--;
    c18f:	8b 44 24 10          	mov    0x10(%esp),%eax
    c193:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c197:	8d 50 ff             	lea    -0x1(%eax),%edx
    c19a:	8b 44 24 10          	mov    0x10(%esp),%eax
    c19e:	66 89 50 30          	mov    %dx,0x30(%eax)
		return;
    c1a2:	eb 72                	jmp    c216 <iput+0x1a5>
	}
	if (!inode->i_nlinks) {
    c1a4:	8b 44 24 10          	mov    0x10(%esp),%eax
    c1a8:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    c1ac:	84 c0                	test   %al,%al
    c1ae:	75 20                	jne    c1d0 <iput+0x15f>
		truncate(inode);
    c1b0:	83 ec 0c             	sub    $0xc,%esp
    c1b3:	ff 74 24 1c          	pushl  0x1c(%esp)
    c1b7:	e8 5a 66 00 00       	call   12816 <truncate>
    c1bc:	83 c4 10             	add    $0x10,%esp
		free_inode(inode);
    c1bf:	83 ec 0c             	sub    $0xc,%esp
    c1c2:	ff 74 24 1c          	pushl  0x1c(%esp)
    c1c6:	e8 73 5e 00 00       	call   1203e <free_inode>
    c1cb:	83 c4 10             	add    $0x10,%esp
		return;
    c1ce:	eb 46                	jmp    c216 <iput+0x1a5>
	}
	if (inode->i_dirt) {
    c1d0:	8b 44 24 10          	mov    0x10(%esp),%eax
    c1d4:	0f b6 40 33          	movzbl 0x33(%eax),%eax
    c1d8:	84 c0                	test   %al,%al
    c1da:	74 20                	je     c1fc <iput+0x18b>
		write_inode(inode);	/* we can sleep - so do again */
    c1dc:	83 ec 0c             	sub    $0xc,%esp
    c1df:	ff 74 24 1c          	pushl  0x1c(%esp)
    c1e3:	e8 f6 04 00 00       	call   c6de <write_inode>
    c1e8:	83 c4 10             	add    $0x10,%esp
		wait_on_inode(inode);
    c1eb:	83 ec 0c             	sub    $0xc,%esp
    c1ee:	ff 74 24 1c          	pushl  0x1c(%esp)
    c1f2:	e8 b1 f8 ff ff       	call   baa8 <wait_on_inode>
    c1f7:	83 c4 10             	add    $0x10,%esp
		goto repeat;
    c1fa:	eb 85                	jmp    c181 <iput+0x110>
	}
	inode->i_count--;
    c1fc:	8b 44 24 10          	mov    0x10(%esp),%eax
    c200:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c204:	8d 50 ff             	lea    -0x1(%eax),%edx
    c207:	8b 44 24 10          	mov    0x10(%esp),%eax
    c20b:	66 89 50 30          	mov    %dx,0x30(%eax)
	return;
    c20f:	90                   	nop
    c210:	eb 04                	jmp    c216 <iput+0x1a5>
}
		
void iput(struct m_inode * inode)
{
	if (!inode)
		return;
    c212:	90                   	nop
    c213:	eb 01                	jmp    c216 <iput+0x1a5>
	if (!inode->i_count)
		panic("iput: trying to free free inode");
	if (inode->i_pipe) {
		wake_up(&inode->i_wait);
		if (--inode->i_count)
			return;
    c215:	90                   	nop
		wait_on_inode(inode);
		goto repeat;
	}
	inode->i_count--;
	return;
}
    c216:	83 c4 0c             	add    $0xc,%esp
    c219:	c3                   	ret    

0000c21a <get_empty_inode>:

struct m_inode * get_empty_inode(void)
{
    c21a:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;
	static struct m_inode * last_inode = inode_table;
	int i;

	do {
		inode = NULL;
    c21d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c224:	00 
		for (i = NR_INODE; i ; i--) {
    c225:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
    c22c:	00 
    c22d:	eb 59                	jmp    c288 <get_empty_inode+0x6e>
			if (++last_inode >= inode_table + NR_INODE)
    c22f:	a1 00 f3 01 00       	mov    0x1f300,%eax
    c234:	83 c0 38             	add    $0x38,%eax
    c237:	a3 00 f3 01 00       	mov    %eax,0x1f300
    c23c:	a1 00 f3 01 00       	mov    0x1f300,%eax
    c241:	ba 60 3c 02 00       	mov    $0x23c60,%edx
    c246:	39 d0                	cmp    %edx,%eax
    c248:	72 0a                	jb     c254 <get_empty_inode+0x3a>
				last_inode = inode_table;
    c24a:	c7 05 00 f3 01 00 60 	movl   $0x23560,0x1f300
    c251:	35 02 00 
			if (!last_inode->i_count) {
    c254:	a1 00 f3 01 00       	mov    0x1f300,%eax
    c259:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c25d:	66 85 c0             	test   %ax,%ax
    c260:	75 21                	jne    c283 <get_empty_inode+0x69>
				inode = last_inode;
    c262:	a1 00 f3 01 00       	mov    0x1f300,%eax
    c267:	89 44 24 0c          	mov    %eax,0xc(%esp)
				if (!inode->i_dirt && !inode->i_lock)
    c26b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c26f:	0f b6 40 33          	movzbl 0x33(%eax),%eax
    c273:	84 c0                	test   %al,%al
    c275:	75 0c                	jne    c283 <get_empty_inode+0x69>
    c277:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c27b:	0f b6 40 32          	movzbl 0x32(%eax),%eax
    c27f:	84 c0                	test   %al,%al
    c281:	74 0e                	je     c291 <get_empty_inode+0x77>
	static struct m_inode * last_inode = inode_table;
	int i;

	do {
		inode = NULL;
		for (i = NR_INODE; i ; i--) {
    c283:	83 6c 24 08 01       	subl   $0x1,0x8(%esp)
    c288:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    c28d:	75 a0                	jne    c22f <get_empty_inode+0x15>
    c28f:	eb 01                	jmp    c292 <get_empty_inode+0x78>
			if (++last_inode >= inode_table + NR_INODE)
				last_inode = inode_table;
			if (!last_inode->i_count) {
				inode = last_inode;
				if (!inode->i_dirt && !inode->i_lock)
					break;
    c291:	90                   	nop
			}
		}
		if (!inode) {
    c292:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    c297:	75 72                	jne    c30b <get_empty_inode+0xf1>
			for (i=0 ; i<NR_INODE ; i++)
    c299:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    c2a0:	00 
    c2a1:	eb 51                	jmp    c2f4 <get_empty_inode+0xda>
				printk("%04x: %6d\t",inode_table[i].i_dev,
					inode_table[i].i_num);
    c2a3:	8b 44 24 08          	mov    0x8(%esp),%eax
    c2a7:	c1 e0 03             	shl    $0x3,%eax
    c2aa:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    c2b1:	29 c2                	sub    %eax,%edx
    c2b3:	89 d0                	mov    %edx,%eax
    c2b5:	05 8e 35 02 00       	add    $0x2358e,%eax
    c2ba:	0f b7 00             	movzwl (%eax),%eax
					break;
			}
		}
		if (!inode) {
			for (i=0 ; i<NR_INODE ; i++)
				printk("%04x: %6d\t",inode_table[i].i_dev,
    c2bd:	0f b7 d0             	movzwl %ax,%edx
    c2c0:	8b 44 24 08          	mov    0x8(%esp),%eax
    c2c4:	c1 e0 03             	shl    $0x3,%eax
    c2c7:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
    c2ce:	29 c1                	sub    %eax,%ecx
    c2d0:	89 c8                	mov    %ecx,%eax
    c2d2:	05 8c 35 02 00       	add    $0x2358c,%eax
    c2d7:	0f b7 00             	movzwl (%eax),%eax
    c2da:	0f b7 c0             	movzwl %ax,%eax
    c2dd:	83 ec 04             	sub    $0x4,%esp
    c2e0:	52                   	push   %edx
    c2e1:	50                   	push   %eax
    c2e2:	68 44 87 01 00       	push   $0x18744
    c2e7:	e8 21 c5 ff ff       	call   880d <printk>
    c2ec:	83 c4 10             	add    $0x10,%esp
				if (!inode->i_dirt && !inode->i_lock)
					break;
			}
		}
		if (!inode) {
			for (i=0 ; i<NR_INODE ; i++)
    c2ef:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    c2f4:	83 7c 24 08 1f       	cmpl   $0x1f,0x8(%esp)
    c2f9:	7e a8                	jle    c2a3 <get_empty_inode+0x89>
				printk("%04x: %6d\t",inode_table[i].i_dev,
					inode_table[i].i_num);
			panic("No free inodes in mem");
    c2fb:	83 ec 0c             	sub    $0xc,%esp
    c2fe:	68 4f 87 01 00       	push   $0x1874f
    c303:	e8 c6 c4 ff ff       	call   87ce <panic>
    c308:	83 c4 10             	add    $0x10,%esp
		}
		wait_on_inode(inode);
    c30b:	83 ec 0c             	sub    $0xc,%esp
    c30e:	ff 74 24 18          	pushl  0x18(%esp)
    c312:	e8 91 f7 ff ff       	call   baa8 <wait_on_inode>
    c317:	83 c4 10             	add    $0x10,%esp
		while (inode->i_dirt) {
    c31a:	eb 1e                	jmp    c33a <get_empty_inode+0x120>
			write_inode(inode);
    c31c:	83 ec 0c             	sub    $0xc,%esp
    c31f:	ff 74 24 18          	pushl  0x18(%esp)
    c323:	e8 b6 03 00 00       	call   c6de <write_inode>
    c328:	83 c4 10             	add    $0x10,%esp
			wait_on_inode(inode);
    c32b:	83 ec 0c             	sub    $0xc,%esp
    c32e:	ff 74 24 18          	pushl  0x18(%esp)
    c332:	e8 71 f7 ff ff       	call   baa8 <wait_on_inode>
    c337:	83 c4 10             	add    $0x10,%esp
				printk("%04x: %6d\t",inode_table[i].i_dev,
					inode_table[i].i_num);
			panic("No free inodes in mem");
		}
		wait_on_inode(inode);
		while (inode->i_dirt) {
    c33a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c33e:	0f b6 40 33          	movzbl 0x33(%eax),%eax
    c342:	84 c0                	test   %al,%al
    c344:	75 d6                	jne    c31c <get_empty_inode+0x102>
			write_inode(inode);
			wait_on_inode(inode);
		}
	} while (inode->i_count);
    c346:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c34a:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c34e:	66 85 c0             	test   %ax,%ax
    c351:	0f 85 c6 fe ff ff    	jne    c21d <get_empty_inode+0x3>
	memset(inode,0,sizeof(*inode));
    c357:	83 ec 04             	sub    $0x4,%esp
    c35a:	6a 38                	push   $0x38
    c35c:	6a 00                	push   $0x0
    c35e:	ff 74 24 18          	pushl  0x18(%esp)
    c362:	e8 1c f7 ff ff       	call   ba83 <memset>
    c367:	83 c4 10             	add    $0x10,%esp
	inode->i_count = 1;
    c36a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c36e:	66 c7 40 30 01 00    	movw   $0x1,0x30(%eax)
	return inode;
    c374:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    c378:	83 c4 1c             	add    $0x1c,%esp
    c37b:	c3                   	ret    

0000c37c <get_pipe_inode>:

struct m_inode * get_pipe_inode(void)
{
    c37c:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;

	if (!(inode = get_empty_inode()))
    c37f:	e8 96 fe ff ff       	call   c21a <get_empty_inode>
    c384:	89 44 24 0c          	mov    %eax,0xc(%esp)
    c388:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    c38d:	75 07                	jne    c396 <get_pipe_inode+0x1a>
		return NULL;
    c38f:	b8 00 00 00 00       	mov    $0x0,%eax
    c394:	eb 5a                	jmp    c3f0 <get_pipe_inode+0x74>
	if (!(inode->i_size=get_free_page())) {
    c396:	e8 e3 df ff ff       	call   a37e <get_free_page>
    c39b:	89 c2                	mov    %eax,%edx
    c39d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3a1:	89 50 04             	mov    %edx,0x4(%eax)
    c3a4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3a8:	8b 40 04             	mov    0x4(%eax),%eax
    c3ab:	85 c0                	test   %eax,%eax
    c3ad:	75 11                	jne    c3c0 <get_pipe_inode+0x44>
		inode->i_count = 0;
    c3af:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3b3:	66 c7 40 30 00 00    	movw   $0x0,0x30(%eax)
		return NULL;
    c3b9:	b8 00 00 00 00       	mov    $0x0,%eax
    c3be:	eb 30                	jmp    c3f0 <get_pipe_inode+0x74>
	}
	inode->i_count = 2;	/* sum of readers/writers */
    c3c0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3c4:	66 c7 40 30 02 00    	movw   $0x2,0x30(%eax)
	PIPE_HEAD(*inode) = PIPE_TAIL(*inode) = 0;
    c3ca:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3ce:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    c3d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3d8:	0f b7 50 10          	movzwl 0x10(%eax),%edx
    c3dc:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3e0:	66 89 50 0e          	mov    %dx,0xe(%eax)
	inode->i_pipe = 1;
    c3e4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c3e8:	c6 40 34 01          	movb   $0x1,0x34(%eax)
	return inode;
    c3ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    c3f0:	83 c4 1c             	add    $0x1c,%esp
    c3f3:	c3                   	ret    

0000c3f4 <iget>:

struct m_inode * iget(int dev,int nr)
{
    c3f4:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode, * empty;

	if (!dev)
    c3f7:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    c3fc:	75 10                	jne    c40e <iget+0x1a>
		panic("iget with dev==0");
    c3fe:	83 ec 0c             	sub    $0xc,%esp
    c401:	68 65 87 01 00       	push   $0x18765
    c406:	e8 c3 c3 ff ff       	call   87ce <panic>
    c40b:	83 c4 10             	add    $0x10,%esp
	empty = get_empty_inode();
    c40e:	e8 07 fe ff ff       	call   c21a <get_empty_inode>
    c413:	89 44 24 04          	mov    %eax,0x4(%esp)
	inode = inode_table;
    c417:	c7 44 24 0c 60 35 02 	movl   $0x23560,0xc(%esp)
    c41e:	00 
	while (inode < NR_INODE+inode_table) {
    c41f:	e9 43 01 00 00       	jmp    c567 <iget+0x173>
		if (inode->i_dev != dev || inode->i_num != nr) {
    c424:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c428:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    c42c:	0f b7 c0             	movzwl %ax,%eax
    c42f:	3b 44 24 20          	cmp    0x20(%esp),%eax
    c433:	75 11                	jne    c446 <iget+0x52>
    c435:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c439:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    c43d:	0f b7 c0             	movzwl %ax,%eax
    c440:	3b 44 24 24          	cmp    0x24(%esp),%eax
    c444:	74 0a                	je     c450 <iget+0x5c>
			inode++;
    c446:	83 44 24 0c 38       	addl   $0x38,0xc(%esp)
			continue;
    c44b:	e9 17 01 00 00       	jmp    c567 <iget+0x173>
		}
		wait_on_inode(inode);
    c450:	83 ec 0c             	sub    $0xc,%esp
    c453:	ff 74 24 18          	pushl  0x18(%esp)
    c457:	e8 4c f6 ff ff       	call   baa8 <wait_on_inode>
    c45c:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dev != dev || inode->i_num != nr) {
    c45f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c463:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    c467:	0f b7 c0             	movzwl %ax,%eax
    c46a:	3b 44 24 20          	cmp    0x20(%esp),%eax
    c46e:	75 11                	jne    c481 <iget+0x8d>
    c470:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c474:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    c478:	0f b7 c0             	movzwl %ax,%eax
    c47b:	3b 44 24 24          	cmp    0x24(%esp),%eax
    c47f:	74 0d                	je     c48e <iget+0x9a>
			inode = inode_table;
    c481:	c7 44 24 0c 60 35 02 	movl   $0x23560,0xc(%esp)
    c488:	00 
			continue;
    c489:	e9 d9 00 00 00       	jmp    c567 <iget+0x173>
		}
		inode->i_count++;
    c48e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c492:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    c496:	8d 50 01             	lea    0x1(%eax),%edx
    c499:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c49d:	66 89 50 30          	mov    %dx,0x30(%eax)
		if (inode->i_mount) {
    c4a1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c4a5:	0f b6 40 35          	movzbl 0x35(%eax),%eax
    c4a9:	84 c0                	test   %al,%al
    c4ab:	0f 84 9a 00 00 00    	je     c54b <iget+0x157>
			int i;

			for (i = 0 ; i<NR_SUPER ; i++)
    c4b1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    c4b8:	00 
    c4b9:	eb 19                	jmp    c4d4 <iget+0xe0>
				if (super_block[i].s_imount==inode)
    c4bb:	8b 44 24 08          	mov    0x8(%esp),%eax
    c4bf:	6b c0 6c             	imul   $0x6c,%eax,%eax
    c4c2:	05 dc 53 02 00       	add    $0x253dc,%eax
    c4c7:	8b 00                	mov    (%eax),%eax
    c4c9:	3b 44 24 0c          	cmp    0xc(%esp),%eax
    c4cd:	74 0e                	je     c4dd <iget+0xe9>
		}
		inode->i_count++;
		if (inode->i_mount) {
			int i;

			for (i = 0 ; i<NR_SUPER ; i++)
    c4cf:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    c4d4:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    c4d9:	7e e0                	jle    c4bb <iget+0xc7>
    c4db:	eb 01                	jmp    c4de <iget+0xea>
				if (super_block[i].s_imount==inode)
					break;
    c4dd:	90                   	nop
			if (i >= NR_SUPER) {
    c4de:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    c4e3:	7e 2f                	jle    c514 <iget+0x120>
				printk("Mounted inode hasn't got sb\n");
    c4e5:	83 ec 0c             	sub    $0xc,%esp
    c4e8:	68 76 87 01 00       	push   $0x18776
    c4ed:	e8 1b c3 ff ff       	call   880d <printk>
    c4f2:	83 c4 10             	add    $0x10,%esp
				if (empty)
    c4f5:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    c4fa:	74 0f                	je     c50b <iget+0x117>
					iput(empty);
    c4fc:	83 ec 0c             	sub    $0xc,%esp
    c4ff:	ff 74 24 10          	pushl  0x10(%esp)
    c503:	e8 69 fb ff ff       	call   c071 <iput>
    c508:	83 c4 10             	add    $0x10,%esp
				return inode;
    c50b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c50f:	e9 a7 00 00 00       	jmp    c5bb <iget+0x1c7>
			}
			iput(inode);
    c514:	83 ec 0c             	sub    $0xc,%esp
    c517:	ff 74 24 18          	pushl  0x18(%esp)
    c51b:	e8 51 fb ff ff       	call   c071 <iput>
    c520:	83 c4 10             	add    $0x10,%esp
			dev = super_block[i].s_dev;
    c523:	8b 44 24 08          	mov    0x8(%esp),%eax
    c527:	6b c0 6c             	imul   $0x6c,%eax,%eax
    c52a:	05 d4 53 02 00       	add    $0x253d4,%eax
    c52f:	0f b7 00             	movzwl (%eax),%eax
    c532:	0f b7 c0             	movzwl %ax,%eax
    c535:	89 44 24 20          	mov    %eax,0x20(%esp)
			nr = ROOT_INO;
    c539:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
    c540:	00 
			inode = inode_table;
    c541:	c7 44 24 0c 60 35 02 	movl   $0x23560,0xc(%esp)
    c548:	00 
			continue;
    c549:	eb 1c                	jmp    c567 <iget+0x173>
		}
		if (empty)
    c54b:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    c550:	74 0f                	je     c561 <iget+0x16d>
			iput(empty);
    c552:	83 ec 0c             	sub    $0xc,%esp
    c555:	ff 74 24 10          	pushl  0x10(%esp)
    c559:	e8 13 fb ff ff       	call   c071 <iput>
    c55e:	83 c4 10             	add    $0x10,%esp
		return inode;
    c561:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c565:	eb 54                	jmp    c5bb <iget+0x1c7>

	if (!dev)
		panic("iget with dev==0");
	empty = get_empty_inode();
	inode = inode_table;
	while (inode < NR_INODE+inode_table) {
    c567:	b8 60 3c 02 00       	mov    $0x23c60,%eax
    c56c:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    c570:	0f 82 ae fe ff ff    	jb     c424 <iget+0x30>
		}
		if (empty)
			iput(empty);
		return inode;
	}
	if (!empty)
    c576:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    c57b:	75 07                	jne    c584 <iget+0x190>
		return (NULL);
    c57d:	b8 00 00 00 00       	mov    $0x0,%eax
    c582:	eb 37                	jmp    c5bb <iget+0x1c7>
	inode=empty;
    c584:	8b 44 24 04          	mov    0x4(%esp),%eax
    c588:	89 44 24 0c          	mov    %eax,0xc(%esp)
	inode->i_dev = dev;
    c58c:	8b 44 24 20          	mov    0x20(%esp),%eax
    c590:	89 c2                	mov    %eax,%edx
    c592:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c596:	66 89 50 2c          	mov    %dx,0x2c(%eax)
	inode->i_num = nr;
    c59a:	8b 44 24 24          	mov    0x24(%esp),%eax
    c59e:	89 c2                	mov    %eax,%edx
    c5a0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c5a4:	66 89 50 2e          	mov    %dx,0x2e(%eax)
	read_inode(inode);
    c5a8:	83 ec 0c             	sub    $0xc,%esp
    c5ab:	ff 74 24 18          	pushl  0x18(%esp)
    c5af:	e8 0b 00 00 00       	call   c5bf <read_inode>
    c5b4:	83 c4 10             	add    $0x10,%esp
	return inode;
    c5b7:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    c5bb:	83 c4 1c             	add    $0x1c,%esp
    c5be:	c3                   	ret    

0000c5bf <read_inode>:

static void read_inode(struct m_inode * inode)
{
    c5bf:	83 ec 1c             	sub    $0x1c,%esp
	struct super_block * sb;
	struct buffer_head * bh;
	int block;

	lock_inode(inode);
    c5c2:	83 ec 0c             	sub    $0xc,%esp
    c5c5:	ff 74 24 2c          	pushl  0x2c(%esp)
    c5c9:	e8 05 f5 ff ff       	call   bad3 <lock_inode>
    c5ce:	83 c4 10             	add    $0x10,%esp
	if (!(sb=get_super(inode->i_dev)))
    c5d1:	8b 44 24 20          	mov    0x20(%esp),%eax
    c5d5:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    c5d9:	0f b7 c0             	movzwl %ax,%eax
    c5dc:	83 ec 0c             	sub    $0xc,%esp
    c5df:	50                   	push   %eax
    c5e0:	e8 6e 0e 00 00       	call   d453 <get_super>
    c5e5:	83 c4 10             	add    $0x10,%esp
    c5e8:	89 44 24 0c          	mov    %eax,0xc(%esp)
    c5ec:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    c5f1:	75 10                	jne    c603 <read_inode+0x44>
		panic("trying to read inode without dev");
    c5f3:	83 ec 0c             	sub    $0xc,%esp
    c5f6:	68 94 87 01 00       	push   $0x18794
    c5fb:	e8 ce c1 ff ff       	call   87ce <panic>
    c600:	83 c4 10             	add    $0x10,%esp
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    c603:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c607:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    c60b:	0f b7 c0             	movzwl %ax,%eax
    c60e:	8d 50 02             	lea    0x2(%eax),%edx
    c611:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c615:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    c619:	0f b7 c0             	movzwl %ax,%eax
    c61c:	01 d0                	add    %edx,%eax
    c61e:	89 c2                	mov    %eax,%edx
		(inode->i_num-1)/INODES_PER_BLOCK;
    c620:	8b 44 24 20          	mov    0x20(%esp),%eax
    c624:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    c628:	0f b7 c0             	movzwl %ax,%eax
    c62b:	83 e8 01             	sub    $0x1,%eax
    c62e:	c1 e8 05             	shr    $0x5,%eax
	int block;

	lock_inode(inode);
	if (!(sb=get_super(inode->i_dev)))
		panic("trying to read inode without dev");
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    c631:	01 d0                	add    %edx,%eax
    c633:	89 44 24 08          	mov    %eax,0x8(%esp)
		(inode->i_num-1)/INODES_PER_BLOCK;
	if (!(bh=bread(inode->i_dev,block)))
    c637:	8b 44 24 20          	mov    0x20(%esp),%eax
    c63b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    c63f:	0f b7 c0             	movzwl %ax,%eax
    c642:	83 ec 08             	sub    $0x8,%esp
    c645:	ff 74 24 10          	pushl  0x10(%esp)
    c649:	50                   	push   %eax
    c64a:	e8 97 09 00 00       	call   cfe6 <bread>
    c64f:	83 c4 10             	add    $0x10,%esp
    c652:	89 44 24 04          	mov    %eax,0x4(%esp)
    c656:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    c65b:	75 10                	jne    c66d <read_inode+0xae>
		panic("unable to read i-node block");
    c65d:	83 ec 0c             	sub    $0xc,%esp
    c660:	68 b5 87 01 00       	push   $0x187b5
    c665:	e8 64 c1 ff ff       	call   87ce <panic>
    c66a:	83 c4 10             	add    $0x10,%esp
	*(struct d_inode *)inode =
		((struct d_inode *)bh->b_data)
    c66d:	8b 44 24 04          	mov    0x4(%esp),%eax
    c671:	8b 10                	mov    (%eax),%edx
			[(inode->i_num-1)%INODES_PER_BLOCK];
    c673:	8b 44 24 20          	mov    0x20(%esp),%eax
    c677:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    c67b:	0f b7 c0             	movzwl %ax,%eax
    c67e:	83 e8 01             	sub    $0x1,%eax
    c681:	83 e0 1f             	and    $0x1f,%eax
    c684:	c1 e0 05             	shl    $0x5,%eax
    c687:	01 c2                	add    %eax,%edx
		panic("trying to read inode without dev");
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
		(inode->i_num-1)/INODES_PER_BLOCK;
	if (!(bh=bread(inode->i_dev,block)))
		panic("unable to read i-node block");
	*(struct d_inode *)inode =
    c689:	8b 44 24 20          	mov    0x20(%esp),%eax
    c68d:	8b 0a                	mov    (%edx),%ecx
    c68f:	89 08                	mov    %ecx,(%eax)
    c691:	8b 4a 04             	mov    0x4(%edx),%ecx
    c694:	89 48 04             	mov    %ecx,0x4(%eax)
    c697:	8b 4a 08             	mov    0x8(%edx),%ecx
    c69a:	89 48 08             	mov    %ecx,0x8(%eax)
    c69d:	8b 4a 0c             	mov    0xc(%edx),%ecx
    c6a0:	89 48 0c             	mov    %ecx,0xc(%eax)
    c6a3:	8b 4a 10             	mov    0x10(%edx),%ecx
    c6a6:	89 48 10             	mov    %ecx,0x10(%eax)
    c6a9:	8b 4a 14             	mov    0x14(%edx),%ecx
    c6ac:	89 48 14             	mov    %ecx,0x14(%eax)
    c6af:	8b 4a 18             	mov    0x18(%edx),%ecx
    c6b2:	89 48 18             	mov    %ecx,0x18(%eax)
    c6b5:	8b 52 1c             	mov    0x1c(%edx),%edx
    c6b8:	89 50 1c             	mov    %edx,0x1c(%eax)
		((struct d_inode *)bh->b_data)
			[(inode->i_num-1)%INODES_PER_BLOCK];
	brelse(bh);
    c6bb:	83 ec 0c             	sub    $0xc,%esp
    c6be:	ff 74 24 10          	pushl  0x10(%esp)
    c6c2:	e8 c9 08 00 00       	call   cf90 <brelse>
    c6c7:	83 c4 10             	add    $0x10,%esp
	unlock_inode(inode);
    c6ca:	83 ec 0c             	sub    $0xc,%esp
    c6cd:	ff 74 24 2c          	pushl  0x2c(%esp)
    c6d1:	e8 30 f4 ff ff       	call   bb06 <unlock_inode>
    c6d6:	83 c4 10             	add    $0x10,%esp
}
    c6d9:	90                   	nop
    c6da:	83 c4 1c             	add    $0x1c,%esp
    c6dd:	c3                   	ret    

0000c6de <write_inode>:

static void write_inode(struct m_inode * inode)
{
    c6de:	83 ec 1c             	sub    $0x1c,%esp
	struct super_block * sb;
	struct buffer_head * bh;
	int block;

	lock_inode(inode);
    c6e1:	83 ec 0c             	sub    $0xc,%esp
    c6e4:	ff 74 24 2c          	pushl  0x2c(%esp)
    c6e8:	e8 e6 f3 ff ff       	call   bad3 <lock_inode>
    c6ed:	83 c4 10             	add    $0x10,%esp
	if (!inode->i_dirt || !inode->i_dev) {
    c6f0:	8b 44 24 20          	mov    0x20(%esp),%eax
    c6f4:	0f b6 40 33          	movzbl 0x33(%eax),%eax
    c6f8:	84 c0                	test   %al,%al
    c6fa:	74 0d                	je     c709 <write_inode+0x2b>
    c6fc:	8b 44 24 20          	mov    0x20(%esp),%eax
    c700:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    c704:	66 85 c0             	test   %ax,%ax
    c707:	75 14                	jne    c71d <write_inode+0x3f>
		unlock_inode(inode);
    c709:	83 ec 0c             	sub    $0xc,%esp
    c70c:	ff 74 24 2c          	pushl  0x2c(%esp)
    c710:	e8 f1 f3 ff ff       	call   bb06 <unlock_inode>
    c715:	83 c4 10             	add    $0x10,%esp
		return;
    c718:	e9 18 01 00 00       	jmp    c835 <write_inode+0x157>
	}
	if (!(sb=get_super(inode->i_dev)))
    c71d:	8b 44 24 20          	mov    0x20(%esp),%eax
    c721:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    c725:	0f b7 c0             	movzwl %ax,%eax
    c728:	83 ec 0c             	sub    $0xc,%esp
    c72b:	50                   	push   %eax
    c72c:	e8 22 0d 00 00       	call   d453 <get_super>
    c731:	83 c4 10             	add    $0x10,%esp
    c734:	89 44 24 0c          	mov    %eax,0xc(%esp)
    c738:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    c73d:	75 10                	jne    c74f <write_inode+0x71>
		panic("trying to write inode without device");
    c73f:	83 ec 0c             	sub    $0xc,%esp
    c742:	68 d4 87 01 00       	push   $0x187d4
    c747:	e8 82 c0 ff ff       	call   87ce <panic>
    c74c:	83 c4 10             	add    $0x10,%esp
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    c74f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c753:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    c757:	0f b7 c0             	movzwl %ax,%eax
    c75a:	8d 50 02             	lea    0x2(%eax),%edx
    c75d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c761:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    c765:	0f b7 c0             	movzwl %ax,%eax
    c768:	01 d0                	add    %edx,%eax
    c76a:	89 c2                	mov    %eax,%edx
		(inode->i_num-1)/INODES_PER_BLOCK;
    c76c:	8b 44 24 20          	mov    0x20(%esp),%eax
    c770:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    c774:	0f b7 c0             	movzwl %ax,%eax
    c777:	83 e8 01             	sub    $0x1,%eax
    c77a:	c1 e8 05             	shr    $0x5,%eax
		unlock_inode(inode);
		return;
	}
	if (!(sb=get_super(inode->i_dev)))
		panic("trying to write inode without device");
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    c77d:	01 d0                	add    %edx,%eax
    c77f:	89 44 24 08          	mov    %eax,0x8(%esp)
		(inode->i_num-1)/INODES_PER_BLOCK;
	if (!(bh=bread(inode->i_dev,block)))
    c783:	8b 44 24 20          	mov    0x20(%esp),%eax
    c787:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    c78b:	0f b7 c0             	movzwl %ax,%eax
    c78e:	83 ec 08             	sub    $0x8,%esp
    c791:	ff 74 24 10          	pushl  0x10(%esp)
    c795:	50                   	push   %eax
    c796:	e8 4b 08 00 00       	call   cfe6 <bread>
    c79b:	83 c4 10             	add    $0x10,%esp
    c79e:	89 44 24 04          	mov    %eax,0x4(%esp)
    c7a2:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    c7a7:	75 10                	jne    c7b9 <write_inode+0xdb>
		panic("unable to read i-node block");
    c7a9:	83 ec 0c             	sub    $0xc,%esp
    c7ac:	68 b5 87 01 00       	push   $0x187b5
    c7b1:	e8 18 c0 ff ff       	call   87ce <panic>
    c7b6:	83 c4 10             	add    $0x10,%esp
	((struct d_inode *)bh->b_data)
    c7b9:	8b 44 24 04          	mov    0x4(%esp),%eax
    c7bd:	8b 10                	mov    (%eax),%edx
		[(inode->i_num-1)%INODES_PER_BLOCK] =
    c7bf:	8b 44 24 20          	mov    0x20(%esp),%eax
    c7c3:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    c7c7:	0f b7 c0             	movzwl %ax,%eax
    c7ca:	83 e8 01             	sub    $0x1,%eax
    c7cd:	83 e0 1f             	and    $0x1f,%eax
    c7d0:	c1 e0 05             	shl    $0x5,%eax
    c7d3:	01 c2                	add    %eax,%edx
    c7d5:	8b 44 24 20          	mov    0x20(%esp),%eax
    c7d9:	8b 08                	mov    (%eax),%ecx
    c7db:	89 0a                	mov    %ecx,(%edx)
    c7dd:	8b 48 04             	mov    0x4(%eax),%ecx
    c7e0:	89 4a 04             	mov    %ecx,0x4(%edx)
    c7e3:	8b 48 08             	mov    0x8(%eax),%ecx
    c7e6:	89 4a 08             	mov    %ecx,0x8(%edx)
    c7e9:	8b 48 0c             	mov    0xc(%eax),%ecx
    c7ec:	89 4a 0c             	mov    %ecx,0xc(%edx)
    c7ef:	8b 48 10             	mov    0x10(%eax),%ecx
    c7f2:	89 4a 10             	mov    %ecx,0x10(%edx)
    c7f5:	8b 48 14             	mov    0x14(%eax),%ecx
    c7f8:	89 4a 14             	mov    %ecx,0x14(%edx)
    c7fb:	8b 48 18             	mov    0x18(%eax),%ecx
    c7fe:	89 4a 18             	mov    %ecx,0x18(%edx)
    c801:	8b 40 1c             	mov    0x1c(%eax),%eax
    c804:	89 42 1c             	mov    %eax,0x1c(%edx)
			*(struct d_inode *)inode;
	bh->b_dirt=1;
    c807:	8b 44 24 04          	mov    0x4(%esp),%eax
    c80b:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	inode->i_dirt=0;
    c80f:	8b 44 24 20          	mov    0x20(%esp),%eax
    c813:	c6 40 33 00          	movb   $0x0,0x33(%eax)
	brelse(bh);
    c817:	83 ec 0c             	sub    $0xc,%esp
    c81a:	ff 74 24 10          	pushl  0x10(%esp)
    c81e:	e8 6d 07 00 00       	call   cf90 <brelse>
    c823:	83 c4 10             	add    $0x10,%esp
	unlock_inode(inode);
    c826:	83 ec 0c             	sub    $0xc,%esp
    c829:	ff 74 24 2c          	pushl  0x2c(%esp)
    c82d:	e8 d4 f2 ff ff       	call   bb06 <unlock_inode>
    c832:	83 c4 10             	add    $0x10,%esp
}
    c835:	83 c4 1c             	add    $0x1c,%esp
    c838:	c3                   	ret    

0000c839 <wait_on_buffer>:
static struct buffer_head * free_list;
static struct task_struct * buffer_wait = NULL;
int NR_BUFFERS = 0;

static inline void wait_on_buffer(struct buffer_head * bh)
{
    c839:	83 ec 0c             	sub    $0xc,%esp
	cli();
    c83c:	fa                   	cli    
	while (bh->b_lock)
    c83d:	eb 13                	jmp    c852 <wait_on_buffer+0x19>
		sleep_on(&bh->b_wait);
    c83f:	8b 44 24 10          	mov    0x10(%esp),%eax
    c843:	83 c0 10             	add    $0x10,%eax
    c846:	83 ec 0c             	sub    $0xc,%esp
    c849:	50                   	push   %eax
    c84a:	e8 23 a6 ff ff       	call   6e72 <sleep_on>
    c84f:	83 c4 10             	add    $0x10,%esp
int NR_BUFFERS = 0;

static inline void wait_on_buffer(struct buffer_head * bh)
{
	cli();
	while (bh->b_lock)
    c852:	8b 44 24 10          	mov    0x10(%esp),%eax
    c856:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    c85a:	84 c0                	test   %al,%al
    c85c:	75 e1                	jne    c83f <wait_on_buffer+0x6>
		sleep_on(&bh->b_wait);
	sti();
    c85e:	fb                   	sti    
}
    c85f:	90                   	nop
    c860:	83 c4 0c             	add    $0xc,%esp
    c863:	c3                   	ret    

0000c864 <sys_sync>:

int sys_sync(void)
{
    c864:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	struct buffer_head * bh;

	sync_inodes();		/* write out inodes into buffers */
    c867:	e8 37 f3 ff ff       	call   bba3 <sync_inodes>
	bh = start_buffer;
    c86c:	a1 04 f3 01 00       	mov    0x1f304,%eax
    c871:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c875:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c87c:	00 
    c87d:	eb 36                	jmp    c8b5 <sys_sync+0x51>
		wait_on_buffer(bh);
    c87f:	83 ec 0c             	sub    $0xc,%esp
    c882:	ff 74 24 14          	pushl  0x14(%esp)
    c886:	e8 ae ff ff ff       	call   c839 <wait_on_buffer>
    c88b:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dirt)
    c88e:	8b 44 24 08          	mov    0x8(%esp),%eax
    c892:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    c896:	84 c0                	test   %al,%al
    c898:	74 11                	je     c8ab <sys_sync+0x47>
			ll_rw_block(WRITE,bh);
    c89a:	83 ec 08             	sub    $0x8,%esp
    c89d:	ff 74 24 10          	pushl  0x10(%esp)
    c8a1:	6a 01                	push   $0x1
    c8a3:	e8 99 64 00 00       	call   12d41 <ll_rw_block>
    c8a8:	83 c4 10             	add    $0x10,%esp
	int i;
	struct buffer_head * bh;

	sync_inodes();		/* write out inodes into buffers */
	bh = start_buffer;
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c8ab:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    c8b0:	83 44 24 08 24       	addl   $0x24,0x8(%esp)
    c8b5:	a1 60 3c 02 00       	mov    0x23c60,%eax
    c8ba:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    c8be:	7c bf                	jl     c87f <sys_sync+0x1b>
		wait_on_buffer(bh);
		if (bh->b_dirt)
			ll_rw_block(WRITE,bh);
	}
	return 0;
    c8c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c8c5:	83 c4 1c             	add    $0x1c,%esp
    c8c8:	c3                   	ret    

0000c8c9 <sync_dev>:

int sync_dev(int dev)
{
    c8c9:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	struct buffer_head * bh;

	bh = start_buffer;
    c8cc:	a1 04 f3 01 00       	mov    0x1f304,%eax
    c8d1:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c8d5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c8dc:	00 
    c8dd:	eb 5b                	jmp    c93a <sync_dev+0x71>
		if (bh->b_dev != dev)
    c8df:	8b 44 24 08          	mov    0x8(%esp),%eax
    c8e3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c8e7:	0f b7 c0             	movzwl %ax,%eax
    c8ea:	3b 44 24 20          	cmp    0x20(%esp),%eax
    c8ee:	75 3f                	jne    c92f <sync_dev+0x66>
			continue;
		wait_on_buffer(bh);
    c8f0:	83 ec 0c             	sub    $0xc,%esp
    c8f3:	ff 74 24 14          	pushl  0x14(%esp)
    c8f7:	e8 3d ff ff ff       	call   c839 <wait_on_buffer>
    c8fc:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_dirt)
    c8ff:	8b 44 24 08          	mov    0x8(%esp),%eax
    c903:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c907:	0f b7 c0             	movzwl %ax,%eax
    c90a:	3b 44 24 20          	cmp    0x20(%esp),%eax
    c90e:	75 20                	jne    c930 <sync_dev+0x67>
    c910:	8b 44 24 08          	mov    0x8(%esp),%eax
    c914:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    c918:	84 c0                	test   %al,%al
    c91a:	74 14                	je     c930 <sync_dev+0x67>
			ll_rw_block(WRITE,bh);
    c91c:	83 ec 08             	sub    $0x8,%esp
    c91f:	ff 74 24 10          	pushl  0x10(%esp)
    c923:	6a 01                	push   $0x1
    c925:	e8 17 64 00 00       	call   12d41 <ll_rw_block>
    c92a:	83 c4 10             	add    $0x10,%esp
    c92d:	eb 01                	jmp    c930 <sync_dev+0x67>
	struct buffer_head * bh;

	bh = start_buffer;
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
		if (bh->b_dev != dev)
			continue;
    c92f:	90                   	nop
{
	int i;
	struct buffer_head * bh;

	bh = start_buffer;
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c930:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    c935:	83 44 24 08 24       	addl   $0x24,0x8(%esp)
    c93a:	a1 60 3c 02 00       	mov    0x23c60,%eax
    c93f:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    c943:	7c 9a                	jl     c8df <sync_dev+0x16>
			continue;
		wait_on_buffer(bh);
		if (bh->b_dev == dev && bh->b_dirt)
			ll_rw_block(WRITE,bh);
	}
	sync_inodes();
    c945:	e8 59 f2 ff ff       	call   bba3 <sync_inodes>
	bh = start_buffer;
    c94a:	a1 04 f3 01 00       	mov    0x1f304,%eax
    c94f:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c953:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c95a:	00 
    c95b:	eb 5b                	jmp    c9b8 <sync_dev+0xef>
		if (bh->b_dev != dev)
    c95d:	8b 44 24 08          	mov    0x8(%esp),%eax
    c961:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c965:	0f b7 c0             	movzwl %ax,%eax
    c968:	3b 44 24 20          	cmp    0x20(%esp),%eax
    c96c:	75 3f                	jne    c9ad <sync_dev+0xe4>
			continue;
		wait_on_buffer(bh);
    c96e:	83 ec 0c             	sub    $0xc,%esp
    c971:	ff 74 24 14          	pushl  0x14(%esp)
    c975:	e8 bf fe ff ff       	call   c839 <wait_on_buffer>
    c97a:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_dirt)
    c97d:	8b 44 24 08          	mov    0x8(%esp),%eax
    c981:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c985:	0f b7 c0             	movzwl %ax,%eax
    c988:	3b 44 24 20          	cmp    0x20(%esp),%eax
    c98c:	75 20                	jne    c9ae <sync_dev+0xe5>
    c98e:	8b 44 24 08          	mov    0x8(%esp),%eax
    c992:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    c996:	84 c0                	test   %al,%al
    c998:	74 14                	je     c9ae <sync_dev+0xe5>
			ll_rw_block(WRITE,bh);
    c99a:	83 ec 08             	sub    $0x8,%esp
    c99d:	ff 74 24 10          	pushl  0x10(%esp)
    c9a1:	6a 01                	push   $0x1
    c9a3:	e8 99 63 00 00       	call   12d41 <ll_rw_block>
    c9a8:	83 c4 10             	add    $0x10,%esp
    c9ab:	eb 01                	jmp    c9ae <sync_dev+0xe5>
	}
	sync_inodes();
	bh = start_buffer;
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
		if (bh->b_dev != dev)
			continue;
    c9ad:	90                   	nop
		if (bh->b_dev == dev && bh->b_dirt)
			ll_rw_block(WRITE,bh);
	}
	sync_inodes();
	bh = start_buffer;
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c9ae:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    c9b3:	83 44 24 08 24       	addl   $0x24,0x8(%esp)
    c9b8:	a1 60 3c 02 00       	mov    0x23c60,%eax
    c9bd:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    c9c1:	7c 9a                	jl     c95d <sync_dev+0x94>
			continue;
		wait_on_buffer(bh);
		if (bh->b_dev == dev && bh->b_dirt)
			ll_rw_block(WRITE,bh);
	}
	return 0;
    c9c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c9c8:	83 c4 1c             	add    $0x1c,%esp
    c9cb:	c3                   	ret    

0000c9cc <invalidate_buffers>:

static inline void invalidate_buffers(int dev)
{
    c9cc:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	struct buffer_head * bh;

	bh = start_buffer;
    c9cf:	a1 04 f3 01 00       	mov    0x1f304,%eax
    c9d4:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c9d8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c9df:	00 
    c9e0:	eb 55                	jmp    ca37 <invalidate_buffers+0x6b>
		if (bh->b_dev != dev)
    c9e2:	8b 44 24 08          	mov    0x8(%esp),%eax
    c9e6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c9ea:	0f b7 c0             	movzwl %ax,%eax
    c9ed:	3b 44 24 20          	cmp    0x20(%esp),%eax
    c9f1:	75 39                	jne    ca2c <invalidate_buffers+0x60>
			continue;
		wait_on_buffer(bh);
    c9f3:	83 ec 0c             	sub    $0xc,%esp
    c9f6:	ff 74 24 14          	pushl  0x14(%esp)
    c9fa:	e8 3a fe ff ff       	call   c839 <wait_on_buffer>
    c9ff:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev)
    ca02:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca06:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    ca0a:	0f b7 c0             	movzwl %ax,%eax
    ca0d:	3b 44 24 20          	cmp    0x20(%esp),%eax
    ca11:	75 1a                	jne    ca2d <invalidate_buffers+0x61>
			bh->b_uptodate = bh->b_dirt = 0;
    ca13:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca17:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
    ca1b:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca1f:	0f b6 50 0b          	movzbl 0xb(%eax),%edx
    ca23:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca27:	88 50 0a             	mov    %dl,0xa(%eax)
    ca2a:	eb 01                	jmp    ca2d <invalidate_buffers+0x61>
	struct buffer_head * bh;

	bh = start_buffer;
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
		if (bh->b_dev != dev)
			continue;
    ca2c:	90                   	nop
{
	int i;
	struct buffer_head * bh;

	bh = start_buffer;
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    ca2d:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    ca32:	83 44 24 08 24       	addl   $0x24,0x8(%esp)
    ca37:	a1 60 3c 02 00       	mov    0x23c60,%eax
    ca3c:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    ca40:	7c a0                	jl     c9e2 <invalidate_buffers+0x16>
			continue;
		wait_on_buffer(bh);
		if (bh->b_dev == dev)
			bh->b_uptodate = bh->b_dirt = 0;
	}
}
    ca42:	90                   	nop
    ca43:	83 c4 1c             	add    $0x1c,%esp
    ca46:	c3                   	ret    

0000ca47 <check_disk_change>:
 * that any additional removable block-device will use this routine,
 * and that mount/open needn't know that floppies/whatever are
 * special.
 */
void check_disk_change(int dev)
{
    ca47:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	if (MAJOR(dev) != 2)
    ca4a:	8b 44 24 20          	mov    0x20(%esp),%eax
    ca4e:	c1 e8 08             	shr    $0x8,%eax
    ca51:	83 f8 02             	cmp    $0x2,%eax
    ca54:	0f 85 83 00 00 00    	jne    cadd <check_disk_change+0x96>
		return;
	if (!floppy_change(dev & 0x03))
    ca5a:	8b 44 24 20          	mov    0x20(%esp),%eax
    ca5e:	83 e0 03             	and    $0x3,%eax
    ca61:	83 ec 0c             	sub    $0xc,%esp
    ca64:	50                   	push   %eax
    ca65:	e8 c6 64 00 00       	call   12f30 <floppy_change>
    ca6a:	83 c4 10             	add    $0x10,%esp
    ca6d:	85 c0                	test   %eax,%eax
    ca6f:	74 6f                	je     cae0 <check_disk_change+0x99>
		return;
	for (i=0 ; i<NR_SUPER ; i++)
    ca71:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    ca78:	00 
    ca79:	eb 3b                	jmp    cab6 <check_disk_change+0x6f>
		if (super_block[i].s_dev == dev)
    ca7b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ca7f:	6b c0 6c             	imul   $0x6c,%eax,%eax
    ca82:	05 d4 53 02 00       	add    $0x253d4,%eax
    ca87:	0f b7 00             	movzwl (%eax),%eax
    ca8a:	0f b7 c0             	movzwl %ax,%eax
    ca8d:	3b 44 24 20          	cmp    0x20(%esp),%eax
    ca91:	75 1e                	jne    cab1 <check_disk_change+0x6a>
			put_super(super_block[i].s_dev);
    ca93:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ca97:	6b c0 6c             	imul   $0x6c,%eax,%eax
    ca9a:	05 d4 53 02 00       	add    $0x253d4,%eax
    ca9f:	0f b7 00             	movzwl (%eax),%eax
    caa2:	0f b7 c0             	movzwl %ax,%eax
    caa5:	83 ec 0c             	sub    $0xc,%esp
    caa8:	50                   	push   %eax
    caa9:	e8 1a 0a 00 00       	call   d4c8 <put_super>
    caae:	83 c4 10             	add    $0x10,%esp

	if (MAJOR(dev) != 2)
		return;
	if (!floppy_change(dev & 0x03))
		return;
	for (i=0 ; i<NR_SUPER ; i++)
    cab1:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    cab6:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
    cabb:	7e be                	jle    ca7b <check_disk_change+0x34>
		if (super_block[i].s_dev == dev)
			put_super(super_block[i].s_dev);
	invalidate_inodes(dev);
    cabd:	83 ec 0c             	sub    $0xc,%esp
    cac0:	ff 74 24 2c          	pushl  0x2c(%esp)
    cac4:	e8 60 f0 ff ff       	call   bb29 <invalidate_inodes>
    cac9:	83 c4 10             	add    $0x10,%esp
	invalidate_buffers(dev);
    cacc:	83 ec 0c             	sub    $0xc,%esp
    cacf:	ff 74 24 2c          	pushl  0x2c(%esp)
    cad3:	e8 f4 fe ff ff       	call   c9cc <invalidate_buffers>
    cad8:	83 c4 10             	add    $0x10,%esp
    cadb:	eb 04                	jmp    cae1 <check_disk_change+0x9a>
void check_disk_change(int dev)
{
	int i;

	if (MAJOR(dev) != 2)
		return;
    cadd:	90                   	nop
    cade:	eb 01                	jmp    cae1 <check_disk_change+0x9a>
	if (!floppy_change(dev & 0x03))
		return;
    cae0:	90                   	nop
	for (i=0 ; i<NR_SUPER ; i++)
		if (super_block[i].s_dev == dev)
			put_super(super_block[i].s_dev);
	invalidate_inodes(dev);
	invalidate_buffers(dev);
}
    cae1:	83 c4 1c             	add    $0x1c,%esp
    cae4:	c3                   	ret    

0000cae5 <remove_from_queues>:

#define _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)
#define hash(dev,block) hash_table[_hashfn(dev,block)]

static inline void remove_from_queues(struct buffer_head * bh)
{
    cae5:	83 ec 0c             	sub    $0xc,%esp
/* remove from hash-queue */
	if (bh->b_next)
    cae8:	8b 44 24 10          	mov    0x10(%esp),%eax
    caec:	8b 40 18             	mov    0x18(%eax),%eax
    caef:	85 c0                	test   %eax,%eax
    caf1:	74 11                	je     cb04 <remove_from_queues+0x1f>
		bh->b_next->b_prev = bh->b_prev;
    caf3:	8b 44 24 10          	mov    0x10(%esp),%eax
    caf7:	8b 40 18             	mov    0x18(%eax),%eax
    cafa:	8b 54 24 10          	mov    0x10(%esp),%edx
    cafe:	8b 52 14             	mov    0x14(%edx),%edx
    cb01:	89 50 14             	mov    %edx,0x14(%eax)
	if (bh->b_prev)
    cb04:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb08:	8b 40 14             	mov    0x14(%eax),%eax
    cb0b:	85 c0                	test   %eax,%eax
    cb0d:	74 11                	je     cb20 <remove_from_queues+0x3b>
		bh->b_prev->b_next = bh->b_next;
    cb0f:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb13:	8b 40 14             	mov    0x14(%eax),%eax
    cb16:	8b 54 24 10          	mov    0x10(%esp),%edx
    cb1a:	8b 52 18             	mov    0x18(%edx),%edx
    cb1d:	89 50 18             	mov    %edx,0x18(%eax)
	if (hash(bh->b_dev,bh->b_blocknr) == bh)
    cb20:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb24:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cb28:	0f b7 d0             	movzwl %ax,%edx
    cb2b:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb2f:	8b 40 04             	mov    0x4(%eax),%eax
    cb32:	89 d1                	mov    %edx,%ecx
    cb34:	31 c1                	xor    %eax,%ecx
    cb36:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
    cb3b:	89 c8                	mov    %ecx,%eax
    cb3d:	f7 e2                	mul    %edx
    cb3f:	89 d0                	mov    %edx,%eax
    cb41:	c1 e8 08             	shr    $0x8,%eax
    cb44:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
    cb4a:	29 c1                	sub    %eax,%ecx
    cb4c:	89 c8                	mov    %ecx,%eax
    cb4e:	8b 04 85 a0 4e 02 00 	mov    0x24ea0(,%eax,4),%eax
    cb55:	3b 44 24 10          	cmp    0x10(%esp),%eax
    cb59:	75 3c                	jne    cb97 <remove_from_queues+0xb2>
		hash(bh->b_dev,bh->b_blocknr) = bh->b_next;
    cb5b:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb5f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cb63:	0f b7 d0             	movzwl %ax,%edx
    cb66:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb6a:	8b 40 04             	mov    0x4(%eax),%eax
    cb6d:	89 d1                	mov    %edx,%ecx
    cb6f:	31 c1                	xor    %eax,%ecx
    cb71:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
    cb76:	89 c8                	mov    %ecx,%eax
    cb78:	f7 e2                	mul    %edx
    cb7a:	89 d0                	mov    %edx,%eax
    cb7c:	c1 e8 08             	shr    $0x8,%eax
    cb7f:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
    cb85:	29 c1                	sub    %eax,%ecx
    cb87:	89 c8                	mov    %ecx,%eax
    cb89:	8b 54 24 10          	mov    0x10(%esp),%edx
    cb8d:	8b 52 18             	mov    0x18(%edx),%edx
    cb90:	89 14 85 a0 4e 02 00 	mov    %edx,0x24ea0(,%eax,4)
/* remove from free list */
	if (!(bh->b_prev_free) || !(bh->b_next_free))
    cb97:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb9b:	8b 40 1c             	mov    0x1c(%eax),%eax
    cb9e:	85 c0                	test   %eax,%eax
    cba0:	74 0b                	je     cbad <remove_from_queues+0xc8>
    cba2:	8b 44 24 10          	mov    0x10(%esp),%eax
    cba6:	8b 40 20             	mov    0x20(%eax),%eax
    cba9:	85 c0                	test   %eax,%eax
    cbab:	75 10                	jne    cbbd <remove_from_queues+0xd8>
		panic("Free block list corrupted");
    cbad:	83 ec 0c             	sub    $0xc,%esp
    cbb0:	68 f9 87 01 00       	push   $0x187f9
    cbb5:	e8 14 bc ff ff       	call   87ce <panic>
    cbba:	83 c4 10             	add    $0x10,%esp
	bh->b_prev_free->b_next_free = bh->b_next_free;
    cbbd:	8b 44 24 10          	mov    0x10(%esp),%eax
    cbc1:	8b 40 1c             	mov    0x1c(%eax),%eax
    cbc4:	8b 54 24 10          	mov    0x10(%esp),%edx
    cbc8:	8b 52 20             	mov    0x20(%edx),%edx
    cbcb:	89 50 20             	mov    %edx,0x20(%eax)
	bh->b_next_free->b_prev_free = bh->b_prev_free;
    cbce:	8b 44 24 10          	mov    0x10(%esp),%eax
    cbd2:	8b 40 20             	mov    0x20(%eax),%eax
    cbd5:	8b 54 24 10          	mov    0x10(%esp),%edx
    cbd9:	8b 52 1c             	mov    0x1c(%edx),%edx
    cbdc:	89 50 1c             	mov    %edx,0x1c(%eax)
	if (free_list == bh)
    cbdf:	a1 64 3c 02 00       	mov    0x23c64,%eax
    cbe4:	3b 44 24 10          	cmp    0x10(%esp),%eax
    cbe8:	75 0c                	jne    cbf6 <remove_from_queues+0x111>
		free_list = bh->b_next_free;
    cbea:	8b 44 24 10          	mov    0x10(%esp),%eax
    cbee:	8b 40 20             	mov    0x20(%eax),%eax
    cbf1:	a3 64 3c 02 00       	mov    %eax,0x23c64
}
    cbf6:	90                   	nop
    cbf7:	83 c4 0c             	add    $0xc,%esp
    cbfa:	c3                   	ret    

0000cbfb <insert_into_queues>:

static inline void insert_into_queues(struct buffer_head * bh)
{
/* put at end of free list */
	bh->b_next_free = free_list;
    cbfb:	8b 15 64 3c 02 00    	mov    0x23c64,%edx
    cc01:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc05:	89 50 20             	mov    %edx,0x20(%eax)
	bh->b_prev_free = free_list->b_prev_free;
    cc08:	a1 64 3c 02 00       	mov    0x23c64,%eax
    cc0d:	8b 50 1c             	mov    0x1c(%eax),%edx
    cc10:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc14:	89 50 1c             	mov    %edx,0x1c(%eax)
	free_list->b_prev_free->b_next_free = bh;
    cc17:	a1 64 3c 02 00       	mov    0x23c64,%eax
    cc1c:	8b 40 1c             	mov    0x1c(%eax),%eax
    cc1f:	8b 54 24 04          	mov    0x4(%esp),%edx
    cc23:	89 50 20             	mov    %edx,0x20(%eax)
	free_list->b_prev_free = bh;
    cc26:	a1 64 3c 02 00       	mov    0x23c64,%eax
    cc2b:	8b 54 24 04          	mov    0x4(%esp),%edx
    cc2f:	89 50 1c             	mov    %edx,0x1c(%eax)
/* put the buffer in new hash-queue if it has a device */
	bh->b_prev = NULL;
    cc32:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc36:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	bh->b_next = NULL;
    cc3d:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc41:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	if (!bh->b_dev)
    cc48:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc4c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cc50:	66 85 c0             	test   %ax,%ax
    cc53:	0f 84 85 00 00 00    	je     ccde <insert_into_queues+0xe3>
		return;
	bh->b_next = hash(bh->b_dev,bh->b_blocknr);
    cc59:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc5d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cc61:	0f b7 d0             	movzwl %ax,%edx
    cc64:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc68:	8b 40 04             	mov    0x4(%eax),%eax
    cc6b:	89 d1                	mov    %edx,%ecx
    cc6d:	31 c1                	xor    %eax,%ecx
    cc6f:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
    cc74:	89 c8                	mov    %ecx,%eax
    cc76:	f7 e2                	mul    %edx
    cc78:	89 d0                	mov    %edx,%eax
    cc7a:	c1 e8 08             	shr    $0x8,%eax
    cc7d:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
    cc83:	29 c1                	sub    %eax,%ecx
    cc85:	89 c8                	mov    %ecx,%eax
    cc87:	8b 14 85 a0 4e 02 00 	mov    0x24ea0(,%eax,4),%edx
    cc8e:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc92:	89 50 18             	mov    %edx,0x18(%eax)
	hash(bh->b_dev,bh->b_blocknr) = bh;
    cc95:	8b 44 24 04          	mov    0x4(%esp),%eax
    cc99:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cc9d:	0f b7 d0             	movzwl %ax,%edx
    cca0:	8b 44 24 04          	mov    0x4(%esp),%eax
    cca4:	8b 40 04             	mov    0x4(%eax),%eax
    cca7:	89 d1                	mov    %edx,%ecx
    cca9:	31 c1                	xor    %eax,%ecx
    ccab:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
    ccb0:	89 c8                	mov    %ecx,%eax
    ccb2:	f7 e2                	mul    %edx
    ccb4:	89 d0                	mov    %edx,%eax
    ccb6:	c1 e8 08             	shr    $0x8,%eax
    ccb9:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
    ccbf:	29 c1                	sub    %eax,%ecx
    ccc1:	89 c8                	mov    %ecx,%eax
    ccc3:	8b 54 24 04          	mov    0x4(%esp),%edx
    ccc7:	89 14 85 a0 4e 02 00 	mov    %edx,0x24ea0(,%eax,4)
	bh->b_next->b_prev = bh;
    ccce:	8b 44 24 04          	mov    0x4(%esp),%eax
    ccd2:	8b 40 18             	mov    0x18(%eax),%eax
    ccd5:	8b 54 24 04          	mov    0x4(%esp),%edx
    ccd9:	89 50 14             	mov    %edx,0x14(%eax)
    ccdc:	eb 01                	jmp    ccdf <insert_into_queues+0xe4>
	free_list->b_prev_free = bh;
/* put the buffer in new hash-queue if it has a device */
	bh->b_prev = NULL;
	bh->b_next = NULL;
	if (!bh->b_dev)
		return;
    ccde:	90                   	nop
	bh->b_next = hash(bh->b_dev,bh->b_blocknr);
	hash(bh->b_dev,bh->b_blocknr) = bh;
	bh->b_next->b_prev = bh;
}
    ccdf:	c3                   	ret    

0000cce0 <find_buffer>:

static struct buffer_head * find_buffer(int dev, int block)
{		
    cce0:	83 ec 10             	sub    $0x10,%esp
	struct buffer_head * tmp;

	for (tmp = hash(dev,block) ; tmp != NULL ; tmp = tmp->b_next)
    cce3:	8b 44 24 14          	mov    0x14(%esp),%eax
    cce7:	33 44 24 18          	xor    0x18(%esp),%eax
    cceb:	89 c1                	mov    %eax,%ecx
    cced:	ba 7d e9 78 d5       	mov    $0xd578e97d,%edx
    ccf2:	89 c8                	mov    %ecx,%eax
    ccf4:	f7 e2                	mul    %edx
    ccf6:	89 d0                	mov    %edx,%eax
    ccf8:	c1 e8 08             	shr    $0x8,%eax
    ccfb:	69 c0 33 01 00 00    	imul   $0x133,%eax,%eax
    cd01:	29 c1                	sub    %eax,%ecx
    cd03:	89 c8                	mov    %ecx,%eax
    cd05:	8b 04 85 a0 4e 02 00 	mov    0x24ea0(,%eax,4),%eax
    cd0c:	89 44 24 0c          	mov    %eax,0xc(%esp)
    cd10:	eb 31                	jmp    cd43 <find_buffer+0x63>
		if (tmp->b_dev==dev && tmp->b_blocknr==block)
    cd12:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cd16:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cd1a:	0f b7 c0             	movzwl %ax,%eax
    cd1d:	3b 44 24 14          	cmp    0x14(%esp),%eax
    cd21:	75 15                	jne    cd38 <find_buffer+0x58>
    cd23:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cd27:	8b 50 04             	mov    0x4(%eax),%edx
    cd2a:	8b 44 24 18          	mov    0x18(%esp),%eax
    cd2e:	39 c2                	cmp    %eax,%edx
    cd30:	75 06                	jne    cd38 <find_buffer+0x58>
			return tmp;
    cd32:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cd36:	eb 17                	jmp    cd4f <find_buffer+0x6f>

static struct buffer_head * find_buffer(int dev, int block)
{		
	struct buffer_head * tmp;

	for (tmp = hash(dev,block) ; tmp != NULL ; tmp = tmp->b_next)
    cd38:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cd3c:	8b 40 18             	mov    0x18(%eax),%eax
    cd3f:	89 44 24 0c          	mov    %eax,0xc(%esp)
    cd43:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    cd48:	75 c8                	jne    cd12 <find_buffer+0x32>
		if (tmp->b_dev==dev && tmp->b_blocknr==block)
			return tmp;
	return NULL;
    cd4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    cd4f:	83 c4 10             	add    $0x10,%esp
    cd52:	c3                   	ret    

0000cd53 <get_hash_table>:
 * something might happen to it while we sleep (ie a read-error
 * will force it bad). This shouldn't really happen currently, but
 * the code is ready.
 */
struct buffer_head * get_hash_table(int dev, int block)
{
    cd53:	83 ec 1c             	sub    $0x1c,%esp
	struct buffer_head * bh;

	for (;;) {
		if (!(bh=find_buffer(dev,block)))
    cd56:	ff 74 24 24          	pushl  0x24(%esp)
    cd5a:	ff 74 24 24          	pushl  0x24(%esp)
    cd5e:	e8 7d ff ff ff       	call   cce0 <find_buffer>
    cd63:	83 c4 08             	add    $0x8,%esp
    cd66:	89 44 24 0c          	mov    %eax,0xc(%esp)
    cd6a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    cd6f:	75 07                	jne    cd78 <get_hash_table+0x25>
			return NULL;
    cd71:	b8 00 00 00 00       	mov    $0x0,%eax
    cd76:	eb 5b                	jmp    cdd3 <get_hash_table+0x80>
		bh->b_count++;
    cd78:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cd7c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    cd80:	8d 50 01             	lea    0x1(%eax),%edx
    cd83:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cd87:	88 50 0c             	mov    %dl,0xc(%eax)
		wait_on_buffer(bh);
    cd8a:	83 ec 0c             	sub    $0xc,%esp
    cd8d:	ff 74 24 18          	pushl  0x18(%esp)
    cd91:	e8 a3 fa ff ff       	call   c839 <wait_on_buffer>
    cd96:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_blocknr == block)
    cd99:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cd9d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cda1:	0f b7 c0             	movzwl %ax,%eax
    cda4:	3b 44 24 20          	cmp    0x20(%esp),%eax
    cda8:	75 15                	jne    cdbf <get_hash_table+0x6c>
    cdaa:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cdae:	8b 50 04             	mov    0x4(%eax),%edx
    cdb1:	8b 44 24 24          	mov    0x24(%esp),%eax
    cdb5:	39 c2                	cmp    %eax,%edx
    cdb7:	75 06                	jne    cdbf <get_hash_table+0x6c>
			return bh;
    cdb9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cdbd:	eb 14                	jmp    cdd3 <get_hash_table+0x80>
		bh->b_count--;
    cdbf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cdc3:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    cdc7:	8d 50 ff             	lea    -0x1(%eax),%edx
    cdca:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cdce:	88 50 0c             	mov    %dl,0xc(%eax)
	}
    cdd1:	eb 83                	jmp    cd56 <get_hash_table+0x3>
}
    cdd3:	83 c4 1c             	add    $0x1c,%esp
    cdd6:	c3                   	ret    

0000cdd7 <getblk>:
 *
 * The algoritm is changed: hopefully better, and an elusive bug removed.
 */
#define BADNESS(bh) (((bh)->b_dirt<<1)+(bh)->b_lock)
struct buffer_head * getblk(int dev,int block)
{
    cdd7:	83 ec 1c             	sub    $0x1c,%esp
	struct buffer_head * tmp, * bh;

repeat:
	if ((bh = get_hash_table(dev,block)))
    cdda:	83 ec 08             	sub    $0x8,%esp
    cddd:	ff 74 24 2c          	pushl  0x2c(%esp)
    cde1:	ff 74 24 2c          	pushl  0x2c(%esp)
    cde5:	e8 69 ff ff ff       	call   cd53 <get_hash_table>
    cdea:	83 c4 10             	add    $0x10,%esp
    cded:	89 44 24 08          	mov    %eax,0x8(%esp)
    cdf1:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    cdf6:	74 09                	je     ce01 <getblk+0x2a>
		return bh;
    cdf8:	8b 44 24 08          	mov    0x8(%esp),%eax
    cdfc:	e9 8b 01 00 00       	jmp    cf8c <getblk+0x1b5>
	tmp = free_list;
    ce01:	a1 64 3c 02 00       	mov    0x23c64,%eax
    ce06:	89 44 24 0c          	mov    %eax,0xc(%esp)
	do {
		if (tmp->b_count)
    ce0a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ce0e:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    ce12:	84 c0                	test   %al,%al
    ce14:	75 6a                	jne    ce80 <getblk+0xa9>
			continue;
		if (!bh || BADNESS(tmp)<BADNESS(bh)) {
    ce16:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    ce1b:	74 3a                	je     ce57 <getblk+0x80>
    ce1d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ce21:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    ce25:	0f b6 c0             	movzbl %al,%eax
    ce28:	8d 14 00             	lea    (%eax,%eax,1),%edx
    ce2b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ce2f:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    ce33:	0f b6 c0             	movzbl %al,%eax
    ce36:	01 c2                	add    %eax,%edx
    ce38:	8b 44 24 08          	mov    0x8(%esp),%eax
    ce3c:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    ce40:	0f b6 c0             	movzbl %al,%eax
    ce43:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
    ce46:	8b 44 24 08          	mov    0x8(%esp),%eax
    ce4a:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    ce4e:	0f b6 c0             	movzbl %al,%eax
    ce51:	01 c8                	add    %ecx,%eax
    ce53:	39 c2                	cmp    %eax,%edx
    ce55:	7d 2a                	jge    ce81 <getblk+0xaa>
			bh = tmp;
    ce57:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ce5b:	89 44 24 08          	mov    %eax,0x8(%esp)
			if (!BADNESS(tmp))
    ce5f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ce63:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    ce67:	0f b6 c0             	movzbl %al,%eax
    ce6a:	8d 14 00             	lea    (%eax,%eax,1),%edx
    ce6d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ce71:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    ce75:	0f b6 c0             	movzbl %al,%eax
    ce78:	01 d0                	add    %edx,%eax
    ce7a:	85 c0                	test   %eax,%eax
    ce7c:	74 1f                	je     ce9d <getblk+0xc6>
    ce7e:	eb 01                	jmp    ce81 <getblk+0xaa>
	if ((bh = get_hash_table(dev,block)))
		return bh;
	tmp = free_list;
	do {
		if (tmp->b_count)
			continue;
    ce80:	90                   	nop
			bh = tmp;
			if (!BADNESS(tmp))
				break;
		}
/* and repeat until we find something good */
	} while ((tmp = tmp->b_next_free) != free_list);
    ce81:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ce85:	8b 40 20             	mov    0x20(%eax),%eax
    ce88:	89 44 24 0c          	mov    %eax,0xc(%esp)
    ce8c:	a1 64 3c 02 00       	mov    0x23c64,%eax
    ce91:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    ce95:	0f 85 6f ff ff ff    	jne    ce0a <getblk+0x33>
    ce9b:	eb 01                	jmp    ce9e <getblk+0xc7>
		if (tmp->b_count)
			continue;
		if (!bh || BADNESS(tmp)<BADNESS(bh)) {
			bh = tmp;
			if (!BADNESS(tmp))
				break;
    ce9d:	90                   	nop
		}
/* and repeat until we find something good */
	} while ((tmp = tmp->b_next_free) != free_list);
	if (!bh) {
    ce9e:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    cea3:	75 15                	jne    ceba <getblk+0xe3>
		sleep_on(&buffer_wait);
    cea5:	83 ec 0c             	sub    $0xc,%esp
    cea8:	68 68 3c 02 00       	push   $0x23c68
    cead:	e8 c0 9f ff ff       	call   6e72 <sleep_on>
    ceb2:	83 c4 10             	add    $0x10,%esp
		goto repeat;
    ceb5:	e9 20 ff ff ff       	jmp    cdda <getblk+0x3>
	}
	wait_on_buffer(bh);
    ceba:	83 ec 0c             	sub    $0xc,%esp
    cebd:	ff 74 24 14          	pushl  0x14(%esp)
    cec1:	e8 73 f9 ff ff       	call   c839 <wait_on_buffer>
    cec6:	83 c4 10             	add    $0x10,%esp
	if (bh->b_count)
    cec9:	8b 44 24 08          	mov    0x8(%esp),%eax
    cecd:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    ced1:	84 c0                	test   %al,%al
    ced3:	74 3c                	je     cf11 <getblk+0x13a>
		goto repeat;
    ced5:	e9 00 ff ff ff       	jmp    cdda <getblk+0x3>
	while (bh->b_dirt) {
		sync_dev(bh->b_dev);
    ceda:	8b 44 24 08          	mov    0x8(%esp),%eax
    cede:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cee2:	0f b7 c0             	movzwl %ax,%eax
    cee5:	83 ec 0c             	sub    $0xc,%esp
    cee8:	50                   	push   %eax
    cee9:	e8 db f9 ff ff       	call   c8c9 <sync_dev>
    ceee:	83 c4 10             	add    $0x10,%esp
		wait_on_buffer(bh);
    cef1:	83 ec 0c             	sub    $0xc,%esp
    cef4:	ff 74 24 14          	pushl  0x14(%esp)
    cef8:	e8 3c f9 ff ff       	call   c839 <wait_on_buffer>
    cefd:	83 c4 10             	add    $0x10,%esp
		if (bh->b_count)
    cf00:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf04:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    cf08:	84 c0                	test   %al,%al
    cf0a:	74 05                	je     cf11 <getblk+0x13a>
			goto repeat;
    cf0c:	e9 c9 fe ff ff       	jmp    cdda <getblk+0x3>
		goto repeat;
	}
	wait_on_buffer(bh);
	if (bh->b_count)
		goto repeat;
	while (bh->b_dirt) {
    cf11:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf15:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    cf19:	84 c0                	test   %al,%al
    cf1b:	75 bd                	jne    ceda <getblk+0x103>
		if (bh->b_count)
			goto repeat;
	}
/* NOTE!! While we slept waiting for this block, somebody else might */
/* already have added "this" block to the cache. check it */
	if (find_buffer(dev,block))
    cf1d:	83 ec 08             	sub    $0x8,%esp
    cf20:	ff 74 24 2c          	pushl  0x2c(%esp)
    cf24:	ff 74 24 2c          	pushl  0x2c(%esp)
    cf28:	e8 b3 fd ff ff       	call   cce0 <find_buffer>
    cf2d:	83 c4 10             	add    $0x10,%esp
    cf30:	85 c0                	test   %eax,%eax
    cf32:	74 05                	je     cf39 <getblk+0x162>
		goto repeat;
    cf34:	e9 a1 fe ff ff       	jmp    cdda <getblk+0x3>
/* OK, FINALLY we know that this buffer is the only one of it's kind, */
/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
	bh->b_count=1;
    cf39:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf3d:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
	bh->b_dirt=0;
    cf41:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf45:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	bh->b_uptodate=0;
    cf49:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf4d:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
	remove_from_queues(bh);
    cf51:	83 ec 0c             	sub    $0xc,%esp
    cf54:	ff 74 24 14          	pushl  0x14(%esp)
    cf58:	e8 88 fb ff ff       	call   cae5 <remove_from_queues>
    cf5d:	83 c4 10             	add    $0x10,%esp
	bh->b_dev=dev;
    cf60:	8b 44 24 20          	mov    0x20(%esp),%eax
    cf64:	89 c2                	mov    %eax,%edx
    cf66:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf6a:	66 89 50 08          	mov    %dx,0x8(%eax)
	bh->b_blocknr=block;
    cf6e:	8b 54 24 24          	mov    0x24(%esp),%edx
    cf72:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf76:	89 50 04             	mov    %edx,0x4(%eax)
	insert_into_queues(bh);
    cf79:	83 ec 0c             	sub    $0xc,%esp
    cf7c:	ff 74 24 14          	pushl  0x14(%esp)
    cf80:	e8 76 fc ff ff       	call   cbfb <insert_into_queues>
    cf85:	83 c4 10             	add    $0x10,%esp
	return bh;
    cf88:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    cf8c:	83 c4 1c             	add    $0x1c,%esp
    cf8f:	c3                   	ret    

0000cf90 <brelse>:

void brelse(struct buffer_head * buf)
{
    cf90:	83 ec 0c             	sub    $0xc,%esp
	if (!buf)
    cf93:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    cf98:	74 47                	je     cfe1 <brelse+0x51>
		return;
	wait_on_buffer(buf);
    cf9a:	83 ec 0c             	sub    $0xc,%esp
    cf9d:	ff 74 24 1c          	pushl  0x1c(%esp)
    cfa1:	e8 93 f8 ff ff       	call   c839 <wait_on_buffer>
    cfa6:	83 c4 10             	add    $0x10,%esp
	if (!(buf->b_count--))
    cfa9:	8b 44 24 10          	mov    0x10(%esp),%eax
    cfad:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    cfb1:	8d 50 ff             	lea    -0x1(%eax),%edx
    cfb4:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    cfb8:	88 51 0c             	mov    %dl,0xc(%ecx)
    cfbb:	84 c0                	test   %al,%al
    cfbd:	75 10                	jne    cfcf <brelse+0x3f>
		panic("Trying to free free buffer");
    cfbf:	83 ec 0c             	sub    $0xc,%esp
    cfc2:	68 13 88 01 00       	push   $0x18813
    cfc7:	e8 02 b8 ff ff       	call   87ce <panic>
    cfcc:	83 c4 10             	add    $0x10,%esp
	wake_up(&buffer_wait);
    cfcf:	83 ec 0c             	sub    $0xc,%esp
    cfd2:	68 68 3c 02 00       	push   $0x23c68
    cfd7:	e8 9d 9f ff ff       	call   6f79 <wake_up>
    cfdc:	83 c4 10             	add    $0x10,%esp
    cfdf:	eb 01                	jmp    cfe2 <brelse+0x52>
}

void brelse(struct buffer_head * buf)
{
	if (!buf)
		return;
    cfe1:	90                   	nop
	wait_on_buffer(buf);
	if (!(buf->b_count--))
		panic("Trying to free free buffer");
	wake_up(&buffer_wait);
}
    cfe2:	83 c4 0c             	add    $0xc,%esp
    cfe5:	c3                   	ret    

0000cfe6 <bread>:
/*
 * bread() reads a specified block and returns the buffer that contains
 * it. It returns NULL if the block was unreadable.
 */
struct buffer_head * bread(int dev,int block)
{
    cfe6:	83 ec 1c             	sub    $0x1c,%esp
	struct buffer_head * bh;

	if (!(bh=getblk(dev,block)))
    cfe9:	83 ec 08             	sub    $0x8,%esp
    cfec:	ff 74 24 2c          	pushl  0x2c(%esp)
    cff0:	ff 74 24 2c          	pushl  0x2c(%esp)
    cff4:	e8 de fd ff ff       	call   cdd7 <getblk>
    cff9:	83 c4 10             	add    $0x10,%esp
    cffc:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d000:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    d005:	75 10                	jne    d017 <bread+0x31>
		panic("bread: getblk returned NULL\n");
    d007:	83 ec 0c             	sub    $0xc,%esp
    d00a:	68 2e 88 01 00       	push   $0x1882e
    d00f:	e8 ba b7 ff ff       	call   87ce <panic>
    d014:	83 c4 10             	add    $0x10,%esp
	if (bh->b_uptodate)
    d017:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d01b:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
    d01f:	84 c0                	test   %al,%al
    d021:	74 06                	je     d029 <bread+0x43>
		return bh;
    d023:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d027:	eb 46                	jmp    d06f <bread+0x89>
	ll_rw_block(READ,bh);
    d029:	83 ec 08             	sub    $0x8,%esp
    d02c:	ff 74 24 14          	pushl  0x14(%esp)
    d030:	6a 00                	push   $0x0
    d032:	e8 0a 5d 00 00       	call   12d41 <ll_rw_block>
    d037:	83 c4 10             	add    $0x10,%esp
	wait_on_buffer(bh);
    d03a:	83 ec 0c             	sub    $0xc,%esp
    d03d:	ff 74 24 18          	pushl  0x18(%esp)
    d041:	e8 f3 f7 ff ff       	call   c839 <wait_on_buffer>
    d046:	83 c4 10             	add    $0x10,%esp
	if (bh->b_uptodate)
    d049:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d04d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
    d051:	84 c0                	test   %al,%al
    d053:	74 06                	je     d05b <bread+0x75>
		return bh;
    d055:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d059:	eb 14                	jmp    d06f <bread+0x89>
	brelse(bh);
    d05b:	83 ec 0c             	sub    $0xc,%esp
    d05e:	ff 74 24 18          	pushl  0x18(%esp)
    d062:	e8 29 ff ff ff       	call   cf90 <brelse>
    d067:	83 c4 10             	add    $0x10,%esp
	return NULL;
    d06a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d06f:	83 c4 1c             	add    $0x1c,%esp
    d072:	c3                   	ret    

0000d073 <bread_page>:
 * a function of its own, as there is some speed to be got by reading them
 * all at the same time, not waiting for one to be read, and then another
 * etc.
 */
void bread_page(unsigned long address,int dev,int b[4])
{
    d073:	57                   	push   %edi
    d074:	56                   	push   %esi
    d075:	53                   	push   %ebx
    d076:	83 ec 20             	sub    $0x20,%esp
	struct buffer_head * bh[4];
	int i;

	for (i=0 ; i<4 ; i++)
    d079:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    d080:	00 
    d081:	e9 89 00 00 00       	jmp    d10f <bread_page+0x9c>
		if (b[i]) {
    d086:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d08a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d091:	8b 44 24 38          	mov    0x38(%esp),%eax
    d095:	01 d0                	add    %edx,%eax
    d097:	8b 00                	mov    (%eax),%eax
    d099:	85 c0                	test   %eax,%eax
    d09b:	74 61                	je     d0fe <bread_page+0x8b>
			if ((bh[i] = getblk(dev,b[i])))
    d09d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d0a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0a8:	8b 44 24 38          	mov    0x38(%esp),%eax
    d0ac:	01 d0                	add    %edx,%eax
    d0ae:	8b 00                	mov    (%eax),%eax
    d0b0:	83 ec 08             	sub    $0x8,%esp
    d0b3:	50                   	push   %eax
    d0b4:	ff 74 24 40          	pushl  0x40(%esp)
    d0b8:	e8 1a fd ff ff       	call   cdd7 <getblk>
    d0bd:	83 c4 10             	add    $0x10,%esp
    d0c0:	89 c2                	mov    %eax,%edx
    d0c2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d0c6:	89 54 84 0c          	mov    %edx,0xc(%esp,%eax,4)
    d0ca:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d0ce:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    d0d2:	85 c0                	test   %eax,%eax
    d0d4:	74 34                	je     d10a <bread_page+0x97>
				if (!bh[i]->b_uptodate)
    d0d6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d0da:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    d0de:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
    d0e2:	84 c0                	test   %al,%al
    d0e4:	75 24                	jne    d10a <bread_page+0x97>
					ll_rw_block(READ,bh[i]);
    d0e6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d0ea:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    d0ee:	83 ec 08             	sub    $0x8,%esp
    d0f1:	50                   	push   %eax
    d0f2:	6a 00                	push   $0x0
    d0f4:	e8 48 5c 00 00       	call   12d41 <ll_rw_block>
    d0f9:	83 c4 10             	add    $0x10,%esp
    d0fc:	eb 0c                	jmp    d10a <bread_page+0x97>
		} else
			bh[i] = NULL;
    d0fe:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d102:	c7 44 84 0c 00 00 00 	movl   $0x0,0xc(%esp,%eax,4)
    d109:	00 
void bread_page(unsigned long address,int dev,int b[4])
{
	struct buffer_head * bh[4];
	int i;

	for (i=0 ; i<4 ; i++)
    d10a:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    d10f:	83 7c 24 1c 03       	cmpl   $0x3,0x1c(%esp)
    d114:	0f 8e 6c ff ff ff    	jle    d086 <bread_page+0x13>
			if ((bh[i] = getblk(dev,b[i])))
				if (!bh[i]->b_uptodate)
					ll_rw_block(READ,bh[i]);
		} else
			bh[i] = NULL;
	for (i=0 ; i<4 ; i++,address += BLOCK_SIZE)
    d11a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    d121:	00 
    d122:	eb 6f                	jmp    d193 <bread_page+0x120>
		if (bh[i]) {
    d124:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d128:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    d12c:	85 c0                	test   %eax,%eax
    d12e:	74 56                	je     d186 <bread_page+0x113>
			wait_on_buffer(bh[i]);
    d130:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d134:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    d138:	83 ec 0c             	sub    $0xc,%esp
    d13b:	50                   	push   %eax
    d13c:	e8 f8 f6 ff ff       	call   c839 <wait_on_buffer>
    d141:	83 c4 10             	add    $0x10,%esp
			if (bh[i]->b_uptodate)
    d144:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d148:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    d14c:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
    d150:	84 c0                	test   %al,%al
    d152:	74 1e                	je     d172 <bread_page+0xff>
				COPYBLK((unsigned long) bh[i]->b_data,address);
    d154:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d158:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    d15c:	8b 00                	mov    (%eax),%eax
    d15e:	89 c3                	mov    %eax,%ebx
    d160:	ba 00 01 00 00       	mov    $0x100,%edx
    d165:	8b 44 24 30          	mov    0x30(%esp),%eax
    d169:	89 d1                	mov    %edx,%ecx
    d16b:	89 de                	mov    %ebx,%esi
    d16d:	89 c7                	mov    %eax,%edi
    d16f:	fc                   	cld    
    d170:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			brelse(bh[i]);
    d172:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d176:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    d17a:	83 ec 0c             	sub    $0xc,%esp
    d17d:	50                   	push   %eax
    d17e:	e8 0d fe ff ff       	call   cf90 <brelse>
    d183:	83 c4 10             	add    $0x10,%esp
			if ((bh[i] = getblk(dev,b[i])))
				if (!bh[i]->b_uptodate)
					ll_rw_block(READ,bh[i]);
		} else
			bh[i] = NULL;
	for (i=0 ; i<4 ; i++,address += BLOCK_SIZE)
    d186:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    d18b:	81 44 24 30 00 04 00 	addl   $0x400,0x30(%esp)
    d192:	00 
    d193:	83 7c 24 1c 03       	cmpl   $0x3,0x1c(%esp)
    d198:	7e 8a                	jle    d124 <bread_page+0xb1>
			wait_on_buffer(bh[i]);
			if (bh[i]->b_uptodate)
				COPYBLK((unsigned long) bh[i]->b_data,address);
			brelse(bh[i]);
		}
}
    d19a:	90                   	nop
    d19b:	83 c4 20             	add    $0x20,%esp
    d19e:	5b                   	pop    %ebx
    d19f:	5e                   	pop    %esi
    d1a0:	5f                   	pop    %edi
    d1a1:	c3                   	ret    

0000d1a2 <breada>:
 * Ok, breada can be used as bread, but additionally to mark other
 * blocks for reading as well. End the argument list with a negative
 * number.
 */
struct buffer_head * breada(int dev,int first, ...)
{
    d1a2:	83 ec 1c             	sub    $0x1c,%esp
	va_list args;
	struct buffer_head * bh, *tmp;

	va_start(args,first);
    d1a5:	8d 44 24 24          	lea    0x24(%esp),%eax
    d1a9:	83 c0 04             	add    $0x4,%eax
    d1ac:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!(bh=getblk(dev,first)))
    d1b0:	8b 44 24 24          	mov    0x24(%esp),%eax
    d1b4:	83 ec 08             	sub    $0x8,%esp
    d1b7:	50                   	push   %eax
    d1b8:	ff 74 24 2c          	pushl  0x2c(%esp)
    d1bc:	e8 16 fc ff ff       	call   cdd7 <getblk>
    d1c1:	83 c4 10             	add    $0x10,%esp
    d1c4:	89 44 24 08          	mov    %eax,0x8(%esp)
    d1c8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    d1cd:	75 10                	jne    d1df <breada+0x3d>
		panic("bread: getblk returned NULL\n");
    d1cf:	83 ec 0c             	sub    $0xc,%esp
    d1d2:	68 2e 88 01 00       	push   $0x1882e
    d1d7:	e8 f2 b5 ff ff       	call   87ce <panic>
    d1dc:	83 c4 10             	add    $0x10,%esp
	if (!bh->b_uptodate)
    d1df:	8b 44 24 08          	mov    0x8(%esp),%eax
    d1e3:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
    d1e7:	84 c0                	test   %al,%al
    d1e9:	75 61                	jne    d24c <breada+0xaa>
		ll_rw_block(READ,bh);
    d1eb:	83 ec 08             	sub    $0x8,%esp
    d1ee:	ff 74 24 10          	pushl  0x10(%esp)
    d1f2:	6a 00                	push   $0x0
    d1f4:	e8 48 5b 00 00       	call   12d41 <ll_rw_block>
    d1f9:	83 c4 10             	add    $0x10,%esp
	while ((first=va_arg(args,int))>=0) {
    d1fc:	eb 4e                	jmp    d24c <breada+0xaa>
		tmp=getblk(dev,first);
    d1fe:	8b 44 24 24          	mov    0x24(%esp),%eax
    d202:	83 ec 08             	sub    $0x8,%esp
    d205:	50                   	push   %eax
    d206:	ff 74 24 2c          	pushl  0x2c(%esp)
    d20a:	e8 c8 fb ff ff       	call   cdd7 <getblk>
    d20f:	83 c4 10             	add    $0x10,%esp
    d212:	89 44 24 04          	mov    %eax,0x4(%esp)
		if (tmp) {
    d216:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    d21b:	74 2f                	je     d24c <breada+0xaa>
			if (!tmp->b_uptodate)
    d21d:	8b 44 24 04          	mov    0x4(%esp),%eax
    d221:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
    d225:	84 c0                	test   %al,%al
    d227:	75 11                	jne    d23a <breada+0x98>
				ll_rw_block(READA,tmp);
    d229:	83 ec 08             	sub    $0x8,%esp
    d22c:	ff 74 24 0c          	pushl  0xc(%esp)
    d230:	6a 02                	push   $0x2
    d232:	e8 0a 5b 00 00       	call   12d41 <ll_rw_block>
    d237:	83 c4 10             	add    $0x10,%esp
			tmp->b_count--;
    d23a:	8b 44 24 04          	mov    0x4(%esp),%eax
    d23e:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    d242:	8d 50 ff             	lea    -0x1(%eax),%edx
    d245:	8b 44 24 04          	mov    0x4(%esp),%eax
    d249:	88 50 0c             	mov    %dl,0xc(%eax)
	va_start(args,first);
	if (!(bh=getblk(dev,first)))
		panic("bread: getblk returned NULL\n");
	if (!bh->b_uptodate)
		ll_rw_block(READ,bh);
	while ((first=va_arg(args,int))>=0) {
    d24c:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)
    d251:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d255:	8b 40 fc             	mov    -0x4(%eax),%eax
    d258:	89 44 24 24          	mov    %eax,0x24(%esp)
    d25c:	8b 44 24 24          	mov    0x24(%esp),%eax
    d260:	85 c0                	test   %eax,%eax
    d262:	79 9a                	jns    d1fe <breada+0x5c>
				ll_rw_block(READA,tmp);
			tmp->b_count--;
		}
	}
	va_end(args);
	wait_on_buffer(bh);
    d264:	83 ec 0c             	sub    $0xc,%esp
    d267:	ff 74 24 14          	pushl  0x14(%esp)
    d26b:	e8 c9 f5 ff ff       	call   c839 <wait_on_buffer>
    d270:	83 c4 10             	add    $0x10,%esp
	if (bh->b_uptodate)
    d273:	8b 44 24 08          	mov    0x8(%esp),%eax
    d277:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
    d27b:	84 c0                	test   %al,%al
    d27d:	74 06                	je     d285 <breada+0xe3>
		return bh;
    d27f:	8b 44 24 08          	mov    0x8(%esp),%eax
    d283:	eb 14                	jmp    d299 <breada+0xf7>
	brelse(bh);
    d285:	83 ec 0c             	sub    $0xc,%esp
    d288:	ff 74 24 14          	pushl  0x14(%esp)
    d28c:	e8 ff fc ff ff       	call   cf90 <brelse>
    d291:	83 c4 10             	add    $0x10,%esp
	return (NULL);
    d294:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d299:	83 c4 1c             	add    $0x1c,%esp
    d29c:	c3                   	ret    

0000d29d <buffer_init>:

void buffer_init(long buffer_end)
{
    d29d:	83 ec 10             	sub    $0x10,%esp
	struct buffer_head * h = start_buffer;
    d2a0:	a1 04 f3 01 00       	mov    0x1f304,%eax
    d2a5:	89 44 24 0c          	mov    %eax,0xc(%esp)
	void * b;
	int i;

	if (buffer_end == 1<<20)
    d2a9:	81 7c 24 14 00 00 10 	cmpl   $0x100000,0x14(%esp)
    d2b0:	00 
    d2b1:	75 0d                	jne    d2c0 <buffer_init+0x23>
		b = (void *) (640*1024);
    d2b3:	c7 44 24 08 00 00 0a 	movl   $0xa0000,0x8(%esp)
    d2ba:	00 
    d2bb:	e9 a2 00 00 00       	jmp    d362 <buffer_init+0xc5>
	else
		b = (void *) buffer_end;
    d2c0:	8b 44 24 14          	mov    0x14(%esp),%eax
    d2c4:	89 44 24 08          	mov    %eax,0x8(%esp)
	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {
    d2c8:	e9 95 00 00 00       	jmp    d362 <buffer_init+0xc5>
		h->b_dev = 0;
    d2cd:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d2d1:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		h->b_dirt = 0;
    d2d7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d2db:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
		h->b_count = 0;
    d2df:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d2e3:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
		h->b_lock = 0;
    d2e7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d2eb:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
		h->b_uptodate = 0;
    d2ef:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d2f3:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
		h->b_wait = NULL;
    d2f7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d2fb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		h->b_next = NULL;
    d302:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d306:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		h->b_prev = NULL;
    d30d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d311:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
		h->b_data = (char *) b;
    d318:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d31c:	8b 54 24 08          	mov    0x8(%esp),%edx
    d320:	89 10                	mov    %edx,(%eax)
		h->b_prev_free = h-1;
    d322:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d326:	8d 50 dc             	lea    -0x24(%eax),%edx
    d329:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d32d:	89 50 1c             	mov    %edx,0x1c(%eax)
		h->b_next_free = h+1;
    d330:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d334:	8d 50 24             	lea    0x24(%eax),%edx
    d337:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d33b:	89 50 20             	mov    %edx,0x20(%eax)
		h++;
    d33e:	83 44 24 0c 24       	addl   $0x24,0xc(%esp)
		NR_BUFFERS++;
    d343:	a1 60 3c 02 00       	mov    0x23c60,%eax
    d348:	83 c0 01             	add    $0x1,%eax
    d34b:	a3 60 3c 02 00       	mov    %eax,0x23c60
		if (b == (void *) 0x100000)
    d350:	81 7c 24 08 00 00 10 	cmpl   $0x100000,0x8(%esp)
    d357:	00 
    d358:	75 08                	jne    d362 <buffer_init+0xc5>
			b = (void *) 0xA0000;
    d35a:	c7 44 24 08 00 00 0a 	movl   $0xa0000,0x8(%esp)
    d361:	00 

	if (buffer_end == 1<<20)
		b = (void *) (640*1024);
	else
		b = (void *) buffer_end;
	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {
    d362:	81 6c 24 08 00 04 00 	subl   $0x400,0x8(%esp)
    d369:	00 
    d36a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d36e:	83 c0 24             	add    $0x24,%eax
    d371:	39 44 24 08          	cmp    %eax,0x8(%esp)
    d375:	0f 83 52 ff ff ff    	jae    d2cd <buffer_init+0x30>
		h++;
		NR_BUFFERS++;
		if (b == (void *) 0x100000)
			b = (void *) 0xA0000;
	}
	h--;
    d37b:	83 6c 24 0c 24       	subl   $0x24,0xc(%esp)
	free_list = start_buffer;
    d380:	a1 04 f3 01 00       	mov    0x1f304,%eax
    d385:	a3 64 3c 02 00       	mov    %eax,0x23c64
	free_list->b_prev_free = h;
    d38a:	a1 64 3c 02 00       	mov    0x23c64,%eax
    d38f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d393:	89 50 1c             	mov    %edx,0x1c(%eax)
	h->b_next_free = free_list;
    d396:	8b 15 64 3c 02 00    	mov    0x23c64,%edx
    d39c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d3a0:	89 50 20             	mov    %edx,0x20(%eax)
	for (i=0;i<NR_HASH;i++)
    d3a3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    d3aa:	00 
    d3ab:	eb 14                	jmp    d3c1 <buffer_init+0x124>
		hash_table[i]=NULL;
    d3ad:	8b 44 24 04          	mov    0x4(%esp),%eax
    d3b1:	c7 04 85 a0 4e 02 00 	movl   $0x0,0x24ea0(,%eax,4)
    d3b8:	00 00 00 00 
	}
	h--;
	free_list = start_buffer;
	free_list->b_prev_free = h;
	h->b_next_free = free_list;
	for (i=0;i<NR_HASH;i++)
    d3bc:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
    d3c1:	81 7c 24 04 32 01 00 	cmpl   $0x132,0x4(%esp)
    d3c8:	00 
    d3c9:	7e e2                	jle    d3ad <buffer_init+0x110>
		hash_table[i]=NULL;
}	
    d3cb:	90                   	nop
    d3cc:	83 c4 10             	add    $0x10,%esp
    d3cf:	c3                   	ret    

0000d3d0 <lock_super>:
struct super_block super_block[NR_SUPER];
/* this is initialized in init/main.c */
int ROOT_DEV = 0;

static void lock_super(struct super_block * sb)
{
    d3d0:	83 ec 0c             	sub    $0xc,%esp
	cli();
    d3d3:	fa                   	cli    
	while (sb->s_lock)
    d3d4:	eb 13                	jmp    d3e9 <lock_super+0x19>
		sleep_on(&(sb->s_wait));
    d3d6:	8b 44 24 10          	mov    0x10(%esp),%eax
    d3da:	83 c0 64             	add    $0x64,%eax
    d3dd:	83 ec 0c             	sub    $0xc,%esp
    d3e0:	50                   	push   %eax
    d3e1:	e8 8c 9a ff ff       	call   6e72 <sleep_on>
    d3e6:	83 c4 10             	add    $0x10,%esp
int ROOT_DEV = 0;

static void lock_super(struct super_block * sb)
{
	cli();
	while (sb->s_lock)
    d3e9:	8b 44 24 10          	mov    0x10(%esp),%eax
    d3ed:	0f b6 40 68          	movzbl 0x68(%eax),%eax
    d3f1:	84 c0                	test   %al,%al
    d3f3:	75 e1                	jne    d3d6 <lock_super+0x6>
		sleep_on(&(sb->s_wait));
	sb->s_lock = 1;
    d3f5:	8b 44 24 10          	mov    0x10(%esp),%eax
    d3f9:	c6 40 68 01          	movb   $0x1,0x68(%eax)
	sti();
    d3fd:	fb                   	sti    
}
    d3fe:	90                   	nop
    d3ff:	83 c4 0c             	add    $0xc,%esp
    d402:	c3                   	ret    

0000d403 <free_super>:

static void free_super(struct super_block * sb)
{
    d403:	83 ec 0c             	sub    $0xc,%esp
	cli();
    d406:	fa                   	cli    
	sb->s_lock = 0;
    d407:	8b 44 24 10          	mov    0x10(%esp),%eax
    d40b:	c6 40 68 00          	movb   $0x0,0x68(%eax)
	wake_up(&(sb->s_wait));
    d40f:	8b 44 24 10          	mov    0x10(%esp),%eax
    d413:	83 c0 64             	add    $0x64,%eax
    d416:	83 ec 0c             	sub    $0xc,%esp
    d419:	50                   	push   %eax
    d41a:	e8 5a 9b ff ff       	call   6f79 <wake_up>
    d41f:	83 c4 10             	add    $0x10,%esp
	sti();
    d422:	fb                   	sti    
}
    d423:	90                   	nop
    d424:	83 c4 0c             	add    $0xc,%esp
    d427:	c3                   	ret    

0000d428 <wait_on_super>:

static void wait_on_super(struct super_block * sb)
{
    d428:	83 ec 0c             	sub    $0xc,%esp
	cli();
    d42b:	fa                   	cli    
	while (sb->s_lock)
    d42c:	eb 13                	jmp    d441 <wait_on_super+0x19>
		sleep_on(&(sb->s_wait));
    d42e:	8b 44 24 10          	mov    0x10(%esp),%eax
    d432:	83 c0 64             	add    $0x64,%eax
    d435:	83 ec 0c             	sub    $0xc,%esp
    d438:	50                   	push   %eax
    d439:	e8 34 9a ff ff       	call   6e72 <sleep_on>
    d43e:	83 c4 10             	add    $0x10,%esp
}

static void wait_on_super(struct super_block * sb)
{
	cli();
	while (sb->s_lock)
    d441:	8b 44 24 10          	mov    0x10(%esp),%eax
    d445:	0f b6 40 68          	movzbl 0x68(%eax),%eax
    d449:	84 c0                	test   %al,%al
    d44b:	75 e1                	jne    d42e <wait_on_super+0x6>
		sleep_on(&(sb->s_wait));
	sti();
    d44d:	fb                   	sti    
}
    d44e:	90                   	nop
    d44f:	83 c4 0c             	add    $0xc,%esp
    d452:	c3                   	ret    

0000d453 <get_super>:

struct super_block * get_super(int dev)
{
    d453:	83 ec 1c             	sub    $0x1c,%esp
	struct super_block * s;

	if (!dev)
    d456:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    d45b:	75 07                	jne    d464 <get_super+0x11>
		return NULL;
    d45d:	b8 00 00 00 00       	mov    $0x0,%eax
    d462:	eb 60                	jmp    d4c4 <get_super+0x71>
	s = 0+super_block;
    d464:	c7 44 24 0c 80 53 02 	movl   $0x25380,0xc(%esp)
    d46b:	00 
	while (s < NR_SUPER+super_block)
    d46c:	eb 46                	jmp    d4b4 <get_super+0x61>
		if (s->s_dev == dev) {
    d46e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d472:	0f b7 40 54          	movzwl 0x54(%eax),%eax
    d476:	0f b7 c0             	movzwl %ax,%eax
    d479:	3b 44 24 20          	cmp    0x20(%esp),%eax
    d47d:	75 30                	jne    d4af <get_super+0x5c>
			wait_on_super(s);
    d47f:	83 ec 0c             	sub    $0xc,%esp
    d482:	ff 74 24 18          	pushl  0x18(%esp)
    d486:	e8 9d ff ff ff       	call   d428 <wait_on_super>
    d48b:	83 c4 10             	add    $0x10,%esp
			if (s->s_dev == dev)
    d48e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d492:	0f b7 40 54          	movzwl 0x54(%eax),%eax
    d496:	0f b7 c0             	movzwl %ax,%eax
    d499:	3b 44 24 20          	cmp    0x20(%esp),%eax
    d49d:	75 06                	jne    d4a5 <get_super+0x52>
				return s;
    d49f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d4a3:	eb 1f                	jmp    d4c4 <get_super+0x71>
			s = 0+super_block;
    d4a5:	c7 44 24 0c 80 53 02 	movl   $0x25380,0xc(%esp)
    d4ac:	00 
    d4ad:	eb 05                	jmp    d4b4 <get_super+0x61>
		} else
			s++;
    d4af:	83 44 24 0c 6c       	addl   $0x6c,0xc(%esp)
	struct super_block * s;

	if (!dev)
		return NULL;
	s = 0+super_block;
	while (s < NR_SUPER+super_block)
    d4b4:	b8 e0 56 02 00       	mov    $0x256e0,%eax
    d4b9:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    d4bd:	72 af                	jb     d46e <get_super+0x1b>
			if (s->s_dev == dev)
				return s;
			s = 0+super_block;
		} else
			s++;
	return NULL;
    d4bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d4c4:	83 c4 1c             	add    $0x1c,%esp
    d4c7:	c3                   	ret    

0000d4c8 <put_super>:

void put_super(int dev)
{
    d4c8:	83 ec 1c             	sub    $0x1c,%esp
	struct super_block * sb;
	/* struct m_inode * inode;*/
	int i;

	if (dev == ROOT_DEV) {
    d4cb:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
    d4d0:	39 44 24 20          	cmp    %eax,0x20(%esp)
    d4d4:	75 15                	jne    d4eb <put_super+0x23>
		printk("root diskette changed: prepare for armageddon\n\r");
    d4d6:	83 ec 0c             	sub    $0xc,%esp
    d4d9:	68 4c 88 01 00       	push   $0x1884c
    d4de:	e8 2a b3 ff ff       	call   880d <printk>
    d4e3:	83 c4 10             	add    $0x10,%esp
		return;
    d4e6:	e9 cc 00 00 00       	jmp    d5b7 <put_super+0xef>
	}
	if (!(sb = get_super(dev)))
    d4eb:	83 ec 0c             	sub    $0xc,%esp
    d4ee:	ff 74 24 2c          	pushl  0x2c(%esp)
    d4f2:	e8 5c ff ff ff       	call   d453 <get_super>
    d4f7:	83 c4 10             	add    $0x10,%esp
    d4fa:	89 44 24 08          	mov    %eax,0x8(%esp)
    d4fe:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    d503:	0f 84 ad 00 00 00    	je     d5b6 <put_super+0xee>
		return;
	if (sb->s_imount) {
    d509:	8b 44 24 08          	mov    0x8(%esp),%eax
    d50d:	8b 40 5c             	mov    0x5c(%eax),%eax
    d510:	85 c0                	test   %eax,%eax
    d512:	74 15                	je     d529 <put_super+0x61>
		printk("Mounted disk changed - tssk, tssk\n\r");
    d514:	83 ec 0c             	sub    $0xc,%esp
    d517:	68 7c 88 01 00       	push   $0x1887c
    d51c:	e8 ec b2 ff ff       	call   880d <printk>
    d521:	83 c4 10             	add    $0x10,%esp
		return;
    d524:	e9 8e 00 00 00       	jmp    d5b7 <put_super+0xef>
	}
	lock_super(sb);
    d529:	83 ec 0c             	sub    $0xc,%esp
    d52c:	ff 74 24 14          	pushl  0x14(%esp)
    d530:	e8 9b fe ff ff       	call   d3d0 <lock_super>
    d535:	83 c4 10             	add    $0x10,%esp
	sb->s_dev = 0;
    d538:	8b 44 24 08          	mov    0x8(%esp),%eax
    d53c:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
	for(i=0;i<I_MAP_SLOTS;i++)
    d542:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    d549:	00 
    d54a:	eb 20                	jmp    d56c <put_super+0xa4>
		brelse(sb->s_imap[i]);
    d54c:	8b 44 24 08          	mov    0x8(%esp),%eax
    d550:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d554:	83 c2 04             	add    $0x4,%edx
    d557:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
    d55b:	83 ec 0c             	sub    $0xc,%esp
    d55e:	50                   	push   %eax
    d55f:	e8 2c fa ff ff       	call   cf90 <brelse>
    d564:	83 c4 10             	add    $0x10,%esp
		printk("Mounted disk changed - tssk, tssk\n\r");
		return;
	}
	lock_super(sb);
	sb->s_dev = 0;
	for(i=0;i<I_MAP_SLOTS;i++)
    d567:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    d56c:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
    d571:	7e d9                	jle    d54c <put_super+0x84>
		brelse(sb->s_imap[i]);
	for(i=0;i<Z_MAP_SLOTS;i++)
    d573:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    d57a:	00 
    d57b:	eb 20                	jmp    d59d <put_super+0xd5>
		brelse(sb->s_zmap[i]);
    d57d:	8b 44 24 08          	mov    0x8(%esp),%eax
    d581:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d585:	83 c2 0c             	add    $0xc,%edx
    d588:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
    d58c:	83 ec 0c             	sub    $0xc,%esp
    d58f:	50                   	push   %eax
    d590:	e8 fb f9 ff ff       	call   cf90 <brelse>
    d595:	83 c4 10             	add    $0x10,%esp
	}
	lock_super(sb);
	sb->s_dev = 0;
	for(i=0;i<I_MAP_SLOTS;i++)
		brelse(sb->s_imap[i]);
	for(i=0;i<Z_MAP_SLOTS;i++)
    d598:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    d59d:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
    d5a2:	7e d9                	jle    d57d <put_super+0xb5>
		brelse(sb->s_zmap[i]);
	free_super(sb);
    d5a4:	83 ec 0c             	sub    $0xc,%esp
    d5a7:	ff 74 24 14          	pushl  0x14(%esp)
    d5ab:	e8 53 fe ff ff       	call   d403 <free_super>
    d5b0:	83 c4 10             	add    $0x10,%esp
	return;
    d5b3:	90                   	nop
    d5b4:	eb 01                	jmp    d5b7 <put_super+0xef>
	if (dev == ROOT_DEV) {
		printk("root diskette changed: prepare for armageddon\n\r");
		return;
	}
	if (!(sb = get_super(dev)))
		return;
    d5b6:	90                   	nop
		brelse(sb->s_imap[i]);
	for(i=0;i<Z_MAP_SLOTS;i++)
		brelse(sb->s_zmap[i]);
	free_super(sb);
	return;
}
    d5b7:	83 c4 1c             	add    $0x1c,%esp
    d5ba:	c3                   	ret    

0000d5bb <read_super>:

static struct super_block * read_super(int dev)
{
    d5bb:	83 ec 1c             	sub    $0x1c,%esp
	struct super_block * s;
	struct buffer_head * bh;
	int i,block;

	if (!dev)
    d5be:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    d5c3:	75 0a                	jne    d5cf <read_super+0x14>
		return NULL;
    d5c5:	b8 00 00 00 00       	mov    $0x0,%eax
    d5ca:	e9 5a 03 00 00       	jmp    d929 <read_super+0x36e>
	check_disk_change(dev);
    d5cf:	83 ec 0c             	sub    $0xc,%esp
    d5d2:	ff 74 24 2c          	pushl  0x2c(%esp)
    d5d6:	e8 6c f4 ff ff       	call   ca47 <check_disk_change>
    d5db:	83 c4 10             	add    $0x10,%esp
	if ((s = get_super(dev)))
    d5de:	83 ec 0c             	sub    $0xc,%esp
    d5e1:	ff 74 24 2c          	pushl  0x2c(%esp)
    d5e5:	e8 69 fe ff ff       	call   d453 <get_super>
    d5ea:	83 c4 10             	add    $0x10,%esp
    d5ed:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d5f1:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    d5f6:	74 09                	je     d601 <read_super+0x46>
		return s;
    d5f8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d5fc:	e9 28 03 00 00       	jmp    d929 <read_super+0x36e>
	for (s = 0+super_block ;; s++) {
    d601:	c7 44 24 0c 80 53 02 	movl   $0x25380,0xc(%esp)
    d608:	00 
		if (s >= NR_SUPER+super_block)
    d609:	b8 e0 56 02 00       	mov    $0x256e0,%eax
    d60e:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    d612:	72 0a                	jb     d61e <read_super+0x63>
			return NULL;
    d614:	b8 00 00 00 00       	mov    $0x0,%eax
    d619:	e9 0b 03 00 00       	jmp    d929 <read_super+0x36e>
		if (!s->s_dev)
    d61e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d622:	0f b7 40 54          	movzwl 0x54(%eax),%eax
    d626:	66 85 c0             	test   %ax,%ax
    d629:	74 07                	je     d632 <read_super+0x77>
	if (!dev)
		return NULL;
	check_disk_change(dev);
	if ((s = get_super(dev)))
		return s;
	for (s = 0+super_block ;; s++) {
    d62b:	83 44 24 0c 6c       	addl   $0x6c,0xc(%esp)
		if (s >= NR_SUPER+super_block)
			return NULL;
		if (!s->s_dev)
			break;
	}
    d630:	eb d7                	jmp    d609 <read_super+0x4e>
		return s;
	for (s = 0+super_block ;; s++) {
		if (s >= NR_SUPER+super_block)
			return NULL;
		if (!s->s_dev)
			break;
    d632:	90                   	nop
	}
	s->s_dev = dev;
    d633:	8b 44 24 20          	mov    0x20(%esp),%eax
    d637:	89 c2                	mov    %eax,%edx
    d639:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d63d:	66 89 50 54          	mov    %dx,0x54(%eax)
	s->s_isup = NULL;
    d641:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d645:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
	s->s_imount = NULL;
    d64c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d650:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
	s->s_time = 0;
    d657:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d65b:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	s->s_rd_only = 0;
    d662:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d666:	c6 40 69 00          	movb   $0x0,0x69(%eax)
	s->s_dirt = 0;
    d66a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d66e:	c6 40 6a 00          	movb   $0x0,0x6a(%eax)
	lock_super(s);
    d672:	83 ec 0c             	sub    $0xc,%esp
    d675:	ff 74 24 18          	pushl  0x18(%esp)
    d679:	e8 52 fd ff ff       	call   d3d0 <lock_super>
    d67e:	83 c4 10             	add    $0x10,%esp
	if (!(bh = bread(dev,1))) {
    d681:	83 ec 08             	sub    $0x8,%esp
    d684:	6a 01                	push   $0x1
    d686:	ff 74 24 2c          	pushl  0x2c(%esp)
    d68a:	e8 57 f9 ff ff       	call   cfe6 <bread>
    d68f:	83 c4 10             	add    $0x10,%esp
    d692:	89 04 24             	mov    %eax,(%esp)
    d695:	83 3c 24 00          	cmpl   $0x0,(%esp)
    d699:	75 23                	jne    d6be <read_super+0x103>
		s->s_dev=0;
    d69b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d69f:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);
    d6a5:	83 ec 0c             	sub    $0xc,%esp
    d6a8:	ff 74 24 18          	pushl  0x18(%esp)
    d6ac:	e8 52 fd ff ff       	call   d403 <free_super>
    d6b1:	83 c4 10             	add    $0x10,%esp
		return NULL;
    d6b4:	b8 00 00 00 00       	mov    $0x0,%eax
    d6b9:	e9 6b 02 00 00       	jmp    d929 <read_super+0x36e>
	}
	*((struct d_super_block *) s) =
		*((struct d_super_block *) bh->b_data);
    d6be:	8b 04 24             	mov    (%esp),%eax
    d6c1:	8b 10                	mov    (%eax),%edx
	if (!(bh = bread(dev,1))) {
		s->s_dev=0;
		free_super(s);
		return NULL;
	}
	*((struct d_super_block *) s) =
    d6c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d6c7:	8b 0a                	mov    (%edx),%ecx
    d6c9:	89 08                	mov    %ecx,(%eax)
    d6cb:	8b 4a 04             	mov    0x4(%edx),%ecx
    d6ce:	89 48 04             	mov    %ecx,0x4(%eax)
    d6d1:	8b 4a 08             	mov    0x8(%edx),%ecx
    d6d4:	89 48 08             	mov    %ecx,0x8(%eax)
    d6d7:	8b 4a 0c             	mov    0xc(%edx),%ecx
    d6da:	89 48 0c             	mov    %ecx,0xc(%eax)
    d6dd:	8b 52 10             	mov    0x10(%edx),%edx
    d6e0:	89 50 10             	mov    %edx,0x10(%eax)
		*((struct d_super_block *) bh->b_data);
	brelse(bh);
    d6e3:	83 ec 0c             	sub    $0xc,%esp
    d6e6:	ff 74 24 0c          	pushl  0xc(%esp)
    d6ea:	e8 a1 f8 ff ff       	call   cf90 <brelse>
    d6ef:	83 c4 10             	add    $0x10,%esp
	if (s->s_magic != SUPER_MAGIC) {
    d6f2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d6f6:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    d6fa:	66 3d 7f 13          	cmp    $0x137f,%ax
    d6fe:	74 23                	je     d723 <read_super+0x168>
		s->s_dev = 0;
    d700:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d704:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);
    d70a:	83 ec 0c             	sub    $0xc,%esp
    d70d:	ff 74 24 18          	pushl  0x18(%esp)
    d711:	e8 ed fc ff ff       	call   d403 <free_super>
    d716:	83 c4 10             	add    $0x10,%esp
		return NULL;
    d719:	b8 00 00 00 00       	mov    $0x0,%eax
    d71e:	e9 06 02 00 00       	jmp    d929 <read_super+0x36e>
	}
	for (i=0;i<I_MAP_SLOTS;i++)
    d723:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    d72a:	00 
    d72b:	eb 18                	jmp    d745 <read_super+0x18a>
		s->s_imap[i] = NULL;
    d72d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d731:	8b 54 24 08          	mov    0x8(%esp),%edx
    d735:	83 c2 04             	add    $0x4,%edx
    d738:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
    d73f:	00 
	if (s->s_magic != SUPER_MAGIC) {
		s->s_dev = 0;
		free_super(s);
		return NULL;
	}
	for (i=0;i<I_MAP_SLOTS;i++)
    d740:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    d745:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    d74a:	7e e1                	jle    d72d <read_super+0x172>
		s->s_imap[i] = NULL;
	for (i=0;i<Z_MAP_SLOTS;i++)
    d74c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    d753:	00 
    d754:	eb 18                	jmp    d76e <read_super+0x1b3>
		s->s_zmap[i] = NULL;
    d756:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d75a:	8b 54 24 08          	mov    0x8(%esp),%edx
    d75e:	83 c2 0c             	add    $0xc,%edx
    d761:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
    d768:	00 
		free_super(s);
		return NULL;
	}
	for (i=0;i<I_MAP_SLOTS;i++)
		s->s_imap[i] = NULL;
	for (i=0;i<Z_MAP_SLOTS;i++)
    d769:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    d76e:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    d773:	7e e1                	jle    d756 <read_super+0x19b>
		s->s_zmap[i] = NULL;
	block=2;
    d775:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
    d77c:	00 
	for (i=0 ; i < s->s_imap_blocks ; i++)
    d77d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    d784:	00 
    d785:	eb 41                	jmp    d7c8 <read_super+0x20d>
		if ((s->s_imap[i]=bread(dev,block)))
    d787:	83 ec 08             	sub    $0x8,%esp
    d78a:	ff 74 24 0c          	pushl  0xc(%esp)
    d78e:	ff 74 24 2c          	pushl  0x2c(%esp)
    d792:	e8 4f f8 ff ff       	call   cfe6 <bread>
    d797:	83 c4 10             	add    $0x10,%esp
    d79a:	89 c1                	mov    %eax,%ecx
    d79c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d7a0:	8b 54 24 08          	mov    0x8(%esp),%edx
    d7a4:	83 c2 04             	add    $0x4,%edx
    d7a7:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
    d7ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d7af:	8b 54 24 08          	mov    0x8(%esp),%edx
    d7b3:	83 c2 04             	add    $0x4,%edx
    d7b6:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
    d7ba:	85 c0                	test   %eax,%eax
    d7bc:	74 1d                	je     d7db <read_super+0x220>
			block++;
    d7be:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
	for (i=0;i<I_MAP_SLOTS;i++)
		s->s_imap[i] = NULL;
	for (i=0;i<Z_MAP_SLOTS;i++)
		s->s_zmap[i] = NULL;
	block=2;
	for (i=0 ; i < s->s_imap_blocks ; i++)
    d7c3:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    d7c8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d7cc:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    d7d0:	0f b7 c0             	movzwl %ax,%eax
    d7d3:	3b 44 24 08          	cmp    0x8(%esp),%eax
    d7d7:	7f ae                	jg     d787 <read_super+0x1cc>
    d7d9:	eb 01                	jmp    d7dc <read_super+0x221>
		if ((s->s_imap[i]=bread(dev,block)))
			block++;
		else
			break;
    d7db:	90                   	nop
	for (i=0 ; i < s->s_zmap_blocks ; i++)
    d7dc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    d7e3:	00 
    d7e4:	eb 41                	jmp    d827 <read_super+0x26c>
		if ((s->s_zmap[i]=bread(dev,block)))
    d7e6:	83 ec 08             	sub    $0x8,%esp
    d7e9:	ff 74 24 0c          	pushl  0xc(%esp)
    d7ed:	ff 74 24 2c          	pushl  0x2c(%esp)
    d7f1:	e8 f0 f7 ff ff       	call   cfe6 <bread>
    d7f6:	83 c4 10             	add    $0x10,%esp
    d7f9:	89 c1                	mov    %eax,%ecx
    d7fb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d7ff:	8b 54 24 08          	mov    0x8(%esp),%edx
    d803:	83 c2 0c             	add    $0xc,%edx
    d806:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
    d80a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d80e:	8b 54 24 08          	mov    0x8(%esp),%edx
    d812:	83 c2 0c             	add    $0xc,%edx
    d815:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
    d819:	85 c0                	test   %eax,%eax
    d81b:	74 1d                	je     d83a <read_super+0x27f>
			block++;
    d81d:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
	for (i=0 ; i < s->s_imap_blocks ; i++)
		if ((s->s_imap[i]=bread(dev,block)))
			block++;
		else
			break;
	for (i=0 ; i < s->s_zmap_blocks ; i++)
    d822:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    d827:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d82b:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    d82f:	0f b7 c0             	movzwl %ax,%eax
    d832:	3b 44 24 08          	cmp    0x8(%esp),%eax
    d836:	7f ae                	jg     d7e6 <read_super+0x22b>
    d838:	eb 01                	jmp    d83b <read_super+0x280>
		if ((s->s_zmap[i]=bread(dev,block)))
			block++;
		else
			break;
    d83a:	90                   	nop
	if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {
    d83b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d83f:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    d843:	0f b7 c0             	movzwl %ax,%eax
    d846:	8d 50 02             	lea    0x2(%eax),%edx
    d849:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d84d:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    d851:	0f b7 c0             	movzwl %ax,%eax
    d854:	01 d0                	add    %edx,%eax
    d856:	3b 44 24 04          	cmp    0x4(%esp),%eax
    d85a:	0f 84 82 00 00 00    	je     d8e2 <read_super+0x327>
		for(i=0;i<I_MAP_SLOTS;i++)
    d860:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    d867:	00 
    d868:	eb 20                	jmp    d88a <read_super+0x2cf>
			brelse(s->s_imap[i]);
    d86a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d86e:	8b 54 24 08          	mov    0x8(%esp),%edx
    d872:	83 c2 04             	add    $0x4,%edx
    d875:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
    d879:	83 ec 0c             	sub    $0xc,%esp
    d87c:	50                   	push   %eax
    d87d:	e8 0e f7 ff ff       	call   cf90 <brelse>
    d882:	83 c4 10             	add    $0x10,%esp
		if ((s->s_zmap[i]=bread(dev,block)))
			block++;
		else
			break;
	if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {
		for(i=0;i<I_MAP_SLOTS;i++)
    d885:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    d88a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    d88f:	7e d9                	jle    d86a <read_super+0x2af>
			brelse(s->s_imap[i]);
		for(i=0;i<Z_MAP_SLOTS;i++)
    d891:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    d898:	00 
    d899:	eb 20                	jmp    d8bb <read_super+0x300>
			brelse(s->s_zmap[i]);
    d89b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d89f:	8b 54 24 08          	mov    0x8(%esp),%edx
    d8a3:	83 c2 0c             	add    $0xc,%edx
    d8a6:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
    d8aa:	83 ec 0c             	sub    $0xc,%esp
    d8ad:	50                   	push   %eax
    d8ae:	e8 dd f6 ff ff       	call   cf90 <brelse>
    d8b3:	83 c4 10             	add    $0x10,%esp
		else
			break;
	if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {
		for(i=0;i<I_MAP_SLOTS;i++)
			brelse(s->s_imap[i]);
		for(i=0;i<Z_MAP_SLOTS;i++)
    d8b6:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
    d8bb:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    d8c0:	7e d9                	jle    d89b <read_super+0x2e0>
			brelse(s->s_zmap[i]);
		s->s_dev=0;
    d8c2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d8c6:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);
    d8cc:	83 ec 0c             	sub    $0xc,%esp
    d8cf:	ff 74 24 18          	pushl  0x18(%esp)
    d8d3:	e8 2b fb ff ff       	call   d403 <free_super>
    d8d8:	83 c4 10             	add    $0x10,%esp
		return NULL;
    d8db:	b8 00 00 00 00       	mov    $0x0,%eax
    d8e0:	eb 47                	jmp    d929 <read_super+0x36e>
	}
	s->s_imap[0]->b_data[0] |= 1;
    d8e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d8e6:	8b 40 14             	mov    0x14(%eax),%eax
    d8e9:	8b 00                	mov    (%eax),%eax
    d8eb:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d8ef:	8b 52 14             	mov    0x14(%edx),%edx
    d8f2:	8b 12                	mov    (%edx),%edx
    d8f4:	0f b6 12             	movzbl (%edx),%edx
    d8f7:	83 ca 01             	or     $0x1,%edx
    d8fa:	88 10                	mov    %dl,(%eax)
	s->s_zmap[0]->b_data[0] |= 1;
    d8fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d900:	8b 40 34             	mov    0x34(%eax),%eax
    d903:	8b 00                	mov    (%eax),%eax
    d905:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d909:	8b 52 34             	mov    0x34(%edx),%edx
    d90c:	8b 12                	mov    (%edx),%edx
    d90e:	0f b6 12             	movzbl (%edx),%edx
    d911:	83 ca 01             	or     $0x1,%edx
    d914:	88 10                	mov    %dl,(%eax)
	free_super(s);
    d916:	83 ec 0c             	sub    $0xc,%esp
    d919:	ff 74 24 18          	pushl  0x18(%esp)
    d91d:	e8 e1 fa ff ff       	call   d403 <free_super>
    d922:	83 c4 10             	add    $0x10,%esp
	return s;
    d925:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    d929:	83 c4 1c             	add    $0x1c,%esp
    d92c:	c3                   	ret    

0000d92d <sys_umount>:

int sys_umount(char * dev_name)
{
    d92d:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;
	struct super_block * sb;
	int dev;

	if (!(inode=namei(dev_name)))
    d930:	83 ec 0c             	sub    $0xc,%esp
    d933:	ff 74 24 2c          	pushl  0x2c(%esp)
    d937:	e8 dc 2d 00 00       	call   10718 <namei>
    d93c:	83 c4 10             	add    $0x10,%esp
    d93f:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d943:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    d948:	75 0a                	jne    d954 <sys_umount+0x27>
		return -ENOENT;
    d94a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    d94f:	e9 59 01 00 00       	jmp    daad <sys_umount+0x180>
	dev = inode->i_zone[0];
    d954:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d958:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    d95c:	0f b7 c0             	movzwl %ax,%eax
    d95f:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (!S_ISBLK(inode->i_mode)) {
    d963:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d967:	0f b7 00             	movzwl (%eax),%eax
    d96a:	0f b7 c0             	movzwl %ax,%eax
    d96d:	25 00 f0 00 00       	and    $0xf000,%eax
    d972:	3d 00 60 00 00       	cmp    $0x6000,%eax
    d977:	74 19                	je     d992 <sys_umount+0x65>
		iput(inode);
    d979:	83 ec 0c             	sub    $0xc,%esp
    d97c:	ff 74 24 18          	pushl  0x18(%esp)
    d980:	e8 ec e6 ff ff       	call   c071 <iput>
    d985:	83 c4 10             	add    $0x10,%esp
		return -ENOTBLK;
    d988:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    d98d:	e9 1b 01 00 00       	jmp    daad <sys_umount+0x180>
	}
	iput(inode);
    d992:	83 ec 0c             	sub    $0xc,%esp
    d995:	ff 74 24 18          	pushl  0x18(%esp)
    d999:	e8 d3 e6 ff ff       	call   c071 <iput>
    d99e:	83 c4 10             	add    $0x10,%esp
	if (dev==ROOT_DEV)
    d9a1:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
    d9a6:	39 44 24 08          	cmp    %eax,0x8(%esp)
    d9aa:	75 0a                	jne    d9b6 <sys_umount+0x89>
		return -EBUSY;
    d9ac:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    d9b1:	e9 f7 00 00 00       	jmp    daad <sys_umount+0x180>
	if (!(sb=get_super(dev)) || !(sb->s_imount))
    d9b6:	83 ec 0c             	sub    $0xc,%esp
    d9b9:	ff 74 24 14          	pushl  0x14(%esp)
    d9bd:	e8 91 fa ff ff       	call   d453 <get_super>
    d9c2:	83 c4 10             	add    $0x10,%esp
    d9c5:	89 44 24 04          	mov    %eax,0x4(%esp)
    d9c9:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    d9ce:	74 0b                	je     d9db <sys_umount+0xae>
    d9d0:	8b 44 24 04          	mov    0x4(%esp),%eax
    d9d4:	8b 40 5c             	mov    0x5c(%eax),%eax
    d9d7:	85 c0                	test   %eax,%eax
    d9d9:	75 0a                	jne    d9e5 <sys_umount+0xb8>
		return -ENOENT;
    d9db:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    d9e0:	e9 c8 00 00 00       	jmp    daad <sys_umount+0x180>
	if (!sb->s_imount->i_mount)
    d9e5:	8b 44 24 04          	mov    0x4(%esp),%eax
    d9e9:	8b 40 5c             	mov    0x5c(%eax),%eax
    d9ec:	0f b6 40 35          	movzbl 0x35(%eax),%eax
    d9f0:	84 c0                	test   %al,%al
    d9f2:	75 10                	jne    da04 <sys_umount+0xd7>
		printk("Mounted inode has i_mount=0\n");
    d9f4:	83 ec 0c             	sub    $0xc,%esp
    d9f7:	68 a0 88 01 00       	push   $0x188a0
    d9fc:	e8 0c ae ff ff       	call   880d <printk>
    da01:	83 c4 10             	add    $0x10,%esp
	for (inode=inode_table+0 ; inode<inode_table+NR_INODE ; inode++)
    da04:	c7 44 24 0c 60 35 02 	movl   $0x23560,0xc(%esp)
    da0b:	00 
    da0c:	eb 2a                	jmp    da38 <sys_umount+0x10b>
		if (inode->i_dev==dev && inode->i_count)
    da0e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    da12:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    da16:	0f b7 c0             	movzwl %ax,%eax
    da19:	3b 44 24 08          	cmp    0x8(%esp),%eax
    da1d:	75 14                	jne    da33 <sys_umount+0x106>
    da1f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    da23:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    da27:	66 85 c0             	test   %ax,%ax
    da2a:	74 07                	je     da33 <sys_umount+0x106>
				return -EBUSY;
    da2c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    da31:	eb 7a                	jmp    daad <sys_umount+0x180>
		return -EBUSY;
	if (!(sb=get_super(dev)) || !(sb->s_imount))
		return -ENOENT;
	if (!sb->s_imount->i_mount)
		printk("Mounted inode has i_mount=0\n");
	for (inode=inode_table+0 ; inode<inode_table+NR_INODE ; inode++)
    da33:	83 44 24 0c 38       	addl   $0x38,0xc(%esp)
    da38:	b8 60 3c 02 00       	mov    $0x23c60,%eax
    da3d:	39 44 24 0c          	cmp    %eax,0xc(%esp)
    da41:	72 cb                	jb     da0e <sys_umount+0xe1>
		if (inode->i_dev==dev && inode->i_count)
				return -EBUSY;
	sb->s_imount->i_mount=0;
    da43:	8b 44 24 04          	mov    0x4(%esp),%eax
    da47:	8b 40 5c             	mov    0x5c(%eax),%eax
    da4a:	c6 40 35 00          	movb   $0x0,0x35(%eax)
	iput(sb->s_imount);
    da4e:	8b 44 24 04          	mov    0x4(%esp),%eax
    da52:	8b 40 5c             	mov    0x5c(%eax),%eax
    da55:	83 ec 0c             	sub    $0xc,%esp
    da58:	50                   	push   %eax
    da59:	e8 13 e6 ff ff       	call   c071 <iput>
    da5e:	83 c4 10             	add    $0x10,%esp
	sb->s_imount = NULL;
    da61:	8b 44 24 04          	mov    0x4(%esp),%eax
    da65:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
	iput(sb->s_isup);
    da6c:	8b 44 24 04          	mov    0x4(%esp),%eax
    da70:	8b 40 58             	mov    0x58(%eax),%eax
    da73:	83 ec 0c             	sub    $0xc,%esp
    da76:	50                   	push   %eax
    da77:	e8 f5 e5 ff ff       	call   c071 <iput>
    da7c:	83 c4 10             	add    $0x10,%esp
	sb->s_isup = NULL;
    da7f:	8b 44 24 04          	mov    0x4(%esp),%eax
    da83:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
	put_super(dev);
    da8a:	83 ec 0c             	sub    $0xc,%esp
    da8d:	ff 74 24 14          	pushl  0x14(%esp)
    da91:	e8 32 fa ff ff       	call   d4c8 <put_super>
    da96:	83 c4 10             	add    $0x10,%esp
	sync_dev(dev);
    da99:	83 ec 0c             	sub    $0xc,%esp
    da9c:	ff 74 24 14          	pushl  0x14(%esp)
    daa0:	e8 24 ee ff ff       	call   c8c9 <sync_dev>
    daa5:	83 c4 10             	add    $0x10,%esp
	return 0;
    daa8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    daad:	83 c4 1c             	add    $0x1c,%esp
    dab0:	c3                   	ret    

0000dab1 <sys_mount>:

int sys_mount(char * dev_name, char * dir_name, int rw_flag)
{
    dab1:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * dev_i, * dir_i;
	struct super_block * sb;
	int dev;

	if (!(dev_i=namei(dev_name)))
    dab4:	83 ec 0c             	sub    $0xc,%esp
    dab7:	ff 74 24 2c          	pushl  0x2c(%esp)
    dabb:	e8 58 2c 00 00       	call   10718 <namei>
    dac0:	83 c4 10             	add    $0x10,%esp
    dac3:	89 44 24 0c          	mov    %eax,0xc(%esp)
    dac7:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    dacc:	75 0a                	jne    dad8 <sys_mount+0x27>
		return -ENOENT;
    dace:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    dad3:	e9 64 01 00 00       	jmp    dc3c <sys_mount+0x18b>
	dev = dev_i->i_zone[0];
    dad8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dadc:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    dae0:	0f b7 c0             	movzwl %ax,%eax
    dae3:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (!S_ISBLK(dev_i->i_mode)) {
    dae7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    daeb:	0f b7 00             	movzwl (%eax),%eax
    daee:	0f b7 c0             	movzwl %ax,%eax
    daf1:	25 00 f0 00 00       	and    $0xf000,%eax
    daf6:	3d 00 60 00 00       	cmp    $0x6000,%eax
    dafb:	74 19                	je     db16 <sys_mount+0x65>
		iput(dev_i);
    dafd:	83 ec 0c             	sub    $0xc,%esp
    db00:	ff 74 24 18          	pushl  0x18(%esp)
    db04:	e8 68 e5 ff ff       	call   c071 <iput>
    db09:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    db0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    db11:	e9 26 01 00 00       	jmp    dc3c <sys_mount+0x18b>
	}
	iput(dev_i);
    db16:	83 ec 0c             	sub    $0xc,%esp
    db19:	ff 74 24 18          	pushl  0x18(%esp)
    db1d:	e8 4f e5 ff ff       	call   c071 <iput>
    db22:	83 c4 10             	add    $0x10,%esp
	if (!(dir_i=namei(dir_name)))
    db25:	83 ec 0c             	sub    $0xc,%esp
    db28:	ff 74 24 30          	pushl  0x30(%esp)
    db2c:	e8 e7 2b 00 00       	call   10718 <namei>
    db31:	83 c4 10             	add    $0x10,%esp
    db34:	89 44 24 04          	mov    %eax,0x4(%esp)
    db38:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    db3d:	75 0a                	jne    db49 <sys_mount+0x98>
		return -ENOENT;
    db3f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    db44:	e9 f3 00 00 00       	jmp    dc3c <sys_mount+0x18b>
	if (dir_i->i_count != 1 || dir_i->i_num == ROOT_INO) {
    db49:	8b 44 24 04          	mov    0x4(%esp),%eax
    db4d:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    db51:	66 83 f8 01          	cmp    $0x1,%ax
    db55:	75 0e                	jne    db65 <sys_mount+0xb4>
    db57:	8b 44 24 04          	mov    0x4(%esp),%eax
    db5b:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    db5f:	66 83 f8 01          	cmp    $0x1,%ax
    db63:	75 19                	jne    db7e <sys_mount+0xcd>
		iput(dir_i);
    db65:	83 ec 0c             	sub    $0xc,%esp
    db68:	ff 74 24 10          	pushl  0x10(%esp)
    db6c:	e8 00 e5 ff ff       	call   c071 <iput>
    db71:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
    db74:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    db79:	e9 be 00 00 00       	jmp    dc3c <sys_mount+0x18b>
	}
	if (!S_ISDIR(dir_i->i_mode)) {
    db7e:	8b 44 24 04          	mov    0x4(%esp),%eax
    db82:	0f b7 00             	movzwl (%eax),%eax
    db85:	0f b7 c0             	movzwl %ax,%eax
    db88:	25 00 f0 00 00       	and    $0xf000,%eax
    db8d:	3d 00 40 00 00       	cmp    $0x4000,%eax
    db92:	74 19                	je     dbad <sys_mount+0xfc>
		iput(dir_i);
    db94:	83 ec 0c             	sub    $0xc,%esp
    db97:	ff 74 24 10          	pushl  0x10(%esp)
    db9b:	e8 d1 e4 ff ff       	call   c071 <iput>
    dba0:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    dba3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    dba8:	e9 8f 00 00 00       	jmp    dc3c <sys_mount+0x18b>
	}
	if (!(sb=read_super(dev))) {
    dbad:	83 ec 0c             	sub    $0xc,%esp
    dbb0:	ff 74 24 14          	pushl  0x14(%esp)
    dbb4:	e8 02 fa ff ff       	call   d5bb <read_super>
    dbb9:	83 c4 10             	add    $0x10,%esp
    dbbc:	89 04 24             	mov    %eax,(%esp)
    dbbf:	83 3c 24 00          	cmpl   $0x0,(%esp)
    dbc3:	75 16                	jne    dbdb <sys_mount+0x12a>
		iput(dir_i);
    dbc5:	83 ec 0c             	sub    $0xc,%esp
    dbc8:	ff 74 24 10          	pushl  0x10(%esp)
    dbcc:	e8 a0 e4 ff ff       	call   c071 <iput>
    dbd1:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
    dbd4:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    dbd9:	eb 61                	jmp    dc3c <sys_mount+0x18b>
	}
	if (sb->s_imount) {
    dbdb:	8b 04 24             	mov    (%esp),%eax
    dbde:	8b 40 5c             	mov    0x5c(%eax),%eax
    dbe1:	85 c0                	test   %eax,%eax
    dbe3:	74 16                	je     dbfb <sys_mount+0x14a>
		iput(dir_i);
    dbe5:	83 ec 0c             	sub    $0xc,%esp
    dbe8:	ff 74 24 10          	pushl  0x10(%esp)
    dbec:	e8 80 e4 ff ff       	call   c071 <iput>
    dbf1:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
    dbf4:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    dbf9:	eb 41                	jmp    dc3c <sys_mount+0x18b>
	}
	if (dir_i->i_mount) {
    dbfb:	8b 44 24 04          	mov    0x4(%esp),%eax
    dbff:	0f b6 40 35          	movzbl 0x35(%eax),%eax
    dc03:	84 c0                	test   %al,%al
    dc05:	74 16                	je     dc1d <sys_mount+0x16c>
		iput(dir_i);
    dc07:	83 ec 0c             	sub    $0xc,%esp
    dc0a:	ff 74 24 10          	pushl  0x10(%esp)
    dc0e:	e8 5e e4 ff ff       	call   c071 <iput>
    dc13:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    dc16:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    dc1b:	eb 1f                	jmp    dc3c <sys_mount+0x18b>
	}
	sb->s_imount=dir_i;
    dc1d:	8b 04 24             	mov    (%esp),%eax
    dc20:	8b 54 24 04          	mov    0x4(%esp),%edx
    dc24:	89 50 5c             	mov    %edx,0x5c(%eax)
	dir_i->i_mount=1;
    dc27:	8b 44 24 04          	mov    0x4(%esp),%eax
    dc2b:	c6 40 35 01          	movb   $0x1,0x35(%eax)
	dir_i->i_dirt=1;		/* NOTE! we don't iput(dir_i) */
    dc2f:	8b 44 24 04          	mov    0x4(%esp),%eax
    dc33:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	return 0;			/* we do that in umount */
    dc37:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dc3c:	83 c4 1c             	add    $0x1c,%esp
    dc3f:	c3                   	ret    

0000dc40 <mount_root>:

void mount_root(void)
{
    dc40:	53                   	push   %ebx
    dc41:	83 ec 18             	sub    $0x18,%esp
	struct super_block * p;
	struct m_inode * mi;

	if (32 != sizeof (struct d_inode))
		panic("bad i-node size");
	for(i=0;i<NR_FILE;i++)
    dc44:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    dc4b:	00 
    dc4c:	eb 16                	jmp    dc64 <mount_root+0x24>
		file_table[i].f_count=0;
    dc4e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dc52:	c1 e0 04             	shl    $0x4,%eax
    dc55:	05 e4 56 02 00       	add    $0x256e4,%eax
    dc5a:	66 c7 00 00 00       	movw   $0x0,(%eax)
	struct super_block * p;
	struct m_inode * mi;

	if (32 != sizeof (struct d_inode))
		panic("bad i-node size");
	for(i=0;i<NR_FILE;i++)
    dc5f:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    dc64:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    dc69:	7e e3                	jle    dc4e <mount_root+0xe>
		file_table[i].f_count=0;
	if (MAJOR(ROOT_DEV) == 2) {
    dc6b:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
    dc70:	c1 e8 08             	shr    $0x8,%eax
    dc73:	83 f8 02             	cmp    $0x2,%eax
    dc76:	75 15                	jne    dc8d <mount_root+0x4d>
		printk("Insert root floppy and press ENTER");
    dc78:	83 ec 0c             	sub    $0xc,%esp
    dc7b:	68 c0 88 01 00       	push   $0x188c0
    dc80:	e8 88 ab ff ff       	call   880d <printk>
    dc85:	83 c4 10             	add    $0x10,%esp
		wait_for_keypress();
    dc88:	e8 3b 71 00 00       	call   14dc8 <wait_for_keypress>
	}
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
    dc8d:	c7 44 24 04 80 53 02 	movl   $0x25380,0x4(%esp)
    dc94:	00 
    dc95:	eb 22                	jmp    dcb9 <mount_root+0x79>
		p->s_dev = 0;
    dc97:	8b 44 24 04          	mov    0x4(%esp),%eax
    dc9b:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		p->s_lock = 0;
    dca1:	8b 44 24 04          	mov    0x4(%esp),%eax
    dca5:	c6 40 68 00          	movb   $0x0,0x68(%eax)
		p->s_wait = NULL;
    dca9:	8b 44 24 04          	mov    0x4(%esp),%eax
    dcad:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
		file_table[i].f_count=0;
	if (MAJOR(ROOT_DEV) == 2) {
		printk("Insert root floppy and press ENTER");
		wait_for_keypress();
	}
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
    dcb4:	83 44 24 04 6c       	addl   $0x6c,0x4(%esp)
    dcb9:	81 7c 24 04 e0 56 02 	cmpl   $0x256e0,0x4(%esp)
    dcc0:	00 
    dcc1:	72 d4                	jb     dc97 <mount_root+0x57>
		p->s_dev = 0;
		p->s_lock = 0;
		p->s_wait = NULL;
	}
	if (!(p=read_super(ROOT_DEV)))
    dcc3:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
    dcc8:	83 ec 0c             	sub    $0xc,%esp
    dccb:	50                   	push   %eax
    dccc:	e8 ea f8 ff ff       	call   d5bb <read_super>
    dcd1:	83 c4 10             	add    $0x10,%esp
    dcd4:	89 44 24 04          	mov    %eax,0x4(%esp)
    dcd8:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    dcdd:	75 10                	jne    dcef <mount_root+0xaf>
		panic("Unable to mount root");
    dcdf:	83 ec 0c             	sub    $0xc,%esp
    dce2:	68 e3 88 01 00       	push   $0x188e3
    dce7:	e8 e2 aa ff ff       	call   87ce <panic>
    dcec:	83 c4 10             	add    $0x10,%esp
	if (!(mi=iget(ROOT_DEV,ROOT_INO)))
    dcef:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
    dcf4:	83 ec 08             	sub    $0x8,%esp
    dcf7:	6a 01                	push   $0x1
    dcf9:	50                   	push   %eax
    dcfa:	e8 f5 e6 ff ff       	call   c3f4 <iget>
    dcff:	83 c4 10             	add    $0x10,%esp
    dd02:	89 04 24             	mov    %eax,(%esp)
    dd05:	83 3c 24 00          	cmpl   $0x0,(%esp)
    dd09:	75 10                	jne    dd1b <mount_root+0xdb>
		panic("Unable to read root i-node");
    dd0b:	83 ec 0c             	sub    $0xc,%esp
    dd0e:	68 f8 88 01 00       	push   $0x188f8
    dd13:	e8 b6 aa ff ff       	call   87ce <panic>
    dd18:	83 c4 10             	add    $0x10,%esp
	mi->i_count += 3 ;	/* NOTE! it is logically used 4 times, not 1 */
    dd1b:	8b 04 24             	mov    (%esp),%eax
    dd1e:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    dd22:	8d 50 03             	lea    0x3(%eax),%edx
    dd25:	8b 04 24             	mov    (%esp),%eax
    dd28:	66 89 50 30          	mov    %dx,0x30(%eax)
	p->s_isup = p->s_imount = mi;
    dd2c:	8b 44 24 04          	mov    0x4(%esp),%eax
    dd30:	8b 14 24             	mov    (%esp),%edx
    dd33:	89 50 5c             	mov    %edx,0x5c(%eax)
    dd36:	8b 44 24 04          	mov    0x4(%esp),%eax
    dd3a:	8b 50 5c             	mov    0x5c(%eax),%edx
    dd3d:	8b 44 24 04          	mov    0x4(%esp),%eax
    dd41:	89 50 58             	mov    %edx,0x58(%eax)
	current->pwd = mi;
    dd44:	a1 40 f1 01 00       	mov    0x1f140,%eax
    dd49:	8b 14 24             	mov    (%esp),%edx
    dd4c:	89 90 70 02 00 00    	mov    %edx,0x270(%eax)
	current->root = mi;
    dd52:	a1 40 f1 01 00       	mov    0x1f140,%eax
    dd57:	8b 14 24             	mov    (%esp),%edx
    dd5a:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
	free=0;
    dd60:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    dd67:	00 
	i=p->s_nzones;
    dd68:	8b 44 24 04          	mov    0x4(%esp),%eax
    dd6c:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    dd70:	0f b7 c0             	movzwl %ax,%eax
    dd73:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (-- i >= 0)
    dd77:	eb 39                	jmp    ddb2 <mount_root+0x172>
		if (!set_bit(i&8191,p->s_zmap[i>>13]->b_data))
    dd79:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dd7d:	25 ff 1f 00 00       	and    $0x1fff,%eax
    dd82:	89 c1                	mov    %eax,%ecx
    dd84:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dd88:	c1 f8 0d             	sar    $0xd,%eax
    dd8b:	89 c2                	mov    %eax,%edx
    dd8d:	8b 44 24 04          	mov    0x4(%esp),%eax
    dd91:	83 c2 0c             	add    $0xc,%edx
    dd94:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
    dd98:	8b 10                	mov    (%eax),%edx
    dd9a:	b8 00 00 00 00       	mov    $0x0,%eax
    dd9f:	0f a3 0a             	bt     %ecx,(%edx)
    dda2:	0f 92 c0             	setb   %al
    dda5:	89 c3                	mov    %eax,%ebx
    dda7:	89 d8                	mov    %ebx,%eax
    dda9:	85 c0                	test   %eax,%eax
    ddab:	75 05                	jne    ddb2 <mount_root+0x172>
			free++;
    ddad:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
	p->s_isup = p->s_imount = mi;
	current->pwd = mi;
	current->root = mi;
	free=0;
	i=p->s_nzones;
	while (-- i >= 0)
    ddb2:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
    ddb7:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    ddbc:	79 bb                	jns    dd79 <mount_root+0x139>
		if (!set_bit(i&8191,p->s_zmap[i>>13]->b_data))
			free++;
	printk("%d/%d free blocks\n\r",free,p->s_nzones);
    ddbe:	8b 44 24 04          	mov    0x4(%esp),%eax
    ddc2:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    ddc6:	0f b7 c0             	movzwl %ax,%eax
    ddc9:	83 ec 04             	sub    $0x4,%esp
    ddcc:	50                   	push   %eax
    ddcd:	ff 74 24 10          	pushl  0x10(%esp)
    ddd1:	68 13 89 01 00       	push   $0x18913
    ddd6:	e8 32 aa ff ff       	call   880d <printk>
    dddb:	83 c4 10             	add    $0x10,%esp
	free=0;
    ddde:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    dde5:	00 
	i=p->s_ninodes+1;
    dde6:	8b 44 24 04          	mov    0x4(%esp),%eax
    ddea:	0f b7 00             	movzwl (%eax),%eax
    dded:	0f b7 c0             	movzwl %ax,%eax
    ddf0:	83 c0 01             	add    $0x1,%eax
    ddf3:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (-- i >= 0)
    ddf7:	eb 39                	jmp    de32 <mount_root+0x1f2>
		if (!set_bit(i&8191,p->s_imap[i>>13]->b_data))
    ddf9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ddfd:	25 ff 1f 00 00       	and    $0x1fff,%eax
    de02:	89 c1                	mov    %eax,%ecx
    de04:	8b 44 24 0c          	mov    0xc(%esp),%eax
    de08:	c1 f8 0d             	sar    $0xd,%eax
    de0b:	89 c2                	mov    %eax,%edx
    de0d:	8b 44 24 04          	mov    0x4(%esp),%eax
    de11:	83 c2 04             	add    $0x4,%edx
    de14:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
    de18:	8b 10                	mov    (%eax),%edx
    de1a:	b8 00 00 00 00       	mov    $0x0,%eax
    de1f:	0f a3 0a             	bt     %ecx,(%edx)
    de22:	0f 92 c0             	setb   %al
    de25:	89 c3                	mov    %eax,%ebx
    de27:	89 d8                	mov    %ebx,%eax
    de29:	85 c0                	test   %eax,%eax
    de2b:	75 05                	jne    de32 <mount_root+0x1f2>
			free++;
    de2d:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
		if (!set_bit(i&8191,p->s_zmap[i>>13]->b_data))
			free++;
	printk("%d/%d free blocks\n\r",free,p->s_nzones);
	free=0;
	i=p->s_ninodes+1;
	while (-- i >= 0)
    de32:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
    de37:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    de3c:	79 bb                	jns    ddf9 <mount_root+0x1b9>
		if (!set_bit(i&8191,p->s_imap[i>>13]->b_data))
			free++;
	printk("%d/%d free inodes\n\r",free,p->s_ninodes);
    de3e:	8b 44 24 04          	mov    0x4(%esp),%eax
    de42:	0f b7 00             	movzwl (%eax),%eax
    de45:	0f b7 c0             	movzwl %ax,%eax
    de48:	83 ec 04             	sub    $0x4,%esp
    de4b:	50                   	push   %eax
    de4c:	ff 74 24 10          	pushl  0x10(%esp)
    de50:	68 27 89 01 00       	push   $0x18927
    de55:	e8 b3 a9 ff ff       	call   880d <printk>
    de5a:	83 c4 10             	add    $0x10,%esp
}
    de5d:	90                   	nop
    de5e:	83 c4 18             	add    $0x18,%esp
    de61:	5b                   	pop    %ebx
    de62:	c3                   	ret    

0000de63 <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
    de63:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    de64:	8b 44 24 08          	mov    0x8(%esp),%eax
    de68:	64 8a 00             	mov    %fs:(%eax),%al
    de6b:	89 c3                	mov    %eax,%ebx
	return _v;
    de6d:	89 d8                	mov    %ebx,%eax
}
    de6f:	5b                   	pop    %ebx
    de70:	c3                   	ret    

0000de71 <put_fs_byte>:
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
	return _v;
}

static inline void put_fs_byte(char val,char *addr)
{
    de71:	83 ec 04             	sub    $0x4,%esp
    de74:	8b 44 24 08          	mov    0x8(%esp),%eax
    de78:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    de7b:	0f b6 04 24          	movzbl (%esp),%eax
    de7f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    de83:	64 88 02             	mov    %al,%fs:(%edx)
}
    de86:	90                   	nop
    de87:	83 c4 04             	add    $0x4,%esp
    de8a:	c3                   	ret    

0000de8b <block_write>:
#include <linux/kernel.h>
#include <asm/segment.h>
#include <asm/system.h>

int block_write(int dev, long * pos, char * buf, int count)
{
    de8b:	56                   	push   %esi
    de8c:	53                   	push   %ebx
    de8d:	83 ec 24             	sub    $0x24,%esp
	int block = *pos >> BLOCK_SIZE_BITS;
    de90:	8b 44 24 34          	mov    0x34(%esp),%eax
    de94:	8b 00                	mov    (%eax),%eax
    de96:	c1 f8 0a             	sar    $0xa,%eax
    de99:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	int offset = *pos & (BLOCK_SIZE-1);
    de9d:	8b 44 24 34          	mov    0x34(%esp),%eax
    dea1:	8b 00                	mov    (%eax),%eax
    dea3:	25 ff 03 00 00       	and    $0x3ff,%eax
    dea8:	89 44 24 18          	mov    %eax,0x18(%esp)
	int chars;
	int written = 0;
    deac:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    deb3:	00 
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
    deb4:	e9 0e 01 00 00       	jmp    dfc7 <block_write+0x13c>
		chars = BLOCK_SIZE - offset;
    deb9:	b8 00 04 00 00       	mov    $0x400,%eax
    debe:	2b 44 24 18          	sub    0x18(%esp),%eax
    dec2:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (chars > count)
    dec6:	8b 44 24 14          	mov    0x14(%esp),%eax
    deca:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
    dece:	7e 08                	jle    ded8 <block_write+0x4d>
			chars=count;
    ded0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    ded4:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (chars == BLOCK_SIZE)
    ded8:	81 7c 24 14 00 04 00 	cmpl   $0x400,0x14(%esp)
    dedf:	00 
    dee0:	75 19                	jne    defb <block_write+0x70>
			bh = getblk(dev,block);
    dee2:	83 ec 08             	sub    $0x8,%esp
    dee5:	ff 74 24 24          	pushl  0x24(%esp)
    dee9:	ff 74 24 3c          	pushl  0x3c(%esp)
    deed:	e8 e5 ee ff ff       	call   cdd7 <getblk>
    def2:	83 c4 10             	add    $0x10,%esp
    def5:	89 44 24 0c          	mov    %eax,0xc(%esp)
    def9:	eb 29                	jmp    df24 <block_write+0x99>
		else
			bh = breada(dev,block,block+1,block+2,-1);
    defb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    deff:	8d 50 02             	lea    0x2(%eax),%edx
    df02:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    df06:	83 c0 01             	add    $0x1,%eax
    df09:	83 ec 0c             	sub    $0xc,%esp
    df0c:	6a ff                	push   $0xffffffff
    df0e:	52                   	push   %edx
    df0f:	50                   	push   %eax
    df10:	ff 74 24 34          	pushl  0x34(%esp)
    df14:	ff 74 24 4c          	pushl  0x4c(%esp)
    df18:	e8 85 f2 ff ff       	call   d1a2 <breada>
    df1d:	83 c4 20             	add    $0x20,%esp
    df20:	89 44 24 0c          	mov    %eax,0xc(%esp)
		block++;
    df24:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
		if (!bh)
    df29:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    df2e:	75 1a                	jne    df4a <block_write+0xbf>
			return written?written:-EIO;
    df30:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    df35:	74 09                	je     df40 <block_write+0xb5>
    df37:	8b 44 24 10          	mov    0x10(%esp),%eax
    df3b:	e9 96 00 00 00       	jmp    dfd6 <block_write+0x14b>
    df40:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    df45:	e9 8c 00 00 00       	jmp    dfd6 <block_write+0x14b>
		p = offset + bh->b_data;
    df4a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    df4e:	8b 10                	mov    (%eax),%edx
    df50:	8b 44 24 18          	mov    0x18(%esp),%eax
    df54:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
		offset = 0;
    df57:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    df5e:	00 
		*pos += chars;
    df5f:	8b 44 24 34          	mov    0x34(%esp),%eax
    df63:	8b 10                	mov    (%eax),%edx
    df65:	8b 44 24 14          	mov    0x14(%esp),%eax
    df69:	01 c2                	add    %eax,%edx
    df6b:	8b 44 24 34          	mov    0x34(%esp),%eax
    df6f:	89 10                	mov    %edx,(%eax)
		written += chars;
    df71:	8b 44 24 14          	mov    0x14(%esp),%eax
    df75:	01 44 24 10          	add    %eax,0x10(%esp)
		count -= chars;
    df79:	8b 44 24 14          	mov    0x14(%esp),%eax
    df7d:	29 44 24 3c          	sub    %eax,0x3c(%esp)
		while (chars-->0)
    df81:	eb 1e                	jmp    dfa1 <block_write+0x116>
			*(p++) = get_fs_byte(buf++);
    df83:	89 de                	mov    %ebx,%esi
    df85:	8d 5e 01             	lea    0x1(%esi),%ebx
    df88:	8b 44 24 38          	mov    0x38(%esp),%eax
    df8c:	8d 50 01             	lea    0x1(%eax),%edx
    df8f:	89 54 24 38          	mov    %edx,0x38(%esp)
    df93:	83 ec 0c             	sub    $0xc,%esp
    df96:	50                   	push   %eax
    df97:	e8 c7 fe ff ff       	call   de63 <get_fs_byte>
    df9c:	83 c4 10             	add    $0x10,%esp
    df9f:	88 06                	mov    %al,(%esi)
		p = offset + bh->b_data;
		offset = 0;
		*pos += chars;
		written += chars;
		count -= chars;
		while (chars-->0)
    dfa1:	8b 44 24 14          	mov    0x14(%esp),%eax
    dfa5:	8d 50 ff             	lea    -0x1(%eax),%edx
    dfa8:	89 54 24 14          	mov    %edx,0x14(%esp)
    dfac:	85 c0                	test   %eax,%eax
    dfae:	7f d3                	jg     df83 <block_write+0xf8>
			*(p++) = get_fs_byte(buf++);
		bh->b_dirt = 1;
    dfb0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dfb4:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		brelse(bh);
    dfb8:	83 ec 0c             	sub    $0xc,%esp
    dfbb:	ff 74 24 18          	pushl  0x18(%esp)
    dfbf:	e8 cc ef ff ff       	call   cf90 <brelse>
    dfc4:	83 c4 10             	add    $0x10,%esp
	int chars;
	int written = 0;
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
    dfc7:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    dfcc:	0f 8f e7 fe ff ff    	jg     deb9 <block_write+0x2e>
		while (chars-->0)
			*(p++) = get_fs_byte(buf++);
		bh->b_dirt = 1;
		brelse(bh);
	}
	return written;
    dfd2:	8b 44 24 10          	mov    0x10(%esp),%eax
}
    dfd6:	83 c4 24             	add    $0x24,%esp
    dfd9:	5b                   	pop    %ebx
    dfda:	5e                   	pop    %esi
    dfdb:	c3                   	ret    

0000dfdc <block_read>:

int block_read(int dev, unsigned long * pos, char * buf, int count)
{
    dfdc:	53                   	push   %ebx
    dfdd:	83 ec 28             	sub    $0x28,%esp
	int block = *pos >> BLOCK_SIZE_BITS;
    dfe0:	8b 44 24 34          	mov    0x34(%esp),%eax
    dfe4:	8b 00                	mov    (%eax),%eax
    dfe6:	c1 e8 0a             	shr    $0xa,%eax
    dfe9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	int offset = *pos & (BLOCK_SIZE-1);
    dfed:	8b 44 24 34          	mov    0x34(%esp),%eax
    dff1:	8b 00                	mov    (%eax),%eax
    dff3:	25 ff 03 00 00       	and    $0x3ff,%eax
    dff8:	89 44 24 18          	mov    %eax,0x18(%esp)
	int chars;
	int read = 0;
    dffc:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    e003:	00 
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
    e004:	e9 e8 00 00 00       	jmp    e0f1 <block_read+0x115>
		chars = BLOCK_SIZE-offset;
    e009:	b8 00 04 00 00       	mov    $0x400,%eax
    e00e:	2b 44 24 18          	sub    0x18(%esp),%eax
    e012:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (chars > count)
    e016:	8b 44 24 14          	mov    0x14(%esp),%eax
    e01a:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
    e01e:	7e 08                	jle    e028 <block_read+0x4c>
			chars = count;
    e020:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e024:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (!(bh = breada(dev,block,block+1,block+2,-1)))
    e028:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e02c:	8d 50 02             	lea    0x2(%eax),%edx
    e02f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e033:	83 c0 01             	add    $0x1,%eax
    e036:	83 ec 0c             	sub    $0xc,%esp
    e039:	6a ff                	push   $0xffffffff
    e03b:	52                   	push   %edx
    e03c:	50                   	push   %eax
    e03d:	ff 74 24 34          	pushl  0x34(%esp)
    e041:	ff 74 24 4c          	pushl  0x4c(%esp)
    e045:	e8 58 f1 ff ff       	call   d1a2 <breada>
    e04a:	83 c4 20             	add    $0x20,%esp
    e04d:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e056:	75 1a                	jne    e072 <block_read+0x96>
			return read?read:-EIO;
    e058:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    e05d:	74 09                	je     e068 <block_read+0x8c>
    e05f:	8b 44 24 10          	mov    0x10(%esp),%eax
    e063:	e9 98 00 00 00       	jmp    e100 <block_read+0x124>
    e068:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    e06d:	e9 8e 00 00 00       	jmp    e100 <block_read+0x124>
		block++;
    e072:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
		p = offset + bh->b_data;
    e077:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e07b:	8b 10                	mov    (%eax),%edx
    e07d:	8b 44 24 18          	mov    0x18(%esp),%eax
    e081:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
		offset = 0;
    e084:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    e08b:	00 
		*pos += chars;
    e08c:	8b 44 24 34          	mov    0x34(%esp),%eax
    e090:	8b 10                	mov    (%eax),%edx
    e092:	8b 44 24 14          	mov    0x14(%esp),%eax
    e096:	01 c2                	add    %eax,%edx
    e098:	8b 44 24 34          	mov    0x34(%esp),%eax
    e09c:	89 10                	mov    %edx,(%eax)
		read += chars;
    e09e:	8b 44 24 14          	mov    0x14(%esp),%eax
    e0a2:	01 44 24 10          	add    %eax,0x10(%esp)
		count -= chars;
    e0a6:	8b 44 24 14          	mov    0x14(%esp),%eax
    e0aa:	29 44 24 3c          	sub    %eax,0x3c(%esp)
		while (chars-->0)
    e0ae:	eb 23                	jmp    e0d3 <block_read+0xf7>
			put_fs_byte(*(p++),buf++);
    e0b0:	8b 44 24 38          	mov    0x38(%esp),%eax
    e0b4:	8d 50 01             	lea    0x1(%eax),%edx
    e0b7:	89 54 24 38          	mov    %edx,0x38(%esp)
    e0bb:	89 da                	mov    %ebx,%edx
    e0bd:	8d 5a 01             	lea    0x1(%edx),%ebx
    e0c0:	0f b6 12             	movzbl (%edx),%edx
    e0c3:	0f be d2             	movsbl %dl,%edx
    e0c6:	83 ec 08             	sub    $0x8,%esp
    e0c9:	50                   	push   %eax
    e0ca:	52                   	push   %edx
    e0cb:	e8 a1 fd ff ff       	call   de71 <put_fs_byte>
    e0d0:	83 c4 10             	add    $0x10,%esp
		p = offset + bh->b_data;
		offset = 0;
		*pos += chars;
		read += chars;
		count -= chars;
		while (chars-->0)
    e0d3:	8b 44 24 14          	mov    0x14(%esp),%eax
    e0d7:	8d 50 ff             	lea    -0x1(%eax),%edx
    e0da:	89 54 24 14          	mov    %edx,0x14(%esp)
    e0de:	85 c0                	test   %eax,%eax
    e0e0:	7f ce                	jg     e0b0 <block_read+0xd4>
			put_fs_byte(*(p++),buf++);
		brelse(bh);
    e0e2:	83 ec 0c             	sub    $0xc,%esp
    e0e5:	ff 74 24 18          	pushl  0x18(%esp)
    e0e9:	e8 a2 ee ff ff       	call   cf90 <brelse>
    e0ee:	83 c4 10             	add    $0x10,%esp
	int chars;
	int read = 0;
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
    e0f1:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    e0f6:	0f 8f 0d ff ff ff    	jg     e009 <block_read+0x2d>
		count -= chars;
		while (chars-->0)
			put_fs_byte(*(p++),buf++);
		brelse(bh);
	}
	return read;
    e0fc:	8b 44 24 10          	mov    0x10(%esp),%eax
}
    e100:	83 c4 28             	add    $0x28,%esp
    e103:	5b                   	pop    %ebx
    e104:	c3                   	ret    

0000e105 <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
    e105:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    e106:	8b 44 24 08          	mov    0x8(%esp),%eax
    e10a:	64 8a 00             	mov    %fs:(%eax),%al
    e10d:	89 c3                	mov    %eax,%ebx
	return _v;
    e10f:	89 d8                	mov    %ebx,%eax
}
    e111:	5b                   	pop    %ebx
    e112:	c3                   	ret    

0000e113 <put_fs_byte>:
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
	return _v;
}

static inline void put_fs_byte(char val,char *addr)
{
    e113:	83 ec 04             	sub    $0x4,%esp
    e116:	8b 44 24 08          	mov    0x8(%esp),%eax
    e11a:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    e11d:	0f b6 04 24          	movzbl (%esp),%eax
    e121:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e125:	64 88 02             	mov    %al,%fs:(%edx)
}
    e128:	90                   	nop
    e129:	83 c4 04             	add    $0x4,%esp
    e12c:	c3                   	ret    

0000e12d <rw_ttyx>:
extern int tty_write(unsigned minor,char * buf,int count);

typedef int (*crw_ptr)(int rw,unsigned minor,char * buf,int count,off_t * pos);

static int rw_ttyx(int rw,unsigned minor,char * buf,int count,off_t * pos)
{
    e12d:	83 ec 0c             	sub    $0xc,%esp
	return ((rw==READ)?tty_read(minor,buf,count):
    e130:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    e135:	75 19                	jne    e150 <rw_ttyx+0x23>
    e137:	83 ec 04             	sub    $0x4,%esp
    e13a:	ff 74 24 20          	pushl  0x20(%esp)
    e13e:	ff 74 24 20          	pushl  0x20(%esp)
    e142:	ff 74 24 20          	pushl  0x20(%esp)
    e146:	e8 a9 72 00 00       	call   153f4 <tty_read>
    e14b:	83 c4 10             	add    $0x10,%esp
    e14e:	eb 17                	jmp    e167 <rw_ttyx+0x3a>
    e150:	83 ec 04             	sub    $0x4,%esp
    e153:	ff 74 24 20          	pushl  0x20(%esp)
    e157:	ff 74 24 20          	pushl  0x20(%esp)
    e15b:	ff 74 24 20          	pushl  0x20(%esp)
    e15f:	e8 06 76 00 00       	call   1576a <tty_write>
    e164:	83 c4 10             	add    $0x10,%esp
		tty_write(minor,buf,count));
}
    e167:	83 c4 0c             	add    $0xc,%esp
    e16a:	c3                   	ret    

0000e16b <rw_tty>:

static int rw_tty(int rw,unsigned minor,char * buf,int count, off_t * pos)
{
    e16b:	83 ec 0c             	sub    $0xc,%esp
	if (current->tty<0)
    e16e:	a1 40 f1 01 00       	mov    0x1f140,%eax
    e173:	8b 80 68 02 00 00    	mov    0x268(%eax),%eax
    e179:	85 c0                	test   %eax,%eax
    e17b:	79 07                	jns    e184 <rw_tty+0x19>
		return -EPERM;
    e17d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    e182:	eb 27                	jmp    e1ab <rw_tty+0x40>
	return rw_ttyx(rw,current->tty,buf,count,pos);
    e184:	a1 40 f1 01 00       	mov    0x1f140,%eax
    e189:	8b 80 68 02 00 00    	mov    0x268(%eax),%eax
    e18f:	83 ec 0c             	sub    $0xc,%esp
    e192:	ff 74 24 2c          	pushl  0x2c(%esp)
    e196:	ff 74 24 2c          	pushl  0x2c(%esp)
    e19a:	ff 74 24 2c          	pushl  0x2c(%esp)
    e19e:	50                   	push   %eax
    e19f:	ff 74 24 2c          	pushl  0x2c(%esp)
    e1a3:	e8 85 ff ff ff       	call   e12d <rw_ttyx>
    e1a8:	83 c4 20             	add    $0x20,%esp
}
    e1ab:	83 c4 0c             	add    $0xc,%esp
    e1ae:	c3                   	ret    

0000e1af <rw_ram>:

static int rw_ram(int rw,char * buf, int count, off_t *pos)
{
	return -EIO;
    e1af:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
    e1b4:	c3                   	ret    

0000e1b5 <rw_mem>:

static int rw_mem(int rw,char * buf, int count, off_t * pos)
{
	return -EIO;
    e1b5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
    e1ba:	c3                   	ret    

0000e1bb <rw_kmem>:

static int rw_kmem(int rw,char * buf, int count, off_t * pos)
{
	return -EIO;
    e1bb:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
    e1c0:	c3                   	ret    

0000e1c1 <rw_port>:

static int rw_port(int rw,char * buf, int count, off_t * pos)
{
    e1c1:	83 ec 10             	sub    $0x10,%esp
	int i=*pos;
    e1c4:	8b 44 24 20          	mov    0x20(%esp),%eax
    e1c8:	8b 00                	mov    (%eax),%eax
    e1ca:	89 44 24 0c          	mov    %eax,0xc(%esp)

	while (count-->0 && i<65536) {
    e1ce:	eb 4f                	jmp    e21f <rw_port+0x5e>
		if (rw==READ)
    e1d0:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    e1d5:	75 2a                	jne    e201 <rw_port+0x40>
			put_fs_byte(inb(i),buf++);
    e1d7:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    e1db:	8d 41 01             	lea    0x1(%ecx),%eax
    e1de:	89 44 24 18          	mov    %eax,0x18(%esp)
    e1e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e1e6:	89 c2                	mov    %eax,%edx
    e1e8:	ec                   	in     (%dx),%al
    e1e9:	88 44 24 0b          	mov    %al,0xb(%esp)
    e1ed:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
    e1f2:	0f be c0             	movsbl %al,%eax
    e1f5:	51                   	push   %ecx
    e1f6:	50                   	push   %eax
    e1f7:	e8 17 ff ff ff       	call   e113 <put_fs_byte>
    e1fc:	83 c4 08             	add    $0x8,%esp
    e1ff:	eb 19                	jmp    e21a <rw_port+0x59>
		else
			outb(get_fs_byte(buf++),i);
    e201:	8b 44 24 18          	mov    0x18(%esp),%eax
    e205:	8d 50 01             	lea    0x1(%eax),%edx
    e208:	89 54 24 18          	mov    %edx,0x18(%esp)
    e20c:	50                   	push   %eax
    e20d:	e8 f3 fe ff ff       	call   e105 <get_fs_byte>
    e212:	83 c4 04             	add    $0x4,%esp
    e215:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e219:	ee                   	out    %al,(%dx)
		i++;
    e21a:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)

static int rw_port(int rw,char * buf, int count, off_t * pos)
{
	int i=*pos;

	while (count-->0 && i<65536) {
    e21f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e223:	8d 50 ff             	lea    -0x1(%eax),%edx
    e226:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    e22a:	85 c0                	test   %eax,%eax
    e22c:	7e 0a                	jle    e238 <rw_port+0x77>
    e22e:	81 7c 24 0c ff ff 00 	cmpl   $0xffff,0xc(%esp)
    e235:	00 
    e236:	7e 98                	jle    e1d0 <rw_port+0xf>
			put_fs_byte(inb(i),buf++);
		else
			outb(get_fs_byte(buf++),i);
		i++;
	}
	i -= *pos;
    e238:	8b 44 24 20          	mov    0x20(%esp),%eax
    e23c:	8b 00                	mov    (%eax),%eax
    e23e:	29 44 24 0c          	sub    %eax,0xc(%esp)
	*pos += i;
    e242:	8b 44 24 20          	mov    0x20(%esp),%eax
    e246:	8b 10                	mov    (%eax),%edx
    e248:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e24c:	01 c2                	add    %eax,%edx
    e24e:	8b 44 24 20          	mov    0x20(%esp),%eax
    e252:	89 10                	mov    %edx,(%eax)
	return i;
    e254:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    e258:	83 c4 10             	add    $0x10,%esp
    e25b:	c3                   	ret    

0000e25c <rw_memory>:

static int rw_memory(int rw, unsigned minor, char * buf, int count, off_t * pos)
{
	switch(minor) {
    e25c:	83 7c 24 08 04       	cmpl   $0x4,0x8(%esp)
    e261:	0f 87 8c 00 00 00    	ja     e2f3 <rw_memory+0x97>
    e267:	8b 44 24 08          	mov    0x8(%esp),%eax
    e26b:	c1 e0 02             	shl    $0x2,%eax
    e26e:	05 3c 89 01 00       	add    $0x1893c,%eax
    e273:	8b 00                	mov    (%eax),%eax
    e275:	ff e0                	jmp    *%eax
		case 0:
			return rw_ram(rw,buf,count,pos);
    e277:	ff 74 24 14          	pushl  0x14(%esp)
    e27b:	ff 74 24 14          	pushl  0x14(%esp)
    e27f:	ff 74 24 14          	pushl  0x14(%esp)
    e283:	ff 74 24 10          	pushl  0x10(%esp)
    e287:	e8 23 ff ff ff       	call   e1af <rw_ram>
    e28c:	83 c4 10             	add    $0x10,%esp
    e28f:	eb 67                	jmp    e2f8 <rw_memory+0x9c>
		case 1:
			return rw_mem(rw,buf,count,pos);
    e291:	ff 74 24 14          	pushl  0x14(%esp)
    e295:	ff 74 24 14          	pushl  0x14(%esp)
    e299:	ff 74 24 14          	pushl  0x14(%esp)
    e29d:	ff 74 24 10          	pushl  0x10(%esp)
    e2a1:	e8 0f ff ff ff       	call   e1b5 <rw_mem>
    e2a6:	83 c4 10             	add    $0x10,%esp
    e2a9:	eb 4d                	jmp    e2f8 <rw_memory+0x9c>
		case 2:
			return rw_kmem(rw,buf,count,pos);
    e2ab:	ff 74 24 14          	pushl  0x14(%esp)
    e2af:	ff 74 24 14          	pushl  0x14(%esp)
    e2b3:	ff 74 24 14          	pushl  0x14(%esp)
    e2b7:	ff 74 24 10          	pushl  0x10(%esp)
    e2bb:	e8 fb fe ff ff       	call   e1bb <rw_kmem>
    e2c0:	83 c4 10             	add    $0x10,%esp
    e2c3:	eb 33                	jmp    e2f8 <rw_memory+0x9c>
		case 3:
			return (rw==READ)?0:count;	/* rw_null */
    e2c5:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    e2ca:	74 06                	je     e2d2 <rw_memory+0x76>
    e2cc:	8b 44 24 10          	mov    0x10(%esp),%eax
    e2d0:	eb 26                	jmp    e2f8 <rw_memory+0x9c>
    e2d2:	b8 00 00 00 00       	mov    $0x0,%eax
    e2d7:	eb 1f                	jmp    e2f8 <rw_memory+0x9c>
		case 4:
			return rw_port(rw,buf,count,pos);
    e2d9:	ff 74 24 14          	pushl  0x14(%esp)
    e2dd:	ff 74 24 14          	pushl  0x14(%esp)
    e2e1:	ff 74 24 14          	pushl  0x14(%esp)
    e2e5:	ff 74 24 10          	pushl  0x10(%esp)
    e2e9:	e8 d3 fe ff ff       	call   e1c1 <rw_port>
    e2ee:	83 c4 10             	add    $0x10,%esp
    e2f1:	eb 05                	jmp    e2f8 <rw_memory+0x9c>
		default:
			return -EIO;
    e2f3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}
}
    e2f8:	c3                   	ret    

0000e2f9 <rw_char>:
	rw_tty,		/* /dev/tty */
	NULL,		/* /dev/lp */
	NULL};		/* unnamed pipes */

int rw_char(int rw,int dev, char * buf, int count, off_t * pos)
{
    e2f9:	83 ec 1c             	sub    $0x1c,%esp
	crw_ptr call_addr;

	if (MAJOR(dev)>=NRDEVS)
    e2fc:	8b 44 24 24          	mov    0x24(%esp),%eax
    e300:	c1 e8 08             	shr    $0x8,%eax
    e303:	83 f8 07             	cmp    $0x7,%eax
    e306:	76 07                	jbe    e30f <rw_char+0x16>
		return -ENODEV;
    e308:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    e30d:	eb 44                	jmp    e353 <rw_char+0x5a>
	if (!(call_addr=crw_table[MAJOR(dev)]))
    e30f:	8b 44 24 24          	mov    0x24(%esp),%eax
    e313:	c1 e8 08             	shr    $0x8,%eax
    e316:	8b 04 85 20 f3 01 00 	mov    0x1f320(,%eax,4),%eax
    e31d:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e321:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e326:	75 07                	jne    e32f <rw_char+0x36>
		return -ENODEV;
    e328:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    e32d:	eb 24                	jmp    e353 <rw_char+0x5a>
	return call_addr(rw,MINOR(dev),buf,count,pos);
    e32f:	8b 44 24 24          	mov    0x24(%esp),%eax
    e333:	0f b6 c0             	movzbl %al,%eax
    e336:	83 ec 0c             	sub    $0xc,%esp
    e339:	ff 74 24 3c          	pushl  0x3c(%esp)
    e33d:	ff 74 24 3c          	pushl  0x3c(%esp)
    e341:	ff 74 24 3c          	pushl  0x3c(%esp)
    e345:	50                   	push   %eax
    e346:	ff 74 24 3c          	pushl  0x3c(%esp)
    e34a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e34e:	ff d0                	call   *%eax
    e350:	83 c4 20             	add    $0x20,%esp
}
    e353:	83 c4 1c             	add    $0x1c,%esp
    e356:	c3                   	ret    

0000e357 <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
    e357:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    e358:	8b 44 24 08          	mov    0x8(%esp),%eax
    e35c:	64 8a 00             	mov    %fs:(%eax),%al
    e35f:	89 c3                	mov    %eax,%ebx
	return _v;
    e361:	89 d8                	mov    %ebx,%eax
}
    e363:	5b                   	pop    %ebx
    e364:	c3                   	ret    

0000e365 <put_fs_byte>:
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
	return _v;
}

static inline void put_fs_byte(char val,char *addr)
{
    e365:	83 ec 04             	sub    $0x4,%esp
    e368:	8b 44 24 08          	mov    0x8(%esp),%eax
    e36c:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    e36f:	0f b6 04 24          	movzbl (%esp),%eax
    e373:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e377:	64 88 02             	mov    %al,%fs:(%edx)
}
    e37a:	90                   	nop
    e37b:	83 c4 04             	add    $0x4,%esp
    e37e:	c3                   	ret    

0000e37f <file_read>:

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))

int file_read(struct m_inode * inode, struct file * filp, char * buf, int count)
{
    e37f:	83 ec 2c             	sub    $0x2c,%esp
	int left,chars,nr;
	struct buffer_head * bh;

	if ((left=count)<=0)
    e382:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e386:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    e38a:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    e38f:	0f 8f 43 01 00 00    	jg     e4d8 <file_read+0x159>
		return 0;
    e395:	b8 00 00 00 00       	mov    $0x0,%eax
    e39a:	e9 87 01 00 00       	jmp    e526 <file_read+0x1a7>
	while (left) {
		if ((nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE))) {
    e39f:	8b 44 24 34          	mov    0x34(%esp),%eax
    e3a3:	8b 40 0c             	mov    0xc(%eax),%eax
    e3a6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
    e3ac:	85 c0                	test   %eax,%eax
    e3ae:	0f 48 c2             	cmovs  %edx,%eax
    e3b1:	c1 f8 0a             	sar    $0xa,%eax
    e3b4:	83 ec 08             	sub    $0x8,%esp
    e3b7:	50                   	push   %eax
    e3b8:	ff 74 24 3c          	pushl  0x3c(%esp)
    e3bc:	e8 78 dc ff ff       	call   c039 <bmap>
    e3c1:	83 c4 10             	add    $0x10,%esp
    e3c4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e3c8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e3cd:	74 2b                	je     e3fa <file_read+0x7b>
			if (!(bh=bread(inode->i_dev,nr)))
    e3cf:	8b 44 24 30          	mov    0x30(%esp),%eax
    e3d3:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    e3d7:	0f b7 c0             	movzwl %ax,%eax
    e3da:	83 ec 08             	sub    $0x8,%esp
    e3dd:	ff 74 24 14          	pushl  0x14(%esp)
    e3e1:	50                   	push   %eax
    e3e2:	e8 ff eb ff ff       	call   cfe6 <bread>
    e3e7:	83 c4 10             	add    $0x10,%esp
    e3ea:	89 44 24 14          	mov    %eax,0x14(%esp)
    e3ee:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    e3f3:	75 0d                	jne    e402 <file_read+0x83>
				break;
    e3f5:	e9 e9 00 00 00       	jmp    e4e3 <file_read+0x164>
		} else
			bh = NULL;
    e3fa:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    e401:	00 
		nr = filp->f_pos % BLOCK_SIZE;
    e402:	8b 44 24 34          	mov    0x34(%esp),%eax
    e406:	8b 40 0c             	mov    0xc(%eax),%eax
    e409:	99                   	cltd   
    e40a:	c1 ea 16             	shr    $0x16,%edx
    e40d:	01 d0                	add    %edx,%eax
    e40f:	25 ff 03 00 00       	and    $0x3ff,%eax
    e414:	29 d0                	sub    %edx,%eax
    e416:	89 44 24 0c          	mov    %eax,0xc(%esp)
		chars = MIN( BLOCK_SIZE-nr , left );
    e41a:	b8 00 04 00 00       	mov    $0x400,%eax
    e41f:	2b 44 24 0c          	sub    0xc(%esp),%eax
    e423:	89 c2                	mov    %eax,%edx
    e425:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e429:	39 c2                	cmp    %eax,%edx
    e42b:	0f 4e c2             	cmovle %edx,%eax
    e42e:	89 44 24 18          	mov    %eax,0x18(%esp)
		filp->f_pos += chars;
    e432:	8b 44 24 34          	mov    0x34(%esp),%eax
    e436:	8b 50 0c             	mov    0xc(%eax),%edx
    e439:	8b 44 24 18          	mov    0x18(%esp),%eax
    e43d:	01 c2                	add    %eax,%edx
    e43f:	8b 44 24 34          	mov    0x34(%esp),%eax
    e443:	89 50 0c             	mov    %edx,0xc(%eax)
		left -= chars;
    e446:	8b 44 24 18          	mov    0x18(%esp),%eax
    e44a:	29 44 24 1c          	sub    %eax,0x1c(%esp)
		if (bh) {
    e44e:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    e453:	74 74                	je     e4c9 <file_read+0x14a>
			char * p = nr + bh->b_data;
    e455:	8b 44 24 14          	mov    0x14(%esp),%eax
    e459:	8b 10                	mov    (%eax),%edx
    e45b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e45f:	01 d0                	add    %edx,%eax
    e461:	89 44 24 10          	mov    %eax,0x10(%esp)
			while (chars-->0)
    e465:	eb 29                	jmp    e490 <file_read+0x111>
				put_fs_byte(*(p++),buf++);
    e467:	8b 44 24 38          	mov    0x38(%esp),%eax
    e46b:	8d 50 01             	lea    0x1(%eax),%edx
    e46e:	89 54 24 38          	mov    %edx,0x38(%esp)
    e472:	8b 54 24 10          	mov    0x10(%esp),%edx
    e476:	8d 4a 01             	lea    0x1(%edx),%ecx
    e479:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    e47d:	0f b6 12             	movzbl (%edx),%edx
    e480:	0f be d2             	movsbl %dl,%edx
    e483:	83 ec 08             	sub    $0x8,%esp
    e486:	50                   	push   %eax
    e487:	52                   	push   %edx
    e488:	e8 d8 fe ff ff       	call   e365 <put_fs_byte>
    e48d:	83 c4 10             	add    $0x10,%esp
		chars = MIN( BLOCK_SIZE-nr , left );
		filp->f_pos += chars;
		left -= chars;
		if (bh) {
			char * p = nr + bh->b_data;
			while (chars-->0)
    e490:	8b 44 24 18          	mov    0x18(%esp),%eax
    e494:	8d 50 ff             	lea    -0x1(%eax),%edx
    e497:	89 54 24 18          	mov    %edx,0x18(%esp)
    e49b:	85 c0                	test   %eax,%eax
    e49d:	7f c8                	jg     e467 <file_read+0xe8>
				put_fs_byte(*(p++),buf++);
			brelse(bh);
    e49f:	83 ec 0c             	sub    $0xc,%esp
    e4a2:	ff 74 24 20          	pushl  0x20(%esp)
    e4a6:	e8 e5 ea ff ff       	call   cf90 <brelse>
    e4ab:	83 c4 10             	add    $0x10,%esp
    e4ae:	eb 28                	jmp    e4d8 <file_read+0x159>
		} else {
			while (chars-->0)
				put_fs_byte(0,buf++);
    e4b0:	8b 44 24 38          	mov    0x38(%esp),%eax
    e4b4:	8d 50 01             	lea    0x1(%eax),%edx
    e4b7:	89 54 24 38          	mov    %edx,0x38(%esp)
    e4bb:	83 ec 08             	sub    $0x8,%esp
    e4be:	50                   	push   %eax
    e4bf:	6a 00                	push   $0x0
    e4c1:	e8 9f fe ff ff       	call   e365 <put_fs_byte>
    e4c6:	83 c4 10             	add    $0x10,%esp
			char * p = nr + bh->b_data;
			while (chars-->0)
				put_fs_byte(*(p++),buf++);
			brelse(bh);
		} else {
			while (chars-->0)
    e4c9:	8b 44 24 18          	mov    0x18(%esp),%eax
    e4cd:	8d 50 ff             	lea    -0x1(%eax),%edx
    e4d0:	89 54 24 18          	mov    %edx,0x18(%esp)
    e4d4:	85 c0                	test   %eax,%eax
    e4d6:	7f d8                	jg     e4b0 <file_read+0x131>
	int left,chars,nr;
	struct buffer_head * bh;

	if ((left=count)<=0)
		return 0;
	while (left) {
    e4d8:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    e4dd:	0f 85 bc fe ff ff    	jne    e39f <file_read+0x20>
		} else {
			while (chars-->0)
				put_fs_byte(0,buf++);
		}
	}
	inode->i_atime = CURRENT_TIME;
    e4e3:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    e4e9:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    e4ee:	89 c8                	mov    %ecx,%eax
    e4f0:	f7 ea                	imul   %edx
    e4f2:	c1 fa 05             	sar    $0x5,%edx
    e4f5:	89 c8                	mov    %ecx,%eax
    e4f7:	c1 f8 1f             	sar    $0x1f,%eax
    e4fa:	29 c2                	sub    %eax,%edx
    e4fc:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
    e501:	01 d0                	add    %edx,%eax
    e503:	89 c2                	mov    %eax,%edx
    e505:	8b 44 24 30          	mov    0x30(%esp),%eax
    e509:	89 50 24             	mov    %edx,0x24(%eax)
	return (count-left)?(count-left):-ERROR;
    e50c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e510:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
    e514:	74 0a                	je     e520 <file_read+0x1a1>
    e516:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e51a:	2b 44 24 1c          	sub    0x1c(%esp),%eax
    e51e:	eb 05                	jmp    e525 <file_read+0x1a6>
    e520:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
    e525:	90                   	nop
}
    e526:	83 c4 2c             	add    $0x2c,%esp
    e529:	c3                   	ret    

0000e52a <file_write>:

int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
    e52a:	53                   	push   %ebx
    e52b:	83 ec 28             	sub    $0x28,%esp
	off_t pos;
	int block,c;
	struct buffer_head * bh;
	char * p;
	int i=0;
    e52e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    e535:	00 

/*
 * ok, append may not work when many processes are writing at the same time
 * but so what. That way leads to madness anyway.
 */
	if (filp->f_flags & O_APPEND)
    e536:	8b 44 24 34          	mov    0x34(%esp),%eax
    e53a:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    e53e:	0f b7 c0             	movzwl %ax,%eax
    e541:	25 00 04 00 00       	and    $0x400,%eax
    e546:	85 c0                	test   %eax,%eax
    e548:	74 10                	je     e55a <file_write+0x30>
		pos = inode->i_size;
    e54a:	8b 44 24 30          	mov    0x30(%esp),%eax
    e54e:	8b 40 04             	mov    0x4(%eax),%eax
    e551:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    e555:	e9 35 01 00 00       	jmp    e68f <file_write+0x165>
	else
		pos = filp->f_pos;
    e55a:	8b 44 24 34          	mov    0x34(%esp),%eax
    e55e:	8b 40 0c             	mov    0xc(%eax),%eax
    e561:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	while (i<count) {
    e565:	e9 25 01 00 00       	jmp    e68f <file_write+0x165>
		if (!(block = create_block(inode,pos/BLOCK_SIZE)))
    e56a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e56e:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
    e574:	85 c0                	test   %eax,%eax
    e576:	0f 48 c2             	cmovs  %edx,%eax
    e579:	c1 f8 0a             	sar    $0xa,%eax
    e57c:	83 ec 08             	sub    $0x8,%esp
    e57f:	50                   	push   %eax
    e580:	ff 74 24 3c          	pushl  0x3c(%esp)
    e584:	e8 cc da ff ff       	call   c055 <create_block>
    e589:	83 c4 10             	add    $0x10,%esp
    e58c:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e590:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e595:	0f 84 04 01 00 00    	je     e69f <file_write+0x175>
			break;
		if (!(bh=bread(inode->i_dev,block)))
    e59b:	8b 44 24 30          	mov    0x30(%esp),%eax
    e59f:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    e5a3:	0f b7 c0             	movzwl %ax,%eax
    e5a6:	83 ec 08             	sub    $0x8,%esp
    e5a9:	ff 74 24 14          	pushl  0x14(%esp)
    e5ad:	50                   	push   %eax
    e5ae:	e8 33 ea ff ff       	call   cfe6 <bread>
    e5b3:	83 c4 10             	add    $0x10,%esp
    e5b6:	89 44 24 08          	mov    %eax,0x8(%esp)
    e5ba:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    e5bf:	0f 84 dd 00 00 00    	je     e6a2 <file_write+0x178>
			break;
		c = pos % BLOCK_SIZE;
    e5c5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e5c9:	99                   	cltd   
    e5ca:	c1 ea 16             	shr    $0x16,%edx
    e5cd:	01 d0                	add    %edx,%eax
    e5cf:	25 ff 03 00 00       	and    $0x3ff,%eax
    e5d4:	29 d0                	sub    %edx,%eax
    e5d6:	89 44 24 18          	mov    %eax,0x18(%esp)
		p = c + bh->b_data;
    e5da:	8b 44 24 08          	mov    0x8(%esp),%eax
    e5de:	8b 10                	mov    (%eax),%edx
    e5e0:	8b 44 24 18          	mov    0x18(%esp),%eax
    e5e4:	01 d0                	add    %edx,%eax
    e5e6:	89 44 24 14          	mov    %eax,0x14(%esp)
		bh->b_dirt = 1;
    e5ea:	8b 44 24 08          	mov    0x8(%esp),%eax
    e5ee:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		c = BLOCK_SIZE-c;
    e5f2:	b8 00 04 00 00       	mov    $0x400,%eax
    e5f7:	2b 44 24 18          	sub    0x18(%esp),%eax
    e5fb:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (c > count-i) c = count-i;
    e5ff:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e603:	2b 44 24 10          	sub    0x10(%esp),%eax
    e607:	3b 44 24 18          	cmp    0x18(%esp),%eax
    e60b:	7d 0c                	jge    e619 <file_write+0xef>
    e60d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e611:	2b 44 24 10          	sub    0x10(%esp),%eax
    e615:	89 44 24 18          	mov    %eax,0x18(%esp)
		pos += c;
    e619:	8b 44 24 18          	mov    0x18(%esp),%eax
    e61d:	01 44 24 1c          	add    %eax,0x1c(%esp)
		if (pos > inode->i_size) {
    e621:	8b 44 24 30          	mov    0x30(%esp),%eax
    e625:	8b 50 04             	mov    0x4(%eax),%edx
    e628:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e62c:	39 c2                	cmp    %eax,%edx
    e62e:	73 13                	jae    e643 <file_write+0x119>
			inode->i_size = pos;
    e630:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    e634:	8b 44 24 30          	mov    0x30(%esp),%eax
    e638:	89 50 04             	mov    %edx,0x4(%eax)
			inode->i_dirt = 1;
    e63b:	8b 44 24 30          	mov    0x30(%esp),%eax
    e63f:	c6 40 33 01          	movb   $0x1,0x33(%eax)
		}
		i += c;
    e643:	8b 44 24 18          	mov    0x18(%esp),%eax
    e647:	01 44 24 10          	add    %eax,0x10(%esp)
		while (c-->0)
    e64b:	eb 24                	jmp    e671 <file_write+0x147>
			*(p++) = get_fs_byte(buf++);
    e64d:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    e651:	8d 43 01             	lea    0x1(%ebx),%eax
    e654:	89 44 24 14          	mov    %eax,0x14(%esp)
    e658:	8b 44 24 38          	mov    0x38(%esp),%eax
    e65c:	8d 50 01             	lea    0x1(%eax),%edx
    e65f:	89 54 24 38          	mov    %edx,0x38(%esp)
    e663:	83 ec 0c             	sub    $0xc,%esp
    e666:	50                   	push   %eax
    e667:	e8 eb fc ff ff       	call   e357 <get_fs_byte>
    e66c:	83 c4 10             	add    $0x10,%esp
    e66f:	88 03                	mov    %al,(%ebx)
		if (pos > inode->i_size) {
			inode->i_size = pos;
			inode->i_dirt = 1;
		}
		i += c;
		while (c-->0)
    e671:	8b 44 24 18          	mov    0x18(%esp),%eax
    e675:	8d 50 ff             	lea    -0x1(%eax),%edx
    e678:	89 54 24 18          	mov    %edx,0x18(%esp)
    e67c:	85 c0                	test   %eax,%eax
    e67e:	7f cd                	jg     e64d <file_write+0x123>
			*(p++) = get_fs_byte(buf++);
		brelse(bh);
    e680:	83 ec 0c             	sub    $0xc,%esp
    e683:	ff 74 24 14          	pushl  0x14(%esp)
    e687:	e8 04 e9 ff ff       	call   cf90 <brelse>
    e68c:	83 c4 10             	add    $0x10,%esp
 */
	if (filp->f_flags & O_APPEND)
		pos = inode->i_size;
	else
		pos = filp->f_pos;
	while (i<count) {
    e68f:	8b 44 24 10          	mov    0x10(%esp),%eax
    e693:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
    e697:	0f 8c cd fe ff ff    	jl     e56a <file_write+0x40>
    e69d:	eb 04                	jmp    e6a3 <file_write+0x179>
		if (!(block = create_block(inode,pos/BLOCK_SIZE)))
			break;
    e69f:	90                   	nop
    e6a0:	eb 01                	jmp    e6a3 <file_write+0x179>
		if (!(bh=bread(inode->i_dev,block)))
			break;
    e6a2:	90                   	nop
		i += c;
		while (c-->0)
			*(p++) = get_fs_byte(buf++);
		brelse(bh);
	}
	inode->i_mtime = CURRENT_TIME;
    e6a3:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    e6a9:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    e6ae:	89 c8                	mov    %ecx,%eax
    e6b0:	f7 ea                	imul   %edx
    e6b2:	c1 fa 05             	sar    $0x5,%edx
    e6b5:	89 c8                	mov    %ecx,%eax
    e6b7:	c1 f8 1f             	sar    $0x1f,%eax
    e6ba:	29 c2                	sub    %eax,%edx
    e6bc:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
    e6c1:	01 d0                	add    %edx,%eax
    e6c3:	89 c2                	mov    %eax,%edx
    e6c5:	8b 44 24 30          	mov    0x30(%esp),%eax
    e6c9:	89 50 08             	mov    %edx,0x8(%eax)
	if (!(filp->f_flags & O_APPEND)) {
    e6cc:	8b 44 24 34          	mov    0x34(%esp),%eax
    e6d0:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    e6d4:	0f b7 c0             	movzwl %ax,%eax
    e6d7:	25 00 04 00 00       	and    $0x400,%eax
    e6dc:	85 c0                	test   %eax,%eax
    e6de:	75 34                	jne    e714 <file_write+0x1ea>
		filp->f_pos = pos;
    e6e0:	8b 44 24 34          	mov    0x34(%esp),%eax
    e6e4:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    e6e8:	89 50 0c             	mov    %edx,0xc(%eax)
		inode->i_ctime = CURRENT_TIME;
    e6eb:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
    e6f1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    e6f6:	89 c8                	mov    %ecx,%eax
    e6f8:	f7 ea                	imul   %edx
    e6fa:	c1 fa 05             	sar    $0x5,%edx
    e6fd:	89 c8                	mov    %ecx,%eax
    e6ff:	c1 f8 1f             	sar    $0x1f,%eax
    e702:	29 c2                	sub    %eax,%edx
    e704:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
    e709:	01 d0                	add    %edx,%eax
    e70b:	89 c2                	mov    %eax,%edx
    e70d:	8b 44 24 30          	mov    0x30(%esp),%eax
    e711:	89 50 28             	mov    %edx,0x28(%eax)
	}
	return (i?i:-1);
    e714:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    e719:	74 06                	je     e721 <file_write+0x1f7>
    e71b:	8b 44 24 10          	mov    0x10(%esp),%eax
    e71f:	eb 05                	jmp    e726 <file_write+0x1fc>
    e721:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    e726:	83 c4 28             	add    $0x28,%esp
    e729:	5b                   	pop    %ebx
    e72a:	c3                   	ret    

0000e72b <put_fs_byte>:
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
	return _v;
}

static inline void put_fs_byte(char val,char *addr)
{
    e72b:	83 ec 04             	sub    $0x4,%esp
    e72e:	8b 44 24 08          	mov    0x8(%esp),%eax
    e732:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    e735:	0f b6 04 24          	movzbl (%esp),%eax
    e739:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e73d:	64 88 02             	mov    %al,%fs:(%edx)
}
    e740:	90                   	nop
    e741:	83 c4 04             	add    $0x4,%esp
    e744:	c3                   	ret    

0000e745 <cp_stat>:
#include <linux/sched.h>
#include <linux/kernel.h>
#include <asm/segment.h>

static void cp_stat(struct m_inode * inode, struct stat * statbuf)
{
    e745:	83 ec 3c             	sub    $0x3c,%esp
	struct stat tmp;
	int i;

	verify_area(statbuf,sizeof (* statbuf));
    e748:	83 ec 08             	sub    $0x8,%esp
    e74b:	6a 20                	push   $0x20
    e74d:	ff 74 24 50          	pushl  0x50(%esp)
    e751:	e8 4e 99 ff ff       	call   80a4 <verify_area>
    e756:	83 c4 10             	add    $0x10,%esp
	tmp.st_dev = inode->i_dev;
    e759:	8b 44 24 40          	mov    0x40(%esp),%eax
    e75d:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    e761:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	tmp.st_ino = inode->i_num;
    e766:	8b 44 24 40          	mov    0x40(%esp),%eax
    e76a:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    e76e:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	tmp.st_mode = inode->i_mode;
    e773:	8b 44 24 40          	mov    0x40(%esp),%eax
    e777:	0f b7 00             	movzwl (%eax),%eax
    e77a:	66 89 44 24 10       	mov    %ax,0x10(%esp)
	tmp.st_nlink = inode->i_nlinks;
    e77f:	8b 44 24 40          	mov    0x40(%esp),%eax
    e783:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    e787:	88 44 24 12          	mov    %al,0x12(%esp)
	tmp.st_uid = inode->i_uid;
    e78b:	8b 44 24 40          	mov    0x40(%esp),%eax
    e78f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    e793:	66 89 44 24 14       	mov    %ax,0x14(%esp)
	tmp.st_gid = inode->i_gid;
    e798:	8b 44 24 40          	mov    0x40(%esp),%eax
    e79c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    e7a0:	88 44 24 16          	mov    %al,0x16(%esp)
	tmp.st_rdev = inode->i_zone[0];
    e7a4:	8b 44 24 40          	mov    0x40(%esp),%eax
    e7a8:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    e7ac:	66 89 44 24 18       	mov    %ax,0x18(%esp)
	tmp.st_size = inode->i_size;
    e7b1:	8b 44 24 40          	mov    0x40(%esp),%eax
    e7b5:	8b 40 04             	mov    0x4(%eax),%eax
    e7b8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	tmp.st_atime = inode->i_atime;
    e7bc:	8b 44 24 40          	mov    0x40(%esp),%eax
    e7c0:	8b 40 24             	mov    0x24(%eax),%eax
    e7c3:	89 44 24 20          	mov    %eax,0x20(%esp)
	tmp.st_mtime = inode->i_mtime;
    e7c7:	8b 44 24 40          	mov    0x40(%esp),%eax
    e7cb:	8b 40 08             	mov    0x8(%eax),%eax
    e7ce:	89 44 24 24          	mov    %eax,0x24(%esp)
	tmp.st_ctime = inode->i_ctime;
    e7d2:	8b 44 24 40          	mov    0x40(%esp),%eax
    e7d6:	8b 40 28             	mov    0x28(%eax),%eax
    e7d9:	89 44 24 28          	mov    %eax,0x28(%esp)
	for (i=0 ; i<sizeof (tmp) ; i++)
    e7dd:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
    e7e4:	00 
    e7e5:	eb 2c                	jmp    e813 <cp_stat+0xce>
		put_fs_byte(((char *) &tmp)[i],&((char *) statbuf)[i]);
    e7e7:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    e7eb:	8b 44 24 44          	mov    0x44(%esp),%eax
    e7ef:	01 c2                	add    %eax,%edx
    e7f1:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e7f5:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
    e7f9:	01 c8                	add    %ecx,%eax
    e7fb:	0f b6 00             	movzbl (%eax),%eax
    e7fe:	0f be c0             	movsbl %al,%eax
    e801:	83 ec 08             	sub    $0x8,%esp
    e804:	52                   	push   %edx
    e805:	50                   	push   %eax
    e806:	e8 20 ff ff ff       	call   e72b <put_fs_byte>
    e80b:	83 c4 10             	add    $0x10,%esp
	tmp.st_rdev = inode->i_zone[0];
	tmp.st_size = inode->i_size;
	tmp.st_atime = inode->i_atime;
	tmp.st_mtime = inode->i_mtime;
	tmp.st_ctime = inode->i_ctime;
	for (i=0 ; i<sizeof (tmp) ; i++)
    e80e:	83 44 24 2c 01       	addl   $0x1,0x2c(%esp)
    e813:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e817:	83 f8 1f             	cmp    $0x1f,%eax
    e81a:	76 cb                	jbe    e7e7 <cp_stat+0xa2>
		put_fs_byte(((char *) &tmp)[i],&((char *) statbuf)[i]);
}
    e81c:	90                   	nop
    e81d:	83 c4 3c             	add    $0x3c,%esp
    e820:	c3                   	ret    

0000e821 <sys_stat>:

int sys_stat(char * filename, struct stat * statbuf)
{
    e821:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;

	if (!(inode=namei(filename)))
    e824:	83 ec 0c             	sub    $0xc,%esp
    e827:	ff 74 24 2c          	pushl  0x2c(%esp)
    e82b:	e8 e8 1e 00 00       	call   10718 <namei>
    e830:	83 c4 10             	add    $0x10,%esp
    e833:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e837:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e83c:	75 07                	jne    e845 <sys_stat+0x24>
		return -ENOENT;
    e83e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    e843:	eb 27                	jmp    e86c <sys_stat+0x4b>
	cp_stat(inode,statbuf);
    e845:	83 ec 08             	sub    $0x8,%esp
    e848:	ff 74 24 2c          	pushl  0x2c(%esp)
    e84c:	ff 74 24 18          	pushl  0x18(%esp)
    e850:	e8 f0 fe ff ff       	call   e745 <cp_stat>
    e855:	83 c4 10             	add    $0x10,%esp
	iput(inode);
    e858:	83 ec 0c             	sub    $0xc,%esp
    e85b:	ff 74 24 18          	pushl  0x18(%esp)
    e85f:	e8 0d d8 ff ff       	call   c071 <iput>
    e864:	83 c4 10             	add    $0x10,%esp
	return 0;
    e867:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e86c:	83 c4 1c             	add    $0x1c,%esp
    e86f:	c3                   	ret    

0000e870 <sys_fstat>:

int sys_fstat(unsigned int fd, struct stat * statbuf)
{
    e870:	83 ec 1c             	sub    $0x1c,%esp
	struct file * f;
	struct m_inode * inode;

	if (fd >= NR_OPEN || !(f=current->filp[fd]) || !(inode=f->f_inode))
    e873:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    e878:	77 2f                	ja     e8a9 <sys_fstat+0x39>
    e87a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    e87f:	8b 54 24 20          	mov    0x20(%esp),%edx
    e883:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    e889:	8b 04 90             	mov    (%eax,%edx,4),%eax
    e88c:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e890:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    e895:	74 12                	je     e8a9 <sys_fstat+0x39>
    e897:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e89b:	8b 40 08             	mov    0x8(%eax),%eax
    e89e:	89 44 24 08          	mov    %eax,0x8(%esp)
    e8a2:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    e8a7:	75 07                	jne    e8b0 <sys_fstat+0x40>
		return -EBADF;
    e8a9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    e8ae:	eb 18                	jmp    e8c8 <sys_fstat+0x58>
	cp_stat(inode,statbuf);
    e8b0:	83 ec 08             	sub    $0x8,%esp
    e8b3:	ff 74 24 2c          	pushl  0x2c(%esp)
    e8b7:	ff 74 24 14          	pushl  0x14(%esp)
    e8bb:	e8 85 fe ff ff       	call   e745 <cp_stat>
    e8c0:	83 c4 10             	add    $0x10,%esp
	return 0;
    e8c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e8c8:	83 c4 1c             	add    $0x1c,%esp
    e8cb:	c3                   	ret    

0000e8cc <strncpy>:
	::"S" (src),"D" (dest));
return dest;
}

static inline char * strncpy(char * dest,const char *src,int count)
{
    e8cc:	57                   	push   %edi
    e8cd:	56                   	push   %esi
__asm__("cld\n"
    e8ce:	8b 44 24 10          	mov    0x10(%esp),%eax
    e8d2:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e8d6:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    e8da:	89 c6                	mov    %eax,%esi
    e8dc:	89 d7                	mov    %edx,%edi
    e8de:	fc                   	cld    
    e8df:	49                   	dec    %ecx
    e8e0:	78 08                	js     e8ea <strncpy+0x1e>
    e8e2:	ac                   	lods   %ds:(%esi),%al
    e8e3:	aa                   	stos   %al,%es:(%edi)
    e8e4:	84 c0                	test   %al,%al
    e8e6:	75 f7                	jne    e8df <strncpy+0x13>
    e8e8:	f3 aa                	rep stos %al,%es:(%edi)
	"jne 1b\n\t"
	"rep\n\t"
	"stosb\n"
	"2:"
	::"S" (src),"D" (dest),"c" (count));
return dest;
    e8ea:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    e8ee:	5e                   	pop    %esi
    e8ef:	5f                   	pop    %edi
    e8f0:	c3                   	ret    

0000e8f1 <strchr>:
	:"=a" (__res):"D" (cs),"S" (ct),"c" (count));
return __res;
}

static inline char * strchr(const char * s,char c)
{
    e8f1:	56                   	push   %esi
    e8f2:	53                   	push   %ebx
    e8f3:	83 ec 04             	sub    $0x4,%esp
    e8f6:	8b 44 24 14          	mov    0x14(%esp),%eax
    e8fa:	88 04 24             	mov    %al,(%esp)
register char * __res ;
__asm__("cld\n\t"
    e8fd:	8b 54 24 10          	mov    0x10(%esp),%edx
    e901:	0f b6 04 24          	movzbl (%esp),%eax
    e905:	89 d6                	mov    %edx,%esi
    e907:	fc                   	cld    
    e908:	88 c4                	mov    %al,%ah
    e90a:	ac                   	lods   %ds:(%esi),%al
    e90b:	38 e0                	cmp    %ah,%al
    e90d:	74 09                	je     e918 <strchr+0x27>
    e90f:	84 c0                	test   %al,%al
    e911:	75 f7                	jne    e90a <strchr+0x19>
    e913:	be 01 00 00 00       	mov    $0x1,%esi
    e918:	89 f0                	mov    %esi,%eax
    e91a:	48                   	dec    %eax
    e91b:	89 c3                	mov    %eax,%ebx
	"jne 1b\n\t"
	"movl $1,%1\n"
	"2:\tmovl %1,%0\n\t"
	"decl %0"
	:"=a" (__res):"S" (s),"0" (c));
return __res;
    e91d:	89 d8                	mov    %ebx,%eax
}
    e91f:	83 c4 04             	add    $0x4,%esp
    e922:	5b                   	pop    %ebx
    e923:	5e                   	pop    %esi
    e924:	c3                   	ret    

0000e925 <_get_base>:
        :"memory"); \
__base;})
**/

static inline unsigned long _get_base(char * addr)
{
    e925:	53                   	push   %ebx
    e926:	83 ec 10             	sub    $0x10,%esp
         __asm__("movb %3,%%dh\n\t"
                 "movb %2,%%dl\n\t"
                 "shll $16,%%edx\n\t"
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
    e929:	8b 44 24 18          	mov    0x18(%esp),%eax
    e92d:	83 c0 02             	add    $0x2,%eax
                  "m" (*((addr)+4)),
    e930:	8b 54 24 18          	mov    0x18(%esp),%edx
    e934:	8d 5a 04             	lea    0x4(%edx),%ebx
                  "m" (*((addr)+7)));
    e937:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    e93b:	83 c1 07             	add    $0x7,%ecx
**/

static inline unsigned long _get_base(char * addr)
{
         unsigned long __base;
         __asm__("movb %3,%%dh\n\t"
    e93e:	8a 31                	mov    (%ecx),%dh
    e940:	8a 13                	mov    (%ebx),%dl
    e942:	c1 e2 10             	shl    $0x10,%edx
    e945:	66 8b 10             	mov    (%eax),%dx
    e948:	89 d0                	mov    %edx,%eax
    e94a:	89 44 24 0c          	mov    %eax,0xc(%esp)
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
                  "m" (*((addr)+4)),
                  "m" (*((addr)+7)));
         return __base;
    e94e:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    e952:	83 c4 10             	add    $0x10,%esp
    e955:	5b                   	pop    %ebx
    e956:	c3                   	ret    

0000e957 <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
    e957:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    e958:	8b 44 24 08          	mov    0x8(%esp),%eax
    e95c:	64 8a 00             	mov    %fs:(%eax),%al
    e95f:	89 c3                	mov    %eax,%ebx
	return _v;
    e961:	89 d8                	mov    %ebx,%eax
}
    e963:	5b                   	pop    %ebx
    e964:	c3                   	ret    

0000e965 <get_fs_long>:
	__asm__ ("movw %%fs:%1,%0":"=r" (_v):"m" (*addr));
	return _v;
}

static inline unsigned long get_fs_long(const unsigned long *addr)
{
    e965:	83 ec 10             	sub    $0x10,%esp
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
    e968:	8b 44 24 14          	mov    0x14(%esp),%eax
    e96c:	64 8b 00             	mov    %fs:(%eax),%eax
    e96f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
    e973:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    e977:	83 c4 10             	add    $0x10,%esp
    e97a:	c3                   	ret    

0000e97b <put_fs_byte>:

static inline void put_fs_byte(char val,char *addr)
{
    e97b:	83 ec 04             	sub    $0x4,%esp
    e97e:	8b 44 24 08          	mov    0x8(%esp),%eax
    e982:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    e985:	0f b6 04 24          	movzbl (%esp),%eax
    e989:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e98d:	64 88 02             	mov    %al,%fs:(%edx)
}
    e990:	90                   	nop
    e991:	83 c4 04             	add    $0x4,%esp
    e994:	c3                   	ret    

0000e995 <put_fs_long>:
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    e995:	8b 44 24 04          	mov    0x4(%esp),%eax
    e999:	8b 54 24 08          	mov    0x8(%esp),%edx
    e99d:	64 89 02             	mov    %eax,%fs:(%edx)
}
    e9a0:	90                   	nop
    e9a1:	c3                   	ret    

0000e9a2 <get_fs>:
 * --- TYT, 11/24/91
 * [ nothing wrong here, Linus ]
 */

static inline unsigned long get_fs() 
{
    e9a2:	83 ec 10             	sub    $0x10,%esp
	unsigned short _v;
	__asm__("mov %%fs,%%ax":"=a" (_v):);
    e9a5:	66 8c e0             	mov    %fs,%ax
    e9a8:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	return _v;
    e9ad:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
}
    e9b2:	83 c4 10             	add    $0x10,%esp
    e9b5:	c3                   	ret    

0000e9b6 <get_ds>:

static inline unsigned long get_ds() 
{
    e9b6:	83 ec 10             	sub    $0x10,%esp
	unsigned short _v;
	__asm__("mov %%ds,%%ax":"=a" (_v):);
    e9b9:	66 8c d8             	mov    %ds,%ax
    e9bc:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	return _v;
    e9c1:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
}
    e9c6:	83 c4 10             	add    $0x10,%esp
    e9c9:	c3                   	ret    

0000e9ca <set_fs>:

static inline void set_fs(unsigned long val)
{
	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
    e9ca:	8b 44 24 04          	mov    0x4(%esp),%eax
    e9ce:	8e e0                	mov    %eax,%fs
}
    e9d0:	90                   	nop
    e9d1:	c3                   	ret    

0000e9d2 <create_tables>:
 * create_tables() parses the env- and arg-strings in new user
 * memory and creates the pointer tables from them, and puts their
 * addresses on the "stack", returning the new stack pointer value.
 */
static unsigned long * create_tables(char * p,int argc,int envc)
{
    e9d2:	83 ec 10             	sub    $0x10,%esp
	unsigned long *argv,*envp;
	unsigned long * sp;

	sp = (unsigned long *) (0xfffffffc & (unsigned long) p);
    e9d5:	8b 44 24 14          	mov    0x14(%esp),%eax
    e9d9:	83 e0 fc             	and    $0xfffffffc,%eax
    e9dc:	89 44 24 04          	mov    %eax,0x4(%esp)
	sp -= envc+1;
    e9e0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e9e4:	8d 50 01             	lea    0x1(%eax),%edx
    e9e7:	b8 00 00 00 00       	mov    $0x0,%eax
    e9ec:	29 d0                	sub    %edx,%eax
    e9ee:	c1 e0 02             	shl    $0x2,%eax
    e9f1:	01 44 24 04          	add    %eax,0x4(%esp)
	envp = sp;
    e9f5:	8b 44 24 04          	mov    0x4(%esp),%eax
    e9f9:	89 44 24 08          	mov    %eax,0x8(%esp)
	sp -= argc+1;
    e9fd:	8b 44 24 18          	mov    0x18(%esp),%eax
    ea01:	8d 50 01             	lea    0x1(%eax),%edx
    ea04:	b8 00 00 00 00       	mov    $0x0,%eax
    ea09:	29 d0                	sub    %edx,%eax
    ea0b:	c1 e0 02             	shl    $0x2,%eax
    ea0e:	01 44 24 04          	add    %eax,0x4(%esp)
	argv = sp;
    ea12:	8b 44 24 04          	mov    0x4(%esp),%eax
    ea16:	89 44 24 0c          	mov    %eax,0xc(%esp)
	put_fs_long((unsigned long)envp,--sp);
    ea1a:	83 6c 24 04 04       	subl   $0x4,0x4(%esp)
    ea1f:	8b 44 24 08          	mov    0x8(%esp),%eax
    ea23:	ff 74 24 04          	pushl  0x4(%esp)
    ea27:	50                   	push   %eax
    ea28:	e8 68 ff ff ff       	call   e995 <put_fs_long>
    ea2d:	83 c4 08             	add    $0x8,%esp
	put_fs_long((unsigned long)argv,--sp);
    ea30:	83 6c 24 04 04       	subl   $0x4,0x4(%esp)
    ea35:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ea39:	ff 74 24 04          	pushl  0x4(%esp)
    ea3d:	50                   	push   %eax
    ea3e:	e8 52 ff ff ff       	call   e995 <put_fs_long>
    ea43:	83 c4 08             	add    $0x8,%esp
	put_fs_long((unsigned long)argc,--sp);
    ea46:	83 6c 24 04 04       	subl   $0x4,0x4(%esp)
    ea4b:	8b 44 24 18          	mov    0x18(%esp),%eax
    ea4f:	ff 74 24 04          	pushl  0x4(%esp)
    ea53:	50                   	push   %eax
    ea54:	e8 3c ff ff ff       	call   e995 <put_fs_long>
    ea59:	83 c4 08             	add    $0x8,%esp
	while (argc-->0) {
    ea5c:	eb 32                	jmp    ea90 <create_tables+0xbe>
		put_fs_long((unsigned long) p,argv++);
    ea5e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ea62:	8d 50 04             	lea    0x4(%eax),%edx
    ea65:	89 54 24 0c          	mov    %edx,0xc(%esp)
    ea69:	8b 54 24 14          	mov    0x14(%esp),%edx
    ea6d:	50                   	push   %eax
    ea6e:	52                   	push   %edx
    ea6f:	e8 21 ff ff ff       	call   e995 <put_fs_long>
    ea74:	83 c4 08             	add    $0x8,%esp
		while (get_fs_byte(p++)) /* nothing */ ;
    ea77:	90                   	nop
    ea78:	8b 44 24 14          	mov    0x14(%esp),%eax
    ea7c:	8d 50 01             	lea    0x1(%eax),%edx
    ea7f:	89 54 24 14          	mov    %edx,0x14(%esp)
    ea83:	50                   	push   %eax
    ea84:	e8 ce fe ff ff       	call   e957 <get_fs_byte>
    ea89:	83 c4 04             	add    $0x4,%esp
    ea8c:	84 c0                	test   %al,%al
    ea8e:	75 e8                	jne    ea78 <create_tables+0xa6>
	sp -= argc+1;
	argv = sp;
	put_fs_long((unsigned long)envp,--sp);
	put_fs_long((unsigned long)argv,--sp);
	put_fs_long((unsigned long)argc,--sp);
	while (argc-->0) {
    ea90:	8b 44 24 18          	mov    0x18(%esp),%eax
    ea94:	8d 50 ff             	lea    -0x1(%eax),%edx
    ea97:	89 54 24 18          	mov    %edx,0x18(%esp)
    ea9b:	85 c0                	test   %eax,%eax
    ea9d:	7f bf                	jg     ea5e <create_tables+0x8c>
		put_fs_long((unsigned long) p,argv++);
		while (get_fs_byte(p++)) /* nothing */ ;
	}
	put_fs_long(0,argv);
    ea9f:	ff 74 24 0c          	pushl  0xc(%esp)
    eaa3:	6a 00                	push   $0x0
    eaa5:	e8 eb fe ff ff       	call   e995 <put_fs_long>
    eaaa:	83 c4 08             	add    $0x8,%esp
	while (envc-->0) {
    eaad:	eb 32                	jmp    eae1 <create_tables+0x10f>
		put_fs_long((unsigned long) p,envp++);
    eaaf:	8b 44 24 08          	mov    0x8(%esp),%eax
    eab3:	8d 50 04             	lea    0x4(%eax),%edx
    eab6:	89 54 24 08          	mov    %edx,0x8(%esp)
    eaba:	8b 54 24 14          	mov    0x14(%esp),%edx
    eabe:	50                   	push   %eax
    eabf:	52                   	push   %edx
    eac0:	e8 d0 fe ff ff       	call   e995 <put_fs_long>
    eac5:	83 c4 08             	add    $0x8,%esp
		while (get_fs_byte(p++)) /* nothing */ ;
    eac8:	90                   	nop
    eac9:	8b 44 24 14          	mov    0x14(%esp),%eax
    eacd:	8d 50 01             	lea    0x1(%eax),%edx
    ead0:	89 54 24 14          	mov    %edx,0x14(%esp)
    ead4:	50                   	push   %eax
    ead5:	e8 7d fe ff ff       	call   e957 <get_fs_byte>
    eada:	83 c4 04             	add    $0x4,%esp
    eadd:	84 c0                	test   %al,%al
    eadf:	75 e8                	jne    eac9 <create_tables+0xf7>
	while (argc-->0) {
		put_fs_long((unsigned long) p,argv++);
		while (get_fs_byte(p++)) /* nothing */ ;
	}
	put_fs_long(0,argv);
	while (envc-->0) {
    eae1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    eae5:	8d 50 ff             	lea    -0x1(%eax),%edx
    eae8:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    eaec:	85 c0                	test   %eax,%eax
    eaee:	7f bf                	jg     eaaf <create_tables+0xdd>
		put_fs_long((unsigned long) p,envp++);
		while (get_fs_byte(p++)) /* nothing */ ;
	}
	put_fs_long(0,envp);
    eaf0:	ff 74 24 08          	pushl  0x8(%esp)
    eaf4:	6a 00                	push   $0x0
    eaf6:	e8 9a fe ff ff       	call   e995 <put_fs_long>
    eafb:	83 c4 08             	add    $0x8,%esp
	return sp;
    eafe:	8b 44 24 04          	mov    0x4(%esp),%eax
}
    eb02:	83 c4 10             	add    $0x10,%esp
    eb05:	c3                   	ret    

0000eb06 <count>:

/*
 * count() counts the number of arguments/envelopes
 */
static int count(char ** argv)
{
    eb06:	83 ec 10             	sub    $0x10,%esp
	int i=0;
    eb09:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    eb10:	00 
	char ** tmp;

	if ((tmp = argv))
    eb11:	8b 44 24 14          	mov    0x14(%esp),%eax
    eb15:	89 44 24 08          	mov    %eax,0x8(%esp)
    eb19:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    eb1e:	74 1f                	je     eb3f <count+0x39>
		while (get_fs_long((unsigned long *) (tmp++)))
    eb20:	eb 05                	jmp    eb27 <count+0x21>
			i++;
    eb22:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
{
	int i=0;
	char ** tmp;

	if ((tmp = argv))
		while (get_fs_long((unsigned long *) (tmp++)))
    eb27:	8b 44 24 08          	mov    0x8(%esp),%eax
    eb2b:	8d 50 04             	lea    0x4(%eax),%edx
    eb2e:	89 54 24 08          	mov    %edx,0x8(%esp)
    eb32:	50                   	push   %eax
    eb33:	e8 2d fe ff ff       	call   e965 <get_fs_long>
    eb38:	83 c4 04             	add    $0x4,%esp
    eb3b:	85 c0                	test   %eax,%eax
    eb3d:	75 e3                	jne    eb22 <count+0x1c>
			i++;

	return i;
    eb3f:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    eb43:	83 c4 10             	add    $0x10,%esp
    eb46:	c3                   	ret    

0000eb47 <copy_strings>:
 * it is expensive to load a segment register, we try to avoid calling
 * set_fs() unless we absolutely have to.
 */
static unsigned long copy_strings(int argc,char ** argv,unsigned long *page,
		unsigned long p, int from_kmem)
{
    eb47:	53                   	push   %ebx
    eb48:	83 ec 28             	sub    $0x28,%esp
	char *tmp, *pag=NULL;
    eb4b:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    eb52:	00 
	int len, offset = 0;
    eb53:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    eb5a:	00 
	unsigned long old_fs, new_fs;

	if (!p)
    eb5b:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    eb60:	75 0a                	jne    eb6c <copy_strings+0x25>
		return 0;	/* bullet-proofing */
    eb62:	b8 00 00 00 00       	mov    $0x0,%eax
    eb67:	e9 b6 01 00 00       	jmp    ed22 <copy_strings+0x1db>
	new_fs = get_ds();
    eb6c:	e8 45 fe ff ff       	call   e9b6 <get_ds>
    eb71:	89 44 24 0c          	mov    %eax,0xc(%esp)
	old_fs = get_fs();
    eb75:	e8 28 fe ff ff       	call   e9a2 <get_fs>
    eb7a:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (from_kmem==2)
    eb7e:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
    eb83:	0f 85 6c 01 00 00    	jne    ecf5 <copy_strings+0x1ae>
		set_fs(new_fs);
    eb89:	ff 74 24 0c          	pushl  0xc(%esp)
    eb8d:	e8 38 fe ff ff       	call   e9ca <set_fs>
    eb92:	83 c4 04             	add    $0x4,%esp
	while (argc-- > 0) {
    eb95:	e9 5b 01 00 00       	jmp    ecf5 <copy_strings+0x1ae>
		if (from_kmem == 1)
    eb9a:	83 7c 24 40 01       	cmpl   $0x1,0x40(%esp)
    eb9f:	75 0c                	jne    ebad <copy_strings+0x66>
			set_fs(new_fs);
    eba1:	ff 74 24 0c          	pushl  0xc(%esp)
    eba5:	e8 20 fe ff ff       	call   e9ca <set_fs>
    ebaa:	83 c4 04             	add    $0x4,%esp
		if (!(tmp = (char *)get_fs_long(((unsigned long *)argv)+argc)))
    ebad:	8b 44 24 30          	mov    0x30(%esp),%eax
    ebb1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ebb8:	8b 44 24 34          	mov    0x34(%esp),%eax
    ebbc:	01 d0                	add    %edx,%eax
    ebbe:	50                   	push   %eax
    ebbf:	e8 a1 fd ff ff       	call   e965 <get_fs_long>
    ebc4:	83 c4 04             	add    $0x4,%esp
    ebc7:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    ebcb:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    ebd0:	75 10                	jne    ebe2 <copy_strings+0x9b>
			panic("argc is wrong");
    ebd2:	83 ec 0c             	sub    $0xc,%esp
    ebd5:	68 50 89 01 00       	push   $0x18950
    ebda:	e8 ef 9b ff ff       	call   87ce <panic>
    ebdf:	83 c4 10             	add    $0x10,%esp
		if (from_kmem == 1)
    ebe2:	83 7c 24 40 01       	cmpl   $0x1,0x40(%esp)
    ebe7:	75 0f                	jne    ebf8 <copy_strings+0xb1>
			set_fs(old_fs);
    ebe9:	83 ec 0c             	sub    $0xc,%esp
    ebec:	ff 74 24 14          	pushl  0x14(%esp)
    ebf0:	e8 d5 fd ff ff       	call   e9ca <set_fs>
    ebf5:	83 c4 10             	add    $0x10,%esp
		len=0;		/* remember zero-padding */
    ebf8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    ebff:	00 
		do {
			len++;
    ec00:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
		} while (get_fs_byte(tmp++));
    ec05:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ec09:	8d 50 01             	lea    0x1(%eax),%edx
    ec0c:	89 54 24 1c          	mov    %edx,0x1c(%esp)
    ec10:	83 ec 0c             	sub    $0xc,%esp
    ec13:	50                   	push   %eax
    ec14:	e8 3e fd ff ff       	call   e957 <get_fs_byte>
    ec19:	83 c4 10             	add    $0x10,%esp
    ec1c:	84 c0                	test   %al,%al
    ec1e:	75 e0                	jne    ec00 <copy_strings+0xb9>
		if (p-len < 0) {	/* this shouldn't happen - 128kB */
			set_fs(old_fs);
			return 0;
		}
		while (len) {
    ec20:	e9 c5 00 00 00       	jmp    ecea <copy_strings+0x1a3>
			--p; --tmp; --len;
    ec25:	83 6c 24 3c 01       	subl   $0x1,0x3c(%esp)
    ec2a:	83 6c 24 1c 01       	subl   $0x1,0x1c(%esp)
    ec2f:	83 6c 24 14 01       	subl   $0x1,0x14(%esp)
			if (--offset < 0) {
    ec34:	83 6c 24 10 01       	subl   $0x1,0x10(%esp)
    ec39:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    ec3e:	0f 89 8a 00 00 00    	jns    ecce <copy_strings+0x187>
				offset = p % PAGE_SIZE;
    ec44:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    ec48:	25 ff 0f 00 00       	and    $0xfff,%eax
    ec4d:	89 44 24 10          	mov    %eax,0x10(%esp)
				if (from_kmem==2)
    ec51:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
    ec56:	75 0f                	jne    ec67 <copy_strings+0x120>
					set_fs(old_fs);
    ec58:	83 ec 0c             	sub    $0xc,%esp
    ec5b:	ff 74 24 14          	pushl  0x14(%esp)
    ec5f:	e8 66 fd ff ff       	call   e9ca <set_fs>
    ec64:	83 c4 10             	add    $0x10,%esp
				if (!(pag = (char *) page[p/PAGE_SIZE]) &&
    ec67:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    ec6b:	c1 e8 0c             	shr    $0xc,%eax
    ec6e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ec75:	8b 44 24 38          	mov    0x38(%esp),%eax
    ec79:	01 d0                	add    %edx,%eax
    ec7b:	8b 00                	mov    (%eax),%eax
    ec7d:	89 44 24 18          	mov    %eax,0x18(%esp)
    ec81:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    ec86:	75 30                	jne    ecb8 <copy_strings+0x171>
				    !(pag = (char *) (page[p/PAGE_SIZE] =
    ec88:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    ec8c:	c1 e8 0c             	shr    $0xc,%eax
    ec8f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ec96:	8b 44 24 38          	mov    0x38(%esp),%eax
    ec9a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
				      get_free_page()))) 
    ec9d:	e8 dc b6 ff ff       	call   a37e <get_free_page>
			if (--offset < 0) {
				offset = p % PAGE_SIZE;
				if (from_kmem==2)
					set_fs(old_fs);
				if (!(pag = (char *) page[p/PAGE_SIZE]) &&
				    !(pag = (char *) (page[p/PAGE_SIZE] =
    eca2:	89 03                	mov    %eax,(%ebx)
    eca4:	8b 03                	mov    (%ebx),%eax
    eca6:	89 44 24 18          	mov    %eax,0x18(%esp)
			--p; --tmp; --len;
			if (--offset < 0) {
				offset = p % PAGE_SIZE;
				if (from_kmem==2)
					set_fs(old_fs);
				if (!(pag = (char *) page[p/PAGE_SIZE]) &&
    ecaa:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    ecaf:	75 07                	jne    ecb8 <copy_strings+0x171>
				    !(pag = (char *) (page[p/PAGE_SIZE] =
				      get_free_page()))) 
					return 0;
    ecb1:	b8 00 00 00 00       	mov    $0x0,%eax
    ecb6:	eb 6a                	jmp    ed22 <copy_strings+0x1db>
				if (from_kmem==2)
    ecb8:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
    ecbd:	75 0f                	jne    ecce <copy_strings+0x187>
					set_fs(new_fs);
    ecbf:	83 ec 0c             	sub    $0xc,%esp
    ecc2:	ff 74 24 18          	pushl  0x18(%esp)
    ecc6:	e8 ff fc ff ff       	call   e9ca <set_fs>
    eccb:	83 c4 10             	add    $0x10,%esp

			}
			*(pag + offset) = get_fs_byte(tmp);
    ecce:	8b 54 24 10          	mov    0x10(%esp),%edx
    ecd2:	8b 44 24 18          	mov    0x18(%esp),%eax
    ecd6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ecd9:	83 ec 0c             	sub    $0xc,%esp
    ecdc:	ff 74 24 28          	pushl  0x28(%esp)
    ece0:	e8 72 fc ff ff       	call   e957 <get_fs_byte>
    ece5:	83 c4 10             	add    $0x10,%esp
    ece8:	88 03                	mov    %al,(%ebx)
		} while (get_fs_byte(tmp++));
		if (p-len < 0) {	/* this shouldn't happen - 128kB */
			set_fs(old_fs);
			return 0;
		}
		while (len) {
    ecea:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    ecef:	0f 85 30 ff ff ff    	jne    ec25 <copy_strings+0xde>
		return 0;	/* bullet-proofing */
	new_fs = get_ds();
	old_fs = get_fs();
	if (from_kmem==2)
		set_fs(new_fs);
	while (argc-- > 0) {
    ecf5:	8b 44 24 30          	mov    0x30(%esp),%eax
    ecf9:	8d 50 ff             	lea    -0x1(%eax),%edx
    ecfc:	89 54 24 30          	mov    %edx,0x30(%esp)
    ed00:	85 c0                	test   %eax,%eax
    ed02:	0f 8f 92 fe ff ff    	jg     eb9a <copy_strings+0x53>

			}
			*(pag + offset) = get_fs_byte(tmp);
		}
	}
	if (from_kmem==2)
    ed08:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
    ed0d:	75 0f                	jne    ed1e <copy_strings+0x1d7>
		set_fs(old_fs);
    ed0f:	83 ec 0c             	sub    $0xc,%esp
    ed12:	ff 74 24 14          	pushl  0x14(%esp)
    ed16:	e8 af fc ff ff       	call   e9ca <set_fs>
    ed1b:	83 c4 10             	add    $0x10,%esp
	return p;
    ed1e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
}
    ed22:	83 c4 28             	add    $0x28,%esp
    ed25:	5b                   	pop    %ebx
    ed26:	c3                   	ret    

0000ed27 <change_ldt>:

static unsigned long change_ldt(unsigned long text_size,unsigned long * page)
{
    ed27:	56                   	push   %esi
    ed28:	53                   	push   %ebx
    ed29:	83 ec 24             	sub    $0x24,%esp
	unsigned long code_limit,data_limit,code_base,data_base;
	int i;

	code_limit = text_size+PAGE_SIZE -1;
    ed2c:	8b 44 24 30          	mov    0x30(%esp),%eax
    ed30:	05 ff 0f 00 00       	add    $0xfff,%eax
    ed35:	89 44 24 14          	mov    %eax,0x14(%esp)
	code_limit &= 0xFFFFF000;
    ed39:	81 64 24 14 00 f0 ff 	andl   $0xfffff000,0x14(%esp)
    ed40:	ff 
	data_limit = 0x4000000;
    ed41:	c7 44 24 10 00 00 00 	movl   $0x4000000,0x10(%esp)
    ed48:	04 
	code_base = get_base(current->ldt[1]);
    ed49:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ed4e:	05 d8 02 00 00       	add    $0x2d8,%eax
    ed53:	50                   	push   %eax
    ed54:	e8 cc fb ff ff       	call   e925 <_get_base>
    ed59:	83 c4 04             	add    $0x4,%esp
    ed5c:	89 44 24 0c          	mov    %eax,0xc(%esp)
	data_base = code_base;
    ed60:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ed64:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	set_base(current->ldt[1],code_base);
    ed68:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ed6d:	05 d8 02 00 00       	add    $0x2d8,%eax
    ed72:	8d 48 02             	lea    0x2(%eax),%ecx
    ed75:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ed7a:	05 d8 02 00 00       	add    $0x2d8,%eax
    ed7f:	8d 58 04             	lea    0x4(%eax),%ebx
    ed82:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ed87:	05 d8 02 00 00       	add    $0x2d8,%eax
    ed8c:	8d 70 07             	lea    0x7(%eax),%esi
    ed8f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ed93:	89 c2                	mov    %eax,%edx
    ed95:	52                   	push   %edx
    ed96:	66 89 11             	mov    %dx,(%ecx)
    ed99:	c1 ca 10             	ror    $0x10,%edx
    ed9c:	88 13                	mov    %dl,(%ebx)
    ed9e:	88 36                	mov    %dh,(%esi)
    eda0:	5a                   	pop    %edx
	set_limit(current->ldt[1],code_limit);
    eda1:	a1 40 f1 01 00       	mov    0x1f140,%eax
    eda6:	05 d8 02 00 00       	add    $0x2d8,%eax
    edab:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    edb1:	81 c2 d8 02 00 00    	add    $0x2d8,%edx
    edb7:	8d 4a 06             	lea    0x6(%edx),%ecx
    edba:	8b 54 24 14          	mov    0x14(%esp),%edx
    edbe:	83 ea 01             	sub    $0x1,%edx
    edc1:	c1 ea 0c             	shr    $0xc,%edx
    edc4:	52                   	push   %edx
    edc5:	66 89 10             	mov    %dx,(%eax)
    edc8:	c1 ca 10             	ror    $0x10,%edx
    edcb:	8a 31                	mov    (%ecx),%dh
    edcd:	80 e6 f0             	and    $0xf0,%dh
    edd0:	08 f2                	or     %dh,%dl
    edd2:	88 11                	mov    %dl,(%ecx)
    edd4:	5a                   	pop    %edx
	set_base(current->ldt[2],data_base);
    edd5:	a1 40 f1 01 00       	mov    0x1f140,%eax
    edda:	05 e0 02 00 00       	add    $0x2e0,%eax
    eddf:	8d 48 02             	lea    0x2(%eax),%ecx
    ede2:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ede7:	05 e0 02 00 00       	add    $0x2e0,%eax
    edec:	8d 58 04             	lea    0x4(%eax),%ebx
    edef:	a1 40 f1 01 00       	mov    0x1f140,%eax
    edf4:	05 e0 02 00 00       	add    $0x2e0,%eax
    edf9:	8d 70 07             	lea    0x7(%eax),%esi
    edfc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ee00:	89 c2                	mov    %eax,%edx
    ee02:	52                   	push   %edx
    ee03:	66 89 11             	mov    %dx,(%ecx)
    ee06:	c1 ca 10             	ror    $0x10,%edx
    ee09:	88 13                	mov    %dl,(%ebx)
    ee0b:	88 36                	mov    %dh,(%esi)
    ee0d:	5a                   	pop    %edx
	set_limit(current->ldt[2],data_limit);
    ee0e:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ee13:	05 e0 02 00 00       	add    $0x2e0,%eax
    ee18:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    ee1e:	81 c2 e0 02 00 00    	add    $0x2e0,%edx
    ee24:	8d 4a 06             	lea    0x6(%edx),%ecx
    ee27:	8b 54 24 10          	mov    0x10(%esp),%edx
    ee2b:	83 ea 01             	sub    $0x1,%edx
    ee2e:	c1 ea 0c             	shr    $0xc,%edx
    ee31:	52                   	push   %edx
    ee32:	66 89 10             	mov    %dx,(%eax)
    ee35:	c1 ca 10             	ror    $0x10,%edx
    ee38:	8a 31                	mov    (%ecx),%dh
    ee3a:	80 e6 f0             	and    $0xf0,%dh
    ee3d:	08 f2                	or     %dh,%dl
    ee3f:	88 11                	mov    %dl,(%ecx)
    ee41:	5a                   	pop    %edx
/* make sure fs points to the NEW data segment */
	__asm__("pushl $0x17\n\tpop %%fs"::);
    ee42:	6a 17                	push   $0x17
    ee44:	0f a1                	pop    %fs
	data_base += data_limit;
    ee46:	8b 44 24 10          	mov    0x10(%esp),%eax
    ee4a:	01 44 24 1c          	add    %eax,0x1c(%esp)
	for (i=MAX_ARG_PAGES-1 ; i>=0 ; i--) {
    ee4e:	c7 44 24 18 1f 00 00 	movl   $0x1f,0x18(%esp)
    ee55:	00 
    ee56:	eb 47                	jmp    ee9f <change_ldt+0x178>
		data_base -= PAGE_SIZE;
    ee58:	81 6c 24 1c 00 10 00 	subl   $0x1000,0x1c(%esp)
    ee5f:	00 
		if (page[i])
    ee60:	8b 44 24 18          	mov    0x18(%esp),%eax
    ee64:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ee6b:	8b 44 24 34          	mov    0x34(%esp),%eax
    ee6f:	01 d0                	add    %edx,%eax
    ee71:	8b 00                	mov    (%eax),%eax
    ee73:	85 c0                	test   %eax,%eax
    ee75:	74 23                	je     ee9a <change_ldt+0x173>
			put_page(page[i],data_base);
    ee77:	8b 44 24 18          	mov    0x18(%esp),%eax
    ee7b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ee82:	8b 44 24 34          	mov    0x34(%esp),%eax
    ee86:	01 d0                	add    %edx,%eax
    ee88:	8b 00                	mov    (%eax),%eax
    ee8a:	83 ec 08             	sub    $0x8,%esp
    ee8d:	ff 74 24 24          	pushl  0x24(%esp)
    ee91:	50                   	push   %eax
    ee92:	e8 3b b8 ff ff       	call   a6d2 <put_page>
    ee97:	83 c4 10             	add    $0x10,%esp
	set_base(current->ldt[2],data_base);
	set_limit(current->ldt[2],data_limit);
/* make sure fs points to the NEW data segment */
	__asm__("pushl $0x17\n\tpop %%fs"::);
	data_base += data_limit;
	for (i=MAX_ARG_PAGES-1 ; i>=0 ; i--) {
    ee9a:	83 6c 24 18 01       	subl   $0x1,0x18(%esp)
    ee9f:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    eea4:	79 b2                	jns    ee58 <change_ldt+0x131>
		data_base -= PAGE_SIZE;
		if (page[i])
			put_page(page[i],data_base);
	}
	return data_limit;
    eea6:	8b 44 24 10          	mov    0x10(%esp),%eax
}
    eeaa:	83 c4 24             	add    $0x24,%esp
    eead:	5b                   	pop    %ebx
    eeae:	5e                   	pop    %esi
    eeaf:	c3                   	ret    

0000eeb0 <do_execve>:
/*
 * 'do_execve()' executes a new program.
 */
int do_execve(unsigned long * eip,long tmp,char * filename,
	char ** argv, char ** envp)
{
    eeb0:	57                   	push   %edi
    eeb1:	56                   	push   %esi
    eeb2:	53                   	push   %ebx
    eeb3:	81 ec f0 04 00 00    	sub    $0x4f0,%esp
	struct exec ex;
	unsigned long page[MAX_ARG_PAGES];
	int i,argc,envc;
	int e_uid, e_gid;
	int retval;
	int sh_bang = 0;
    eeb9:	c7 84 24 dc 04 00 00 	movl   $0x0,0x4dc(%esp)
    eec0:	00 00 00 00 
	unsigned long p=PAGE_SIZE*MAX_ARG_PAGES-4;
    eec4:	c7 84 24 d8 04 00 00 	movl   $0x1fffc,0x4d8(%esp)
    eecb:	fc ff 01 00 

	if ((0xffff & eip[1]) != 0x000f)
    eecf:	8b 84 24 00 05 00 00 	mov    0x500(%esp),%eax
    eed6:	83 c0 04             	add    $0x4,%eax
    eed9:	8b 00                	mov    (%eax),%eax
    eedb:	0f b7 c0             	movzwl %ax,%eax
    eede:	83 f8 0f             	cmp    $0xf,%eax
    eee1:	74 10                	je     eef3 <do_execve+0x43>
		panic("execve called from supervisor mode");
    eee3:	83 ec 0c             	sub    $0xc,%esp
    eee6:	68 60 89 01 00       	push   $0x18960
    eeeb:	e8 de 98 ff ff       	call   87ce <panic>
    eef0:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<MAX_ARG_PAGES ; i++)	/* clear page-table */
    eef3:	c7 84 24 e8 04 00 00 	movl   $0x0,0x4e8(%esp)
    eefa:	00 00 00 00 
    eefe:	eb 1a                	jmp    ef1a <do_execve+0x6a>
		page[i]=0;
    ef00:	8b 84 24 e8 04 00 00 	mov    0x4e8(%esp),%eax
    ef07:	c7 84 84 14 04 00 00 	movl   $0x0,0x414(%esp,%eax,4)
    ef0e:	00 00 00 00 
	int sh_bang = 0;
	unsigned long p=PAGE_SIZE*MAX_ARG_PAGES-4;

	if ((0xffff & eip[1]) != 0x000f)
		panic("execve called from supervisor mode");
	for (i=0 ; i<MAX_ARG_PAGES ; i++)	/* clear page-table */
    ef12:	83 84 24 e8 04 00 00 	addl   $0x1,0x4e8(%esp)
    ef19:	01 
    ef1a:	83 bc 24 e8 04 00 00 	cmpl   $0x1f,0x4e8(%esp)
    ef21:	1f 
    ef22:	7e dc                	jle    ef00 <do_execve+0x50>
		page[i]=0;
	if (!(inode=namei(filename)))		/* get executables inode */
    ef24:	8b 84 24 08 05 00 00 	mov    0x508(%esp),%eax
    ef2b:	83 ec 0c             	sub    $0xc,%esp
    ef2e:	50                   	push   %eax
    ef2f:	e8 e4 17 00 00       	call   10718 <namei>
    ef34:	83 c4 10             	add    $0x10,%esp
    ef37:	89 84 24 ec 04 00 00 	mov    %eax,0x4ec(%esp)
    ef3e:	83 bc 24 ec 04 00 00 	cmpl   $0x0,0x4ec(%esp)
    ef45:	00 
    ef46:	75 0a                	jne    ef52 <do_execve+0xa2>
		return -ENOENT;
    ef48:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    ef4d:	e9 0a 0a 00 00       	jmp    f95c <do_execve+0xaac>
	argc = count(argv);
    ef52:	83 ec 0c             	sub    $0xc,%esp
    ef55:	ff b4 24 18 05 00 00 	pushl  0x518(%esp)
    ef5c:	e8 a5 fb ff ff       	call   eb06 <count>
    ef61:	83 c4 10             	add    $0x10,%esp
    ef64:	89 84 24 e4 04 00 00 	mov    %eax,0x4e4(%esp)
	envc = count(envp);
    ef6b:	83 ec 0c             	sub    $0xc,%esp
    ef6e:	ff b4 24 1c 05 00 00 	pushl  0x51c(%esp)
    ef75:	e8 8c fb ff ff       	call   eb06 <count>
    ef7a:	83 c4 10             	add    $0x10,%esp
    ef7d:	89 84 24 d0 04 00 00 	mov    %eax,0x4d0(%esp)
	
restart_interp:
	if (!S_ISREG(inode->i_mode)) {	/* must be regular file */
    ef84:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    ef8b:	0f b7 00             	movzwl (%eax),%eax
    ef8e:	0f b7 c0             	movzwl %ax,%eax
    ef91:	25 00 f0 00 00       	and    $0xf000,%eax
    ef96:	3d 00 80 00 00       	cmp    $0x8000,%eax
    ef9b:	74 10                	je     efad <do_execve+0xfd>
		retval = -EACCES;
    ef9d:	c7 84 24 e0 04 00 00 	movl   $0xfffffff3,0x4e0(%esp)
    efa4:	f3 ff ff ff 
		goto exec_error2;
    efa8:	e9 5d 09 00 00       	jmp    f90a <do_execve+0xa5a>
	}
	i = inode->i_mode;
    efad:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    efb4:	0f b7 00             	movzwl (%eax),%eax
    efb7:	0f b7 c0             	movzwl %ax,%eax
    efba:	89 84 24 e8 04 00 00 	mov    %eax,0x4e8(%esp)
	e_uid = (i & S_ISUID) ? inode->i_uid : current->euid;
    efc1:	8b 84 24 e8 04 00 00 	mov    0x4e8(%esp),%eax
    efc8:	25 00 08 00 00       	and    $0x800,%eax
    efcd:	85 c0                	test   %eax,%eax
    efcf:	74 10                	je     efe1 <do_execve+0x131>
    efd1:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    efd8:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    efdc:	0f b7 c0             	movzwl %ax,%eax
    efdf:	eb 0f                	jmp    eff0 <do_execve+0x140>
    efe1:	a1 40 f1 01 00       	mov    0x1f140,%eax
    efe6:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    efed:	0f b7 c0             	movzwl %ax,%eax
    eff0:	89 84 24 cc 04 00 00 	mov    %eax,0x4cc(%esp)
	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
    eff7:	8b 84 24 e8 04 00 00 	mov    0x4e8(%esp),%eax
    effe:	25 00 04 00 00       	and    $0x400,%eax
    f003:	85 c0                	test   %eax,%eax
    f005:	74 10                	je     f017 <do_execve+0x167>
    f007:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    f00e:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    f012:	0f b6 c0             	movzbl %al,%eax
    f015:	eb 0f                	jmp    f026 <do_execve+0x176>
    f017:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f01c:	0f b7 80 48 02 00 00 	movzwl 0x248(%eax),%eax
    f023:	0f b7 c0             	movzwl %ax,%eax
    f026:	89 84 24 c8 04 00 00 	mov    %eax,0x4c8(%esp)
	if (current->euid == inode->i_uid)
    f02d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f032:	0f b7 90 42 02 00 00 	movzwl 0x242(%eax),%edx
    f039:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    f040:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    f044:	66 39 c2             	cmp    %ax,%dx
    f047:	75 0a                	jne    f053 <do_execve+0x1a3>
		i >>= 6;
    f049:	c1 bc 24 e8 04 00 00 	sarl   $0x6,0x4e8(%esp)
    f050:	06 
    f051:	eb 27                	jmp    f07a <do_execve+0x1ca>
	else if (current->egid == inode->i_gid)
    f053:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f058:	0f b7 90 48 02 00 00 	movzwl 0x248(%eax),%edx
    f05f:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    f066:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    f06a:	0f b6 c0             	movzbl %al,%eax
    f06d:	66 39 c2             	cmp    %ax,%dx
    f070:	75 08                	jne    f07a <do_execve+0x1ca>
		i >>= 3;
    f072:	c1 bc 24 e8 04 00 00 	sarl   $0x3,0x4e8(%esp)
    f079:	03 
	if (!(i & 1) &&
    f07a:	8b 84 24 e8 04 00 00 	mov    0x4e8(%esp),%eax
    f081:	83 e0 01             	and    $0x1,%eax
    f084:	85 c0                	test   %eax,%eax
    f086:	75 35                	jne    f0bd <do_execve+0x20d>
	    !((inode->i_mode & 0111) && suser())) {
    f088:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    f08f:	0f b7 00             	movzwl (%eax),%eax
    f092:	0f b7 c0             	movzwl %ax,%eax
    f095:	83 e0 49             	and    $0x49,%eax
	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
	if (current->euid == inode->i_uid)
		i >>= 6;
	else if (current->egid == inode->i_gid)
		i >>= 3;
	if (!(i & 1) &&
    f098:	85 c0                	test   %eax,%eax
    f09a:	74 11                	je     f0ad <do_execve+0x1fd>
	    !((inode->i_mode & 0111) && suser())) {
    f09c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f0a1:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    f0a8:	66 85 c0             	test   %ax,%ax
    f0ab:	74 10                	je     f0bd <do_execve+0x20d>
		retval = -ENOEXEC;
    f0ad:	c7 84 24 e0 04 00 00 	movl   $0xfffffff8,0x4e0(%esp)
    f0b4:	f8 ff ff ff 
		goto exec_error2;
    f0b8:	e9 4d 08 00 00       	jmp    f90a <do_execve+0xa5a>
	}
	if (!(bh = bread(inode->i_dev,inode->i_zone[0]))) {
    f0bd:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    f0c4:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    f0c8:	0f b7 d0             	movzwl %ax,%edx
    f0cb:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    f0d2:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    f0d6:	0f b7 c0             	movzwl %ax,%eax
    f0d9:	83 ec 08             	sub    $0x8,%esp
    f0dc:	52                   	push   %edx
    f0dd:	50                   	push   %eax
    f0de:	e8 03 df ff ff       	call   cfe6 <bread>
    f0e3:	83 c4 10             	add    $0x10,%esp
    f0e6:	89 84 24 c4 04 00 00 	mov    %eax,0x4c4(%esp)
    f0ed:	83 bc 24 c4 04 00 00 	cmpl   $0x0,0x4c4(%esp)
    f0f4:	00 
    f0f5:	75 10                	jne    f107 <do_execve+0x257>
		retval = -EACCES;
    f0f7:	c7 84 24 e0 04 00 00 	movl   $0xfffffff3,0x4e0(%esp)
    f0fe:	f3 ff ff ff 
		goto exec_error2;
    f102:	e9 03 08 00 00       	jmp    f90a <do_execve+0xa5a>
	}
	ex = *((struct exec *) bh->b_data);	/* read exec-header */
    f107:	8b 84 24 c4 04 00 00 	mov    0x4c4(%esp),%eax
    f10e:	8b 00                	mov    (%eax),%eax
    f110:	8b 10                	mov    (%eax),%edx
    f112:	89 94 24 94 04 00 00 	mov    %edx,0x494(%esp)
    f119:	8b 50 04             	mov    0x4(%eax),%edx
    f11c:	89 94 24 98 04 00 00 	mov    %edx,0x498(%esp)
    f123:	8b 50 08             	mov    0x8(%eax),%edx
    f126:	89 94 24 9c 04 00 00 	mov    %edx,0x49c(%esp)
    f12d:	8b 50 0c             	mov    0xc(%eax),%edx
    f130:	89 94 24 a0 04 00 00 	mov    %edx,0x4a0(%esp)
    f137:	8b 50 10             	mov    0x10(%eax),%edx
    f13a:	89 94 24 a4 04 00 00 	mov    %edx,0x4a4(%esp)
    f141:	8b 50 14             	mov    0x14(%eax),%edx
    f144:	89 94 24 a8 04 00 00 	mov    %edx,0x4a8(%esp)
    f14b:	8b 50 18             	mov    0x18(%eax),%edx
    f14e:	89 94 24 ac 04 00 00 	mov    %edx,0x4ac(%esp)
    f155:	8b 40 1c             	mov    0x1c(%eax),%eax
    f158:	89 84 24 b0 04 00 00 	mov    %eax,0x4b0(%esp)
	if ((bh->b_data[0] == '#') && (bh->b_data[1] == '!') && (!sh_bang)) {
    f15f:	8b 84 24 c4 04 00 00 	mov    0x4c4(%esp),%eax
    f166:	8b 00                	mov    (%eax),%eax
    f168:	0f b6 00             	movzbl (%eax),%eax
    f16b:	3c 23                	cmp    $0x23,%al
    f16d:	0f 85 64 03 00 00    	jne    f4d7 <do_execve+0x627>
    f173:	8b 84 24 c4 04 00 00 	mov    0x4c4(%esp),%eax
    f17a:	8b 00                	mov    (%eax),%eax
    f17c:	83 c0 01             	add    $0x1,%eax
    f17f:	0f b6 00             	movzbl (%eax),%eax
    f182:	3c 21                	cmp    $0x21,%al
    f184:	0f 85 4d 03 00 00    	jne    f4d7 <do_execve+0x627>
    f18a:	83 bc 24 dc 04 00 00 	cmpl   $0x0,0x4dc(%esp)
    f191:	00 
    f192:	0f 85 3f 03 00 00    	jne    f4d7 <do_execve+0x627>
		 */

		char buf[1023], *cp, *interp, *i_name, *i_arg;
		unsigned long old_fs;

		strncpy(buf, bh->b_data+2, 1022);
    f198:	8b 84 24 c4 04 00 00 	mov    0x4c4(%esp),%eax
    f19f:	8b 00                	mov    (%eax),%eax
    f1a1:	83 c0 02             	add    $0x2,%eax
    f1a4:	83 ec 04             	sub    $0x4,%esp
    f1a7:	68 fe 03 00 00       	push   $0x3fe
    f1ac:	50                   	push   %eax
    f1ad:	8d 44 24 19          	lea    0x19(%esp),%eax
    f1b1:	50                   	push   %eax
    f1b2:	e8 15 f7 ff ff       	call   e8cc <strncpy>
    f1b7:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
    f1ba:	83 ec 0c             	sub    $0xc,%esp
    f1bd:	ff b4 24 d0 04 00 00 	pushl  0x4d0(%esp)
    f1c4:	e8 c7 dd ff ff       	call   cf90 <brelse>
    f1c9:	83 c4 10             	add    $0x10,%esp
		iput(inode);
    f1cc:	83 ec 0c             	sub    $0xc,%esp
    f1cf:	ff b4 24 f8 04 00 00 	pushl  0x4f8(%esp)
    f1d6:	e8 96 ce ff ff       	call   c071 <iput>
    f1db:	83 c4 10             	add    $0x10,%esp
		buf[1022] = '\0';
    f1de:	c6 84 24 0b 04 00 00 	movb   $0x0,0x40b(%esp)
    f1e5:	00 
		if ((cp = strchr(buf, '\n'))) {
    f1e6:	83 ec 08             	sub    $0x8,%esp
    f1e9:	6a 0a                	push   $0xa
    f1eb:	8d 44 24 19          	lea    0x19(%esp),%eax
    f1ef:	50                   	push   %eax
    f1f0:	e8 fc f6 ff ff       	call   e8f1 <strchr>
    f1f5:	83 c4 10             	add    $0x10,%esp
    f1f8:	89 84 24 d4 04 00 00 	mov    %eax,0x4d4(%esp)
    f1ff:	83 bc 24 d4 04 00 00 	cmpl   $0x0,0x4d4(%esp)
    f206:	00 
    f207:	74 3b                	je     f244 <do_execve+0x394>
			*cp = '\0';
    f209:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f210:	c6 00 00             	movb   $0x0,(%eax)
			for (cp = buf; (*cp == ' ') || (*cp == '\t'); cp++);
    f213:	8d 44 24 0d          	lea    0xd(%esp),%eax
    f217:	89 84 24 d4 04 00 00 	mov    %eax,0x4d4(%esp)
    f21e:	eb 08                	jmp    f228 <do_execve+0x378>
    f220:	83 84 24 d4 04 00 00 	addl   $0x1,0x4d4(%esp)
    f227:	01 
    f228:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f22f:	0f b6 00             	movzbl (%eax),%eax
    f232:	3c 20                	cmp    $0x20,%al
    f234:	74 ea                	je     f220 <do_execve+0x370>
    f236:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f23d:	0f b6 00             	movzbl (%eax),%eax
    f240:	3c 09                	cmp    $0x9,%al
    f242:	74 dc                	je     f220 <do_execve+0x370>
		}
		if (!cp || *cp == '\0') {
    f244:	83 bc 24 d4 04 00 00 	cmpl   $0x0,0x4d4(%esp)
    f24b:	00 
    f24c:	74 0e                	je     f25c <do_execve+0x3ac>
    f24e:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f255:	0f b6 00             	movzbl (%eax),%eax
    f258:	84 c0                	test   %al,%al
    f25a:	75 10                	jne    f26c <do_execve+0x3bc>
			retval = -ENOEXEC; /* No interpreter name found */
    f25c:	c7 84 24 e0 04 00 00 	movl   $0xfffffff8,0x4e0(%esp)
    f263:	f8 ff ff ff 
			goto exec_error1;
    f267:	e9 b0 06 00 00       	jmp    f91c <do_execve+0xa6c>
		}
		interp = i_name = cp;
    f26c:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f273:	89 84 24 10 04 00 00 	mov    %eax,0x410(%esp)
    f27a:	8b 84 24 10 04 00 00 	mov    0x410(%esp),%eax
    f281:	89 84 24 c0 04 00 00 	mov    %eax,0x4c0(%esp)
		i_arg = 0;
    f288:	c7 84 24 0c 04 00 00 	movl   $0x0,0x40c(%esp)
    f28f:	00 00 00 00 
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
    f293:	eb 27                	jmp    f2bc <do_execve+0x40c>
 			if (*cp == '/')
    f295:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f29c:	0f b6 00             	movzbl (%eax),%eax
    f29f:	3c 2f                	cmp    $0x2f,%al
    f2a1:	75 11                	jne    f2b4 <do_execve+0x404>
				i_name = cp+1;
    f2a3:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f2aa:	83 c0 01             	add    $0x1,%eax
    f2ad:	89 84 24 10 04 00 00 	mov    %eax,0x410(%esp)
			retval = -ENOEXEC; /* No interpreter name found */
			goto exec_error1;
		}
		interp = i_name = cp;
		i_arg = 0;
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
    f2b4:	83 84 24 d4 04 00 00 	addl   $0x1,0x4d4(%esp)
    f2bb:	01 
    f2bc:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f2c3:	0f b6 00             	movzbl (%eax),%eax
    f2c6:	84 c0                	test   %al,%al
    f2c8:	74 1c                	je     f2e6 <do_execve+0x436>
    f2ca:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f2d1:	0f b6 00             	movzbl (%eax),%eax
    f2d4:	3c 20                	cmp    $0x20,%al
    f2d6:	74 0e                	je     f2e6 <do_execve+0x436>
    f2d8:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f2df:	0f b6 00             	movzbl (%eax),%eax
    f2e2:	3c 09                	cmp    $0x9,%al
    f2e4:	75 af                	jne    f295 <do_execve+0x3e5>
 			if (*cp == '/')
				i_name = cp+1;
		}
		if (*cp) {
    f2e6:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f2ed:	0f b6 00             	movzbl (%eax),%eax
    f2f0:	84 c0                	test   %al,%al
    f2f2:	74 22                	je     f316 <do_execve+0x466>
			*cp++ = '\0';
    f2f4:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f2fb:	8d 50 01             	lea    0x1(%eax),%edx
    f2fe:	89 94 24 d4 04 00 00 	mov    %edx,0x4d4(%esp)
    f305:	c6 00 00             	movb   $0x0,(%eax)
			i_arg = cp;
    f308:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    f30f:	89 84 24 0c 04 00 00 	mov    %eax,0x40c(%esp)
		}
		/*
		 * OK, we've parsed out the interpreter name and
		 * (optional) argument.
		 */
		if (sh_bang++ == 0) {
    f316:	8b 84 24 dc 04 00 00 	mov    0x4dc(%esp),%eax
    f31d:	8d 50 01             	lea    0x1(%eax),%edx
    f320:	89 94 24 dc 04 00 00 	mov    %edx,0x4dc(%esp)
    f327:	85 c0                	test   %eax,%eax
    f329:	75 6e                	jne    f399 <do_execve+0x4e9>
			p = copy_strings(envc, envp, page, p, 0);
    f32b:	83 ec 0c             	sub    $0xc,%esp
    f32e:	6a 00                	push   $0x0
    f330:	ff b4 24 e8 04 00 00 	pushl  0x4e8(%esp)
    f337:	8d 84 24 28 04 00 00 	lea    0x428(%esp),%eax
    f33e:	50                   	push   %eax
    f33f:	ff b4 24 28 05 00 00 	pushl  0x528(%esp)
    f346:	ff b4 24 ec 04 00 00 	pushl  0x4ec(%esp)
    f34d:	e8 f5 f7 ff ff       	call   eb47 <copy_strings>
    f352:	83 c4 20             	add    $0x20,%esp
    f355:	89 84 24 d8 04 00 00 	mov    %eax,0x4d8(%esp)
			p = copy_strings(--argc, argv+1, page, p, 0);
    f35c:	8b 84 24 0c 05 00 00 	mov    0x50c(%esp),%eax
    f363:	8d 50 04             	lea    0x4(%eax),%edx
    f366:	83 ac 24 e4 04 00 00 	subl   $0x1,0x4e4(%esp)
    f36d:	01 
    f36e:	83 ec 0c             	sub    $0xc,%esp
    f371:	6a 00                	push   $0x0
    f373:	ff b4 24 e8 04 00 00 	pushl  0x4e8(%esp)
    f37a:	8d 84 24 28 04 00 00 	lea    0x428(%esp),%eax
    f381:	50                   	push   %eax
    f382:	52                   	push   %edx
    f383:	ff b4 24 00 05 00 00 	pushl  0x500(%esp)
    f38a:	e8 b8 f7 ff ff       	call   eb47 <copy_strings>
    f38f:	83 c4 20             	add    $0x20,%esp
    f392:	89 84 24 d8 04 00 00 	mov    %eax,0x4d8(%esp)
		 *           (3) filename of shell script
		 *
		 * This is done in reverse order, because of how the
		 * user environment and arguments are stored.
		 */
		p = copy_strings(1, &filename, page, p, 1);
    f399:	83 ec 0c             	sub    $0xc,%esp
    f39c:	6a 01                	push   $0x1
    f39e:	ff b4 24 e8 04 00 00 	pushl  0x4e8(%esp)
    f3a5:	8d 84 24 28 04 00 00 	lea    0x428(%esp),%eax
    f3ac:	50                   	push   %eax
    f3ad:	8d 84 24 20 05 00 00 	lea    0x520(%esp),%eax
    f3b4:	50                   	push   %eax
    f3b5:	6a 01                	push   $0x1
    f3b7:	e8 8b f7 ff ff       	call   eb47 <copy_strings>
    f3bc:	83 c4 20             	add    $0x20,%esp
    f3bf:	89 84 24 d8 04 00 00 	mov    %eax,0x4d8(%esp)
		argc++;
    f3c6:	83 84 24 e4 04 00 00 	addl   $0x1,0x4e4(%esp)
    f3cd:	01 
		if (i_arg) {
    f3ce:	8b 84 24 0c 04 00 00 	mov    0x40c(%esp),%eax
    f3d5:	85 c0                	test   %eax,%eax
    f3d7:	74 35                	je     f40e <do_execve+0x55e>
			p = copy_strings(1, &i_arg, page, p, 2);
    f3d9:	83 ec 0c             	sub    $0xc,%esp
    f3dc:	6a 02                	push   $0x2
    f3de:	ff b4 24 e8 04 00 00 	pushl  0x4e8(%esp)
    f3e5:	8d 84 24 28 04 00 00 	lea    0x428(%esp),%eax
    f3ec:	50                   	push   %eax
    f3ed:	8d 84 24 24 04 00 00 	lea    0x424(%esp),%eax
    f3f4:	50                   	push   %eax
    f3f5:	6a 01                	push   $0x1
    f3f7:	e8 4b f7 ff ff       	call   eb47 <copy_strings>
    f3fc:	83 c4 20             	add    $0x20,%esp
    f3ff:	89 84 24 d8 04 00 00 	mov    %eax,0x4d8(%esp)
			argc++;
    f406:	83 84 24 e4 04 00 00 	addl   $0x1,0x4e4(%esp)
    f40d:	01 
		}
		p = copy_strings(1, &i_name, page, p, 2);
    f40e:	83 ec 0c             	sub    $0xc,%esp
    f411:	6a 02                	push   $0x2
    f413:	ff b4 24 e8 04 00 00 	pushl  0x4e8(%esp)
    f41a:	8d 84 24 28 04 00 00 	lea    0x428(%esp),%eax
    f421:	50                   	push   %eax
    f422:	8d 84 24 28 04 00 00 	lea    0x428(%esp),%eax
    f429:	50                   	push   %eax
    f42a:	6a 01                	push   $0x1
    f42c:	e8 16 f7 ff ff       	call   eb47 <copy_strings>
    f431:	83 c4 20             	add    $0x20,%esp
    f434:	89 84 24 d8 04 00 00 	mov    %eax,0x4d8(%esp)
		argc++;
    f43b:	83 84 24 e4 04 00 00 	addl   $0x1,0x4e4(%esp)
    f442:	01 
		if (!p) {
    f443:	83 bc 24 d8 04 00 00 	cmpl   $0x0,0x4d8(%esp)
    f44a:	00 
    f44b:	75 10                	jne    f45d <do_execve+0x5ad>
			retval = -ENOMEM;
    f44d:	c7 84 24 e0 04 00 00 	movl   $0xfffffff4,0x4e0(%esp)
    f454:	f4 ff ff ff 
			goto exec_error1;
    f458:	e9 bf 04 00 00       	jmp    f91c <do_execve+0xa6c>
		}
		/*
		 * OK, now restart the process with the interpreter's inode.
		 */
		old_fs = get_fs();
    f45d:	e8 40 f5 ff ff       	call   e9a2 <get_fs>
    f462:	89 84 24 bc 04 00 00 	mov    %eax,0x4bc(%esp)
		set_fs(get_ds());
    f469:	e8 48 f5 ff ff       	call   e9b6 <get_ds>
    f46e:	83 ec 0c             	sub    $0xc,%esp
    f471:	50                   	push   %eax
    f472:	e8 53 f5 ff ff       	call   e9ca <set_fs>
    f477:	83 c4 10             	add    $0x10,%esp
		if (!(inode=namei(interp))) { /* get executables inode */
    f47a:	83 ec 0c             	sub    $0xc,%esp
    f47d:	ff b4 24 cc 04 00 00 	pushl  0x4cc(%esp)
    f484:	e8 8f 12 00 00       	call   10718 <namei>
    f489:	83 c4 10             	add    $0x10,%esp
    f48c:	89 84 24 ec 04 00 00 	mov    %eax,0x4ec(%esp)
    f493:	83 bc 24 ec 04 00 00 	cmpl   $0x0,0x4ec(%esp)
    f49a:	00 
    f49b:	75 23                	jne    f4c0 <do_execve+0x610>
			set_fs(old_fs);
    f49d:	83 ec 0c             	sub    $0xc,%esp
    f4a0:	ff b4 24 c8 04 00 00 	pushl  0x4c8(%esp)
    f4a7:	e8 1e f5 ff ff       	call   e9ca <set_fs>
    f4ac:	83 c4 10             	add    $0x10,%esp
			retval = -ENOENT;
    f4af:	c7 84 24 e0 04 00 00 	movl   $0xfffffffe,0x4e0(%esp)
    f4b6:	fe ff ff ff 
			goto exec_error1;
    f4ba:	90                   	nop
    f4bb:	e9 5c 04 00 00       	jmp    f91c <do_execve+0xa6c>
		}
		set_fs(old_fs);
    f4c0:	83 ec 0c             	sub    $0xc,%esp
    f4c3:	ff b4 24 c8 04 00 00 	pushl  0x4c8(%esp)
    f4ca:	e8 fb f4 ff ff       	call   e9ca <set_fs>
    f4cf:	83 c4 10             	add    $0x10,%esp
    f4d2:	e9 ad fa ff ff       	jmp    ef84 <do_execve+0xd4>
		goto restart_interp;
	}
	brelse(bh);
    f4d7:	83 ec 0c             	sub    $0xc,%esp
    f4da:	ff b4 24 d0 04 00 00 	pushl  0x4d0(%esp)
    f4e1:	e8 aa da ff ff       	call   cf90 <brelse>
    f4e6:	83 c4 10             	add    $0x10,%esp
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
    f4e9:	8b 84 24 94 04 00 00 	mov    0x494(%esp),%eax
    f4f0:	3d 0b 01 00 00       	cmp    $0x10b,%eax
    f4f5:	75 7a                	jne    f571 <do_execve+0x6c1>
    f4f7:	8b 84 24 ac 04 00 00 	mov    0x4ac(%esp),%eax
    f4fe:	85 c0                	test   %eax,%eax
    f500:	75 6f                	jne    f571 <do_execve+0x6c1>
    f502:	8b 84 24 b0 04 00 00 	mov    0x4b0(%esp),%eax
    f509:	85 c0                	test   %eax,%eax
    f50b:	75 64                	jne    f571 <do_execve+0x6c1>
		ex.a_text+ex.a_data+ex.a_bss>0x3000000 ||
    f50d:	8b 94 24 98 04 00 00 	mov    0x498(%esp),%edx
    f514:	8b 84 24 9c 04 00 00 	mov    0x49c(%esp),%eax
    f51b:	01 c2                	add    %eax,%edx
    f51d:	8b 84 24 a0 04 00 00 	mov    0x4a0(%esp),%eax
    f524:	01 d0                	add    %edx,%eax
		}
		set_fs(old_fs);
		goto restart_interp;
	}
	brelse(bh);
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
    f526:	3d 00 00 00 03       	cmp    $0x3000000,%eax
    f52b:	77 44                	ja     f571 <do_execve+0x6c1>
		ex.a_text+ex.a_data+ex.a_bss>0x3000000 ||
		inode->i_size < ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) {
    f52d:	8b 84 24 ec 04 00 00 	mov    0x4ec(%esp),%eax
    f534:	8b 40 04             	mov    0x4(%eax),%eax
    f537:	8b 8c 24 98 04 00 00 	mov    0x498(%esp),%ecx
    f53e:	8b 94 24 9c 04 00 00 	mov    0x49c(%esp),%edx
    f545:	01 d1                	add    %edx,%ecx
    f547:	8b 94 24 a4 04 00 00 	mov    0x4a4(%esp),%edx
    f54e:	01 d1                	add    %edx,%ecx
    f550:	8b 94 24 94 04 00 00 	mov    0x494(%esp),%edx
    f557:	81 fa 0b 01 00 00    	cmp    $0x10b,%edx
    f55d:	75 07                	jne    f566 <do_execve+0x6b6>
    f55f:	ba 00 04 00 00       	mov    $0x400,%edx
    f564:	eb 05                	jmp    f56b <do_execve+0x6bb>
    f566:	ba 20 00 00 00       	mov    $0x20,%edx
    f56b:	01 ca                	add    %ecx,%edx
		set_fs(old_fs);
		goto restart_interp;
	}
	brelse(bh);
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
		ex.a_text+ex.a_data+ex.a_bss>0x3000000 ||
    f56d:	39 d0                	cmp    %edx,%eax
    f56f:	73 10                	jae    f581 <do_execve+0x6d1>
		inode->i_size < ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) {
		retval = -ENOEXEC;
    f571:	c7 84 24 e0 04 00 00 	movl   $0xfffffff8,0x4e0(%esp)
    f578:	f8 ff ff ff 
		goto exec_error2;
    f57c:	e9 89 03 00 00       	jmp    f90a <do_execve+0xa5a>
	}
	if (N_TXTOFF(ex) != BLOCK_SIZE) {
    f581:	8b 84 24 94 04 00 00 	mov    0x494(%esp),%eax
    f588:	3d 0b 01 00 00       	cmp    $0x10b,%eax
    f58d:	74 28                	je     f5b7 <do_execve+0x707>
		printk("%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.", filename);
    f58f:	8b 84 24 08 05 00 00 	mov    0x508(%esp),%eax
    f596:	83 ec 08             	sub    $0x8,%esp
    f599:	50                   	push   %eax
    f59a:	68 84 89 01 00       	push   $0x18984
    f59f:	e8 69 92 ff ff       	call   880d <printk>
    f5a4:	83 c4 10             	add    $0x10,%esp
		retval = -ENOEXEC;
    f5a7:	c7 84 24 e0 04 00 00 	movl   $0xfffffff8,0x4e0(%esp)
    f5ae:	f8 ff ff ff 
		goto exec_error2;
    f5b2:	e9 53 03 00 00       	jmp    f90a <do_execve+0xa5a>
	}
	if (!sh_bang) {
    f5b7:	83 bc 24 dc 04 00 00 	cmpl   $0x0,0x4dc(%esp)
    f5be:	00 
    f5bf:	75 7c                	jne    f63d <do_execve+0x78d>
		p = copy_strings(envc,envp,page,p,0);
    f5c1:	83 ec 0c             	sub    $0xc,%esp
    f5c4:	6a 00                	push   $0x0
    f5c6:	ff b4 24 e8 04 00 00 	pushl  0x4e8(%esp)
    f5cd:	8d 84 24 28 04 00 00 	lea    0x428(%esp),%eax
    f5d4:	50                   	push   %eax
    f5d5:	ff b4 24 28 05 00 00 	pushl  0x528(%esp)
    f5dc:	ff b4 24 ec 04 00 00 	pushl  0x4ec(%esp)
    f5e3:	e8 5f f5 ff ff       	call   eb47 <copy_strings>
    f5e8:	83 c4 20             	add    $0x20,%esp
    f5eb:	89 84 24 d8 04 00 00 	mov    %eax,0x4d8(%esp)
		p = copy_strings(argc,argv,page,p,0);
    f5f2:	83 ec 0c             	sub    $0xc,%esp
    f5f5:	6a 00                	push   $0x0
    f5f7:	ff b4 24 e8 04 00 00 	pushl  0x4e8(%esp)
    f5fe:	8d 84 24 28 04 00 00 	lea    0x428(%esp),%eax
    f605:	50                   	push   %eax
    f606:	ff b4 24 24 05 00 00 	pushl  0x524(%esp)
    f60d:	ff b4 24 00 05 00 00 	pushl  0x500(%esp)
    f614:	e8 2e f5 ff ff       	call   eb47 <copy_strings>
    f619:	83 c4 20             	add    $0x20,%esp
    f61c:	89 84 24 d8 04 00 00 	mov    %eax,0x4d8(%esp)
		if (!p) {
    f623:	83 bc 24 d8 04 00 00 	cmpl   $0x0,0x4d8(%esp)
    f62a:	00 
    f62b:	75 10                	jne    f63d <do_execve+0x78d>
			retval = -ENOMEM;
    f62d:	c7 84 24 e0 04 00 00 	movl   $0xfffffff4,0x4e0(%esp)
    f634:	f4 ff ff ff 
			goto exec_error2;
    f638:	e9 cd 02 00 00       	jmp    f90a <do_execve+0xa5a>
		}
	}
/* OK, This is the point of no return */
	if (current->executable)
    f63d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f642:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    f648:	85 c0                	test   %eax,%eax
    f64a:	74 17                	je     f663 <do_execve+0x7b3>
		iput(current->executable);
    f64c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f651:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    f657:	83 ec 0c             	sub    $0xc,%esp
    f65a:	50                   	push   %eax
    f65b:	e8 11 ca ff ff       	call   c071 <iput>
    f660:	83 c4 10             	add    $0x10,%esp
	current->executable = inode;
    f663:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f668:	8b 94 24 ec 04 00 00 	mov    0x4ec(%esp),%edx
    f66f:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
	for (i=0 ; i<32 ; i++) {
    f675:	c7 84 24 e8 04 00 00 	movl   $0x0,0x4e8(%esp)
    f67c:	00 00 00 00 
    f680:	eb 3d                	jmp    f6bf <do_execve+0x80f>
		if (current->sigaction[i].sa_handler != SIG_IGN)
    f682:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f687:	8b 94 24 e8 04 00 00 	mov    0x4e8(%esp),%edx
    f68e:	83 c2 01             	add    $0x1,%edx
    f691:	c1 e2 04             	shl    $0x4,%edx
    f694:	01 d0                	add    %edx,%eax
    f696:	8b 00                	mov    (%eax),%eax
    f698:	83 f8 01             	cmp    $0x1,%eax
    f69b:	74 1a                	je     f6b7 <do_execve+0x807>
			current->sigaction[i].sa_handler = NULL;
    f69d:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f6a2:	8b 94 24 e8 04 00 00 	mov    0x4e8(%esp),%edx
    f6a9:	83 c2 01             	add    $0x1,%edx
    f6ac:	c1 e2 04             	shl    $0x4,%edx
    f6af:	01 d0                	add    %edx,%eax
    f6b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
/* OK, This is the point of no return */
	if (current->executable)
		iput(current->executable);
	current->executable = inode;
	for (i=0 ; i<32 ; i++) {
    f6b7:	83 84 24 e8 04 00 00 	addl   $0x1,0x4e8(%esp)
    f6be:	01 
    f6bf:	83 bc 24 e8 04 00 00 	cmpl   $0x1f,0x4e8(%esp)
    f6c6:	1f 
    f6c7:	7e b9                	jle    f682 <do_execve+0x7d2>
		if (current->sigaction[i].sa_handler != SIG_IGN)
			current->sigaction[i].sa_handler = NULL;
	}
	for (i=0 ; i<NR_OPEN ; i++)
    f6c9:	c7 84 24 e8 04 00 00 	movl   $0x0,0x4e8(%esp)
    f6d0:	00 00 00 00 
    f6d4:	eb 39                	jmp    f70f <do_execve+0x85f>
		if ((current->close_on_exec>>i)&1)
    f6d6:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f6db:	8b 90 7c 02 00 00    	mov    0x27c(%eax),%edx
    f6e1:	8b 84 24 e8 04 00 00 	mov    0x4e8(%esp),%eax
    f6e8:	89 c1                	mov    %eax,%ecx
    f6ea:	d3 ea                	shr    %cl,%edx
    f6ec:	89 d0                	mov    %edx,%eax
    f6ee:	83 e0 01             	and    $0x1,%eax
    f6f1:	85 c0                	test   %eax,%eax
    f6f3:	74 12                	je     f707 <do_execve+0x857>
			sys_close(i);
    f6f5:	83 ec 0c             	sub    $0xc,%esp
    f6f8:	ff b4 24 f4 04 00 00 	pushl  0x4f4(%esp)
    f6ff:	e8 49 be ff ff       	call   b54d <sys_close>
    f704:	83 c4 10             	add    $0x10,%esp
	current->executable = inode;
	for (i=0 ; i<32 ; i++) {
		if (current->sigaction[i].sa_handler != SIG_IGN)
			current->sigaction[i].sa_handler = NULL;
	}
	for (i=0 ; i<NR_OPEN ; i++)
    f707:	83 84 24 e8 04 00 00 	addl   $0x1,0x4e8(%esp)
    f70e:	01 
    f70f:	83 bc 24 e8 04 00 00 	cmpl   $0x13,0x4e8(%esp)
    f716:	13 
    f717:	7e bd                	jle    f6d6 <do_execve+0x826>
		if ((current->close_on_exec>>i)&1)
			sys_close(i);
	current->close_on_exec = 0;
    f719:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f71e:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%eax)
    f725:	00 00 00 
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
    f728:	b8 0f 00 00 00       	mov    $0xf,%eax
    f72d:	0f 03 c0             	lsl    %ax,%eax
    f730:	40                   	inc    %eax
    f731:	89 84 24 b8 04 00 00 	mov    %eax,0x4b8(%esp)
    f738:	8b 9c 24 b8 04 00 00 	mov    0x4b8(%esp),%ebx
    f73f:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f744:	05 d8 02 00 00       	add    $0x2d8,%eax
    f749:	83 ec 0c             	sub    $0xc,%esp
    f74c:	50                   	push   %eax
    f74d:	e8 d3 f1 ff ff       	call   e925 <_get_base>
    f752:	83 c4 10             	add    $0x10,%esp
    f755:	83 ec 08             	sub    $0x8,%esp
    f758:	53                   	push   %ebx
    f759:	50                   	push   %eax
    f75a:	e8 d5 ac ff ff       	call   a434 <free_page_tables>
    f75f:	83 c4 10             	add    $0x10,%esp
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
    f762:	b8 17 00 00 00       	mov    $0x17,%eax
    f767:	0f 03 c0             	lsl    %ax,%eax
    f76a:	40                   	inc    %eax
    f76b:	89 84 24 b4 04 00 00 	mov    %eax,0x4b4(%esp)
    f772:	8b 9c 24 b4 04 00 00 	mov    0x4b4(%esp),%ebx
    f779:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f77e:	05 e0 02 00 00       	add    $0x2e0,%eax
    f783:	83 ec 0c             	sub    $0xc,%esp
    f786:	50                   	push   %eax
    f787:	e8 99 f1 ff ff       	call   e925 <_get_base>
    f78c:	83 c4 10             	add    $0x10,%esp
    f78f:	83 ec 08             	sub    $0x8,%esp
    f792:	53                   	push   %ebx
    f793:	50                   	push   %eax
    f794:	e8 9b ac ff ff       	call   a434 <free_page_tables>
    f799:	83 c4 10             	add    $0x10,%esp
	if (last_task_used_math == current)
    f79c:	8b 15 e8 1e 02 00    	mov    0x21ee8,%edx
    f7a2:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f7a7:	39 c2                	cmp    %eax,%edx
    f7a9:	75 0a                	jne    f7b5 <do_execve+0x905>
		last_task_used_math = NULL;
    f7ab:	c7 05 e8 1e 02 00 00 	movl   $0x0,0x21ee8
    f7b2:	00 00 00 
	current->used_math = 0;
    f7b5:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f7ba:	66 c7 80 64 02 00 00 	movw   $0x0,0x264(%eax)
    f7c1:	00 00 
	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;
    f7c3:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
    f7ca:	83 ec 08             	sub    $0x8,%esp
    f7cd:	8d 94 24 1c 04 00 00 	lea    0x41c(%esp),%edx
    f7d4:	52                   	push   %edx
    f7d5:	50                   	push   %eax
    f7d6:	e8 4c f5 ff ff       	call   ed27 <change_ldt>
    f7db:	83 c4 10             	add    $0x10,%esp
    f7de:	2d 00 00 02 00       	sub    $0x20000,%eax
    f7e3:	01 84 24 d8 04 00 00 	add    %eax,0x4d8(%esp)
	p = (unsigned long) create_tables((char *)p,argc,envc);
    f7ea:	8b 84 24 d8 04 00 00 	mov    0x4d8(%esp),%eax
    f7f1:	83 ec 04             	sub    $0x4,%esp
    f7f4:	ff b4 24 d4 04 00 00 	pushl  0x4d4(%esp)
    f7fb:	ff b4 24 ec 04 00 00 	pushl  0x4ec(%esp)
    f802:	50                   	push   %eax
    f803:	e8 ca f1 ff ff       	call   e9d2 <create_tables>
    f808:	83 c4 10             	add    $0x10,%esp
    f80b:	89 84 24 d8 04 00 00 	mov    %eax,0x4d8(%esp)
	current->brk = ex.a_bss +
    f812:	8b 0d 40 f1 01 00    	mov    0x1f140,%ecx
    f818:	8b b4 24 a0 04 00 00 	mov    0x4a0(%esp),%esi
		(current->end_data = ex.a_data +
    f81f:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f824:	8b bc 24 9c 04 00 00 	mov    0x49c(%esp),%edi
		(current->end_code = ex.a_text));
    f82b:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    f831:	8b 9c 24 98 04 00 00 	mov    0x498(%esp),%ebx
    f838:	89 9a 1c 02 00 00    	mov    %ebx,0x21c(%edx)
    f83e:	8b 92 1c 02 00 00    	mov    0x21c(%edx),%edx
		last_task_used_math = NULL;
	current->used_math = 0;
	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;
	p = (unsigned long) create_tables((char *)p,argc,envc);
	current->brk = ex.a_bss +
		(current->end_data = ex.a_data +
    f844:	01 fa                	add    %edi,%edx
    f846:	89 90 20 02 00 00    	mov    %edx,0x220(%eax)
    f84c:	8b 80 20 02 00 00    	mov    0x220(%eax),%eax
	if (last_task_used_math == current)
		last_task_used_math = NULL;
	current->used_math = 0;
	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;
	p = (unsigned long) create_tables((char *)p,argc,envc);
	current->brk = ex.a_bss +
    f852:	01 f0                	add    %esi,%eax
    f854:	89 81 24 02 00 00    	mov    %eax,0x224(%ecx)
		(current->end_data = ex.a_data +
		(current->end_code = ex.a_text));
	current->start_stack = p & 0xfffff000;
    f85a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f85f:	8b 94 24 d8 04 00 00 	mov    0x4d8(%esp),%edx
    f866:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
    f86c:	89 90 28 02 00 00    	mov    %edx,0x228(%eax)
	current->euid = e_uid;
    f872:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f877:	8b 94 24 cc 04 00 00 	mov    0x4cc(%esp),%edx
    f87e:	66 89 90 42 02 00 00 	mov    %dx,0x242(%eax)
	current->egid = e_gid;
    f885:	a1 40 f1 01 00       	mov    0x1f140,%eax
    f88a:	8b 94 24 c8 04 00 00 	mov    0x4c8(%esp),%edx
    f891:	66 89 90 48 02 00 00 	mov    %dx,0x248(%eax)
	i = ex.a_text+ex.a_data;
    f898:	8b 94 24 98 04 00 00 	mov    0x498(%esp),%edx
    f89f:	8b 84 24 9c 04 00 00 	mov    0x49c(%esp),%eax
    f8a6:	01 d0                	add    %edx,%eax
    f8a8:	89 84 24 e8 04 00 00 	mov    %eax,0x4e8(%esp)
	while (i&0xfff)
    f8af:	eb 1f                	jmp    f8d0 <do_execve+0xa20>
		put_fs_byte(0,(char *) (i++));
    f8b1:	8b 84 24 e8 04 00 00 	mov    0x4e8(%esp),%eax
    f8b8:	8d 50 01             	lea    0x1(%eax),%edx
    f8bb:	89 94 24 e8 04 00 00 	mov    %edx,0x4e8(%esp)
    f8c2:	83 ec 08             	sub    $0x8,%esp
    f8c5:	50                   	push   %eax
    f8c6:	6a 00                	push   $0x0
    f8c8:	e8 ae f0 ff ff       	call   e97b <put_fs_byte>
    f8cd:	83 c4 10             	add    $0x10,%esp
		(current->end_code = ex.a_text));
	current->start_stack = p & 0xfffff000;
	current->euid = e_uid;
	current->egid = e_gid;
	i = ex.a_text+ex.a_data;
	while (i&0xfff)
    f8d0:	8b 84 24 e8 04 00 00 	mov    0x4e8(%esp),%eax
    f8d7:	25 ff 0f 00 00       	and    $0xfff,%eax
    f8dc:	85 c0                	test   %eax,%eax
    f8de:	75 d1                	jne    f8b1 <do_execve+0xa01>
		put_fs_byte(0,(char *) (i++));
	eip[0] = ex.a_entry;		/* eip, magic happens :-) */
    f8e0:	8b 94 24 a8 04 00 00 	mov    0x4a8(%esp),%edx
    f8e7:	8b 84 24 00 05 00 00 	mov    0x500(%esp),%eax
    f8ee:	89 10                	mov    %edx,(%eax)
	eip[3] = p;			/* stack pointer */
    f8f0:	8b 84 24 00 05 00 00 	mov    0x500(%esp),%eax
    f8f7:	8d 50 0c             	lea    0xc(%eax),%edx
    f8fa:	8b 84 24 d8 04 00 00 	mov    0x4d8(%esp),%eax
    f901:	89 02                	mov    %eax,(%edx)
	return 0;
    f903:	b8 00 00 00 00       	mov    $0x0,%eax
    f908:	eb 52                	jmp    f95c <do_execve+0xaac>
exec_error2:
	iput(inode);
    f90a:	83 ec 0c             	sub    $0xc,%esp
    f90d:	ff b4 24 f8 04 00 00 	pushl  0x4f8(%esp)
    f914:	e8 58 c7 ff ff       	call   c071 <iput>
    f919:	83 c4 10             	add    $0x10,%esp
exec_error1:
	for (i=0 ; i<MAX_ARG_PAGES ; i++)
    f91c:	c7 84 24 e8 04 00 00 	movl   $0x0,0x4e8(%esp)
    f923:	00 00 00 00 
    f927:	eb 22                	jmp    f94b <do_execve+0xa9b>
		free_page(page[i]);
    f929:	8b 84 24 e8 04 00 00 	mov    0x4e8(%esp),%eax
    f930:	8b 84 84 14 04 00 00 	mov    0x414(%esp,%eax,4),%eax
    f937:	83 ec 0c             	sub    $0xc,%esp
    f93a:	50                   	push   %eax
    f93b:	e8 7a aa ff ff       	call   a3ba <free_page>
    f940:	83 c4 10             	add    $0x10,%esp
	eip[3] = p;			/* stack pointer */
	return 0;
exec_error2:
	iput(inode);
exec_error1:
	for (i=0 ; i<MAX_ARG_PAGES ; i++)
    f943:	83 84 24 e8 04 00 00 	addl   $0x1,0x4e8(%esp)
    f94a:	01 
    f94b:	83 bc 24 e8 04 00 00 	cmpl   $0x1f,0x4e8(%esp)
    f952:	1f 
    f953:	7e d4                	jle    f929 <do_execve+0xa79>
		free_page(page[i]);
	return(retval);
    f955:	8b 84 24 e0 04 00 00 	mov    0x4e0(%esp),%eax
}
    f95c:	81 c4 f0 04 00 00    	add    $0x4f0,%esp
    f962:	5b                   	pop    %ebx
    f963:	5e                   	pop    %esi
    f964:	5f                   	pop    %edi
    f965:	c3                   	ret    

0000f966 <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
    f966:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    f967:	8b 44 24 08          	mov    0x8(%esp),%eax
    f96b:	64 8a 00             	mov    %fs:(%eax),%al
    f96e:	89 c3                	mov    %eax,%ebx
	return _v;
    f970:	89 d8                	mov    %ebx,%eax
}
    f972:	5b                   	pop    %ebx
    f973:	c3                   	ret    

0000f974 <put_fs_byte>:
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
	return _v;
}

static inline void put_fs_byte(char val,char *addr)
{
    f974:	83 ec 04             	sub    $0x4,%esp
    f977:	8b 44 24 08          	mov    0x8(%esp),%eax
    f97b:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    f97e:	0f b6 04 24          	movzbl (%esp),%eax
    f982:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f986:	64 88 02             	mov    %al,%fs:(%edx)
}
    f989:	90                   	nop
    f98a:	83 c4 04             	add    $0x4,%esp
    f98d:	c3                   	ret    

0000f98e <put_fs_long>:
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    f98e:	8b 44 24 04          	mov    0x4(%esp),%eax
    f992:	8b 54 24 08          	mov    0x8(%esp),%edx
    f996:	64 89 02             	mov    %eax,%fs:(%edx)
}
    f999:	90                   	nop
    f99a:	c3                   	ret    

0000f99b <read_pipe>:
#include <linux/sched.h>
#include <linux/mm.h>	/* for get_free_page */
#include <asm/segment.h>

int read_pipe(struct m_inode * inode, char * buf, int count)
{
    f99b:	83 ec 1c             	sub    $0x1c,%esp
	int chars, size, read = 0;
    f99e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    f9a5:	00 

	while (count>0) {
    f9a6:	e9 33 01 00 00       	jmp    fade <read_pipe+0x143>
		while (!(size=PIPE_SIZE(*inode))) {
			wake_up(&inode->i_wait);
    f9ab:	8b 44 24 20          	mov    0x20(%esp),%eax
    f9af:	83 c0 20             	add    $0x20,%eax
    f9b2:	83 ec 0c             	sub    $0xc,%esp
    f9b5:	50                   	push   %eax
    f9b6:	e8 be 75 ff ff       	call   6f79 <wake_up>
    f9bb:	83 c4 10             	add    $0x10,%esp
			if (inode->i_count != 2) /* are there any writers? */
    f9be:	8b 44 24 20          	mov    0x20(%esp),%eax
    f9c2:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f9c6:	66 83 f8 02          	cmp    $0x2,%ax
    f9ca:	74 09                	je     f9d5 <read_pipe+0x3a>
				return read;
    f9cc:	8b 44 24 04          	mov    0x4(%esp),%eax
    f9d0:	e9 2b 01 00 00       	jmp    fb00 <read_pipe+0x165>
			sleep_on(&inode->i_wait);
    f9d5:	8b 44 24 20          	mov    0x20(%esp),%eax
    f9d9:	83 c0 20             	add    $0x20,%eax
    f9dc:	83 ec 0c             	sub    $0xc,%esp
    f9df:	50                   	push   %eax
    f9e0:	e8 8d 74 ff ff       	call   6e72 <sleep_on>
    f9e5:	83 c4 10             	add    $0x10,%esp
int read_pipe(struct m_inode * inode, char * buf, int count)
{
	int chars, size, read = 0;

	while (count>0) {
		while (!(size=PIPE_SIZE(*inode))) {
    f9e8:	8b 44 24 20          	mov    0x20(%esp),%eax
    f9ec:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    f9f0:	0f b7 d0             	movzwl %ax,%edx
    f9f3:	8b 44 24 20          	mov    0x20(%esp),%eax
    f9f7:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    f9fb:	0f b7 c0             	movzwl %ax,%eax
    f9fe:	29 c2                	sub    %eax,%edx
    fa00:	89 d0                	mov    %edx,%eax
    fa02:	25 ff 0f 00 00       	and    $0xfff,%eax
    fa07:	89 44 24 08          	mov    %eax,0x8(%esp)
    fa0b:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    fa10:	74 99                	je     f9ab <read_pipe+0x10>
			wake_up(&inode->i_wait);
			if (inode->i_count != 2) /* are there any writers? */
				return read;
			sleep_on(&inode->i_wait);
		}
		chars = PAGE_SIZE-PIPE_TAIL(*inode);
    fa12:	8b 44 24 20          	mov    0x20(%esp),%eax
    fa16:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    fa1a:	0f b7 c0             	movzwl %ax,%eax
    fa1d:	ba 00 10 00 00       	mov    $0x1000,%edx
    fa22:	29 c2                	sub    %eax,%edx
    fa24:	89 d0                	mov    %edx,%eax
    fa26:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (chars > count)
    fa2a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fa2e:	3b 44 24 28          	cmp    0x28(%esp),%eax
    fa32:	7e 08                	jle    fa3c <read_pipe+0xa1>
			chars = count;
    fa34:	8b 44 24 28          	mov    0x28(%esp),%eax
    fa38:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (chars > size)
    fa3c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fa40:	3b 44 24 08          	cmp    0x8(%esp),%eax
    fa44:	7e 08                	jle    fa4e <read_pipe+0xb3>
			chars = size;
    fa46:	8b 44 24 08          	mov    0x8(%esp),%eax
    fa4a:	89 44 24 0c          	mov    %eax,0xc(%esp)
		count -= chars;
    fa4e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fa52:	29 44 24 28          	sub    %eax,0x28(%esp)
		read += chars;
    fa56:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fa5a:	01 44 24 04          	add    %eax,0x4(%esp)
		size = PIPE_TAIL(*inode);
    fa5e:	8b 44 24 20          	mov    0x20(%esp),%eax
    fa62:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    fa66:	0f b7 c0             	movzwl %ax,%eax
    fa69:	89 44 24 08          	mov    %eax,0x8(%esp)
		PIPE_TAIL(*inode) += chars;
    fa6d:	8b 44 24 20          	mov    0x20(%esp),%eax
    fa71:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    fa75:	8b 54 24 0c          	mov    0xc(%esp),%edx
    fa79:	01 c2                	add    %eax,%edx
    fa7b:	8b 44 24 20          	mov    0x20(%esp),%eax
    fa7f:	66 89 50 10          	mov    %dx,0x10(%eax)
		PIPE_TAIL(*inode) &= (PAGE_SIZE-1);
    fa83:	8b 44 24 20          	mov    0x20(%esp),%eax
    fa87:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    fa8b:	66 25 ff 0f          	and    $0xfff,%ax
    fa8f:	89 c2                	mov    %eax,%edx
    fa91:	8b 44 24 20          	mov    0x20(%esp),%eax
    fa95:	66 89 50 10          	mov    %dx,0x10(%eax)
		while (chars-->0)
    fa99:	eb 34                	jmp    facf <read_pipe+0x134>
			put_fs_byte(((char *)inode->i_size)[size++],buf++);
    fa9b:	8b 44 24 24          	mov    0x24(%esp),%eax
    fa9f:	8d 50 01             	lea    0x1(%eax),%edx
    faa2:	89 54 24 24          	mov    %edx,0x24(%esp)
    faa6:	8b 54 24 08          	mov    0x8(%esp),%edx
    faaa:	8d 4a 01             	lea    0x1(%edx),%ecx
    faad:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    fab1:	89 d1                	mov    %edx,%ecx
    fab3:	8b 54 24 20          	mov    0x20(%esp),%edx
    fab7:	8b 52 04             	mov    0x4(%edx),%edx
    faba:	01 ca                	add    %ecx,%edx
    fabc:	0f b6 12             	movzbl (%edx),%edx
    fabf:	0f be d2             	movsbl %dl,%edx
    fac2:	83 ec 08             	sub    $0x8,%esp
    fac5:	50                   	push   %eax
    fac6:	52                   	push   %edx
    fac7:	e8 a8 fe ff ff       	call   f974 <put_fs_byte>
    facc:	83 c4 10             	add    $0x10,%esp
		count -= chars;
		read += chars;
		size = PIPE_TAIL(*inode);
		PIPE_TAIL(*inode) += chars;
		PIPE_TAIL(*inode) &= (PAGE_SIZE-1);
		while (chars-->0)
    facf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fad3:	8d 50 ff             	lea    -0x1(%eax),%edx
    fad6:	89 54 24 0c          	mov    %edx,0xc(%esp)
    fada:	85 c0                	test   %eax,%eax
    fadc:	7f bd                	jg     fa9b <read_pipe+0x100>

int read_pipe(struct m_inode * inode, char * buf, int count)
{
	int chars, size, read = 0;

	while (count>0) {
    fade:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    fae3:	0f 8f ff fe ff ff    	jg     f9e8 <read_pipe+0x4d>
		PIPE_TAIL(*inode) += chars;
		PIPE_TAIL(*inode) &= (PAGE_SIZE-1);
		while (chars-->0)
			put_fs_byte(((char *)inode->i_size)[size++],buf++);
	}
	wake_up(&inode->i_wait);
    fae9:	8b 44 24 20          	mov    0x20(%esp),%eax
    faed:	83 c0 20             	add    $0x20,%eax
    faf0:	83 ec 0c             	sub    $0xc,%esp
    faf3:	50                   	push   %eax
    faf4:	e8 80 74 ff ff       	call   6f79 <wake_up>
    faf9:	83 c4 10             	add    $0x10,%esp
	return read;
    fafc:	8b 44 24 04          	mov    0x4(%esp),%eax
}
    fb00:	83 c4 1c             	add    $0x1c,%esp
    fb03:	c3                   	ret    

0000fb04 <write_pipe>:
	
int write_pipe(struct m_inode * inode, char * buf, int count)
{
    fb04:	53                   	push   %ebx
    fb05:	83 ec 18             	sub    $0x18,%esp
	int chars, size, written = 0;
    fb08:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    fb0f:	00 

	while (count>0) {
    fb10:	e9 5b 01 00 00       	jmp    fc70 <write_pipe+0x16c>
		while (!(size=(PAGE_SIZE-1)-PIPE_SIZE(*inode))) {
			wake_up(&inode->i_wait);
    fb15:	8b 44 24 20          	mov    0x20(%esp),%eax
    fb19:	83 c0 20             	add    $0x20,%eax
    fb1c:	83 ec 0c             	sub    $0xc,%esp
    fb1f:	50                   	push   %eax
    fb20:	e8 54 74 ff ff       	call   6f79 <wake_up>
    fb25:	83 c4 10             	add    $0x10,%esp
			if (inode->i_count != 2) { /* no readers */
    fb28:	8b 44 24 20          	mov    0x20(%esp),%eax
    fb2c:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    fb30:	66 83 f8 02          	cmp    $0x2,%ax
    fb34:	74 2e                	je     fb64 <write_pipe+0x60>
				current->signal |= (1<<(SIGPIPE-1));
    fb36:	a1 40 f1 01 00       	mov    0x1f140,%eax
    fb3b:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
    fb41:	8b 52 0c             	mov    0xc(%edx),%edx
    fb44:	80 ce 10             	or     $0x10,%dh
    fb47:	89 50 0c             	mov    %edx,0xc(%eax)
				return written?written:-1;
    fb4a:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    fb4f:	74 09                	je     fb5a <write_pipe+0x56>
    fb51:	8b 44 24 04          	mov    0x4(%esp),%eax
    fb55:	e9 38 01 00 00       	jmp    fc92 <write_pipe+0x18e>
    fb5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    fb5f:	e9 2e 01 00 00       	jmp    fc92 <write_pipe+0x18e>
			}
			sleep_on(&inode->i_wait);
    fb64:	8b 44 24 20          	mov    0x20(%esp),%eax
    fb68:	83 c0 20             	add    $0x20,%eax
    fb6b:	83 ec 0c             	sub    $0xc,%esp
    fb6e:	50                   	push   %eax
    fb6f:	e8 fe 72 ff ff       	call   6e72 <sleep_on>
    fb74:	83 c4 10             	add    $0x10,%esp
int write_pipe(struct m_inode * inode, char * buf, int count)
{
	int chars, size, written = 0;

	while (count>0) {
		while (!(size=(PAGE_SIZE-1)-PIPE_SIZE(*inode))) {
    fb77:	8b 44 24 20          	mov    0x20(%esp),%eax
    fb7b:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    fb7f:	0f b7 d0             	movzwl %ax,%edx
    fb82:	8b 44 24 20          	mov    0x20(%esp),%eax
    fb86:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    fb8a:	0f b7 c0             	movzwl %ax,%eax
    fb8d:	29 c2                	sub    %eax,%edx
    fb8f:	89 d0                	mov    %edx,%eax
    fb91:	f7 d0                	not    %eax
    fb93:	25 ff 0f 00 00       	and    $0xfff,%eax
    fb98:	89 44 24 08          	mov    %eax,0x8(%esp)
    fb9c:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    fba1:	0f 84 6e ff ff ff    	je     fb15 <write_pipe+0x11>
				current->signal |= (1<<(SIGPIPE-1));
				return written?written:-1;
			}
			sleep_on(&inode->i_wait);
		}
		chars = PAGE_SIZE-PIPE_HEAD(*inode);
    fba7:	8b 44 24 20          	mov    0x20(%esp),%eax
    fbab:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    fbaf:	0f b7 c0             	movzwl %ax,%eax
    fbb2:	ba 00 10 00 00       	mov    $0x1000,%edx
    fbb7:	29 c2                	sub    %eax,%edx
    fbb9:	89 d0                	mov    %edx,%eax
    fbbb:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (chars > count)
    fbbf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fbc3:	3b 44 24 28          	cmp    0x28(%esp),%eax
    fbc7:	7e 08                	jle    fbd1 <write_pipe+0xcd>
			chars = count;
    fbc9:	8b 44 24 28          	mov    0x28(%esp),%eax
    fbcd:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (chars > size)
    fbd1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fbd5:	3b 44 24 08          	cmp    0x8(%esp),%eax
    fbd9:	7e 08                	jle    fbe3 <write_pipe+0xdf>
			chars = size;
    fbdb:	8b 44 24 08          	mov    0x8(%esp),%eax
    fbdf:	89 44 24 0c          	mov    %eax,0xc(%esp)
		count -= chars;
    fbe3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fbe7:	29 44 24 28          	sub    %eax,0x28(%esp)
		written += chars;
    fbeb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fbef:	01 44 24 04          	add    %eax,0x4(%esp)
		size = PIPE_HEAD(*inode);
    fbf3:	8b 44 24 20          	mov    0x20(%esp),%eax
    fbf7:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    fbfb:	0f b7 c0             	movzwl %ax,%eax
    fbfe:	89 44 24 08          	mov    %eax,0x8(%esp)
		PIPE_HEAD(*inode) += chars;
    fc02:	8b 44 24 20          	mov    0x20(%esp),%eax
    fc06:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    fc0a:	8b 54 24 0c          	mov    0xc(%esp),%edx
    fc0e:	01 c2                	add    %eax,%edx
    fc10:	8b 44 24 20          	mov    0x20(%esp),%eax
    fc14:	66 89 50 0e          	mov    %dx,0xe(%eax)
		PIPE_HEAD(*inode) &= (PAGE_SIZE-1);
    fc18:	8b 44 24 20          	mov    0x20(%esp),%eax
    fc1c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    fc20:	66 25 ff 0f          	and    $0xfff,%ax
    fc24:	89 c2                	mov    %eax,%edx
    fc26:	8b 44 24 20          	mov    0x20(%esp),%eax
    fc2a:	66 89 50 0e          	mov    %dx,0xe(%eax)
		while (chars-->0)
    fc2e:	eb 31                	jmp    fc61 <write_pipe+0x15d>
			((char *)inode->i_size)[size++]=get_fs_byte(buf++);
    fc30:	8b 44 24 08          	mov    0x8(%esp),%eax
    fc34:	8d 50 01             	lea    0x1(%eax),%edx
    fc37:	89 54 24 08          	mov    %edx,0x8(%esp)
    fc3b:	89 c2                	mov    %eax,%edx
    fc3d:	8b 44 24 20          	mov    0x20(%esp),%eax
    fc41:	8b 40 04             	mov    0x4(%eax),%eax
    fc44:	01 d0                	add    %edx,%eax
    fc46:	89 c3                	mov    %eax,%ebx
    fc48:	8b 44 24 24          	mov    0x24(%esp),%eax
    fc4c:	8d 50 01             	lea    0x1(%eax),%edx
    fc4f:	89 54 24 24          	mov    %edx,0x24(%esp)
    fc53:	83 ec 0c             	sub    $0xc,%esp
    fc56:	50                   	push   %eax
    fc57:	e8 0a fd ff ff       	call   f966 <get_fs_byte>
    fc5c:	83 c4 10             	add    $0x10,%esp
    fc5f:	88 03                	mov    %al,(%ebx)
		count -= chars;
		written += chars;
		size = PIPE_HEAD(*inode);
		PIPE_HEAD(*inode) += chars;
		PIPE_HEAD(*inode) &= (PAGE_SIZE-1);
		while (chars-->0)
    fc61:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc65:	8d 50 ff             	lea    -0x1(%eax),%edx
    fc68:	89 54 24 0c          	mov    %edx,0xc(%esp)
    fc6c:	85 c0                	test   %eax,%eax
    fc6e:	7f c0                	jg     fc30 <write_pipe+0x12c>
	
int write_pipe(struct m_inode * inode, char * buf, int count)
{
	int chars, size, written = 0;

	while (count>0) {
    fc70:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    fc75:	0f 8f fc fe ff ff    	jg     fb77 <write_pipe+0x73>
		PIPE_HEAD(*inode) += chars;
		PIPE_HEAD(*inode) &= (PAGE_SIZE-1);
		while (chars-->0)
			((char *)inode->i_size)[size++]=get_fs_byte(buf++);
	}
	wake_up(&inode->i_wait);
    fc7b:	8b 44 24 20          	mov    0x20(%esp),%eax
    fc7f:	83 c0 20             	add    $0x20,%eax
    fc82:	83 ec 0c             	sub    $0xc,%esp
    fc85:	50                   	push   %eax
    fc86:	e8 ee 72 ff ff       	call   6f79 <wake_up>
    fc8b:	83 c4 10             	add    $0x10,%esp
	return written;
    fc8e:	8b 44 24 04          	mov    0x4(%esp),%eax
}
    fc92:	83 c4 18             	add    $0x18,%esp
    fc95:	5b                   	pop    %ebx
    fc96:	c3                   	ret    

0000fc97 <sys_pipe>:

int sys_pipe(unsigned long * fildes)
{
    fc97:	56                   	push   %esi
    fc98:	53                   	push   %ebx
    fc99:	83 ec 24             	sub    $0x24,%esp
	struct m_inode * inode;
	struct file * f[2];
	int fd[2];
	int i,j;

	j=0;
    fc9c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    fca3:	00 
	for(i=0;j<2 && i<NR_FILE;i++)
    fca4:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    fcab:	00 
    fcac:	eb 44                	jmp    fcf2 <sys_pipe+0x5b>
		if (!file_table[i].f_count)
    fcae:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    fcb2:	c1 e0 04             	shl    $0x4,%eax
    fcb5:	05 e4 56 02 00       	add    $0x256e4,%eax
    fcba:	0f b7 00             	movzwl (%eax),%eax
    fcbd:	66 85 c0             	test   %ax,%ax
    fcc0:	75 2b                	jne    fced <sys_pipe+0x56>
			(f[j++]=i+file_table)->f_count++;
    fcc2:	8b 44 24 18          	mov    0x18(%esp),%eax
    fcc6:	8d 50 01             	lea    0x1(%eax),%edx
    fcc9:	89 54 24 18          	mov    %edx,0x18(%esp)
    fccd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    fcd1:	c1 e2 04             	shl    $0x4,%edx
    fcd4:	81 c2 e0 56 02 00    	add    $0x256e0,%edx
    fcda:	89 54 84 0c          	mov    %edx,0xc(%esp,%eax,4)
    fcde:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
    fce2:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    fce6:	83 c2 01             	add    $0x1,%edx
    fce9:	66 89 50 04          	mov    %dx,0x4(%eax)
	struct file * f[2];
	int fd[2];
	int i,j;

	j=0;
	for(i=0;j<2 && i<NR_FILE;i++)
    fced:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    fcf2:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
    fcf7:	7f 07                	jg     fd00 <sys_pipe+0x69>
    fcf9:	83 7c 24 1c 3f       	cmpl   $0x3f,0x1c(%esp)
    fcfe:	7e ae                	jle    fcae <sys_pipe+0x17>
		if (!file_table[i].f_count)
			(f[j++]=i+file_table)->f_count++;
	if (j==1)
    fd00:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
    fd05:	75 0a                	jne    fd11 <sys_pipe+0x7a>
		f[0]->f_count=0;
    fd07:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fd0b:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
	if (j<2)
    fd11:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
    fd16:	7f 0a                	jg     fd22 <sys_pipe+0x8b>
		return -1;
    fd18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    fd1d:	e9 7a 01 00 00       	jmp    fe9c <sys_pipe+0x205>
	j=0;
    fd22:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    fd29:	00 
	for(i=0;j<2 && i<NR_OPEN;i++)
    fd2a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    fd31:	00 
    fd32:	eb 4a                	jmp    fd7e <sys_pipe+0xe7>
		if (!current->filp[i]) {
    fd34:	a1 40 f1 01 00       	mov    0x1f140,%eax
    fd39:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    fd3d:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    fd43:	8b 04 90             	mov    (%eax,%edx,4),%eax
    fd46:	85 c0                	test   %eax,%eax
    fd48:	75 2f                	jne    fd79 <sys_pipe+0xe2>
			current->filp[ fd[j]=i ] = f[j];
    fd4a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    fd4f:	8b 54 24 18          	mov    0x18(%esp),%edx
    fd53:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    fd57:	89 4c 94 04          	mov    %ecx,0x4(%esp,%edx,4)
    fd5b:	8b 54 24 18          	mov    0x18(%esp),%edx
    fd5f:	8b 4c 94 04          	mov    0x4(%esp,%edx,4),%ecx
    fd63:	8b 54 24 18          	mov    0x18(%esp),%edx
    fd67:	8b 54 94 0c          	mov    0xc(%esp,%edx,4),%edx
    fd6b:	81 c1 a0 00 00 00    	add    $0xa0,%ecx
    fd71:	89 14 88             	mov    %edx,(%eax,%ecx,4)
			j++;
    fd74:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
	if (j==1)
		f[0]->f_count=0;
	if (j<2)
		return -1;
	j=0;
	for(i=0;j<2 && i<NR_OPEN;i++)
    fd79:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
    fd7e:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
    fd83:	7f 07                	jg     fd8c <sys_pipe+0xf5>
    fd85:	83 7c 24 1c 13       	cmpl   $0x13,0x1c(%esp)
    fd8a:	7e a8                	jle    fd34 <sys_pipe+0x9d>
		if (!current->filp[i]) {
			current->filp[ fd[j]=i ] = f[j];
			j++;
		}
	if (j==1)
    fd8c:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
    fd91:	75 16                	jne    fda9 <sys_pipe+0x112>
		current->filp[fd[0]]=NULL;
    fd93:	a1 40 f1 01 00       	mov    0x1f140,%eax
    fd98:	8b 54 24 04          	mov    0x4(%esp),%edx
    fd9c:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    fda2:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
	if (j<2) {
    fda9:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
    fdae:	7f 20                	jg     fdd0 <sys_pipe+0x139>
		f[0]->f_count=f[1]->f_count=0;
    fdb0:	8b 54 24 0c          	mov    0xc(%esp),%edx
    fdb4:	8b 44 24 10          	mov    0x10(%esp),%eax
    fdb8:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
    fdbe:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    fdc2:	66 89 42 04          	mov    %ax,0x4(%edx)
		return -1;
    fdc6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    fdcb:	e9 cc 00 00 00       	jmp    fe9c <sys_pipe+0x205>
	}
	if (!(inode=get_pipe_inode())) {
    fdd0:	e8 a7 c5 ff ff       	call   c37c <get_pipe_inode>
    fdd5:	89 44 24 14          	mov    %eax,0x14(%esp)
    fdd9:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    fdde:	75 4f                	jne    fe2f <sys_pipe+0x198>
		current->filp[fd[0]] =
    fde0:	8b 0d 40 f1 01 00    	mov    0x1f140,%ecx
    fde6:	8b 74 24 04          	mov    0x4(%esp),%esi
			current->filp[fd[1]] = NULL;
    fdea:	a1 40 f1 01 00       	mov    0x1f140,%eax
    fdef:	8b 54 24 08          	mov    0x8(%esp),%edx
    fdf3:	8d 9a a0 00 00 00    	lea    0xa0(%edx),%ebx
    fdf9:	c7 04 98 00 00 00 00 	movl   $0x0,(%eax,%ebx,4)
    fe00:	81 c2 a0 00 00 00    	add    $0xa0,%edx
    fe06:	8b 04 90             	mov    (%eax,%edx,4),%eax
	if (j<2) {
		f[0]->f_count=f[1]->f_count=0;
		return -1;
	}
	if (!(inode=get_pipe_inode())) {
		current->filp[fd[0]] =
    fe09:	8d 96 a0 00 00 00    	lea    0xa0(%esi),%edx
    fe0f:	89 04 91             	mov    %eax,(%ecx,%edx,4)
			current->filp[fd[1]] = NULL;
		f[0]->f_count = f[1]->f_count = 0;
    fe12:	8b 54 24 0c          	mov    0xc(%esp),%edx
    fe16:	8b 44 24 10          	mov    0x10(%esp),%eax
    fe1a:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
    fe20:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    fe24:	66 89 42 04          	mov    %ax,0x4(%edx)
		return -1;
    fe28:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    fe2d:	eb 6d                	jmp    fe9c <sys_pipe+0x205>
	}
	f[0]->f_inode = f[1]->f_inode = inode;
    fe2f:	8b 54 24 0c          	mov    0xc(%esp),%edx
    fe33:	8b 44 24 10          	mov    0x10(%esp),%eax
    fe37:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    fe3b:	89 48 08             	mov    %ecx,0x8(%eax)
    fe3e:	8b 40 08             	mov    0x8(%eax),%eax
    fe41:	89 42 08             	mov    %eax,0x8(%edx)
	f[0]->f_pos = f[1]->f_pos = 0;
    fe44:	8b 54 24 0c          	mov    0xc(%esp),%edx
    fe48:	8b 44 24 10          	mov    0x10(%esp),%eax
    fe4c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    fe53:	8b 40 0c             	mov    0xc(%eax),%eax
    fe56:	89 42 0c             	mov    %eax,0xc(%edx)
	f[0]->f_mode = 1;		/* read */
    fe59:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fe5d:	66 c7 00 01 00       	movw   $0x1,(%eax)
	f[1]->f_mode = 2;		/* write */
    fe62:	8b 44 24 10          	mov    0x10(%esp),%eax
    fe66:	66 c7 00 02 00       	movw   $0x2,(%eax)
	put_fs_long(fd[0],0+fildes);
    fe6b:	8b 44 24 04          	mov    0x4(%esp),%eax
    fe6f:	83 ec 08             	sub    $0x8,%esp
    fe72:	ff 74 24 38          	pushl  0x38(%esp)
    fe76:	50                   	push   %eax
    fe77:	e8 12 fb ff ff       	call   f98e <put_fs_long>
    fe7c:	83 c4 10             	add    $0x10,%esp
	put_fs_long(fd[1],1+fildes);
    fe7f:	8b 44 24 30          	mov    0x30(%esp),%eax
    fe83:	83 c0 04             	add    $0x4,%eax
    fe86:	8b 54 24 08          	mov    0x8(%esp),%edx
    fe8a:	83 ec 08             	sub    $0x8,%esp
    fe8d:	50                   	push   %eax
    fe8e:	52                   	push   %edx
    fe8f:	e8 fa fa ff ff       	call   f98e <put_fs_long>
    fe94:	83 c4 10             	add    $0x10,%esp
	return 0;
    fe97:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fe9c:	83 c4 24             	add    $0x24,%esp
    fe9f:	5b                   	pop    %ebx
    fea0:	5e                   	pop    %esi
    fea1:	c3                   	ret    

0000fea2 <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
    fea2:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    fea3:	8b 44 24 08          	mov    0x8(%esp),%eax
    fea7:	64 8a 00             	mov    %fs:(%eax),%al
    feaa:	89 c3                	mov    %eax,%ebx
	return _v;
    feac:	89 d8                	mov    %ebx,%eax
}
    feae:	5b                   	pop    %ebx
    feaf:	c3                   	ret    

0000feb0 <strcpy>:
 *
 *		(C) 1991 Linus Torvalds
 */
 
static inline char * strcpy(char * dest,const char *src)
{
    feb0:	57                   	push   %edi
    feb1:	56                   	push   %esi
__asm__("cld\n"
    feb2:	8b 44 24 10          	mov    0x10(%esp),%eax
    feb6:	8b 54 24 0c          	mov    0xc(%esp),%edx
    feba:	89 c6                	mov    %eax,%esi
    febc:	89 d7                	mov    %edx,%edi
    febe:	fc                   	cld    
    febf:	ac                   	lods   %ds:(%esi),%al
    fec0:	aa                   	stos   %al,%es:(%edi)
    fec1:	84 c0                	test   %al,%al
    fec3:	75 fa                	jne    febf <strcpy+0xf>
	"1:\tlodsb\n\t"
	"stosb\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b"
	::"S" (src),"D" (dest));
return dest;
    fec5:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    fec9:	5e                   	pop    %esi
    feca:	5f                   	pop    %edi
    fecb:	c3                   	ret    

0000fecc <strcmp>:
	);
return dest;
}

static inline int strcmp(const char * cs,const char * ct)
{
    fecc:	57                   	push   %edi
    fecd:	56                   	push   %esi
    fece:	53                   	push   %ebx
register int __res ;
__asm__("cld\n"
    fecf:	8b 44 24 10          	mov    0x10(%esp),%eax
    fed3:	8b 54 24 14          	mov    0x14(%esp),%edx
    fed7:	89 c7                	mov    %eax,%edi
    fed9:	89 d6                	mov    %edx,%esi
    fedb:	fc                   	cld    
    fedc:	ac                   	lods   %ds:(%esi),%al
    fedd:	ae                   	scas   %es:(%edi),%al
    fede:	75 08                	jne    fee8 <strcmp+0x1c>
    fee0:	84 c0                	test   %al,%al
    fee2:	75 f8                	jne    fedc <strcmp+0x10>
    fee4:	31 c0                	xor    %eax,%eax
    fee6:	eb 09                	jmp    fef1 <strcmp+0x25>
    fee8:	b8 01 00 00 00       	mov    $0x1,%eax
    feed:	7c 02                	jl     fef1 <strcmp+0x25>
    feef:	f7 d8                	neg    %eax
    fef1:	89 c3                	mov    %eax,%ebx
	"2:\tmovl $1,%%eax\n\t"
	"jl 3f\n\t"
	"negl %%eax\n"
	"3:"
	:"=a" (__res):"D" (cs),"S" (ct));
return __res;
    fef3:	89 d8                	mov    %ebx,%eax
}
    fef5:	5b                   	pop    %ebx
    fef6:	5e                   	pop    %esi
    fef7:	5f                   	pop    %edi
    fef8:	c3                   	ret    

0000fef9 <permission>:
 * is used to check for read/write/execute permissions on a file.
 * I don't know if we should look at just the euid or both euid and
 * uid, but that should be easily changed.
 */
static int permission(struct m_inode * inode,int mask)
{
    fef9:	83 ec 10             	sub    $0x10,%esp
	int mode = inode->i_mode;
    fefc:	8b 44 24 14          	mov    0x14(%esp),%eax
    ff00:	0f b7 00             	movzwl (%eax),%eax
    ff03:	0f b7 c0             	movzwl %ax,%eax
    ff06:	89 44 24 0c          	mov    %eax,0xc(%esp)

/* special case: not even root can read/write a deleted file */
	if (inode->i_dev && !inode->i_nlinks)
    ff0a:	8b 44 24 14          	mov    0x14(%esp),%eax
    ff0e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    ff12:	66 85 c0             	test   %ax,%ax
    ff15:	74 13                	je     ff2a <permission+0x31>
    ff17:	8b 44 24 14          	mov    0x14(%esp),%eax
    ff1b:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    ff1f:	84 c0                	test   %al,%al
    ff21:	75 07                	jne    ff2a <permission+0x31>
		return 0;
    ff23:	b8 00 00 00 00       	mov    $0x0,%eax
    ff28:	eb 6f                	jmp    ff99 <permission+0xa0>
	else if (current->euid==inode->i_uid)
    ff2a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ff2f:	0f b7 90 42 02 00 00 	movzwl 0x242(%eax),%edx
    ff36:	8b 44 24 14          	mov    0x14(%esp),%eax
    ff3a:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    ff3e:	66 39 c2             	cmp    %ax,%dx
    ff41:	75 07                	jne    ff4a <permission+0x51>
		mode >>= 6;
    ff43:	c1 7c 24 0c 06       	sarl   $0x6,0xc(%esp)
    ff48:	eb 21                	jmp    ff6b <permission+0x72>
	else if (current->egid==inode->i_gid)
    ff4a:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ff4f:	0f b7 90 48 02 00 00 	movzwl 0x248(%eax),%edx
    ff56:	8b 44 24 14          	mov    0x14(%esp),%eax
    ff5a:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    ff5e:	0f b6 c0             	movzbl %al,%eax
    ff61:	66 39 c2             	cmp    %ax,%dx
    ff64:	75 05                	jne    ff6b <permission+0x72>
		mode >>= 3;
    ff66:	c1 7c 24 0c 03       	sarl   $0x3,0xc(%esp)
	if (((mode & mask & 0007) == mask) || suser())
    ff6b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ff6f:	23 44 24 18          	and    0x18(%esp),%eax
    ff73:	83 e0 07             	and    $0x7,%eax
    ff76:	3b 44 24 18          	cmp    0x18(%esp),%eax
    ff7a:	74 11                	je     ff8d <permission+0x94>
    ff7c:	a1 40 f1 01 00       	mov    0x1f140,%eax
    ff81:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    ff88:	66 85 c0             	test   %ax,%ax
    ff8b:	75 07                	jne    ff94 <permission+0x9b>
		return 1;
    ff8d:	b8 01 00 00 00       	mov    $0x1,%eax
    ff92:	eb 05                	jmp    ff99 <permission+0xa0>
	return 0;
    ff94:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ff99:	83 c4 10             	add    $0x10,%esp
    ff9c:	c3                   	ret    

0000ff9d <match>:
 * some sanity tests.
 *
 * NOTE! unlike strncmp, match returns 1 for success, 0 for failure.
 */
static int match(int len,const char * name,struct dir_entry * de)
{
    ff9d:	57                   	push   %edi
    ff9e:	56                   	push   %esi
    ff9f:	53                   	push   %ebx
	register int same ;

	if (!de || !de->inode || len > NAME_LEN)
    ffa0:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    ffa5:	74 13                	je     ffba <match+0x1d>
    ffa7:	8b 44 24 18          	mov    0x18(%esp),%eax
    ffab:	0f b7 00             	movzwl (%eax),%eax
    ffae:	66 85 c0             	test   %ax,%ax
    ffb1:	74 07                	je     ffba <match+0x1d>
    ffb3:	83 7c 24 10 0e       	cmpl   $0xe,0x10(%esp)
    ffb8:	7e 07                	jle    ffc1 <match+0x24>
		return 0;
    ffba:	b8 00 00 00 00       	mov    $0x0,%eax
    ffbf:	eb 47                	jmp    10008 <match+0x6b>
	if (len < NAME_LEN && de->name[len])
    ffc1:	83 7c 24 10 0d       	cmpl   $0xd,0x10(%esp)
    ffc6:	7f 1b                	jg     ffe3 <match+0x46>
    ffc8:	8b 54 24 18          	mov    0x18(%esp),%edx
    ffcc:	8b 44 24 10          	mov    0x10(%esp),%eax
    ffd0:	01 d0                	add    %edx,%eax
    ffd2:	83 c0 02             	add    $0x2,%eax
    ffd5:	0f b6 00             	movzbl (%eax),%eax
    ffd8:	84 c0                	test   %al,%al
    ffda:	74 07                	je     ffe3 <match+0x46>
		return 0;
    ffdc:	b8 00 00 00 00       	mov    $0x0,%eax
    ffe1:	eb 25                	jmp    10008 <match+0x6b>
	__asm__("cld\n\t"
		"fs ; repe ; cmpsb\n\t"
		"setz %%al"
		:"=a" (same)
		:"0" (0),"S" ((long) name),"D" ((long) de->name),"c" (len)
    ffe3:	8b 54 24 14          	mov    0x14(%esp),%edx
    ffe7:	8b 44 24 18          	mov    0x18(%esp),%eax
    ffeb:	83 c0 02             	add    $0x2,%eax
    ffee:	89 c3                	mov    %eax,%ebx

	if (!de || !de->inode || len > NAME_LEN)
		return 0;
	if (len < NAME_LEN && de->name[len])
		return 0;
	__asm__("cld\n\t"
    fff0:	b8 00 00 00 00       	mov    $0x0,%eax
    fff5:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    fff9:	89 d6                	mov    %edx,%esi
    fffb:	89 df                	mov    %ebx,%edi
    fffd:	fc                   	cld    
    fffe:	64 f3 a6             	repz cmpsb %es:(%edi),%fs:(%esi)
   10001:	0f 94 c0             	sete   %al
   10004:	89 c3                	mov    %eax,%ebx
		"fs ; repe ; cmpsb\n\t"
		"setz %%al"
		:"=a" (same)
		:"0" (0),"S" ((long) name),"D" ((long) de->name),"c" (len)
		);
	return same;
   10006:	89 d8                	mov    %ebx,%eax
}
   10008:	5b                   	pop    %ebx
   10009:	5e                   	pop    %esi
   1000a:	5f                   	pop    %edi
   1000b:	c3                   	ret    

0001000c <find_entry>:
 * This also takes care of the few special cases due to '..'-traversal
 * over a pseudo-root and a mount point.
 */
static struct buffer_head * find_entry(struct m_inode ** dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
   1000c:	83 ec 2c             	sub    $0x2c,%esp

#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
   1000f:	83 7c 24 38 0e       	cmpl   $0xe,0x38(%esp)
   10014:	7e 08                	jle    1001e <find_entry+0x12>
		namelen = NAME_LEN;
   10016:	c7 44 24 38 0e 00 00 	movl   $0xe,0x38(%esp)
   1001d:	00 
#endif
	entries = (*dir)->i_size / (sizeof (struct dir_entry));
   1001e:	8b 44 24 30          	mov    0x30(%esp),%eax
   10022:	8b 00                	mov    (%eax),%eax
   10024:	8b 40 04             	mov    0x4(%eax),%eax
   10027:	c1 e8 04             	shr    $0x4,%eax
   1002a:	89 44 24 10          	mov    %eax,0x10(%esp)
	*res_dir = NULL;
   1002e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   10032:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	if (!namelen)
   10038:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   1003d:	75 0a                	jne    10049 <find_entry+0x3d>
		return NULL;
   1003f:	b8 00 00 00 00       	mov    $0x0,%eax
   10044:	e9 0e 02 00 00       	jmp    10257 <find_entry+0x24b>
/* check for '..', as we might have to do some "magic" for it */
	if (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {
   10049:	83 7c 24 38 02       	cmpl   $0x2,0x38(%esp)
   1004e:	0f 85 b3 00 00 00    	jne    10107 <find_entry+0xfb>
   10054:	ff 74 24 34          	pushl  0x34(%esp)
   10058:	e8 45 fe ff ff       	call   fea2 <get_fs_byte>
   1005d:	83 c4 04             	add    $0x4,%esp
   10060:	3c 2e                	cmp    $0x2e,%al
   10062:	0f 85 9f 00 00 00    	jne    10107 <find_entry+0xfb>
   10068:	8b 44 24 34          	mov    0x34(%esp),%eax
   1006c:	83 c0 01             	add    $0x1,%eax
   1006f:	50                   	push   %eax
   10070:	e8 2d fe ff ff       	call   fea2 <get_fs_byte>
   10075:	83 c4 04             	add    $0x4,%esp
   10078:	3c 2e                	cmp    $0x2e,%al
   1007a:	0f 85 87 00 00 00    	jne    10107 <find_entry+0xfb>
/* '..' in a pseudo-root results in a faked '.' (just change namelen) */
		if ((*dir) == current->root)
   10080:	8b 44 24 30          	mov    0x30(%esp),%eax
   10084:	8b 10                	mov    (%eax),%edx
   10086:	a1 40 f1 01 00       	mov    0x1f140,%eax
   1008b:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   10091:	39 c2                	cmp    %eax,%edx
   10093:	75 0a                	jne    1009f <find_entry+0x93>
			namelen=1;
   10095:	c7 44 24 38 01 00 00 	movl   $0x1,0x38(%esp)
   1009c:	00 
   1009d:	eb 68                	jmp    10107 <find_entry+0xfb>
		else if ((*dir)->i_num == ROOT_INO) {
   1009f:	8b 44 24 30          	mov    0x30(%esp),%eax
   100a3:	8b 00                	mov    (%eax),%eax
   100a5:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
   100a9:	66 83 f8 01          	cmp    $0x1,%ax
   100ad:	75 58                	jne    10107 <find_entry+0xfb>
/* '..' over a mount-point results in 'dir' being exchanged for the mounted
   directory-inode. NOTE! We set mounted, so that we can iput the new dir */
			sb=get_super((*dir)->i_dev);
   100af:	8b 44 24 30          	mov    0x30(%esp),%eax
   100b3:	8b 00                	mov    (%eax),%eax
   100b5:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   100b9:	0f b7 c0             	movzwl %ax,%eax
   100bc:	83 ec 0c             	sub    $0xc,%esp
   100bf:	50                   	push   %eax
   100c0:	e8 8e d3 ff ff       	call   d453 <get_super>
   100c5:	83 c4 10             	add    $0x10,%esp
   100c8:	89 44 24 0c          	mov    %eax,0xc(%esp)
			if (sb->s_imount) {
   100cc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   100d0:	8b 40 5c             	mov    0x5c(%eax),%eax
   100d3:	85 c0                	test   %eax,%eax
   100d5:	74 30                	je     10107 <find_entry+0xfb>
				iput(*dir);
   100d7:	8b 44 24 30          	mov    0x30(%esp),%eax
   100db:	8b 00                	mov    (%eax),%eax
   100dd:	83 ec 0c             	sub    $0xc,%esp
   100e0:	50                   	push   %eax
   100e1:	e8 8b bf ff ff       	call   c071 <iput>
   100e6:	83 c4 10             	add    $0x10,%esp
				(*dir)=sb->s_imount;
   100e9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   100ed:	8b 50 5c             	mov    0x5c(%eax),%edx
   100f0:	8b 44 24 30          	mov    0x30(%esp),%eax
   100f4:	89 10                	mov    %edx,(%eax)
				(*dir)->i_count++;
   100f6:	8b 44 24 30          	mov    0x30(%esp),%eax
   100fa:	8b 00                	mov    (%eax),%eax
   100fc:	0f b7 50 30          	movzwl 0x30(%eax),%edx
   10100:	83 c2 01             	add    $0x1,%edx
   10103:	66 89 50 30          	mov    %dx,0x30(%eax)
			}
		}
	}
	if (!(block = (*dir)->i_zone[0]))
   10107:	8b 44 24 30          	mov    0x30(%esp),%eax
   1010b:	8b 00                	mov    (%eax),%eax
   1010d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   10111:	0f b7 c0             	movzwl %ax,%eax
   10114:	89 44 24 08          	mov    %eax,0x8(%esp)
   10118:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1011d:	75 0a                	jne    10129 <find_entry+0x11d>
		return NULL;
   1011f:	b8 00 00 00 00       	mov    $0x0,%eax
   10124:	e9 2e 01 00 00       	jmp    10257 <find_entry+0x24b>
	if (!(bh = bread((*dir)->i_dev,block)))
   10129:	8b 44 24 30          	mov    0x30(%esp),%eax
   1012d:	8b 00                	mov    (%eax),%eax
   1012f:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10133:	0f b7 c0             	movzwl %ax,%eax
   10136:	83 ec 08             	sub    $0x8,%esp
   10139:	ff 74 24 10          	pushl  0x10(%esp)
   1013d:	50                   	push   %eax
   1013e:	e8 a3 ce ff ff       	call   cfe6 <bread>
   10143:	83 c4 10             	add    $0x10,%esp
   10146:	89 44 24 18          	mov    %eax,0x18(%esp)
   1014a:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   1014f:	75 0a                	jne    1015b <find_entry+0x14f>
		return NULL;
   10151:	b8 00 00 00 00       	mov    $0x0,%eax
   10156:	e9 fc 00 00 00       	jmp    10257 <find_entry+0x24b>
	i = 0;
   1015b:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   10162:	00 
	de = (struct dir_entry *) bh->b_data;
   10163:	8b 44 24 18          	mov    0x18(%esp),%eax
   10167:	8b 00                	mov    (%eax),%eax
   10169:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (i < entries) {
   1016d:	e9 c3 00 00 00       	jmp    10235 <find_entry+0x229>
		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
   10172:	8b 44 24 18          	mov    0x18(%esp),%eax
   10176:	8b 00                	mov    (%eax),%eax
   10178:	05 00 04 00 00       	add    $0x400,%eax
   1017d:	3b 44 24 14          	cmp    0x14(%esp),%eax
   10181:	77 7d                	ja     10200 <find_entry+0x1f4>
			brelse(bh);
   10183:	83 ec 0c             	sub    $0xc,%esp
   10186:	ff 74 24 24          	pushl  0x24(%esp)
   1018a:	e8 01 ce ff ff       	call   cf90 <brelse>
   1018f:	83 c4 10             	add    $0x10,%esp
			bh = NULL;
   10192:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   10199:	00 
			if (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||
   1019a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1019e:	c1 e8 06             	shr    $0x6,%eax
   101a1:	89 c2                	mov    %eax,%edx
   101a3:	8b 44 24 30          	mov    0x30(%esp),%eax
   101a7:	8b 00                	mov    (%eax),%eax
   101a9:	83 ec 08             	sub    $0x8,%esp
   101ac:	52                   	push   %edx
   101ad:	50                   	push   %eax
   101ae:	e8 86 be ff ff       	call   c039 <bmap>
   101b3:	83 c4 10             	add    $0x10,%esp
   101b6:	89 44 24 08          	mov    %eax,0x8(%esp)
   101ba:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   101bf:	74 28                	je     101e9 <find_entry+0x1dd>
			    !(bh = bread((*dir)->i_dev,block))) {
   101c1:	8b 44 24 30          	mov    0x30(%esp),%eax
   101c5:	8b 00                	mov    (%eax),%eax
   101c7:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   101cb:	0f b7 c0             	movzwl %ax,%eax
	de = (struct dir_entry *) bh->b_data;
	while (i < entries) {
		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
			brelse(bh);
			bh = NULL;
			if (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||
   101ce:	83 ec 08             	sub    $0x8,%esp
   101d1:	ff 74 24 10          	pushl  0x10(%esp)
   101d5:	50                   	push   %eax
   101d6:	e8 0b ce ff ff       	call   cfe6 <bread>
   101db:	83 c4 10             	add    $0x10,%esp
   101de:	89 44 24 18          	mov    %eax,0x18(%esp)
   101e2:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   101e7:	75 0d                	jne    101f6 <find_entry+0x1ea>
			    !(bh = bread((*dir)->i_dev,block))) {
				i += DIR_ENTRIES_PER_BLOCK;
   101e9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   101ed:	83 c0 40             	add    $0x40,%eax
   101f0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
				continue;
   101f4:	eb 3f                	jmp    10235 <find_entry+0x229>
			}
			de = (struct dir_entry *) bh->b_data;
   101f6:	8b 44 24 18          	mov    0x18(%esp),%eax
   101fa:	8b 00                	mov    (%eax),%eax
   101fc:	89 44 24 14          	mov    %eax,0x14(%esp)
		}
		if (match(namelen,name,de)) {
   10200:	83 ec 04             	sub    $0x4,%esp
   10203:	ff 74 24 18          	pushl  0x18(%esp)
   10207:	ff 74 24 3c          	pushl  0x3c(%esp)
   1020b:	ff 74 24 44          	pushl  0x44(%esp)
   1020f:	e8 89 fd ff ff       	call   ff9d <match>
   10214:	83 c4 10             	add    $0x10,%esp
   10217:	85 c0                	test   %eax,%eax
   10219:	74 10                	je     1022b <find_entry+0x21f>
			*res_dir = de;
   1021b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   1021f:	8b 54 24 14          	mov    0x14(%esp),%edx
   10223:	89 10                	mov    %edx,(%eax)
			return bh;
   10225:	8b 44 24 18          	mov    0x18(%esp),%eax
   10229:	eb 2c                	jmp    10257 <find_entry+0x24b>
		}
		de++;
   1022b:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
		i++;
   10230:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
		return NULL;
	if (!(bh = bread((*dir)->i_dev,block)))
		return NULL;
	i = 0;
	de = (struct dir_entry *) bh->b_data;
	while (i < entries) {
   10235:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10239:	3b 44 24 10          	cmp    0x10(%esp),%eax
   1023d:	0f 8c 2f ff ff ff    	jl     10172 <find_entry+0x166>
			return bh;
		}
		de++;
		i++;
	}
	brelse(bh);
   10243:	83 ec 0c             	sub    $0xc,%esp
   10246:	ff 74 24 24          	pushl  0x24(%esp)
   1024a:	e8 41 cd ff ff       	call   cf90 <brelse>
   1024f:	83 c4 10             	add    $0x10,%esp
	return NULL;
   10252:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10257:	83 c4 2c             	add    $0x2c,%esp
   1025a:	c3                   	ret    

0001025b <add_entry>:
 * may not sleep between calling this and putting something into
 * the entry, as someone else might have used it while you slept.
 */
static struct buffer_head * add_entry(struct m_inode * dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
   1025b:	83 ec 1c             	sub    $0x1c,%esp
	int block,i;
	struct buffer_head * bh;
	struct dir_entry * de;

	*res_dir = NULL;
   1025e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   10262:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
   10268:	83 7c 24 28 0e       	cmpl   $0xe,0x28(%esp)
   1026d:	7e 08                	jle    10277 <add_entry+0x1c>
		namelen = NAME_LEN;
   1026f:	c7 44 24 28 0e 00 00 	movl   $0xe,0x28(%esp)
   10276:	00 
#endif
	if (!namelen)
   10277:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   1027c:	75 0a                	jne    10288 <add_entry+0x2d>
		return NULL;
   1027e:	b8 00 00 00 00       	mov    $0x0,%eax
   10283:	e9 05 02 00 00       	jmp    1048d <add_entry+0x232>
	if (!(block = dir->i_zone[0]))
   10288:	8b 44 24 20          	mov    0x20(%esp),%eax
   1028c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   10290:	0f b7 c0             	movzwl %ax,%eax
   10293:	89 04 24             	mov    %eax,(%esp)
   10296:	83 3c 24 00          	cmpl   $0x0,(%esp)
   1029a:	75 0a                	jne    102a6 <add_entry+0x4b>
		return NULL;
   1029c:	b8 00 00 00 00       	mov    $0x0,%eax
   102a1:	e9 e7 01 00 00       	jmp    1048d <add_entry+0x232>
	if (!(bh = bread(dir->i_dev,block)))
   102a6:	8b 44 24 20          	mov    0x20(%esp),%eax
   102aa:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   102ae:	0f b7 c0             	movzwl %ax,%eax
   102b1:	83 ec 08             	sub    $0x8,%esp
   102b4:	ff 74 24 08          	pushl  0x8(%esp)
   102b8:	50                   	push   %eax
   102b9:	e8 28 cd ff ff       	call   cfe6 <bread>
   102be:	83 c4 10             	add    $0x10,%esp
   102c1:	89 44 24 08          	mov    %eax,0x8(%esp)
   102c5:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   102ca:	75 0a                	jne    102d6 <add_entry+0x7b>
		return NULL;
   102cc:	b8 00 00 00 00       	mov    $0x0,%eax
   102d1:	e9 b7 01 00 00       	jmp    1048d <add_entry+0x232>
	i = 0;
   102d6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   102dd:	00 
	de = (struct dir_entry *) bh->b_data;
   102de:	8b 44 24 08          	mov    0x8(%esp),%eax
   102e2:	8b 00                	mov    (%eax),%eax
   102e4:	89 44 24 04          	mov    %eax,0x4(%esp)
	while (1) {
		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
   102e8:	8b 44 24 08          	mov    0x8(%esp),%eax
   102ec:	8b 00                	mov    (%eax),%eax
   102ee:	05 00 04 00 00       	add    $0x400,%eax
   102f3:	3b 44 24 04          	cmp    0x4(%esp),%eax
   102f7:	0f 87 81 00 00 00    	ja     1037e <add_entry+0x123>
			brelse(bh);
   102fd:	83 ec 0c             	sub    $0xc,%esp
   10300:	ff 74 24 14          	pushl  0x14(%esp)
   10304:	e8 87 cc ff ff       	call   cf90 <brelse>
   10309:	83 c4 10             	add    $0x10,%esp
			bh = NULL;
   1030c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   10313:	00 
			block = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);
   10314:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10318:	c1 e8 06             	shr    $0x6,%eax
   1031b:	83 ec 08             	sub    $0x8,%esp
   1031e:	50                   	push   %eax
   1031f:	ff 74 24 2c          	pushl  0x2c(%esp)
   10323:	e8 2d bd ff ff       	call   c055 <create_block>
   10328:	83 c4 10             	add    $0x10,%esp
   1032b:	89 04 24             	mov    %eax,(%esp)
			if (!block)
   1032e:	83 3c 24 00          	cmpl   $0x0,(%esp)
   10332:	75 0a                	jne    1033e <add_entry+0xe3>
				return NULL;
   10334:	b8 00 00 00 00       	mov    $0x0,%eax
   10339:	e9 4f 01 00 00       	jmp    1048d <add_entry+0x232>
			if (!(bh = bread(dir->i_dev,block))) {
   1033e:	8b 44 24 20          	mov    0x20(%esp),%eax
   10342:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10346:	0f b7 c0             	movzwl %ax,%eax
   10349:	83 ec 08             	sub    $0x8,%esp
   1034c:	ff 74 24 08          	pushl  0x8(%esp)
   10350:	50                   	push   %eax
   10351:	e8 90 cc ff ff       	call   cfe6 <bread>
   10356:	83 c4 10             	add    $0x10,%esp
   10359:	89 44 24 08          	mov    %eax,0x8(%esp)
   1035d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   10362:	75 10                	jne    10374 <add_entry+0x119>
				i += DIR_ENTRIES_PER_BLOCK;
   10364:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10368:	83 c0 40             	add    $0x40,%eax
   1036b:	89 44 24 0c          	mov    %eax,0xc(%esp)
				continue;
   1036f:	e9 14 01 00 00       	jmp    10488 <add_entry+0x22d>
			}
			de = (struct dir_entry *) bh->b_data;
   10374:	8b 44 24 08          	mov    0x8(%esp),%eax
   10378:	8b 00                	mov    (%eax),%eax
   1037a:	89 44 24 04          	mov    %eax,0x4(%esp)
		}
		if (i*sizeof(struct dir_entry) >= dir->i_size) {
   1037e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10382:	c1 e0 04             	shl    $0x4,%eax
   10385:	89 c2                	mov    %eax,%edx
   10387:	8b 44 24 20          	mov    0x20(%esp),%eax
   1038b:	8b 40 04             	mov    0x4(%eax),%eax
   1038e:	39 c2                	cmp    %eax,%edx
   10390:	72 4d                	jb     103df <add_entry+0x184>
			de->inode=0;
   10392:	8b 44 24 04          	mov    0x4(%esp),%eax
   10396:	66 c7 00 00 00       	movw   $0x0,(%eax)
			dir->i_size = (i+1)*sizeof(struct dir_entry);
   1039b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1039f:	83 c0 01             	add    $0x1,%eax
   103a2:	c1 e0 04             	shl    $0x4,%eax
   103a5:	89 c2                	mov    %eax,%edx
   103a7:	8b 44 24 20          	mov    0x20(%esp),%eax
   103ab:	89 50 04             	mov    %edx,0x4(%eax)
			dir->i_dirt = 1;
   103ae:	8b 44 24 20          	mov    0x20(%esp),%eax
   103b2:	c6 40 33 01          	movb   $0x1,0x33(%eax)
			dir->i_ctime = CURRENT_TIME;
   103b6:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   103bc:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   103c1:	89 c8                	mov    %ecx,%eax
   103c3:	f7 ea                	imul   %edx
   103c5:	c1 fa 05             	sar    $0x5,%edx
   103c8:	89 c8                	mov    %ecx,%eax
   103ca:	c1 f8 1f             	sar    $0x1f,%eax
   103cd:	29 c2                	sub    %eax,%edx
   103cf:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   103d4:	01 d0                	add    %edx,%eax
   103d6:	89 c2                	mov    %eax,%edx
   103d8:	8b 44 24 20          	mov    0x20(%esp),%eax
   103dc:	89 50 28             	mov    %edx,0x28(%eax)
		}
		if (!de->inode) {
   103df:	8b 44 24 04          	mov    0x4(%esp),%eax
   103e3:	0f b7 00             	movzwl (%eax),%eax
   103e6:	66 85 c0             	test   %ax,%ax
   103e9:	0f 85 8f 00 00 00    	jne    1047e <add_entry+0x223>
			dir->i_mtime = CURRENT_TIME;
   103ef:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   103f5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   103fa:	89 c8                	mov    %ecx,%eax
   103fc:	f7 ea                	imul   %edx
   103fe:	c1 fa 05             	sar    $0x5,%edx
   10401:	89 c8                	mov    %ecx,%eax
   10403:	c1 f8 1f             	sar    $0x1f,%eax
   10406:	29 c2                	sub    %eax,%edx
   10408:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   1040d:	01 d0                	add    %edx,%eax
   1040f:	89 c2                	mov    %eax,%edx
   10411:	8b 44 24 20          	mov    0x20(%esp),%eax
   10415:	89 50 08             	mov    %edx,0x8(%eax)
			for (i=0; i < NAME_LEN ; i++)
   10418:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1041f:	00 
   10420:	eb 3d                	jmp    1045f <add_entry+0x204>
				de->name[i]=(i<namelen)?get_fs_byte(name+i):0;
   10422:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10426:	3b 44 24 28          	cmp    0x28(%esp),%eax
   1042a:	7d 1a                	jge    10446 <add_entry+0x1eb>
   1042c:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10430:	8b 44 24 24          	mov    0x24(%esp),%eax
   10434:	01 d0                	add    %edx,%eax
   10436:	83 ec 0c             	sub    $0xc,%esp
   10439:	50                   	push   %eax
   1043a:	e8 63 fa ff ff       	call   fea2 <get_fs_byte>
   1043f:	83 c4 10             	add    $0x10,%esp
   10442:	89 c1                	mov    %eax,%ecx
   10444:	eb 05                	jmp    1044b <add_entry+0x1f0>
   10446:	b9 00 00 00 00       	mov    $0x0,%ecx
   1044b:	8b 54 24 04          	mov    0x4(%esp),%edx
   1044f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10453:	01 d0                	add    %edx,%eax
   10455:	83 c0 02             	add    $0x2,%eax
   10458:	88 08                	mov    %cl,(%eax)
			dir->i_dirt = 1;
			dir->i_ctime = CURRENT_TIME;
		}
		if (!de->inode) {
			dir->i_mtime = CURRENT_TIME;
			for (i=0; i < NAME_LEN ; i++)
   1045a:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1045f:	83 7c 24 0c 0d       	cmpl   $0xd,0xc(%esp)
   10464:	7e bc                	jle    10422 <add_entry+0x1c7>
				de->name[i]=(i<namelen)?get_fs_byte(name+i):0;
			bh->b_dirt = 1;
   10466:	8b 44 24 08          	mov    0x8(%esp),%eax
   1046a:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
			*res_dir = de;
   1046e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   10472:	8b 54 24 04          	mov    0x4(%esp),%edx
   10476:	89 10                	mov    %edx,(%eax)
			return bh;
   10478:	8b 44 24 08          	mov    0x8(%esp),%eax
   1047c:	eb 0f                	jmp    1048d <add_entry+0x232>
		}
		de++;
   1047e:	83 44 24 04 10       	addl   $0x10,0x4(%esp)
		i++;
   10483:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
	}
   10488:	e9 5b fe ff ff       	jmp    102e8 <add_entry+0x8d>
	brelse(bh);
	return NULL;
}
   1048d:	83 c4 1c             	add    $0x1c,%esp
   10490:	c3                   	ret    

00010491 <get_dir>:
 *
 * Getdir traverses the pathname until it hits the topmost directory.
 * It returns NULL on failure.
 */
static struct m_inode * get_dir(const char * pathname)
{
   10491:	83 ec 2c             	sub    $0x2c,%esp
	struct m_inode * inode;
	struct buffer_head * bh;
	int namelen,inr,idev;
	struct dir_entry * de;

	if (!current->root || !current->root->i_count)
   10494:	a1 40 f1 01 00       	mov    0x1f140,%eax
   10499:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   1049f:	85 c0                	test   %eax,%eax
   104a1:	74 14                	je     104b7 <get_dir+0x26>
   104a3:	a1 40 f1 01 00       	mov    0x1f140,%eax
   104a8:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   104ae:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   104b2:	66 85 c0             	test   %ax,%ax
   104b5:	75 10                	jne    104c7 <get_dir+0x36>
		panic("No root inode");
   104b7:	83 ec 0c             	sub    $0xc,%esp
   104ba:	68 b0 89 01 00       	push   $0x189b0
   104bf:	e8 0a 83 ff ff       	call   87ce <panic>
   104c4:	83 c4 10             	add    $0x10,%esp
	if (!current->pwd || !current->pwd->i_count)
   104c7:	a1 40 f1 01 00       	mov    0x1f140,%eax
   104cc:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
   104d2:	85 c0                	test   %eax,%eax
   104d4:	74 14                	je     104ea <get_dir+0x59>
   104d6:	a1 40 f1 01 00       	mov    0x1f140,%eax
   104db:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
   104e1:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   104e5:	66 85 c0             	test   %ax,%ax
   104e8:	75 10                	jne    104fa <get_dir+0x69>
		panic("No cwd inode");
   104ea:	83 ec 0c             	sub    $0xc,%esp
   104ed:	68 be 89 01 00       	push   $0x189be
   104f2:	e8 d7 82 ff ff       	call   87ce <panic>
   104f7:	83 c4 10             	add    $0x10,%esp
	if ((c=get_fs_byte(pathname))=='/') {
   104fa:	83 ec 0c             	sub    $0xc,%esp
   104fd:	ff 74 24 3c          	pushl  0x3c(%esp)
   10501:	e8 9c f9 ff ff       	call   fea2 <get_fs_byte>
   10506:	83 c4 10             	add    $0x10,%esp
   10509:	88 44 24 1b          	mov    %al,0x1b(%esp)
   1050d:	80 7c 24 1b 2f       	cmpb   $0x2f,0x1b(%esp)
   10512:	75 16                	jne    1052a <get_dir+0x99>
		inode = current->root;
   10514:	a1 40 f1 01 00       	mov    0x1f140,%eax
   10519:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   1051f:	89 44 24 04          	mov    %eax,0x4(%esp)
		pathname++;
   10523:	83 44 24 30 01       	addl   $0x1,0x30(%esp)
   10528:	eb 22                	jmp    1054c <get_dir+0xbb>
	} else if (c)
   1052a:	80 7c 24 1b 00       	cmpb   $0x0,0x1b(%esp)
   1052f:	74 11                	je     10542 <get_dir+0xb1>
		inode = current->pwd;
   10531:	a1 40 f1 01 00       	mov    0x1f140,%eax
   10536:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
   1053c:	89 44 24 04          	mov    %eax,0x4(%esp)
   10540:	eb 0a                	jmp    1054c <get_dir+0xbb>
	else
		return NULL;	/* empty name is bad */
   10542:	b8 00 00 00 00       	mov    $0x0,%eax
   10547:	e9 42 01 00 00       	jmp    1068e <get_dir+0x1fd>
	inode->i_count++;
   1054c:	8b 44 24 04          	mov    0x4(%esp),%eax
   10550:	0f b7 50 30          	movzwl 0x30(%eax),%edx
   10554:	83 c2 01             	add    $0x1,%edx
   10557:	66 89 50 30          	mov    %dx,0x30(%eax)
	while (1) {
		thisname = pathname;
   1055b:	8b 44 24 30          	mov    0x30(%esp),%eax
   1055f:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {
   10563:	8b 44 24 04          	mov    0x4(%esp),%eax
   10567:	0f b7 00             	movzwl (%eax),%eax
   1056a:	0f b7 c0             	movzwl %ax,%eax
   1056d:	25 00 f0 00 00       	and    $0xf000,%eax
   10572:	3d 00 40 00 00       	cmp    $0x4000,%eax
   10577:	75 16                	jne    1058f <get_dir+0xfe>
   10579:	8b 44 24 04          	mov    0x4(%esp),%eax
   1057d:	83 ec 08             	sub    $0x8,%esp
   10580:	6a 01                	push   $0x1
   10582:	50                   	push   %eax
   10583:	e8 71 f9 ff ff       	call   fef9 <permission>
   10588:	83 c4 10             	add    $0x10,%esp
   1058b:	85 c0                	test   %eax,%eax
   1058d:	75 1a                	jne    105a9 <get_dir+0x118>
			iput(inode);
   1058f:	8b 44 24 04          	mov    0x4(%esp),%eax
   10593:	83 ec 0c             	sub    $0xc,%esp
   10596:	50                   	push   %eax
   10597:	e8 d5 ba ff ff       	call   c071 <iput>
   1059c:	83 c4 10             	add    $0x10,%esp
			return NULL;
   1059f:	b8 00 00 00 00       	mov    $0x0,%eax
   105a4:	e9 e5 00 00 00       	jmp    1068e <get_dir+0x1fd>
		}
		for(namelen=0;(c=get_fs_byte(pathname++))&&(c!='/');namelen++)
   105a9:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   105b0:	00 
   105b1:	eb 05                	jmp    105b8 <get_dir+0x127>
   105b3:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   105b8:	8b 44 24 30          	mov    0x30(%esp),%eax
   105bc:	8d 50 01             	lea    0x1(%eax),%edx
   105bf:	89 54 24 30          	mov    %edx,0x30(%esp)
   105c3:	83 ec 0c             	sub    $0xc,%esp
   105c6:	50                   	push   %eax
   105c7:	e8 d6 f8 ff ff       	call   fea2 <get_fs_byte>
   105cc:	83 c4 10             	add    $0x10,%esp
   105cf:	88 44 24 1b          	mov    %al,0x1b(%esp)
   105d3:	80 7c 24 1b 00       	cmpb   $0x0,0x1b(%esp)
   105d8:	74 07                	je     105e1 <get_dir+0x150>
   105da:	80 7c 24 1b 2f       	cmpb   $0x2f,0x1b(%esp)
   105df:	75 d2                	jne    105b3 <get_dir+0x122>
			/* nothing */ ;
		if (!c)
   105e1:	80 7c 24 1b 00       	cmpb   $0x0,0x1b(%esp)
   105e6:	75 09                	jne    105f1 <get_dir+0x160>
			return inode;
   105e8:	8b 44 24 04          	mov    0x4(%esp),%eax
   105ec:	e9 9d 00 00 00       	jmp    1068e <get_dir+0x1fd>
		if (!(bh = find_entry(&inode,thisname,namelen,&de))) {
   105f1:	89 e0                	mov    %esp,%eax
   105f3:	50                   	push   %eax
   105f4:	ff 74 24 20          	pushl  0x20(%esp)
   105f8:	ff 74 24 1c          	pushl  0x1c(%esp)
   105fc:	8d 44 24 10          	lea    0x10(%esp),%eax
   10600:	50                   	push   %eax
   10601:	e8 06 fa ff ff       	call   1000c <find_entry>
   10606:	83 c4 10             	add    $0x10,%esp
   10609:	89 44 24 10          	mov    %eax,0x10(%esp)
   1060d:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   10612:	75 17                	jne    1062b <get_dir+0x19a>
			iput(inode);
   10614:	8b 44 24 04          	mov    0x4(%esp),%eax
   10618:	83 ec 0c             	sub    $0xc,%esp
   1061b:	50                   	push   %eax
   1061c:	e8 50 ba ff ff       	call   c071 <iput>
   10621:	83 c4 10             	add    $0x10,%esp
			return NULL;
   10624:	b8 00 00 00 00       	mov    $0x0,%eax
   10629:	eb 63                	jmp    1068e <get_dir+0x1fd>
		}
		inr = de->inode;
   1062b:	8b 04 24             	mov    (%esp),%eax
   1062e:	0f b7 00             	movzwl (%eax),%eax
   10631:	0f b7 c0             	movzwl %ax,%eax
   10634:	89 44 24 0c          	mov    %eax,0xc(%esp)
		idev = inode->i_dev;
   10638:	8b 44 24 04          	mov    0x4(%esp),%eax
   1063c:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10640:	0f b7 c0             	movzwl %ax,%eax
   10643:	89 44 24 08          	mov    %eax,0x8(%esp)
		brelse(bh);
   10647:	83 ec 0c             	sub    $0xc,%esp
   1064a:	ff 74 24 1c          	pushl  0x1c(%esp)
   1064e:	e8 3d c9 ff ff       	call   cf90 <brelse>
   10653:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   10656:	8b 44 24 04          	mov    0x4(%esp),%eax
   1065a:	83 ec 0c             	sub    $0xc,%esp
   1065d:	50                   	push   %eax
   1065e:	e8 0e ba ff ff       	call   c071 <iput>
   10663:	83 c4 10             	add    $0x10,%esp
		if (!(inode = iget(idev,inr)))
   10666:	83 ec 08             	sub    $0x8,%esp
   10669:	ff 74 24 14          	pushl  0x14(%esp)
   1066d:	ff 74 24 14          	pushl  0x14(%esp)
   10671:	e8 7e bd ff ff       	call   c3f4 <iget>
   10676:	83 c4 10             	add    $0x10,%esp
   10679:	89 44 24 04          	mov    %eax,0x4(%esp)
   1067d:	8b 44 24 04          	mov    0x4(%esp),%eax
   10681:	85 c0                	test   %eax,%eax
   10683:	0f 85 d2 fe ff ff    	jne    1055b <get_dir+0xca>
			return NULL;
   10689:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
   1068e:	83 c4 2c             	add    $0x2c,%esp
   10691:	c3                   	ret    

00010692 <dir_namei>:
 * dir_namei() returns the inode of the directory of the
 * specified name, and the name within that directory.
 */
static struct m_inode * dir_namei(const char * pathname,
	int * namelen, const char ** name)
{
   10692:	83 ec 1c             	sub    $0x1c,%esp
	char c;
	const char * basename;
	struct m_inode * dir;

	if (!(dir = get_dir(pathname)))
   10695:	83 ec 0c             	sub    $0xc,%esp
   10698:	ff 74 24 2c          	pushl  0x2c(%esp)
   1069c:	e8 f0 fd ff ff       	call   10491 <get_dir>
   106a1:	83 c4 10             	add    $0x10,%esp
   106a4:	89 44 24 08          	mov    %eax,0x8(%esp)
   106a8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   106ad:	75 07                	jne    106b6 <dir_namei+0x24>
		return NULL;
   106af:	b8 00 00 00 00       	mov    $0x0,%eax
   106b4:	eb 5e                	jmp    10714 <dir_namei+0x82>
	basename = pathname;
   106b6:	8b 44 24 20          	mov    0x20(%esp),%eax
   106ba:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while ((c=get_fs_byte(pathname++)))
   106be:	eb 0f                	jmp    106cf <dir_namei+0x3d>
		if (c=='/')
   106c0:	80 7c 24 07 2f       	cmpb   $0x2f,0x7(%esp)
   106c5:	75 08                	jne    106cf <dir_namei+0x3d>
			basename=pathname;
   106c7:	8b 44 24 20          	mov    0x20(%esp),%eax
   106cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
	struct m_inode * dir;

	if (!(dir = get_dir(pathname)))
		return NULL;
	basename = pathname;
	while ((c=get_fs_byte(pathname++)))
   106cf:	8b 44 24 20          	mov    0x20(%esp),%eax
   106d3:	8d 50 01             	lea    0x1(%eax),%edx
   106d6:	89 54 24 20          	mov    %edx,0x20(%esp)
   106da:	83 ec 0c             	sub    $0xc,%esp
   106dd:	50                   	push   %eax
   106de:	e8 bf f7 ff ff       	call   fea2 <get_fs_byte>
   106e3:	83 c4 10             	add    $0x10,%esp
   106e6:	88 44 24 07          	mov    %al,0x7(%esp)
   106ea:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
   106ef:	75 cf                	jne    106c0 <dir_namei+0x2e>
		if (c=='/')
			basename=pathname;
	*namelen = pathname-basename-1;
   106f1:	8b 54 24 20          	mov    0x20(%esp),%edx
   106f5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   106f9:	29 c2                	sub    %eax,%edx
   106fb:	89 d0                	mov    %edx,%eax
   106fd:	8d 50 ff             	lea    -0x1(%eax),%edx
   10700:	8b 44 24 24          	mov    0x24(%esp),%eax
   10704:	89 10                	mov    %edx,(%eax)
	*name = basename;
   10706:	8b 44 24 28          	mov    0x28(%esp),%eax
   1070a:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1070e:	89 10                	mov    %edx,(%eax)
	return dir;
   10710:	8b 44 24 08          	mov    0x8(%esp),%eax
}
   10714:	83 c4 1c             	add    $0x1c,%esp
   10717:	c3                   	ret    

00010718 <namei>:
 * is used by most simple commands to get the inode of a specified name.
 * Open, link etc use their own routines, but this is enough for things
 * like 'chmod' etc.
 */
struct m_inode * namei(const char * pathname)
{
   10718:	53                   	push   %ebx
   10719:	83 ec 28             	sub    $0x28,%esp
	int inr,dev,namelen;
	struct m_inode * dir;
	struct buffer_head * bh;
	struct dir_entry * de;

	if (!(dir = dir_namei(pathname,&namelen,&basename)))
   1071c:	83 ec 04             	sub    $0x4,%esp
   1071f:	8d 44 24 14          	lea    0x14(%esp),%eax
   10723:	50                   	push   %eax
   10724:	8d 44 24 14          	lea    0x14(%esp),%eax
   10728:	50                   	push   %eax
   10729:	ff 74 24 3c          	pushl  0x3c(%esp)
   1072d:	e8 60 ff ff ff       	call   10692 <dir_namei>
   10732:	83 c4 10             	add    $0x10,%esp
   10735:	89 44 24 08          	mov    %eax,0x8(%esp)
   10739:	8b 44 24 08          	mov    0x8(%esp),%eax
   1073d:	85 c0                	test   %eax,%eax
   1073f:	75 0a                	jne    1074b <namei+0x33>
		return NULL;
   10741:	b8 00 00 00 00       	mov    $0x0,%eax
   10746:	e9 e0 00 00 00       	jmp    1082b <namei+0x113>
	if (!namelen)			/* special case: '/usr/' etc */
   1074b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1074f:	85 c0                	test   %eax,%eax
   10751:	75 09                	jne    1075c <namei+0x44>
		return dir;
   10753:	8b 44 24 08          	mov    0x8(%esp),%eax
   10757:	e9 cf 00 00 00       	jmp    1082b <namei+0x113>
	bh = find_entry(&dir,basename,namelen,&de);
   1075c:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10760:	8b 44 24 10          	mov    0x10(%esp),%eax
   10764:	8d 4c 24 04          	lea    0x4(%esp),%ecx
   10768:	51                   	push   %ecx
   10769:	52                   	push   %edx
   1076a:	50                   	push   %eax
   1076b:	8d 44 24 14          	lea    0x14(%esp),%eax
   1076f:	50                   	push   %eax
   10770:	e8 97 f8 ff ff       	call   1000c <find_entry>
   10775:	83 c4 10             	add    $0x10,%esp
   10778:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   1077c:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   10781:	75 1a                	jne    1079d <namei+0x85>
		iput(dir);
   10783:	8b 44 24 08          	mov    0x8(%esp),%eax
   10787:	83 ec 0c             	sub    $0xc,%esp
   1078a:	50                   	push   %eax
   1078b:	e8 e1 b8 ff ff       	call   c071 <iput>
   10790:	83 c4 10             	add    $0x10,%esp
		return NULL;
   10793:	b8 00 00 00 00       	mov    $0x0,%eax
   10798:	e9 8e 00 00 00       	jmp    1082b <namei+0x113>
	}
	inr = de->inode;
   1079d:	8b 44 24 04          	mov    0x4(%esp),%eax
   107a1:	0f b7 00             	movzwl (%eax),%eax
   107a4:	0f b7 c0             	movzwl %ax,%eax
   107a7:	89 44 24 18          	mov    %eax,0x18(%esp)
	dev = dir->i_dev;
   107ab:	8b 44 24 08          	mov    0x8(%esp),%eax
   107af:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   107b3:	0f b7 c0             	movzwl %ax,%eax
   107b6:	89 44 24 14          	mov    %eax,0x14(%esp)
	brelse(bh);
   107ba:	83 ec 0c             	sub    $0xc,%esp
   107bd:	ff 74 24 28          	pushl  0x28(%esp)
   107c1:	e8 ca c7 ff ff       	call   cf90 <brelse>
   107c6:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   107c9:	8b 44 24 08          	mov    0x8(%esp),%eax
   107cd:	83 ec 0c             	sub    $0xc,%esp
   107d0:	50                   	push   %eax
   107d1:	e8 9b b8 ff ff       	call   c071 <iput>
   107d6:	83 c4 10             	add    $0x10,%esp
	dir=iget(dev,inr);
   107d9:	83 ec 08             	sub    $0x8,%esp
   107dc:	ff 74 24 20          	pushl  0x20(%esp)
   107e0:	ff 74 24 20          	pushl  0x20(%esp)
   107e4:	e8 0b bc ff ff       	call   c3f4 <iget>
   107e9:	83 c4 10             	add    $0x10,%esp
   107ec:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (dir) {
   107f0:	8b 44 24 08          	mov    0x8(%esp),%eax
   107f4:	85 c0                	test   %eax,%eax
   107f6:	74 2f                	je     10827 <namei+0x10f>
		dir->i_atime=CURRENT_TIME;
   107f8:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   107fc:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   10802:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   10807:	89 c8                	mov    %ecx,%eax
   10809:	f7 ea                	imul   %edx
   1080b:	c1 fa 05             	sar    $0x5,%edx
   1080e:	89 c8                	mov    %ecx,%eax
   10810:	c1 f8 1f             	sar    $0x1f,%eax
   10813:	29 c2                	sub    %eax,%edx
   10815:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   1081a:	01 d0                	add    %edx,%eax
   1081c:	89 43 24             	mov    %eax,0x24(%ebx)
		dir->i_dirt=1;
   1081f:	8b 44 24 08          	mov    0x8(%esp),%eax
   10823:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	}
	return dir;
   10827:	8b 44 24 08          	mov    0x8(%esp),%eax
}
   1082b:	83 c4 28             	add    $0x28,%esp
   1082e:	5b                   	pop    %ebx
   1082f:	c3                   	ret    

00010830 <open_namei>:
 *
 * namei for open - this is in fact almost the whole open-routine.
 */
int open_namei(const char * pathname, int flag, int mode,
	struct m_inode ** res_inode)
{
   10830:	53                   	push   %ebx
   10831:	83 ec 28             	sub    $0x28,%esp
	int inr,dev,namelen;
	struct m_inode * dir, *inode;
	struct buffer_head * bh;
	struct dir_entry * de;

	if ((flag & O_TRUNC) && !(flag & O_ACCMODE))
   10834:	8b 44 24 34          	mov    0x34(%esp),%eax
   10838:	25 00 02 00 00       	and    $0x200,%eax
   1083d:	85 c0                	test   %eax,%eax
   1083f:	74 10                	je     10851 <open_namei+0x21>
   10841:	8b 44 24 34          	mov    0x34(%esp),%eax
   10845:	83 e0 03             	and    $0x3,%eax
   10848:	85 c0                	test   %eax,%eax
   1084a:	75 05                	jne    10851 <open_namei+0x21>
		flag |= O_WRONLY;
   1084c:	83 4c 24 34 01       	orl    $0x1,0x34(%esp)
	mode &= 0777 & ~current->umask;
   10851:	a1 40 f1 01 00       	mov    0x1f140,%eax
   10856:	0f b7 80 6c 02 00 00 	movzwl 0x26c(%eax),%eax
   1085d:	0f b7 c0             	movzwl %ax,%eax
   10860:	f7 d0                	not    %eax
   10862:	25 ff 01 00 00       	and    $0x1ff,%eax
   10867:	21 44 24 38          	and    %eax,0x38(%esp)
	mode |= I_REGULAR;
   1086b:	81 4c 24 38 00 80 00 	orl    $0x8000,0x38(%esp)
   10872:	00 
	if (!(dir = dir_namei(pathname,&namelen,&basename)))
   10873:	83 ec 04             	sub    $0x4,%esp
   10876:	8d 44 24 10          	lea    0x10(%esp),%eax
   1087a:	50                   	push   %eax
   1087b:	8d 44 24 10          	lea    0x10(%esp),%eax
   1087f:	50                   	push   %eax
   10880:	ff 74 24 3c          	pushl  0x3c(%esp)
   10884:	e8 09 fe ff ff       	call   10692 <dir_namei>
   10889:	83 c4 10             	add    $0x10,%esp
   1088c:	89 44 24 04          	mov    %eax,0x4(%esp)
   10890:	8b 44 24 04          	mov    0x4(%esp),%eax
   10894:	85 c0                	test   %eax,%eax
   10896:	75 0a                	jne    108a2 <open_namei+0x72>
		return -ENOENT;
   10898:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1089d:	e9 f9 02 00 00       	jmp    10b9b <open_namei+0x36b>
	if (!namelen) {			/* special case: '/usr/' etc */
   108a2:	8b 44 24 08          	mov    0x8(%esp),%eax
   108a6:	85 c0                	test   %eax,%eax
   108a8:	75 3b                	jne    108e5 <open_namei+0xb5>
		if (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {
   108aa:	8b 44 24 34          	mov    0x34(%esp),%eax
   108ae:	25 43 02 00 00       	and    $0x243,%eax
   108b3:	85 c0                	test   %eax,%eax
   108b5:	75 14                	jne    108cb <open_namei+0x9b>
			*res_inode=dir;
   108b7:	8b 54 24 04          	mov    0x4(%esp),%edx
   108bb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   108bf:	89 10                	mov    %edx,(%eax)
			return 0;
   108c1:	b8 00 00 00 00       	mov    $0x0,%eax
   108c6:	e9 d0 02 00 00       	jmp    10b9b <open_namei+0x36b>
		}
		iput(dir);
   108cb:	8b 44 24 04          	mov    0x4(%esp),%eax
   108cf:	83 ec 0c             	sub    $0xc,%esp
   108d2:	50                   	push   %eax
   108d3:	e8 99 b7 ff ff       	call   c071 <iput>
   108d8:	83 c4 10             	add    $0x10,%esp
		return -EISDIR;
   108db:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax
   108e0:	e9 b6 02 00 00       	jmp    10b9b <open_namei+0x36b>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   108e5:	8b 54 24 08          	mov    0x8(%esp),%edx
   108e9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   108ed:	89 e1                	mov    %esp,%ecx
   108ef:	51                   	push   %ecx
   108f0:	52                   	push   %edx
   108f1:	50                   	push   %eax
   108f2:	8d 44 24 10          	lea    0x10(%esp),%eax
   108f6:	50                   	push   %eax
   108f7:	e8 10 f7 ff ff       	call   1000c <find_entry>
   108fc:	83 c4 10             	add    $0x10,%esp
   108ff:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   10903:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   10908:	0f 85 63 01 00 00    	jne    10a71 <open_namei+0x241>
		if (!(flag & O_CREAT)) {
   1090e:	8b 44 24 34          	mov    0x34(%esp),%eax
   10912:	83 e0 40             	and    $0x40,%eax
   10915:	85 c0                	test   %eax,%eax
   10917:	75 1a                	jne    10933 <open_namei+0x103>
			iput(dir);
   10919:	8b 44 24 04          	mov    0x4(%esp),%eax
   1091d:	83 ec 0c             	sub    $0xc,%esp
   10920:	50                   	push   %eax
   10921:	e8 4b b7 ff ff       	call   c071 <iput>
   10926:	83 c4 10             	add    $0x10,%esp
			return -ENOENT;
   10929:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1092e:	e9 68 02 00 00       	jmp    10b9b <open_namei+0x36b>
		}
		if (!permission(dir,MAY_WRITE)) {
   10933:	8b 44 24 04          	mov    0x4(%esp),%eax
   10937:	83 ec 08             	sub    $0x8,%esp
   1093a:	6a 02                	push   $0x2
   1093c:	50                   	push   %eax
   1093d:	e8 b7 f5 ff ff       	call   fef9 <permission>
   10942:	83 c4 10             	add    $0x10,%esp
   10945:	85 c0                	test   %eax,%eax
   10947:	75 1a                	jne    10963 <open_namei+0x133>
			iput(dir);
   10949:	8b 44 24 04          	mov    0x4(%esp),%eax
   1094d:	83 ec 0c             	sub    $0xc,%esp
   10950:	50                   	push   %eax
   10951:	e8 1b b7 ff ff       	call   c071 <iput>
   10956:	83 c4 10             	add    $0x10,%esp
			return -EACCES;
   10959:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   1095e:	e9 38 02 00 00       	jmp    10b9b <open_namei+0x36b>
		}
		inode = new_inode(dir->i_dev);
   10963:	8b 44 24 04          	mov    0x4(%esp),%eax
   10967:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1096b:	0f b7 c0             	movzwl %ax,%eax
   1096e:	83 ec 0c             	sub    $0xc,%esp
   10971:	50                   	push   %eax
   10972:	e8 44 18 00 00       	call   121bb <new_inode>
   10977:	83 c4 10             	add    $0x10,%esp
   1097a:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (!inode) {
   1097e:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   10983:	75 1a                	jne    1099f <open_namei+0x16f>
			iput(dir);
   10985:	8b 44 24 04          	mov    0x4(%esp),%eax
   10989:	83 ec 0c             	sub    $0xc,%esp
   1098c:	50                   	push   %eax
   1098d:	e8 df b6 ff ff       	call   c071 <iput>
   10992:	83 c4 10             	add    $0x10,%esp
			return -ENOSPC;
   10995:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   1099a:	e9 fc 01 00 00       	jmp    10b9b <open_namei+0x36b>
		}
		inode->i_uid = current->euid;
   1099f:	a1 40 f1 01 00       	mov    0x1f140,%eax
   109a4:	0f b7 90 42 02 00 00 	movzwl 0x242(%eax),%edx
   109ab:	8b 44 24 18          	mov    0x18(%esp),%eax
   109af:	66 89 50 02          	mov    %dx,0x2(%eax)
		inode->i_mode = mode;
   109b3:	8b 44 24 38          	mov    0x38(%esp),%eax
   109b7:	89 c2                	mov    %eax,%edx
   109b9:	8b 44 24 18          	mov    0x18(%esp),%eax
   109bd:	66 89 10             	mov    %dx,(%eax)
		inode->i_dirt = 1;
   109c0:	8b 44 24 18          	mov    0x18(%esp),%eax
   109c4:	c6 40 33 01          	movb   $0x1,0x33(%eax)
		bh = add_entry(dir,basename,namelen,&de);
   109c8:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   109cc:	8b 54 24 0c          	mov    0xc(%esp),%edx
   109d0:	8b 44 24 04          	mov    0x4(%esp),%eax
   109d4:	89 e3                	mov    %esp,%ebx
   109d6:	53                   	push   %ebx
   109d7:	51                   	push   %ecx
   109d8:	52                   	push   %edx
   109d9:	50                   	push   %eax
   109da:	e8 7c f8 ff ff       	call   1025b <add_entry>
   109df:	83 c4 10             	add    $0x10,%esp
   109e2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if (!bh) {
   109e6:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   109eb:	75 3b                	jne    10a28 <open_namei+0x1f8>
			inode->i_nlinks--;
   109ed:	8b 44 24 18          	mov    0x18(%esp),%eax
   109f1:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   109f5:	8d 50 ff             	lea    -0x1(%eax),%edx
   109f8:	8b 44 24 18          	mov    0x18(%esp),%eax
   109fc:	88 50 0d             	mov    %dl,0xd(%eax)
			iput(inode);
   109ff:	83 ec 0c             	sub    $0xc,%esp
   10a02:	ff 74 24 24          	pushl  0x24(%esp)
   10a06:	e8 66 b6 ff ff       	call   c071 <iput>
   10a0b:	83 c4 10             	add    $0x10,%esp
			iput(dir);
   10a0e:	8b 44 24 04          	mov    0x4(%esp),%eax
   10a12:	83 ec 0c             	sub    $0xc,%esp
   10a15:	50                   	push   %eax
   10a16:	e8 56 b6 ff ff       	call   c071 <iput>
   10a1b:	83 c4 10             	add    $0x10,%esp
			return -ENOSPC;
   10a1e:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   10a23:	e9 73 01 00 00       	jmp    10b9b <open_namei+0x36b>
		}
		de->inode = inode->i_num;
   10a28:	8b 04 24             	mov    (%esp),%eax
   10a2b:	8b 54 24 18          	mov    0x18(%esp),%edx
   10a2f:	0f b7 52 2e          	movzwl 0x2e(%edx),%edx
   10a33:	66 89 10             	mov    %dx,(%eax)
		bh->b_dirt = 1;
   10a36:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10a3a:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		brelse(bh);
   10a3e:	83 ec 0c             	sub    $0xc,%esp
   10a41:	ff 74 24 28          	pushl  0x28(%esp)
   10a45:	e8 46 c5 ff ff       	call   cf90 <brelse>
   10a4a:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   10a4d:	8b 44 24 04          	mov    0x4(%esp),%eax
   10a51:	83 ec 0c             	sub    $0xc,%esp
   10a54:	50                   	push   %eax
   10a55:	e8 17 b6 ff ff       	call   c071 <iput>
   10a5a:	83 c4 10             	add    $0x10,%esp
		*res_inode = inode;
   10a5d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   10a61:	8b 54 24 18          	mov    0x18(%esp),%edx
   10a65:	89 10                	mov    %edx,(%eax)
		return 0;
   10a67:	b8 00 00 00 00       	mov    $0x0,%eax
   10a6c:	e9 2a 01 00 00       	jmp    10b9b <open_namei+0x36b>
	}
	inr = de->inode;
   10a71:	8b 04 24             	mov    (%esp),%eax
   10a74:	0f b7 00             	movzwl (%eax),%eax
   10a77:	0f b7 c0             	movzwl %ax,%eax
   10a7a:	89 44 24 14          	mov    %eax,0x14(%esp)
	dev = dir->i_dev;
   10a7e:	8b 44 24 04          	mov    0x4(%esp),%eax
   10a82:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10a86:	0f b7 c0             	movzwl %ax,%eax
   10a89:	89 44 24 10          	mov    %eax,0x10(%esp)
	brelse(bh);
   10a8d:	83 ec 0c             	sub    $0xc,%esp
   10a90:	ff 74 24 28          	pushl  0x28(%esp)
   10a94:	e8 f7 c4 ff ff       	call   cf90 <brelse>
   10a99:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   10a9c:	8b 44 24 04          	mov    0x4(%esp),%eax
   10aa0:	83 ec 0c             	sub    $0xc,%esp
   10aa3:	50                   	push   %eax
   10aa4:	e8 c8 b5 ff ff       	call   c071 <iput>
   10aa9:	83 c4 10             	add    $0x10,%esp
	if (flag & O_EXCL)
   10aac:	8b 44 24 34          	mov    0x34(%esp),%eax
   10ab0:	25 80 00 00 00       	and    $0x80,%eax
   10ab5:	85 c0                	test   %eax,%eax
   10ab7:	74 0a                	je     10ac3 <open_namei+0x293>
		return -EEXIST;
   10ab9:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   10abe:	e9 d8 00 00 00       	jmp    10b9b <open_namei+0x36b>
	if (!(inode=iget(dev,inr)))
   10ac3:	83 ec 08             	sub    $0x8,%esp
   10ac6:	ff 74 24 1c          	pushl  0x1c(%esp)
   10aca:	ff 74 24 1c          	pushl  0x1c(%esp)
   10ace:	e8 21 b9 ff ff       	call   c3f4 <iget>
   10ad3:	83 c4 10             	add    $0x10,%esp
   10ad6:	89 44 24 18          	mov    %eax,0x18(%esp)
   10ada:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   10adf:	75 0a                	jne    10aeb <open_namei+0x2bb>
		return -EACCES;
   10ae1:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10ae6:	e9 b0 00 00 00       	jmp    10b9b <open_namei+0x36b>
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
   10aeb:	8b 44 24 18          	mov    0x18(%esp),%eax
   10aef:	0f b7 00             	movzwl (%eax),%eax
   10af2:	0f b7 c0             	movzwl %ax,%eax
   10af5:	25 00 f0 00 00       	and    $0xf000,%eax
   10afa:	3d 00 40 00 00       	cmp    $0x4000,%eax
   10aff:	75 0b                	jne    10b0c <open_namei+0x2dc>
   10b01:	8b 44 24 34          	mov    0x34(%esp),%eax
   10b05:	83 e0 03             	and    $0x3,%eax
   10b08:	85 c0                	test   %eax,%eax
   10b0a:	75 25                	jne    10b31 <open_namei+0x301>
	    !permission(inode,ACC_MODE(flag))) {
   10b0c:	8b 44 24 34          	mov    0x34(%esp),%eax
   10b10:	83 e0 03             	and    $0x3,%eax
   10b13:	0f b6 80 cb 89 01 00 	movzbl 0x189cb(%eax),%eax
   10b1a:	0f be c0             	movsbl %al,%eax
   10b1d:	83 ec 08             	sub    $0x8,%esp
   10b20:	50                   	push   %eax
   10b21:	ff 74 24 24          	pushl  0x24(%esp)
   10b25:	e8 cf f3 ff ff       	call   fef9 <permission>
   10b2a:	83 c4 10             	add    $0x10,%esp
	iput(dir);
	if (flag & O_EXCL)
		return -EEXIST;
	if (!(inode=iget(dev,inr)))
		return -EACCES;
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
   10b2d:	85 c0                	test   %eax,%eax
   10b2f:	75 16                	jne    10b47 <open_namei+0x317>
	    !permission(inode,ACC_MODE(flag))) {
		iput(inode);
   10b31:	83 ec 0c             	sub    $0xc,%esp
   10b34:	ff 74 24 24          	pushl  0x24(%esp)
   10b38:	e8 34 b5 ff ff       	call   c071 <iput>
   10b3d:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10b40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10b45:	eb 54                	jmp    10b9b <open_namei+0x36b>
	}
	inode->i_atime = CURRENT_TIME;
   10b47:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   10b4d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   10b52:	89 c8                	mov    %ecx,%eax
   10b54:	f7 ea                	imul   %edx
   10b56:	c1 fa 05             	sar    $0x5,%edx
   10b59:	89 c8                	mov    %ecx,%eax
   10b5b:	c1 f8 1f             	sar    $0x1f,%eax
   10b5e:	29 c2                	sub    %eax,%edx
   10b60:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   10b65:	01 d0                	add    %edx,%eax
   10b67:	89 c2                	mov    %eax,%edx
   10b69:	8b 44 24 18          	mov    0x18(%esp),%eax
   10b6d:	89 50 24             	mov    %edx,0x24(%eax)
	if (flag & O_TRUNC)
   10b70:	8b 44 24 34          	mov    0x34(%esp),%eax
   10b74:	25 00 02 00 00       	and    $0x200,%eax
   10b79:	85 c0                	test   %eax,%eax
   10b7b:	74 0f                	je     10b8c <open_namei+0x35c>
		truncate(inode);
   10b7d:	83 ec 0c             	sub    $0xc,%esp
   10b80:	ff 74 24 24          	pushl  0x24(%esp)
   10b84:	e8 8d 1c 00 00       	call   12816 <truncate>
   10b89:	83 c4 10             	add    $0x10,%esp
	*res_inode = inode;
   10b8c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   10b90:	8b 54 24 18          	mov    0x18(%esp),%edx
   10b94:	89 10                	mov    %edx,(%eax)
	return 0;
   10b96:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b9b:	83 c4 28             	add    $0x28,%esp
   10b9e:	5b                   	pop    %ebx
   10b9f:	c3                   	ret    

00010ba0 <sys_mknod>:

int sys_mknod(const char * filename, int mode, int dev)
{
   10ba0:	53                   	push   %ebx
   10ba1:	83 ec 28             	sub    $0x28,%esp
	int namelen;
	struct m_inode * dir, * inode;
	struct buffer_head * bh;
	struct dir_entry * de;
	
	if (!suser())
   10ba4:	a1 40 f1 01 00       	mov    0x1f140,%eax
   10ba9:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
   10bb0:	66 85 c0             	test   %ax,%ax
   10bb3:	74 0a                	je     10bbf <sys_mknod+0x1f>
		return -EPERM;
   10bb5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10bba:	e9 26 02 00 00       	jmp    10de5 <sys_mknod+0x245>
	if (!(dir = dir_namei(filename,&namelen,&basename)))
   10bbf:	83 ec 04             	sub    $0x4,%esp
   10bc2:	8d 44 24 18          	lea    0x18(%esp),%eax
   10bc6:	50                   	push   %eax
   10bc7:	8d 44 24 18          	lea    0x18(%esp),%eax
   10bcb:	50                   	push   %eax
   10bcc:	ff 74 24 3c          	pushl  0x3c(%esp)
   10bd0:	e8 bd fa ff ff       	call   10692 <dir_namei>
   10bd5:	83 c4 10             	add    $0x10,%esp
   10bd8:	89 44 24 0c          	mov    %eax,0xc(%esp)
   10bdc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10be0:	85 c0                	test   %eax,%eax
   10be2:	75 0a                	jne    10bee <sys_mknod+0x4e>
		return -ENOENT;
   10be4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   10be9:	e9 f7 01 00 00       	jmp    10de5 <sys_mknod+0x245>
	if (!namelen) {
   10bee:	8b 44 24 10          	mov    0x10(%esp),%eax
   10bf2:	85 c0                	test   %eax,%eax
   10bf4:	75 1a                	jne    10c10 <sys_mknod+0x70>
		iput(dir);
   10bf6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10bfa:	83 ec 0c             	sub    $0xc,%esp
   10bfd:	50                   	push   %eax
   10bfe:	e8 6e b4 ff ff       	call   c071 <iput>
   10c03:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   10c06:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   10c0b:	e9 d5 01 00 00       	jmp    10de5 <sys_mknod+0x245>
	}
	if (!permission(dir,MAY_WRITE)) {
   10c10:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10c14:	83 ec 08             	sub    $0x8,%esp
   10c17:	6a 02                	push   $0x2
   10c19:	50                   	push   %eax
   10c1a:	e8 da f2 ff ff       	call   fef9 <permission>
   10c1f:	83 c4 10             	add    $0x10,%esp
   10c22:	85 c0                	test   %eax,%eax
   10c24:	75 1a                	jne    10c40 <sys_mknod+0xa0>
		iput(dir);
   10c26:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10c2a:	83 ec 0c             	sub    $0xc,%esp
   10c2d:	50                   	push   %eax
   10c2e:	e8 3e b4 ff ff       	call   c071 <iput>
   10c33:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10c36:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10c3b:	e9 a5 01 00 00       	jmp    10de5 <sys_mknod+0x245>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   10c40:	8b 54 24 10          	mov    0x10(%esp),%edx
   10c44:	8b 44 24 14          	mov    0x14(%esp),%eax
   10c48:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   10c4c:	51                   	push   %ecx
   10c4d:	52                   	push   %edx
   10c4e:	50                   	push   %eax
   10c4f:	8d 44 24 18          	lea    0x18(%esp),%eax
   10c53:	50                   	push   %eax
   10c54:	e8 b3 f3 ff ff       	call   1000c <find_entry>
   10c59:	83 c4 10             	add    $0x10,%esp
   10c5c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (bh) {
   10c60:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   10c65:	74 29                	je     10c90 <sys_mknod+0xf0>
		brelse(bh);
   10c67:	83 ec 0c             	sub    $0xc,%esp
   10c6a:	ff 74 24 28          	pushl  0x28(%esp)
   10c6e:	e8 1d c3 ff ff       	call   cf90 <brelse>
   10c73:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   10c76:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10c7a:	83 ec 0c             	sub    $0xc,%esp
   10c7d:	50                   	push   %eax
   10c7e:	e8 ee b3 ff ff       	call   c071 <iput>
   10c83:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   10c86:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   10c8b:	e9 55 01 00 00       	jmp    10de5 <sys_mknod+0x245>
	}
	inode = new_inode(dir->i_dev);
   10c90:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10c94:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10c98:	0f b7 c0             	movzwl %ax,%eax
   10c9b:	83 ec 0c             	sub    $0xc,%esp
   10c9e:	50                   	push   %eax
   10c9f:	e8 17 15 00 00       	call   121bb <new_inode>
   10ca4:	83 c4 10             	add    $0x10,%esp
   10ca7:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!inode) {
   10cab:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   10cb0:	75 1a                	jne    10ccc <sys_mknod+0x12c>
		iput(dir);
   10cb2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10cb6:	83 ec 0c             	sub    $0xc,%esp
   10cb9:	50                   	push   %eax
   10cba:	e8 b2 b3 ff ff       	call   c071 <iput>
   10cbf:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   10cc2:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   10cc7:	e9 19 01 00 00       	jmp    10de5 <sys_mknod+0x245>
	}
	inode->i_mode = mode;
   10ccc:	8b 44 24 34          	mov    0x34(%esp),%eax
   10cd0:	89 c2                	mov    %eax,%edx
   10cd2:	8b 44 24 18          	mov    0x18(%esp),%eax
   10cd6:	66 89 10             	mov    %dx,(%eax)
	if (S_ISBLK(mode) || S_ISCHR(mode))
   10cd9:	8b 44 24 34          	mov    0x34(%esp),%eax
   10cdd:	25 00 f0 00 00       	and    $0xf000,%eax
   10ce2:	3d 00 60 00 00       	cmp    $0x6000,%eax
   10ce7:	74 10                	je     10cf9 <sys_mknod+0x159>
   10ce9:	8b 44 24 34          	mov    0x34(%esp),%eax
   10ced:	25 00 f0 00 00       	and    $0xf000,%eax
   10cf2:	3d 00 20 00 00       	cmp    $0x2000,%eax
   10cf7:	75 0e                	jne    10d07 <sys_mknod+0x167>
		inode->i_zone[0] = dev;
   10cf9:	8b 44 24 38          	mov    0x38(%esp),%eax
   10cfd:	89 c2                	mov    %eax,%edx
   10cff:	8b 44 24 18          	mov    0x18(%esp),%eax
   10d03:	66 89 50 0e          	mov    %dx,0xe(%eax)
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
   10d07:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   10d0d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   10d12:	89 c8                	mov    %ecx,%eax
   10d14:	f7 ea                	imul   %edx
   10d16:	c1 fa 05             	sar    $0x5,%edx
   10d19:	89 c8                	mov    %ecx,%eax
   10d1b:	c1 f8 1f             	sar    $0x1f,%eax
   10d1e:	29 c2                	sub    %eax,%edx
   10d20:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   10d25:	01 d0                	add    %edx,%eax
   10d27:	89 c2                	mov    %eax,%edx
   10d29:	8b 44 24 18          	mov    0x18(%esp),%eax
   10d2d:	89 50 24             	mov    %edx,0x24(%eax)
   10d30:	8b 44 24 18          	mov    0x18(%esp),%eax
   10d34:	8b 50 24             	mov    0x24(%eax),%edx
   10d37:	8b 44 24 18          	mov    0x18(%esp),%eax
   10d3b:	89 50 08             	mov    %edx,0x8(%eax)
	inode->i_dirt = 1;
   10d3e:	8b 44 24 18          	mov    0x18(%esp),%eax
   10d42:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	bh = add_entry(dir,basename,namelen,&de);
   10d46:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   10d4a:	8b 54 24 14          	mov    0x14(%esp),%edx
   10d4e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10d52:	8d 5c 24 08          	lea    0x8(%esp),%ebx
   10d56:	53                   	push   %ebx
   10d57:	51                   	push   %ecx
   10d58:	52                   	push   %edx
   10d59:	50                   	push   %eax
   10d5a:	e8 fc f4 ff ff       	call   1025b <add_entry>
   10d5f:	83 c4 10             	add    $0x10,%esp
   10d62:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   10d66:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   10d6b:	75 2e                	jne    10d9b <sys_mknod+0x1fb>
		iput(dir);
   10d6d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10d71:	83 ec 0c             	sub    $0xc,%esp
   10d74:	50                   	push   %eax
   10d75:	e8 f7 b2 ff ff       	call   c071 <iput>
   10d7a:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks=0;
   10d7d:	8b 44 24 18          	mov    0x18(%esp),%eax
   10d81:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
		iput(inode);
   10d85:	83 ec 0c             	sub    $0xc,%esp
   10d88:	ff 74 24 24          	pushl  0x24(%esp)
   10d8c:	e8 e0 b2 ff ff       	call   c071 <iput>
   10d91:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   10d94:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   10d99:	eb 4a                	jmp    10de5 <sys_mknod+0x245>
	}
	de->inode = inode->i_num;
   10d9b:	8b 44 24 08          	mov    0x8(%esp),%eax
   10d9f:	8b 54 24 18          	mov    0x18(%esp),%edx
   10da3:	0f b7 52 2e          	movzwl 0x2e(%edx),%edx
   10da7:	66 89 10             	mov    %dx,(%eax)
	bh->b_dirt = 1;
   10daa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10dae:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	iput(dir);
   10db2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10db6:	83 ec 0c             	sub    $0xc,%esp
   10db9:	50                   	push   %eax
   10dba:	e8 b2 b2 ff ff       	call   c071 <iput>
   10dbf:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   10dc2:	83 ec 0c             	sub    $0xc,%esp
   10dc5:	ff 74 24 24          	pushl  0x24(%esp)
   10dc9:	e8 a3 b2 ff ff       	call   c071 <iput>
   10dce:	83 c4 10             	add    $0x10,%esp
	brelse(bh);
   10dd1:	83 ec 0c             	sub    $0xc,%esp
   10dd4:	ff 74 24 28          	pushl  0x28(%esp)
   10dd8:	e8 b3 c1 ff ff       	call   cf90 <brelse>
   10ddd:	83 c4 10             	add    $0x10,%esp
	return 0;
   10de0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10de5:	83 c4 28             	add    $0x28,%esp
   10de8:	5b                   	pop    %ebx
   10de9:	c3                   	ret    

00010dea <sys_mkdir>:

int sys_mkdir(const char * pathname, int mode)
{
   10dea:	53                   	push   %ebx
   10deb:	83 ec 28             	sub    $0x28,%esp
	int namelen;
	struct m_inode * dir, * inode;
	struct buffer_head * bh, *dir_block;
	struct dir_entry * de;

	if (!suser())
   10dee:	a1 40 f1 01 00       	mov    0x1f140,%eax
   10df3:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
   10dfa:	66 85 c0             	test   %ax,%ax
   10dfd:	74 0a                	je     10e09 <sys_mkdir+0x1f>
		return -EPERM;
   10dff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10e04:	e9 dc 03 00 00       	jmp    111e5 <sys_mkdir+0x3fb>
	if (!(dir = dir_namei(pathname,&namelen,&basename)))
   10e09:	83 ec 04             	sub    $0x4,%esp
   10e0c:	8d 44 24 14          	lea    0x14(%esp),%eax
   10e10:	50                   	push   %eax
   10e11:	8d 44 24 14          	lea    0x14(%esp),%eax
   10e15:	50                   	push   %eax
   10e16:	ff 74 24 3c          	pushl  0x3c(%esp)
   10e1a:	e8 73 f8 ff ff       	call   10692 <dir_namei>
   10e1f:	83 c4 10             	add    $0x10,%esp
   10e22:	89 44 24 08          	mov    %eax,0x8(%esp)
   10e26:	8b 44 24 08          	mov    0x8(%esp),%eax
   10e2a:	85 c0                	test   %eax,%eax
   10e2c:	75 0a                	jne    10e38 <sys_mkdir+0x4e>
		return -ENOENT;
   10e2e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   10e33:	e9 ad 03 00 00       	jmp    111e5 <sys_mkdir+0x3fb>
	if (!namelen) {
   10e38:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10e3c:	85 c0                	test   %eax,%eax
   10e3e:	75 1a                	jne    10e5a <sys_mkdir+0x70>
		iput(dir);
   10e40:	8b 44 24 08          	mov    0x8(%esp),%eax
   10e44:	83 ec 0c             	sub    $0xc,%esp
   10e47:	50                   	push   %eax
   10e48:	e8 24 b2 ff ff       	call   c071 <iput>
   10e4d:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   10e50:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   10e55:	e9 8b 03 00 00       	jmp    111e5 <sys_mkdir+0x3fb>
	}
	if (!permission(dir,MAY_WRITE)) {
   10e5a:	8b 44 24 08          	mov    0x8(%esp),%eax
   10e5e:	83 ec 08             	sub    $0x8,%esp
   10e61:	6a 02                	push   $0x2
   10e63:	50                   	push   %eax
   10e64:	e8 90 f0 ff ff       	call   fef9 <permission>
   10e69:	83 c4 10             	add    $0x10,%esp
   10e6c:	85 c0                	test   %eax,%eax
   10e6e:	75 1a                	jne    10e8a <sys_mkdir+0xa0>
		iput(dir);
   10e70:	8b 44 24 08          	mov    0x8(%esp),%eax
   10e74:	83 ec 0c             	sub    $0xc,%esp
   10e77:	50                   	push   %eax
   10e78:	e8 f4 b1 ff ff       	call   c071 <iput>
   10e7d:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10e80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10e85:	e9 5b 03 00 00       	jmp    111e5 <sys_mkdir+0x3fb>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   10e8a:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10e8e:	8b 44 24 10          	mov    0x10(%esp),%eax
   10e92:	8d 4c 24 04          	lea    0x4(%esp),%ecx
   10e96:	51                   	push   %ecx
   10e97:	52                   	push   %edx
   10e98:	50                   	push   %eax
   10e99:	8d 44 24 14          	lea    0x14(%esp),%eax
   10e9d:	50                   	push   %eax
   10e9e:	e8 69 f1 ff ff       	call   1000c <find_entry>
   10ea3:	83 c4 10             	add    $0x10,%esp
   10ea6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (bh) {
   10eaa:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   10eaf:	74 29                	je     10eda <sys_mkdir+0xf0>
		brelse(bh);
   10eb1:	83 ec 0c             	sub    $0xc,%esp
   10eb4:	ff 74 24 28          	pushl  0x28(%esp)
   10eb8:	e8 d3 c0 ff ff       	call   cf90 <brelse>
   10ebd:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   10ec0:	8b 44 24 08          	mov    0x8(%esp),%eax
   10ec4:	83 ec 0c             	sub    $0xc,%esp
   10ec7:	50                   	push   %eax
   10ec8:	e8 a4 b1 ff ff       	call   c071 <iput>
   10ecd:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   10ed0:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   10ed5:	e9 0b 03 00 00       	jmp    111e5 <sys_mkdir+0x3fb>
	}
	inode = new_inode(dir->i_dev);
   10eda:	8b 44 24 08          	mov    0x8(%esp),%eax
   10ede:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10ee2:	0f b7 c0             	movzwl %ax,%eax
   10ee5:	83 ec 0c             	sub    $0xc,%esp
   10ee8:	50                   	push   %eax
   10ee9:	e8 cd 12 00 00       	call   121bb <new_inode>
   10eee:	83 c4 10             	add    $0x10,%esp
   10ef1:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!inode) {
   10ef5:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   10efa:	75 1a                	jne    10f16 <sys_mkdir+0x12c>
		iput(dir);
   10efc:	8b 44 24 08          	mov    0x8(%esp),%eax
   10f00:	83 ec 0c             	sub    $0xc,%esp
   10f03:	50                   	push   %eax
   10f04:	e8 68 b1 ff ff       	call   c071 <iput>
   10f09:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   10f0c:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   10f11:	e9 cf 02 00 00       	jmp    111e5 <sys_mkdir+0x3fb>
	}
	inode->i_size = 32;
   10f16:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f1a:	c7 40 04 20 00 00 00 	movl   $0x20,0x4(%eax)
	inode->i_dirt = 1;
   10f21:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f25:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
   10f29:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   10f2f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   10f34:	89 c8                	mov    %ecx,%eax
   10f36:	f7 ea                	imul   %edx
   10f38:	c1 fa 05             	sar    $0x5,%edx
   10f3b:	89 c8                	mov    %ecx,%eax
   10f3d:	c1 f8 1f             	sar    $0x1f,%eax
   10f40:	29 c2                	sub    %eax,%edx
   10f42:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   10f47:	01 d0                	add    %edx,%eax
   10f49:	89 c2                	mov    %eax,%edx
   10f4b:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f4f:	89 50 24             	mov    %edx,0x24(%eax)
   10f52:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f56:	8b 50 24             	mov    0x24(%eax),%edx
   10f59:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f5d:	89 50 08             	mov    %edx,0x8(%eax)
	if (!(inode->i_zone[0]=new_block(inode->i_dev))) {
   10f60:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f64:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10f68:	0f b7 c0             	movzwl %ax,%eax
   10f6b:	83 ec 0c             	sub    $0xc,%esp
   10f6e:	50                   	push   %eax
   10f6f:	e8 04 0f 00 00       	call   11e78 <new_block>
   10f74:	83 c4 10             	add    $0x10,%esp
   10f77:	89 c2                	mov    %eax,%edx
   10f79:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f7d:	66 89 50 0e          	mov    %dx,0xe(%eax)
   10f81:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f85:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   10f89:	66 85 c0             	test   %ax,%ax
   10f8c:	75 3b                	jne    10fc9 <sys_mkdir+0x1df>
		iput(dir);
   10f8e:	8b 44 24 08          	mov    0x8(%esp),%eax
   10f92:	83 ec 0c             	sub    $0xc,%esp
   10f95:	50                   	push   %eax
   10f96:	e8 d6 b0 ff ff       	call   c071 <iput>
   10f9b:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks--;
   10f9e:	8b 44 24 18          	mov    0x18(%esp),%eax
   10fa2:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   10fa6:	8d 50 ff             	lea    -0x1(%eax),%edx
   10fa9:	8b 44 24 18          	mov    0x18(%esp),%eax
   10fad:	88 50 0d             	mov    %dl,0xd(%eax)
		iput(inode);
   10fb0:	83 ec 0c             	sub    $0xc,%esp
   10fb3:	ff 74 24 24          	pushl  0x24(%esp)
   10fb7:	e8 b5 b0 ff ff       	call   c071 <iput>
   10fbc:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   10fbf:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   10fc4:	e9 1c 02 00 00       	jmp    111e5 <sys_mkdir+0x3fb>
	}
	inode->i_dirt = 1;
   10fc9:	8b 44 24 18          	mov    0x18(%esp),%eax
   10fcd:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	if (!(dir_block=bread(inode->i_dev,inode->i_zone[0]))) {
   10fd1:	8b 44 24 18          	mov    0x18(%esp),%eax
   10fd5:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   10fd9:	0f b7 d0             	movzwl %ax,%edx
   10fdc:	8b 44 24 18          	mov    0x18(%esp),%eax
   10fe0:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10fe4:	0f b7 c0             	movzwl %ax,%eax
   10fe7:	83 ec 08             	sub    $0x8,%esp
   10fea:	52                   	push   %edx
   10feb:	50                   	push   %eax
   10fec:	e8 f5 bf ff ff       	call   cfe6 <bread>
   10ff1:	83 c4 10             	add    $0x10,%esp
   10ff4:	89 44 24 14          	mov    %eax,0x14(%esp)
   10ff8:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   10ffd:	75 5e                	jne    1105d <sys_mkdir+0x273>
		iput(dir);
   10fff:	8b 44 24 08          	mov    0x8(%esp),%eax
   11003:	83 ec 0c             	sub    $0xc,%esp
   11006:	50                   	push   %eax
   11007:	e8 65 b0 ff ff       	call   c071 <iput>
   1100c:	83 c4 10             	add    $0x10,%esp
		free_block(inode->i_dev,inode->i_zone[0]);
   1100f:	8b 44 24 18          	mov    0x18(%esp),%eax
   11013:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   11017:	0f b7 d0             	movzwl %ax,%edx
   1101a:	8b 44 24 18          	mov    0x18(%esp),%eax
   1101e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11022:	0f b7 c0             	movzwl %ax,%eax
   11025:	83 ec 08             	sub    $0x8,%esp
   11028:	52                   	push   %edx
   11029:	50                   	push   %eax
   1102a:	e8 c8 0c 00 00       	call   11cf7 <free_block>
   1102f:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks--;
   11032:	8b 44 24 18          	mov    0x18(%esp),%eax
   11036:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1103a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1103d:	8b 44 24 18          	mov    0x18(%esp),%eax
   11041:	88 50 0d             	mov    %dl,0xd(%eax)
		iput(inode);
   11044:	83 ec 0c             	sub    $0xc,%esp
   11047:	ff 74 24 24          	pushl  0x24(%esp)
   1104b:	e8 21 b0 ff ff       	call   c071 <iput>
   11050:	83 c4 10             	add    $0x10,%esp
		return -ERROR;
   11053:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
   11058:	e9 88 01 00 00       	jmp    111e5 <sys_mkdir+0x3fb>
	}
	de = (struct dir_entry *) dir_block->b_data;
   1105d:	8b 44 24 14          	mov    0x14(%esp),%eax
   11061:	8b 00                	mov    (%eax),%eax
   11063:	89 44 24 04          	mov    %eax,0x4(%esp)
	de->inode=inode->i_num;
   11067:	8b 44 24 04          	mov    0x4(%esp),%eax
   1106b:	8b 54 24 18          	mov    0x18(%esp),%edx
   1106f:	0f b7 52 2e          	movzwl 0x2e(%edx),%edx
   11073:	66 89 10             	mov    %dx,(%eax)
	strcpy(de->name,".");
   11076:	8b 44 24 04          	mov    0x4(%esp),%eax
   1107a:	83 c0 02             	add    $0x2,%eax
   1107d:	83 ec 08             	sub    $0x8,%esp
   11080:	68 d0 89 01 00       	push   $0x189d0
   11085:	50                   	push   %eax
   11086:	e8 25 ee ff ff       	call   feb0 <strcpy>
   1108b:	83 c4 10             	add    $0x10,%esp
	de++;
   1108e:	8b 44 24 04          	mov    0x4(%esp),%eax
   11092:	83 c0 10             	add    $0x10,%eax
   11095:	89 44 24 04          	mov    %eax,0x4(%esp)
	de->inode = dir->i_num;
   11099:	8b 44 24 04          	mov    0x4(%esp),%eax
   1109d:	8b 54 24 08          	mov    0x8(%esp),%edx
   110a1:	0f b7 52 2e          	movzwl 0x2e(%edx),%edx
   110a5:	66 89 10             	mov    %dx,(%eax)
	strcpy(de->name,"..");
   110a8:	8b 44 24 04          	mov    0x4(%esp),%eax
   110ac:	83 c0 02             	add    $0x2,%eax
   110af:	83 ec 08             	sub    $0x8,%esp
   110b2:	68 d2 89 01 00       	push   $0x189d2
   110b7:	50                   	push   %eax
   110b8:	e8 f3 ed ff ff       	call   feb0 <strcpy>
   110bd:	83 c4 10             	add    $0x10,%esp
	inode->i_nlinks = 2;
   110c0:	8b 44 24 18          	mov    0x18(%esp),%eax
   110c4:	c6 40 0d 02          	movb   $0x2,0xd(%eax)
	dir_block->b_dirt = 1;
   110c8:	8b 44 24 14          	mov    0x14(%esp),%eax
   110cc:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(dir_block);
   110d0:	83 ec 0c             	sub    $0xc,%esp
   110d3:	ff 74 24 20          	pushl  0x20(%esp)
   110d7:	e8 b4 be ff ff       	call   cf90 <brelse>
   110dc:	83 c4 10             	add    $0x10,%esp
	inode->i_mode = I_DIRECTORY | (mode & 0777 & ~current->umask);
   110df:	8b 44 24 34          	mov    0x34(%esp),%eax
   110e3:	66 25 ff 01          	and    $0x1ff,%ax
   110e7:	89 c2                	mov    %eax,%edx
   110e9:	a1 40 f1 01 00       	mov    0x1f140,%eax
   110ee:	0f b7 80 6c 02 00 00 	movzwl 0x26c(%eax),%eax
   110f5:	f7 d0                	not    %eax
   110f7:	21 d0                	and    %edx,%eax
   110f9:	80 cc 40             	or     $0x40,%ah
   110fc:	89 c2                	mov    %eax,%edx
   110fe:	8b 44 24 18          	mov    0x18(%esp),%eax
   11102:	66 89 10             	mov    %dx,(%eax)
	inode->i_dirt = 1;
   11105:	8b 44 24 18          	mov    0x18(%esp),%eax
   11109:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	bh = add_entry(dir,basename,namelen,&de);
   1110d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   11111:	8b 54 24 10          	mov    0x10(%esp),%edx
   11115:	8b 44 24 08          	mov    0x8(%esp),%eax
   11119:	8d 5c 24 04          	lea    0x4(%esp),%ebx
   1111d:	53                   	push   %ebx
   1111e:	51                   	push   %ecx
   1111f:	52                   	push   %edx
   11120:	50                   	push   %eax
   11121:	e8 35 f1 ff ff       	call   1025b <add_entry>
   11126:	83 c4 10             	add    $0x10,%esp
   11129:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   1112d:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   11132:	75 51                	jne    11185 <sys_mkdir+0x39b>
		iput(dir);
   11134:	8b 44 24 08          	mov    0x8(%esp),%eax
   11138:	83 ec 0c             	sub    $0xc,%esp
   1113b:	50                   	push   %eax
   1113c:	e8 30 af ff ff       	call   c071 <iput>
   11141:	83 c4 10             	add    $0x10,%esp
		free_block(inode->i_dev,inode->i_zone[0]);
   11144:	8b 44 24 18          	mov    0x18(%esp),%eax
   11148:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1114c:	0f b7 d0             	movzwl %ax,%edx
   1114f:	8b 44 24 18          	mov    0x18(%esp),%eax
   11153:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11157:	0f b7 c0             	movzwl %ax,%eax
   1115a:	83 ec 08             	sub    $0x8,%esp
   1115d:	52                   	push   %edx
   1115e:	50                   	push   %eax
   1115f:	e8 93 0b 00 00       	call   11cf7 <free_block>
   11164:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks=0;
   11167:	8b 44 24 18          	mov    0x18(%esp),%eax
   1116b:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
		iput(inode);
   1116f:	83 ec 0c             	sub    $0xc,%esp
   11172:	ff 74 24 24          	pushl  0x24(%esp)
   11176:	e8 f6 ae ff ff       	call   c071 <iput>
   1117b:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   1117e:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   11183:	eb 60                	jmp    111e5 <sys_mkdir+0x3fb>
	}
	de->inode = inode->i_num;
   11185:	8b 44 24 04          	mov    0x4(%esp),%eax
   11189:	8b 54 24 18          	mov    0x18(%esp),%edx
   1118d:	0f b7 52 2e          	movzwl 0x2e(%edx),%edx
   11191:	66 89 10             	mov    %dx,(%eax)
	bh->b_dirt = 1;
   11194:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11198:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	dir->i_nlinks++;
   1119c:	8b 44 24 08          	mov    0x8(%esp),%eax
   111a0:	0f b6 50 0d          	movzbl 0xd(%eax),%edx
   111a4:	83 c2 01             	add    $0x1,%edx
   111a7:	88 50 0d             	mov    %dl,0xd(%eax)
	dir->i_dirt = 1;
   111aa:	8b 44 24 08          	mov    0x8(%esp),%eax
   111ae:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(dir);
   111b2:	8b 44 24 08          	mov    0x8(%esp),%eax
   111b6:	83 ec 0c             	sub    $0xc,%esp
   111b9:	50                   	push   %eax
   111ba:	e8 b2 ae ff ff       	call   c071 <iput>
   111bf:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   111c2:	83 ec 0c             	sub    $0xc,%esp
   111c5:	ff 74 24 24          	pushl  0x24(%esp)
   111c9:	e8 a3 ae ff ff       	call   c071 <iput>
   111ce:	83 c4 10             	add    $0x10,%esp
	brelse(bh);
   111d1:	83 ec 0c             	sub    $0xc,%esp
   111d4:	ff 74 24 28          	pushl  0x28(%esp)
   111d8:	e8 b3 bd ff ff       	call   cf90 <brelse>
   111dd:	83 c4 10             	add    $0x10,%esp
	return 0;
   111e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   111e5:	83 c4 28             	add    $0x28,%esp
   111e8:	5b                   	pop    %ebx
   111e9:	c3                   	ret    

000111ea <empty_dir>:

/*
 * routine to check that the specified directory is empty (for rmdir)
 */
static int empty_dir(struct m_inode * inode)
{
   111ea:	83 ec 2c             	sub    $0x2c,%esp
	int nr,block;
	int len;
	struct buffer_head * bh;
	struct dir_entry * de;

	len = inode->i_size / sizeof (struct dir_entry);
   111ed:	8b 44 24 30          	mov    0x30(%esp),%eax
   111f1:	8b 40 04             	mov    0x4(%eax),%eax
   111f4:	c1 e8 04             	shr    $0x4,%eax
   111f7:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (len<2 || !inode->i_zone[0] ||
   111fb:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
   11200:	7e 3b                	jle    1123d <empty_dir+0x53>
   11202:	8b 44 24 30          	mov    0x30(%esp),%eax
   11206:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1120a:	66 85 c0             	test   %ax,%ax
   1120d:	74 2e                	je     1123d <empty_dir+0x53>
	    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {
   1120f:	8b 44 24 30          	mov    0x30(%esp),%eax
   11213:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   11217:	0f b7 d0             	movzwl %ax,%edx
   1121a:	8b 44 24 30          	mov    0x30(%esp),%eax
   1121e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11222:	0f b7 c0             	movzwl %ax,%eax
	int len;
	struct buffer_head * bh;
	struct dir_entry * de;

	len = inode->i_size / sizeof (struct dir_entry);
	if (len<2 || !inode->i_zone[0] ||
   11225:	83 ec 08             	sub    $0x8,%esp
   11228:	52                   	push   %edx
   11229:	50                   	push   %eax
   1122a:	e8 b7 bd ff ff       	call   cfe6 <bread>
   1122f:	83 c4 10             	add    $0x10,%esp
   11232:	89 44 24 18          	mov    %eax,0x18(%esp)
   11236:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   1123b:	75 26                	jne    11263 <empty_dir+0x79>
	    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {
	    	printk("warning - bad directory on dev %04x\n",inode->i_dev);
   1123d:	8b 44 24 30          	mov    0x30(%esp),%eax
   11241:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11245:	0f b7 c0             	movzwl %ax,%eax
   11248:	83 ec 08             	sub    $0x8,%esp
   1124b:	50                   	push   %eax
   1124c:	68 d8 89 01 00       	push   $0x189d8
   11251:	e8 b7 75 ff ff       	call   880d <printk>
   11256:	83 c4 10             	add    $0x10,%esp
		return 0;
   11259:	b8 00 00 00 00       	mov    $0x0,%eax
   1125e:	e9 74 01 00 00       	jmp    113d7 <empty_dir+0x1ed>
	}
	de = (struct dir_entry *) bh->b_data;
   11263:	8b 44 24 18          	mov    0x18(%esp),%eax
   11267:	8b 00                	mov    (%eax),%eax
   11269:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (de[0].inode != inode->i_num || !de[1].inode || 
   1126d:	8b 44 24 14          	mov    0x14(%esp),%eax
   11271:	0f b7 10             	movzwl (%eax),%edx
   11274:	8b 44 24 30          	mov    0x30(%esp),%eax
   11278:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
   1127c:	66 39 c2             	cmp    %ax,%dx
   1127f:	75 4a                	jne    112cb <empty_dir+0xe1>
   11281:	8b 44 24 14          	mov    0x14(%esp),%eax
   11285:	83 c0 10             	add    $0x10,%eax
   11288:	0f b7 00             	movzwl (%eax),%eax
   1128b:	66 85 c0             	test   %ax,%ax
   1128e:	74 3b                	je     112cb <empty_dir+0xe1>
	    strcmp(".",de[0].name) || strcmp("..",de[1].name)) {
   11290:	8b 44 24 14          	mov    0x14(%esp),%eax
   11294:	83 c0 02             	add    $0x2,%eax
   11297:	83 ec 08             	sub    $0x8,%esp
   1129a:	50                   	push   %eax
   1129b:	68 d0 89 01 00       	push   $0x189d0
   112a0:	e8 27 ec ff ff       	call   fecc <strcmp>
   112a5:	83 c4 10             	add    $0x10,%esp
	    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {
	    	printk("warning - bad directory on dev %04x\n",inode->i_dev);
		return 0;
	}
	de = (struct dir_entry *) bh->b_data;
	if (de[0].inode != inode->i_num || !de[1].inode || 
   112a8:	85 c0                	test   %eax,%eax
   112aa:	75 1f                	jne    112cb <empty_dir+0xe1>
	    strcmp(".",de[0].name) || strcmp("..",de[1].name)) {
   112ac:	8b 44 24 14          	mov    0x14(%esp),%eax
   112b0:	83 c0 10             	add    $0x10,%eax
   112b3:	83 c0 02             	add    $0x2,%eax
   112b6:	83 ec 08             	sub    $0x8,%esp
   112b9:	50                   	push   %eax
   112ba:	68 d2 89 01 00       	push   $0x189d2
   112bf:	e8 08 ec ff ff       	call   fecc <strcmp>
   112c4:	83 c4 10             	add    $0x10,%esp
   112c7:	85 c0                	test   %eax,%eax
   112c9:	74 26                	je     112f1 <empty_dir+0x107>
	    	printk("warning - bad directory on dev %04x\n",inode->i_dev);
   112cb:	8b 44 24 30          	mov    0x30(%esp),%eax
   112cf:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   112d3:	0f b7 c0             	movzwl %ax,%eax
   112d6:	83 ec 08             	sub    $0x8,%esp
   112d9:	50                   	push   %eax
   112da:	68 d8 89 01 00       	push   $0x189d8
   112df:	e8 29 75 ff ff       	call   880d <printk>
   112e4:	83 c4 10             	add    $0x10,%esp
		return 0;
   112e7:	b8 00 00 00 00       	mov    $0x0,%eax
   112ec:	e9 e6 00 00 00       	jmp    113d7 <empty_dir+0x1ed>
	}
	nr = 2;
   112f1:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
   112f8:	00 
	de += 2;
   112f9:	83 44 24 14 20       	addl   $0x20,0x14(%esp)
	while (nr<len) {
   112fe:	e9 b2 00 00 00       	jmp    113b5 <empty_dir+0x1cb>
		if ((void *) de >= (void *) (bh->b_data+BLOCK_SIZE)) {
   11303:	8b 44 24 18          	mov    0x18(%esp),%eax
   11307:	8b 00                	mov    (%eax),%eax
   11309:	05 00 04 00 00       	add    $0x400,%eax
   1130e:	3b 44 24 14          	cmp    0x14(%esp),%eax
   11312:	77 75                	ja     11389 <empty_dir+0x19f>
			brelse(bh);
   11314:	83 ec 0c             	sub    $0xc,%esp
   11317:	ff 74 24 24          	pushl  0x24(%esp)
   1131b:	e8 70 bc ff ff       	call   cf90 <brelse>
   11320:	83 c4 10             	add    $0x10,%esp
			block=bmap(inode,nr/DIR_ENTRIES_PER_BLOCK);
   11323:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11327:	c1 e8 06             	shr    $0x6,%eax
   1132a:	83 ec 08             	sub    $0x8,%esp
   1132d:	50                   	push   %eax
   1132e:	ff 74 24 3c          	pushl  0x3c(%esp)
   11332:	e8 02 ad ff ff       	call   c039 <bmap>
   11337:	83 c4 10             	add    $0x10,%esp
   1133a:	89 44 24 0c          	mov    %eax,0xc(%esp)
			if (!block) {
   1133e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11343:	75 0d                	jne    11352 <empty_dir+0x168>
				nr += DIR_ENTRIES_PER_BLOCK;
   11345:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11349:	83 c0 40             	add    $0x40,%eax
   1134c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
				continue;
   11350:	eb 63                	jmp    113b5 <empty_dir+0x1cb>
			}
			if (!(bh=bread(inode->i_dev,block)))
   11352:	8b 44 24 30          	mov    0x30(%esp),%eax
   11356:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1135a:	0f b7 c0             	movzwl %ax,%eax
   1135d:	83 ec 08             	sub    $0x8,%esp
   11360:	ff 74 24 14          	pushl  0x14(%esp)
   11364:	50                   	push   %eax
   11365:	e8 7c bc ff ff       	call   cfe6 <bread>
   1136a:	83 c4 10             	add    $0x10,%esp
   1136d:	89 44 24 18          	mov    %eax,0x18(%esp)
   11371:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   11376:	75 07                	jne    1137f <empty_dir+0x195>
				return 0;
   11378:	b8 00 00 00 00       	mov    $0x0,%eax
   1137d:	eb 58                	jmp    113d7 <empty_dir+0x1ed>
			de = (struct dir_entry *) bh->b_data;
   1137f:	8b 44 24 18          	mov    0x18(%esp),%eax
   11383:	8b 00                	mov    (%eax),%eax
   11385:	89 44 24 14          	mov    %eax,0x14(%esp)
		}
		if (de->inode) {
   11389:	8b 44 24 14          	mov    0x14(%esp),%eax
   1138d:	0f b7 00             	movzwl (%eax),%eax
   11390:	66 85 c0             	test   %ax,%ax
   11393:	74 16                	je     113ab <empty_dir+0x1c1>
			brelse(bh);
   11395:	83 ec 0c             	sub    $0xc,%esp
   11398:	ff 74 24 24          	pushl  0x24(%esp)
   1139c:	e8 ef bb ff ff       	call   cf90 <brelse>
   113a1:	83 c4 10             	add    $0x10,%esp
			return 0;
   113a4:	b8 00 00 00 00       	mov    $0x0,%eax
   113a9:	eb 2c                	jmp    113d7 <empty_dir+0x1ed>
		}
		de++;
   113ab:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
		nr++;
   113b0:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
	    	printk("warning - bad directory on dev %04x\n",inode->i_dev);
		return 0;
	}
	nr = 2;
	de += 2;
	while (nr<len) {
   113b5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   113b9:	3b 44 24 10          	cmp    0x10(%esp),%eax
   113bd:	0f 8c 40 ff ff ff    	jl     11303 <empty_dir+0x119>
			return 0;
		}
		de++;
		nr++;
	}
	brelse(bh);
   113c3:	83 ec 0c             	sub    $0xc,%esp
   113c6:	ff 74 24 24          	pushl  0x24(%esp)
   113ca:	e8 c1 bb ff ff       	call   cf90 <brelse>
   113cf:	83 c4 10             	add    $0x10,%esp
	return 1;
   113d2:	b8 01 00 00 00       	mov    $0x1,%eax
}
   113d7:	83 c4 2c             	add    $0x2c,%esp
   113da:	c3                   	ret    

000113db <sys_rmdir>:

int sys_rmdir(const char * name)
{
   113db:	56                   	push   %esi
   113dc:	53                   	push   %ebx
   113dd:	83 ec 24             	sub    $0x24,%esp
	int namelen;
	struct m_inode * dir, * inode;
	struct buffer_head * bh;
	struct dir_entry * de;

	if (!suser())
   113e0:	a1 40 f1 01 00       	mov    0x1f140,%eax
   113e5:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
   113ec:	66 85 c0             	test   %ax,%ax
   113ef:	74 0a                	je     113fb <sys_rmdir+0x20>
		return -EPERM;
   113f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   113f6:	e9 86 03 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	if (!(dir = dir_namei(name,&namelen,&basename)))
   113fb:	83 ec 04             	sub    $0x4,%esp
   113fe:	8d 44 24 18          	lea    0x18(%esp),%eax
   11402:	50                   	push   %eax
   11403:	8d 44 24 18          	lea    0x18(%esp),%eax
   11407:	50                   	push   %eax
   11408:	ff 74 24 3c          	pushl  0x3c(%esp)
   1140c:	e8 81 f2 ff ff       	call   10692 <dir_namei>
   11411:	83 c4 10             	add    $0x10,%esp
   11414:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11418:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1141c:	85 c0                	test   %eax,%eax
   1141e:	75 0a                	jne    1142a <sys_rmdir+0x4f>
		return -ENOENT;
   11420:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   11425:	e9 57 03 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	if (!namelen) {
   1142a:	8b 44 24 10          	mov    0x10(%esp),%eax
   1142e:	85 c0                	test   %eax,%eax
   11430:	75 1a                	jne    1144c <sys_rmdir+0x71>
		iput(dir);
   11432:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11436:	83 ec 0c             	sub    $0xc,%esp
   11439:	50                   	push   %eax
   1143a:	e8 32 ac ff ff       	call   c071 <iput>
   1143f:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   11442:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   11447:	e9 35 03 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	if (!permission(dir,MAY_WRITE)) {
   1144c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11450:	83 ec 08             	sub    $0x8,%esp
   11453:	6a 02                	push   $0x2
   11455:	50                   	push   %eax
   11456:	e8 9e ea ff ff       	call   fef9 <permission>
   1145b:	83 c4 10             	add    $0x10,%esp
   1145e:	85 c0                	test   %eax,%eax
   11460:	75 1a                	jne    1147c <sys_rmdir+0xa1>
		iput(dir);
   11462:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11466:	83 ec 0c             	sub    $0xc,%esp
   11469:	50                   	push   %eax
   1146a:	e8 02 ac ff ff       	call   c071 <iput>
   1146f:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   11472:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11477:	e9 05 03 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   1147c:	8b 54 24 10          	mov    0x10(%esp),%edx
   11480:	8b 44 24 14          	mov    0x14(%esp),%eax
   11484:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   11488:	51                   	push   %ecx
   11489:	52                   	push   %edx
   1148a:	50                   	push   %eax
   1148b:	8d 44 24 18          	lea    0x18(%esp),%eax
   1148f:	50                   	push   %eax
   11490:	e8 77 eb ff ff       	call   1000c <find_entry>
   11495:	83 c4 10             	add    $0x10,%esp
   11498:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   1149c:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   114a1:	75 1a                	jne    114bd <sys_rmdir+0xe2>
		iput(dir);
   114a3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   114a7:	83 ec 0c             	sub    $0xc,%esp
   114aa:	50                   	push   %eax
   114ab:	e8 c1 ab ff ff       	call   c071 <iput>
   114b0:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   114b3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   114b8:	e9 c4 02 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	if (!(inode = iget(dir->i_dev, de->inode))) {
   114bd:	8b 44 24 08          	mov    0x8(%esp),%eax
   114c1:	0f b7 00             	movzwl (%eax),%eax
   114c4:	0f b7 d0             	movzwl %ax,%edx
   114c7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   114cb:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   114cf:	0f b7 c0             	movzwl %ax,%eax
   114d2:	83 ec 08             	sub    $0x8,%esp
   114d5:	52                   	push   %edx
   114d6:	50                   	push   %eax
   114d7:	e8 18 af ff ff       	call   c3f4 <iget>
   114dc:	83 c4 10             	add    $0x10,%esp
   114df:	89 44 24 18          	mov    %eax,0x18(%esp)
   114e3:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   114e8:	75 29                	jne    11513 <sys_rmdir+0x138>
		iput(dir);
   114ea:	8b 44 24 0c          	mov    0xc(%esp),%eax
   114ee:	83 ec 0c             	sub    $0xc,%esp
   114f1:	50                   	push   %eax
   114f2:	e8 7a ab ff ff       	call   c071 <iput>
   114f7:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   114fa:	83 ec 0c             	sub    $0xc,%esp
   114fd:	ff 74 24 28          	pushl  0x28(%esp)
   11501:	e8 8a ba ff ff       	call   cf90 <brelse>
   11506:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   11509:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1150e:	e9 6e 02 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	if ((dir->i_mode & S_ISVTX) && current->euid &&
   11513:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11517:	0f b7 00             	movzwl (%eax),%eax
   1151a:	0f b7 c0             	movzwl %ax,%eax
   1151d:	25 00 02 00 00       	and    $0x200,%eax
   11522:	85 c0                	test   %eax,%eax
   11524:	74 62                	je     11588 <sys_rmdir+0x1ad>
   11526:	a1 40 f1 01 00       	mov    0x1f140,%eax
   1152b:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
   11532:	66 85 c0             	test   %ax,%ax
   11535:	74 51                	je     11588 <sys_rmdir+0x1ad>
	    inode->i_uid != current->euid) {
   11537:	8b 44 24 18          	mov    0x18(%esp),%eax
   1153b:	0f b7 50 02          	movzwl 0x2(%eax),%edx
   1153f:	a1 40 f1 01 00       	mov    0x1f140,%eax
   11544:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
	if (!(inode = iget(dir->i_dev, de->inode))) {
		iput(dir);
		brelse(bh);
		return -EPERM;
	}
	if ((dir->i_mode & S_ISVTX) && current->euid &&
   1154b:	66 39 c2             	cmp    %ax,%dx
   1154e:	74 38                	je     11588 <sys_rmdir+0x1ad>
	    inode->i_uid != current->euid) {
		iput(dir);
   11550:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11554:	83 ec 0c             	sub    $0xc,%esp
   11557:	50                   	push   %eax
   11558:	e8 14 ab ff ff       	call   c071 <iput>
   1155d:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   11560:	83 ec 0c             	sub    $0xc,%esp
   11563:	ff 74 24 24          	pushl  0x24(%esp)
   11567:	e8 05 ab ff ff       	call   c071 <iput>
   1156c:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   1156f:	83 ec 0c             	sub    $0xc,%esp
   11572:	ff 74 24 28          	pushl  0x28(%esp)
   11576:	e8 15 ba ff ff       	call   cf90 <brelse>
   1157b:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   1157e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11583:	e9 f9 01 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	if (inode->i_dev != dir->i_dev || inode->i_count>1) {
   11588:	8b 44 24 18          	mov    0x18(%esp),%eax
   1158c:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
   11590:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11594:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11598:	66 39 c2             	cmp    %ax,%dx
   1159b:	75 0e                	jne    115ab <sys_rmdir+0x1d0>
   1159d:	8b 44 24 18          	mov    0x18(%esp),%eax
   115a1:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   115a5:	66 83 f8 01          	cmp    $0x1,%ax
   115a9:	76 38                	jbe    115e3 <sys_rmdir+0x208>
		iput(dir);
   115ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
   115af:	83 ec 0c             	sub    $0xc,%esp
   115b2:	50                   	push   %eax
   115b3:	e8 b9 aa ff ff       	call   c071 <iput>
   115b8:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   115bb:	83 ec 0c             	sub    $0xc,%esp
   115be:	ff 74 24 24          	pushl  0x24(%esp)
   115c2:	e8 aa aa ff ff       	call   c071 <iput>
   115c7:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   115ca:	83 ec 0c             	sub    $0xc,%esp
   115cd:	ff 74 24 28          	pushl  0x28(%esp)
   115d1:	e8 ba b9 ff ff       	call   cf90 <brelse>
   115d6:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   115d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   115de:	e9 9e 01 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	if (inode == dir) {	/* we may not delete ".", but "../dir" is ok */
   115e3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   115e7:	39 44 24 18          	cmp    %eax,0x18(%esp)
   115eb:	75 38                	jne    11625 <sys_rmdir+0x24a>
		iput(inode);
   115ed:	83 ec 0c             	sub    $0xc,%esp
   115f0:	ff 74 24 24          	pushl  0x24(%esp)
   115f4:	e8 78 aa ff ff       	call   c071 <iput>
   115f9:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   115fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11600:	83 ec 0c             	sub    $0xc,%esp
   11603:	50                   	push   %eax
   11604:	e8 68 aa ff ff       	call   c071 <iput>
   11609:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   1160c:	83 ec 0c             	sub    $0xc,%esp
   1160f:	ff 74 24 28          	pushl  0x28(%esp)
   11613:	e8 78 b9 ff ff       	call   cf90 <brelse>
   11618:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   1161b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11620:	e9 5c 01 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	if (!S_ISDIR(inode->i_mode)) {
   11625:	8b 44 24 18          	mov    0x18(%esp),%eax
   11629:	0f b7 00             	movzwl (%eax),%eax
   1162c:	0f b7 c0             	movzwl %ax,%eax
   1162f:	25 00 f0 00 00       	and    $0xf000,%eax
   11634:	3d 00 40 00 00       	cmp    $0x4000,%eax
   11639:	74 38                	je     11673 <sys_rmdir+0x298>
		iput(inode);
   1163b:	83 ec 0c             	sub    $0xc,%esp
   1163e:	ff 74 24 24          	pushl  0x24(%esp)
   11642:	e8 2a aa ff ff       	call   c071 <iput>
   11647:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   1164a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1164e:	83 ec 0c             	sub    $0xc,%esp
   11651:	50                   	push   %eax
   11652:	e8 1a aa ff ff       	call   c071 <iput>
   11657:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   1165a:	83 ec 0c             	sub    $0xc,%esp
   1165d:	ff 74 24 28          	pushl  0x28(%esp)
   11661:	e8 2a b9 ff ff       	call   cf90 <brelse>
   11666:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
   11669:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
   1166e:	e9 0e 01 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	if (!empty_dir(inode)) {
   11673:	83 ec 0c             	sub    $0xc,%esp
   11676:	ff 74 24 24          	pushl  0x24(%esp)
   1167a:	e8 6b fb ff ff       	call   111ea <empty_dir>
   1167f:	83 c4 10             	add    $0x10,%esp
   11682:	85 c0                	test   %eax,%eax
   11684:	75 38                	jne    116be <sys_rmdir+0x2e3>
		iput(inode);
   11686:	83 ec 0c             	sub    $0xc,%esp
   11689:	ff 74 24 24          	pushl  0x24(%esp)
   1168d:	e8 df a9 ff ff       	call   c071 <iput>
   11692:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   11695:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11699:	83 ec 0c             	sub    $0xc,%esp
   1169c:	50                   	push   %eax
   1169d:	e8 cf a9 ff ff       	call   c071 <iput>
   116a2:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   116a5:	83 ec 0c             	sub    $0xc,%esp
   116a8:	ff 74 24 28          	pushl  0x28(%esp)
   116ac:	e8 df b8 ff ff       	call   cf90 <brelse>
   116b1:	83 c4 10             	add    $0x10,%esp
		return -ENOTEMPTY;
   116b4:	b8 d9 ff ff ff       	mov    $0xffffffd9,%eax
   116b9:	e9 c3 00 00 00       	jmp    11781 <sys_rmdir+0x3a6>
	}
	if (inode->i_nlinks != 2)
   116be:	8b 44 24 18          	mov    0x18(%esp),%eax
   116c2:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   116c6:	3c 02                	cmp    $0x2,%al
   116c8:	74 1c                	je     116e6 <sys_rmdir+0x30b>
		printk("empty directory has nlink!=2 (%d)",inode->i_nlinks);
   116ca:	8b 44 24 18          	mov    0x18(%esp),%eax
   116ce:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   116d2:	0f b6 c0             	movzbl %al,%eax
   116d5:	83 ec 08             	sub    $0x8,%esp
   116d8:	50                   	push   %eax
   116d9:	68 00 8a 01 00       	push   $0x18a00
   116de:	e8 2a 71 ff ff       	call   880d <printk>
   116e3:	83 c4 10             	add    $0x10,%esp
	de->inode = 0;
   116e6:	8b 44 24 08          	mov    0x8(%esp),%eax
   116ea:	66 c7 00 00 00       	movw   $0x0,(%eax)
	bh->b_dirt = 1;
   116ef:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   116f3:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   116f7:	83 ec 0c             	sub    $0xc,%esp
   116fa:	ff 74 24 28          	pushl  0x28(%esp)
   116fe:	e8 8d b8 ff ff       	call   cf90 <brelse>
   11703:	83 c4 10             	add    $0x10,%esp
	inode->i_nlinks=0;
   11706:	8b 44 24 18          	mov    0x18(%esp),%eax
   1170a:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	inode->i_dirt=1;
   1170e:	8b 44 24 18          	mov    0x18(%esp),%eax
   11712:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	dir->i_nlinks--;
   11716:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1171a:	0f b6 50 0d          	movzbl 0xd(%eax),%edx
   1171e:	83 ea 01             	sub    $0x1,%edx
   11721:	88 50 0d             	mov    %dl,0xd(%eax)
	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
   11724:	8b 74 24 0c          	mov    0xc(%esp),%esi
   11728:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1172c:	8b 1d e0 1e 02 00    	mov    0x21ee0,%ebx
   11732:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   11737:	89 d8                	mov    %ebx,%eax
   11739:	f7 ea                	imul   %edx
   1173b:	c1 fa 05             	sar    $0x5,%edx
   1173e:	89 d8                	mov    %ebx,%eax
   11740:	c1 f8 1f             	sar    $0x1f,%eax
   11743:	29 c2                	sub    %eax,%edx
   11745:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   1174a:	01 d0                	add    %edx,%eax
   1174c:	89 41 08             	mov    %eax,0x8(%ecx)
   1174f:	8b 41 08             	mov    0x8(%ecx),%eax
   11752:	89 46 28             	mov    %eax,0x28(%esi)
	dir->i_dirt=1;
   11755:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11759:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(dir);
   1175d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11761:	83 ec 0c             	sub    $0xc,%esp
   11764:	50                   	push   %eax
   11765:	e8 07 a9 ff ff       	call   c071 <iput>
   1176a:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   1176d:	83 ec 0c             	sub    $0xc,%esp
   11770:	ff 74 24 24          	pushl  0x24(%esp)
   11774:	e8 f8 a8 ff ff       	call   c071 <iput>
   11779:	83 c4 10             	add    $0x10,%esp
	return 0;
   1177c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11781:	83 c4 24             	add    $0x24,%esp
   11784:	5b                   	pop    %ebx
   11785:	5e                   	pop    %esi
   11786:	c3                   	ret    

00011787 <sys_unlink>:

int sys_unlink(const char * name)
{
   11787:	83 ec 2c             	sub    $0x2c,%esp
	int namelen;
	struct m_inode * dir, * inode;
	struct buffer_head * bh;
	struct dir_entry * de;

	if (!(dir = dir_namei(name,&namelen,&basename)))
   1178a:	83 ec 04             	sub    $0x4,%esp
   1178d:	8d 44 24 18          	lea    0x18(%esp),%eax
   11791:	50                   	push   %eax
   11792:	8d 44 24 18          	lea    0x18(%esp),%eax
   11796:	50                   	push   %eax
   11797:	ff 74 24 3c          	pushl  0x3c(%esp)
   1179b:	e8 f2 ee ff ff       	call   10692 <dir_namei>
   117a0:	83 c4 10             	add    $0x10,%esp
   117a3:	89 44 24 0c          	mov    %eax,0xc(%esp)
   117a7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   117ab:	85 c0                	test   %eax,%eax
   117ad:	75 0a                	jne    117b9 <sys_unlink+0x32>
		return -ENOENT;
   117af:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   117b4:	e9 91 02 00 00       	jmp    11a4a <sys_unlink+0x2c3>
	if (!namelen) {
   117b9:	8b 44 24 10          	mov    0x10(%esp),%eax
   117bd:	85 c0                	test   %eax,%eax
   117bf:	75 1a                	jne    117db <sys_unlink+0x54>
		iput(dir);
   117c1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   117c5:	83 ec 0c             	sub    $0xc,%esp
   117c8:	50                   	push   %eax
   117c9:	e8 a3 a8 ff ff       	call   c071 <iput>
   117ce:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   117d1:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   117d6:	e9 6f 02 00 00       	jmp    11a4a <sys_unlink+0x2c3>
	}
	if (!permission(dir,MAY_WRITE)) {
   117db:	8b 44 24 0c          	mov    0xc(%esp),%eax
   117df:	83 ec 08             	sub    $0x8,%esp
   117e2:	6a 02                	push   $0x2
   117e4:	50                   	push   %eax
   117e5:	e8 0f e7 ff ff       	call   fef9 <permission>
   117ea:	83 c4 10             	add    $0x10,%esp
   117ed:	85 c0                	test   %eax,%eax
   117ef:	75 1a                	jne    1180b <sys_unlink+0x84>
		iput(dir);
   117f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   117f5:	83 ec 0c             	sub    $0xc,%esp
   117f8:	50                   	push   %eax
   117f9:	e8 73 a8 ff ff       	call   c071 <iput>
   117fe:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   11801:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11806:	e9 3f 02 00 00       	jmp    11a4a <sys_unlink+0x2c3>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   1180b:	8b 54 24 10          	mov    0x10(%esp),%edx
   1180f:	8b 44 24 14          	mov    0x14(%esp),%eax
   11813:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   11817:	51                   	push   %ecx
   11818:	52                   	push   %edx
   11819:	50                   	push   %eax
   1181a:	8d 44 24 18          	lea    0x18(%esp),%eax
   1181e:	50                   	push   %eax
   1181f:	e8 e8 e7 ff ff       	call   1000c <find_entry>
   11824:	83 c4 10             	add    $0x10,%esp
   11827:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!bh) {
   1182b:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   11830:	75 1a                	jne    1184c <sys_unlink+0xc5>
		iput(dir);
   11832:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11836:	83 ec 0c             	sub    $0xc,%esp
   11839:	50                   	push   %eax
   1183a:	e8 32 a8 ff ff       	call   c071 <iput>
   1183f:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   11842:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   11847:	e9 fe 01 00 00       	jmp    11a4a <sys_unlink+0x2c3>
	}
	if (!(inode = iget(dir->i_dev, de->inode))) {
   1184c:	8b 44 24 08          	mov    0x8(%esp),%eax
   11850:	0f b7 00             	movzwl (%eax),%eax
   11853:	0f b7 d0             	movzwl %ax,%edx
   11856:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1185a:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1185e:	0f b7 c0             	movzwl %ax,%eax
   11861:	83 ec 08             	sub    $0x8,%esp
   11864:	52                   	push   %edx
   11865:	50                   	push   %eax
   11866:	e8 89 ab ff ff       	call   c3f4 <iget>
   1186b:	83 c4 10             	add    $0x10,%esp
   1186e:	89 44 24 18          	mov    %eax,0x18(%esp)
   11872:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   11877:	75 29                	jne    118a2 <sys_unlink+0x11b>
		iput(dir);
   11879:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1187d:	83 ec 0c             	sub    $0xc,%esp
   11880:	50                   	push   %eax
   11881:	e8 eb a7 ff ff       	call   c071 <iput>
   11886:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   11889:	83 ec 0c             	sub    $0xc,%esp
   1188c:	ff 74 24 28          	pushl  0x28(%esp)
   11890:	e8 fb b6 ff ff       	call   cf90 <brelse>
   11895:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   11898:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1189d:	e9 a8 01 00 00       	jmp    11a4a <sys_unlink+0x2c3>
	}
	if ((dir->i_mode & S_ISVTX) && !suser() &&
   118a2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   118a6:	0f b7 00             	movzwl (%eax),%eax
   118a9:	0f b7 c0             	movzwl %ax,%eax
   118ac:	25 00 02 00 00       	and    $0x200,%eax
   118b1:	85 c0                	test   %eax,%eax
   118b3:	74 7b                	je     11930 <sys_unlink+0x1a9>
   118b5:	a1 40 f1 01 00       	mov    0x1f140,%eax
   118ba:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
   118c1:	66 85 c0             	test   %ax,%ax
   118c4:	74 6a                	je     11930 <sys_unlink+0x1a9>
	    current->euid != inode->i_uid &&
   118c6:	a1 40 f1 01 00       	mov    0x1f140,%eax
   118cb:	0f b7 90 42 02 00 00 	movzwl 0x242(%eax),%edx
   118d2:	8b 44 24 18          	mov    0x18(%esp),%eax
   118d6:	0f b7 40 02          	movzwl 0x2(%eax),%eax
	if (!(inode = iget(dir->i_dev, de->inode))) {
		iput(dir);
		brelse(bh);
		return -ENOENT;
	}
	if ((dir->i_mode & S_ISVTX) && !suser() &&
   118da:	66 39 c2             	cmp    %ax,%dx
   118dd:	74 51                	je     11930 <sys_unlink+0x1a9>
	    current->euid != inode->i_uid &&
	    current->euid != dir->i_uid) {
   118df:	a1 40 f1 01 00       	mov    0x1f140,%eax
   118e4:	0f b7 90 42 02 00 00 	movzwl 0x242(%eax),%edx
   118eb:	8b 44 24 0c          	mov    0xc(%esp),%eax
   118ef:	0f b7 40 02          	movzwl 0x2(%eax),%eax
		iput(dir);
		brelse(bh);
		return -ENOENT;
	}
	if ((dir->i_mode & S_ISVTX) && !suser() &&
	    current->euid != inode->i_uid &&
   118f3:	66 39 c2             	cmp    %ax,%dx
   118f6:	74 38                	je     11930 <sys_unlink+0x1a9>
	    current->euid != dir->i_uid) {
		iput(dir);
   118f8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   118fc:	83 ec 0c             	sub    $0xc,%esp
   118ff:	50                   	push   %eax
   11900:	e8 6c a7 ff ff       	call   c071 <iput>
   11905:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   11908:	83 ec 0c             	sub    $0xc,%esp
   1190b:	ff 74 24 24          	pushl  0x24(%esp)
   1190f:	e8 5d a7 ff ff       	call   c071 <iput>
   11914:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   11917:	83 ec 0c             	sub    $0xc,%esp
   1191a:	ff 74 24 28          	pushl  0x28(%esp)
   1191e:	e8 6d b6 ff ff       	call   cf90 <brelse>
   11923:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   11926:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1192b:	e9 1a 01 00 00       	jmp    11a4a <sys_unlink+0x2c3>
	}
	if (S_ISDIR(inode->i_mode)) {
   11930:	8b 44 24 18          	mov    0x18(%esp),%eax
   11934:	0f b7 00             	movzwl (%eax),%eax
   11937:	0f b7 c0             	movzwl %ax,%eax
   1193a:	25 00 f0 00 00       	and    $0xf000,%eax
   1193f:	3d 00 40 00 00       	cmp    $0x4000,%eax
   11944:	75 38                	jne    1197e <sys_unlink+0x1f7>
		iput(inode);
   11946:	83 ec 0c             	sub    $0xc,%esp
   11949:	ff 74 24 24          	pushl  0x24(%esp)
   1194d:	e8 1f a7 ff ff       	call   c071 <iput>
   11952:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   11955:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11959:	83 ec 0c             	sub    $0xc,%esp
   1195c:	50                   	push   %eax
   1195d:	e8 0f a7 ff ff       	call   c071 <iput>
   11962:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   11965:	83 ec 0c             	sub    $0xc,%esp
   11968:	ff 74 24 28          	pushl  0x28(%esp)
   1196c:	e8 1f b6 ff ff       	call   cf90 <brelse>
   11971:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   11974:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11979:	e9 cc 00 00 00       	jmp    11a4a <sys_unlink+0x2c3>
	}
	if (!inode->i_nlinks) {
   1197e:	8b 44 24 18          	mov    0x18(%esp),%eax
   11982:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   11986:	84 c0                	test   %al,%al
   11988:	75 39                	jne    119c3 <sys_unlink+0x23c>
		printk("Deleting nonexistent file (%04x:%d), %d\n",
			inode->i_dev,inode->i_num,inode->i_nlinks);
   1198a:	8b 44 24 18          	mov    0x18(%esp),%eax
   1198e:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
		iput(dir);
		brelse(bh);
		return -EPERM;
	}
	if (!inode->i_nlinks) {
		printk("Deleting nonexistent file (%04x:%d), %d\n",
   11992:	0f b6 c8             	movzbl %al,%ecx
			inode->i_dev,inode->i_num,inode->i_nlinks);
   11995:	8b 44 24 18          	mov    0x18(%esp),%eax
   11999:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
		iput(dir);
		brelse(bh);
		return -EPERM;
	}
	if (!inode->i_nlinks) {
		printk("Deleting nonexistent file (%04x:%d), %d\n",
   1199d:	0f b7 d0             	movzwl %ax,%edx
			inode->i_dev,inode->i_num,inode->i_nlinks);
   119a0:	8b 44 24 18          	mov    0x18(%esp),%eax
   119a4:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
		iput(dir);
		brelse(bh);
		return -EPERM;
	}
	if (!inode->i_nlinks) {
		printk("Deleting nonexistent file (%04x:%d), %d\n",
   119a8:	0f b7 c0             	movzwl %ax,%eax
   119ab:	51                   	push   %ecx
   119ac:	52                   	push   %edx
   119ad:	50                   	push   %eax
   119ae:	68 24 8a 01 00       	push   $0x18a24
   119b3:	e8 55 6e ff ff       	call   880d <printk>
   119b8:	83 c4 10             	add    $0x10,%esp
			inode->i_dev,inode->i_num,inode->i_nlinks);
		inode->i_nlinks=1;
   119bb:	8b 44 24 18          	mov    0x18(%esp),%eax
   119bf:	c6 40 0d 01          	movb   $0x1,0xd(%eax)
	}
	de->inode = 0;
   119c3:	8b 44 24 08          	mov    0x8(%esp),%eax
   119c7:	66 c7 00 00 00       	movw   $0x0,(%eax)
	bh->b_dirt = 1;
   119cc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   119d0:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   119d4:	83 ec 0c             	sub    $0xc,%esp
   119d7:	ff 74 24 28          	pushl  0x28(%esp)
   119db:	e8 b0 b5 ff ff       	call   cf90 <brelse>
   119e0:	83 c4 10             	add    $0x10,%esp
	inode->i_nlinks--;
   119e3:	8b 44 24 18          	mov    0x18(%esp),%eax
   119e7:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   119eb:	8d 50 ff             	lea    -0x1(%eax),%edx
   119ee:	8b 44 24 18          	mov    0x18(%esp),%eax
   119f2:	88 50 0d             	mov    %dl,0xd(%eax)
	inode->i_dirt = 1;
   119f5:	8b 44 24 18          	mov    0x18(%esp),%eax
   119f9:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	inode->i_ctime = CURRENT_TIME;
   119fd:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   11a03:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   11a08:	89 c8                	mov    %ecx,%eax
   11a0a:	f7 ea                	imul   %edx
   11a0c:	c1 fa 05             	sar    $0x5,%edx
   11a0f:	89 c8                	mov    %ecx,%eax
   11a11:	c1 f8 1f             	sar    $0x1f,%eax
   11a14:	29 c2                	sub    %eax,%edx
   11a16:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   11a1b:	01 d0                	add    %edx,%eax
   11a1d:	89 c2                	mov    %eax,%edx
   11a1f:	8b 44 24 18          	mov    0x18(%esp),%eax
   11a23:	89 50 28             	mov    %edx,0x28(%eax)
	iput(inode);
   11a26:	83 ec 0c             	sub    $0xc,%esp
   11a29:	ff 74 24 24          	pushl  0x24(%esp)
   11a2d:	e8 3f a6 ff ff       	call   c071 <iput>
   11a32:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   11a35:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11a39:	83 ec 0c             	sub    $0xc,%esp
   11a3c:	50                   	push   %eax
   11a3d:	e8 2f a6 ff ff       	call   c071 <iput>
   11a42:	83 c4 10             	add    $0x10,%esp
	return 0;
   11a45:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11a4a:	83 c4 2c             	add    $0x2c,%esp
   11a4d:	c3                   	ret    

00011a4e <sys_link>:

int sys_link(const char * oldname, const char * newname)
{
   11a4e:	53                   	push   %ebx
   11a4f:	83 ec 28             	sub    $0x28,%esp
	struct m_inode * oldinode, * dir;
	struct buffer_head * bh;
	const char * basename;
	int namelen;

	oldinode=namei(oldname);
   11a52:	83 ec 0c             	sub    $0xc,%esp
   11a55:	ff 74 24 3c          	pushl  0x3c(%esp)
   11a59:	e8 ba ec ff ff       	call   10718 <namei>
   11a5e:	83 c4 10             	add    $0x10,%esp
   11a61:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!oldinode)
   11a65:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   11a6a:	75 0a                	jne    11a76 <sys_link+0x28>
		return -ENOENT;
   11a6c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   11a71:	e9 57 02 00 00       	jmp    11ccd <sys_link+0x27f>
	if (S_ISDIR(oldinode->i_mode)) {
   11a76:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11a7a:	0f b7 00             	movzwl (%eax),%eax
   11a7d:	0f b7 c0             	movzwl %ax,%eax
   11a80:	25 00 f0 00 00       	and    $0xf000,%eax
   11a85:	3d 00 40 00 00       	cmp    $0x4000,%eax
   11a8a:	75 19                	jne    11aa5 <sys_link+0x57>
		iput(oldinode);
   11a8c:	83 ec 0c             	sub    $0xc,%esp
   11a8f:	ff 74 24 28          	pushl  0x28(%esp)
   11a93:	e8 d9 a5 ff ff       	call   c071 <iput>
   11a98:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   11a9b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11aa0:	e9 28 02 00 00       	jmp    11ccd <sys_link+0x27f>
	}
	dir = dir_namei(newname,&namelen,&basename);
   11aa5:	83 ec 04             	sub    $0x4,%esp
   11aa8:	8d 44 24 10          	lea    0x10(%esp),%eax
   11aac:	50                   	push   %eax
   11aad:	8d 44 24 10          	lea    0x10(%esp),%eax
   11ab1:	50                   	push   %eax
   11ab2:	ff 74 24 40          	pushl  0x40(%esp)
   11ab6:	e8 d7 eb ff ff       	call   10692 <dir_namei>
   11abb:	83 c4 10             	add    $0x10,%esp
   11abe:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!dir) {
   11ac2:	8b 44 24 10          	mov    0x10(%esp),%eax
   11ac6:	85 c0                	test   %eax,%eax
   11ac8:	75 19                	jne    11ae3 <sys_link+0x95>
		iput(oldinode);
   11aca:	83 ec 0c             	sub    $0xc,%esp
   11acd:	ff 74 24 28          	pushl  0x28(%esp)
   11ad1:	e8 9b a5 ff ff       	call   c071 <iput>
   11ad6:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
   11ad9:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   11ade:	e9 ea 01 00 00       	jmp    11ccd <sys_link+0x27f>
	}
	if (!namelen) {
   11ae3:	8b 44 24 08          	mov    0x8(%esp),%eax
   11ae7:	85 c0                	test   %eax,%eax
   11ae9:	75 29                	jne    11b14 <sys_link+0xc6>
		iput(oldinode);
   11aeb:	83 ec 0c             	sub    $0xc,%esp
   11aee:	ff 74 24 28          	pushl  0x28(%esp)
   11af2:	e8 7a a5 ff ff       	call   c071 <iput>
   11af7:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   11afa:	8b 44 24 10          	mov    0x10(%esp),%eax
   11afe:	83 ec 0c             	sub    $0xc,%esp
   11b01:	50                   	push   %eax
   11b02:	e8 6a a5 ff ff       	call   c071 <iput>
   11b07:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   11b0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11b0f:	e9 b9 01 00 00       	jmp    11ccd <sys_link+0x27f>
	}
	if (dir->i_dev != oldinode->i_dev) {
   11b14:	8b 44 24 10          	mov    0x10(%esp),%eax
   11b18:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
   11b1c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11b20:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11b24:	66 39 c2             	cmp    %ax,%dx
   11b27:	74 29                	je     11b52 <sys_link+0x104>
		iput(dir);
   11b29:	8b 44 24 10          	mov    0x10(%esp),%eax
   11b2d:	83 ec 0c             	sub    $0xc,%esp
   11b30:	50                   	push   %eax
   11b31:	e8 3b a5 ff ff       	call   c071 <iput>
   11b36:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   11b39:	83 ec 0c             	sub    $0xc,%esp
   11b3c:	ff 74 24 28          	pushl  0x28(%esp)
   11b40:	e8 2c a5 ff ff       	call   c071 <iput>
   11b45:	83 c4 10             	add    $0x10,%esp
		return -EXDEV;
   11b48:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
   11b4d:	e9 7b 01 00 00       	jmp    11ccd <sys_link+0x27f>
	}
	if (!permission(dir,MAY_WRITE)) {
   11b52:	8b 44 24 10          	mov    0x10(%esp),%eax
   11b56:	83 ec 08             	sub    $0x8,%esp
   11b59:	6a 02                	push   $0x2
   11b5b:	50                   	push   %eax
   11b5c:	e8 98 e3 ff ff       	call   fef9 <permission>
   11b61:	83 c4 10             	add    $0x10,%esp
   11b64:	85 c0                	test   %eax,%eax
   11b66:	75 29                	jne    11b91 <sys_link+0x143>
		iput(dir);
   11b68:	8b 44 24 10          	mov    0x10(%esp),%eax
   11b6c:	83 ec 0c             	sub    $0xc,%esp
   11b6f:	50                   	push   %eax
   11b70:	e8 fc a4 ff ff       	call   c071 <iput>
   11b75:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   11b78:	83 ec 0c             	sub    $0xc,%esp
   11b7b:	ff 74 24 28          	pushl  0x28(%esp)
   11b7f:	e8 ed a4 ff ff       	call   c071 <iput>
   11b84:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
   11b87:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   11b8c:	e9 3c 01 00 00       	jmp    11ccd <sys_link+0x27f>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   11b91:	8b 54 24 08          	mov    0x8(%esp),%edx
   11b95:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11b99:	8d 4c 24 14          	lea    0x14(%esp),%ecx
   11b9d:	51                   	push   %ecx
   11b9e:	52                   	push   %edx
   11b9f:	50                   	push   %eax
   11ba0:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   11ba4:	50                   	push   %eax
   11ba5:	e8 62 e4 ff ff       	call   1000c <find_entry>
   11baa:	83 c4 10             	add    $0x10,%esp
   11bad:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (bh) {
   11bb1:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   11bb6:	74 38                	je     11bf0 <sys_link+0x1a2>
		brelse(bh);
   11bb8:	83 ec 0c             	sub    $0xc,%esp
   11bbb:	ff 74 24 24          	pushl  0x24(%esp)
   11bbf:	e8 cc b3 ff ff       	call   cf90 <brelse>
   11bc4:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   11bc7:	8b 44 24 10          	mov    0x10(%esp),%eax
   11bcb:	83 ec 0c             	sub    $0xc,%esp
   11bce:	50                   	push   %eax
   11bcf:	e8 9d a4 ff ff       	call   c071 <iput>
   11bd4:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   11bd7:	83 ec 0c             	sub    $0xc,%esp
   11bda:	ff 74 24 28          	pushl  0x28(%esp)
   11bde:	e8 8e a4 ff ff       	call   c071 <iput>
   11be3:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   11be6:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   11beb:	e9 dd 00 00 00       	jmp    11ccd <sys_link+0x27f>
	}
	bh = add_entry(dir,basename,namelen,&de);
   11bf0:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   11bf4:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11bf8:	8b 44 24 10          	mov    0x10(%esp),%eax
   11bfc:	8d 5c 24 14          	lea    0x14(%esp),%ebx
   11c00:	53                   	push   %ebx
   11c01:	51                   	push   %ecx
   11c02:	52                   	push   %edx
   11c03:	50                   	push   %eax
   11c04:	e8 52 e6 ff ff       	call   1025b <add_entry>
   11c09:	83 c4 10             	add    $0x10,%esp
   11c0c:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!bh) {
   11c10:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   11c15:	75 29                	jne    11c40 <sys_link+0x1f2>
		iput(dir);
   11c17:	8b 44 24 10          	mov    0x10(%esp),%eax
   11c1b:	83 ec 0c             	sub    $0xc,%esp
   11c1e:	50                   	push   %eax
   11c1f:	e8 4d a4 ff ff       	call   c071 <iput>
   11c24:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   11c27:	83 ec 0c             	sub    $0xc,%esp
   11c2a:	ff 74 24 28          	pushl  0x28(%esp)
   11c2e:	e8 3e a4 ff ff       	call   c071 <iput>
   11c33:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   11c36:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
   11c3b:	e9 8d 00 00 00       	jmp    11ccd <sys_link+0x27f>
	}
	de->inode = oldinode->i_num;
   11c40:	8b 44 24 14          	mov    0x14(%esp),%eax
   11c44:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   11c48:	0f b7 52 2e          	movzwl 0x2e(%edx),%edx
   11c4c:	66 89 10             	mov    %dx,(%eax)
	bh->b_dirt = 1;
   11c4f:	8b 44 24 18          	mov    0x18(%esp),%eax
   11c53:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   11c57:	83 ec 0c             	sub    $0xc,%esp
   11c5a:	ff 74 24 24          	pushl  0x24(%esp)
   11c5e:	e8 2d b3 ff ff       	call   cf90 <brelse>
   11c63:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   11c66:	8b 44 24 10          	mov    0x10(%esp),%eax
   11c6a:	83 ec 0c             	sub    $0xc,%esp
   11c6d:	50                   	push   %eax
   11c6e:	e8 fe a3 ff ff       	call   c071 <iput>
   11c73:	83 c4 10             	add    $0x10,%esp
	oldinode->i_nlinks++;
   11c76:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11c7a:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   11c7e:	8d 50 01             	lea    0x1(%eax),%edx
   11c81:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11c85:	88 50 0d             	mov    %dl,0xd(%eax)
	oldinode->i_ctime = CURRENT_TIME;
   11c88:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   11c8e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   11c93:	89 c8                	mov    %ecx,%eax
   11c95:	f7 ea                	imul   %edx
   11c97:	c1 fa 05             	sar    $0x5,%edx
   11c9a:	89 c8                	mov    %ecx,%eax
   11c9c:	c1 f8 1f             	sar    $0x1f,%eax
   11c9f:	29 c2                	sub    %eax,%edx
   11ca1:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   11ca6:	01 d0                	add    %edx,%eax
   11ca8:	89 c2                	mov    %eax,%edx
   11caa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11cae:	89 50 28             	mov    %edx,0x28(%eax)
	oldinode->i_dirt = 1;
   11cb1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11cb5:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(oldinode);
   11cb9:	83 ec 0c             	sub    $0xc,%esp
   11cbc:	ff 74 24 28          	pushl  0x28(%esp)
   11cc0:	e8 ac a3 ff ff       	call   c071 <iput>
   11cc5:	83 c4 10             	add    $0x10,%esp
	return 0;
   11cc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11ccd:	83 c4 28             	add    $0x28,%esp
   11cd0:	5b                   	pop    %ebx
   11cd1:	c3                   	ret    

00011cd2 <memset>:
	);
return __res;
}

static inline void * memset(void * s,char c,int count)
{
   11cd2:	57                   	push   %edi
   11cd3:	83 ec 04             	sub    $0x4,%esp
   11cd6:	8b 44 24 10          	mov    0x10(%esp),%eax
   11cda:	88 04 24             	mov    %al,(%esp)
__asm__("cld\n\t"
   11cdd:	0f b6 04 24          	movzbl (%esp),%eax
   11ce1:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11ce5:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   11ce9:	89 d7                	mov    %edx,%edi
   11ceb:	fc                   	cld    
   11cec:	f3 aa                	rep stos %al,%es:(%edi)
	"rep\n\t"
	"stosb"
	::"a" (c),"D" (s),"c" (count)
	);
return s;
   11cee:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   11cf2:	83 c4 04             	add    $0x4,%esp
   11cf5:	5f                   	pop    %edi
   11cf6:	c3                   	ret    

00011cf7 <free_block>:
	"3:" \
	:"=c" (__res):"c" (0),"S" (addr)); \
__res;})

void free_block(int dev, int block)
{
   11cf7:	53                   	push   %ebx
   11cf8:	83 ec 18             	sub    $0x18,%esp
	struct super_block * sb;
	struct buffer_head * bh;

	if (!(sb = get_super(dev)))
   11cfb:	83 ec 0c             	sub    $0xc,%esp
   11cfe:	ff 74 24 2c          	pushl  0x2c(%esp)
   11d02:	e8 4c b7 ff ff       	call   d453 <get_super>
   11d07:	83 c4 10             	add    $0x10,%esp
   11d0a:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11d0e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11d13:	75 10                	jne    11d25 <free_block+0x2e>
		panic("trying to free block on nonexistent device");
   11d15:	83 ec 0c             	sub    $0xc,%esp
   11d18:	68 50 8a 01 00       	push   $0x18a50
   11d1d:	e8 ac 6a ff ff       	call   87ce <panic>
   11d22:	83 c4 10             	add    $0x10,%esp
	if (block < sb->s_firstdatazone || block >= sb->s_nzones)
   11d25:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11d29:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   11d2d:	0f b7 c0             	movzwl %ax,%eax
   11d30:	3b 44 24 24          	cmp    0x24(%esp),%eax
   11d34:	7f 11                	jg     11d47 <free_block+0x50>
   11d36:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11d3a:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   11d3e:	0f b7 c0             	movzwl %ax,%eax
   11d41:	3b 44 24 24          	cmp    0x24(%esp),%eax
   11d45:	7f 10                	jg     11d57 <free_block+0x60>
		panic("trying to free block not in datazone");
   11d47:	83 ec 0c             	sub    $0xc,%esp
   11d4a:	68 7c 8a 01 00       	push   $0x18a7c
   11d4f:	e8 7a 6a ff ff       	call   87ce <panic>
   11d54:	83 c4 10             	add    $0x10,%esp
	bh = get_hash_table(dev,block);
   11d57:	83 ec 08             	sub    $0x8,%esp
   11d5a:	ff 74 24 2c          	pushl  0x2c(%esp)
   11d5e:	ff 74 24 2c          	pushl  0x2c(%esp)
   11d62:	e8 ec af ff ff       	call   cd53 <get_hash_table>
   11d67:	83 c4 10             	add    $0x10,%esp
   11d6a:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (bh) {
   11d6e:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   11d73:	74 51                	je     11dc6 <free_block+0xcf>
		if (bh->b_count != 1) {
   11d75:	8b 44 24 08          	mov    0x8(%esp),%eax
   11d79:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   11d7d:	3c 01                	cmp    $0x1,%al
   11d7f:	74 26                	je     11da7 <free_block+0xb0>
			printk("trying to free block (%04x:%d), count=%d\n",
				dev,block,bh->b_count);
   11d81:	8b 44 24 08          	mov    0x8(%esp),%eax
   11d85:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
	if (block < sb->s_firstdatazone || block >= sb->s_nzones)
		panic("trying to free block not in datazone");
	bh = get_hash_table(dev,block);
	if (bh) {
		if (bh->b_count != 1) {
			printk("trying to free block (%04x:%d), count=%d\n",
   11d89:	0f b6 c0             	movzbl %al,%eax
   11d8c:	50                   	push   %eax
   11d8d:	ff 74 24 28          	pushl  0x28(%esp)
   11d91:	ff 74 24 28          	pushl  0x28(%esp)
   11d95:	68 a4 8a 01 00       	push   $0x18aa4
   11d9a:	e8 6e 6a ff ff       	call   880d <printk>
   11d9f:	83 c4 10             	add    $0x10,%esp
				dev,block,bh->b_count);
			return;
   11da2:	e9 cc 00 00 00       	jmp    11e73 <free_block+0x17c>
		}
		bh->b_dirt=0;
   11da7:	8b 44 24 08          	mov    0x8(%esp),%eax
   11dab:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
		bh->b_uptodate=0;
   11daf:	8b 44 24 08          	mov    0x8(%esp),%eax
   11db3:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
		brelse(bh);
   11db7:	83 ec 0c             	sub    $0xc,%esp
   11dba:	ff 74 24 14          	pushl  0x14(%esp)
   11dbe:	e8 cd b1 ff ff       	call   cf90 <brelse>
   11dc3:	83 c4 10             	add    $0x10,%esp
	}
	block -= sb->s_firstdatazone - 1 ;
   11dc6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11dca:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   11dce:	0f b7 c0             	movzwl %ax,%eax
   11dd1:	83 e8 01             	sub    $0x1,%eax
   11dd4:	29 44 24 24          	sub    %eax,0x24(%esp)
	if (clear_bit(block&8191,sb->s_zmap[block/8192]->b_data)) {
   11dd8:	8b 44 24 24          	mov    0x24(%esp),%eax
   11ddc:	25 ff 1f 00 00       	and    $0x1fff,%eax
   11de1:	89 c1                	mov    %eax,%ecx
   11de3:	8b 44 24 24          	mov    0x24(%esp),%eax
   11de7:	8d 90 ff 1f 00 00    	lea    0x1fff(%eax),%edx
   11ded:	85 c0                	test   %eax,%eax
   11def:	0f 48 c2             	cmovs  %edx,%eax
   11df2:	c1 f8 0d             	sar    $0xd,%eax
   11df5:	89 c2                	mov    %eax,%edx
   11df7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11dfb:	83 c2 0c             	add    $0xc,%edx
   11dfe:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   11e02:	8b 10                	mov    (%eax),%edx
   11e04:	b8 00 00 00 00       	mov    $0x0,%eax
   11e09:	0f b3 0a             	btr    %ecx,(%edx)
   11e0c:	0f 93 c0             	setae  %al
   11e0f:	89 c3                	mov    %eax,%ebx
   11e11:	89 d8                	mov    %ebx,%eax
   11e13:	85 c0                	test   %eax,%eax
   11e15:	74 39                	je     11e50 <free_block+0x159>
		printk("block (%04x:%d) ",dev,block+sb->s_firstdatazone-1);
   11e17:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11e1b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   11e1f:	0f b7 d0             	movzwl %ax,%edx
   11e22:	8b 44 24 24          	mov    0x24(%esp),%eax
   11e26:	01 d0                	add    %edx,%eax
   11e28:	83 e8 01             	sub    $0x1,%eax
   11e2b:	83 ec 04             	sub    $0x4,%esp
   11e2e:	50                   	push   %eax
   11e2f:	ff 74 24 28          	pushl  0x28(%esp)
   11e33:	68 ce 8a 01 00       	push   $0x18ace
   11e38:	e8 d0 69 ff ff       	call   880d <printk>
   11e3d:	83 c4 10             	add    $0x10,%esp
		panic("free_block: bit already cleared");
   11e40:	83 ec 0c             	sub    $0xc,%esp
   11e43:	68 e0 8a 01 00       	push   $0x18ae0
   11e48:	e8 81 69 ff ff       	call   87ce <panic>
   11e4d:	83 c4 10             	add    $0x10,%esp
	}
	sb->s_zmap[block/8192]->b_dirt = 1;
   11e50:	8b 44 24 24          	mov    0x24(%esp),%eax
   11e54:	8d 90 ff 1f 00 00    	lea    0x1fff(%eax),%edx
   11e5a:	85 c0                	test   %eax,%eax
   11e5c:	0f 48 c2             	cmovs  %edx,%eax
   11e5f:	c1 f8 0d             	sar    $0xd,%eax
   11e62:	89 c2                	mov    %eax,%edx
   11e64:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11e68:	83 c2 0c             	add    $0xc,%edx
   11e6b:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   11e6f:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
}
   11e73:	83 c4 18             	add    $0x18,%esp
   11e76:	5b                   	pop    %ebx
   11e77:	c3                   	ret    

00011e78 <new_block>:

int new_block(int dev)
{
   11e78:	57                   	push   %edi
   11e79:	56                   	push   %esi
   11e7a:	53                   	push   %ebx
   11e7b:	83 ec 20             	sub    $0x20,%esp
	struct buffer_head * bh;
	struct super_block * sb;
	int i,j;

	if (!(sb = get_super(dev)))
   11e7e:	83 ec 0c             	sub    $0xc,%esp
   11e81:	ff 74 24 3c          	pushl  0x3c(%esp)
   11e85:	e8 c9 b5 ff ff       	call   d453 <get_super>
   11e8a:	83 c4 10             	add    $0x10,%esp
   11e8d:	89 44 24 10          	mov    %eax,0x10(%esp)
   11e91:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   11e96:	75 10                	jne    11ea8 <new_block+0x30>
		panic("trying to get new block from nonexistant device");
   11e98:	83 ec 0c             	sub    $0xc,%esp
   11e9b:	68 00 8b 01 00       	push   $0x18b00
   11ea0:	e8 29 69 ff ff       	call   87ce <panic>
   11ea5:	83 c4 10             	add    $0x10,%esp
	j = 8192;
   11ea8:	c7 44 24 14 00 20 00 	movl   $0x2000,0x14(%esp)
   11eaf:	00 
	for (i=0 ; i<8 ; i++)
   11eb0:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   11eb7:	00 
   11eb8:	eb 5e                	jmp    11f18 <new_block+0xa0>
		if ((bh=sb->s_zmap[i]))
   11eba:	8b 44 24 10          	mov    0x10(%esp),%eax
   11ebe:	8b 54 24 18          	mov    0x18(%esp),%edx
   11ec2:	83 c2 0c             	add    $0xc,%edx
   11ec5:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   11ec9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   11ecd:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   11ed2:	74 3f                	je     11f13 <new_block+0x9b>
			if ((j=find_first_zero(bh->b_data))<8192)
   11ed4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11ed8:	8b 00                	mov    (%eax),%eax
   11eda:	ba 00 00 00 00       	mov    $0x0,%edx
   11edf:	89 d1                	mov    %edx,%ecx
   11ee1:	89 c6                	mov    %eax,%esi
   11ee3:	fc                   	cld    
   11ee4:	ad                   	lods   %ds:(%esi),%eax
   11ee5:	f7 d0                	not    %eax
   11ee7:	0f bc d0             	bsf    %eax,%edx
   11eea:	74 04                	je     11ef0 <new_block+0x78>
   11eec:	01 d1                	add    %edx,%ecx
   11eee:	eb 0b                	jmp    11efb <new_block+0x83>
   11ef0:	83 c1 20             	add    $0x20,%ecx
   11ef3:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
   11ef9:	7c e9                	jl     11ee4 <new_block+0x6c>
   11efb:	89 c8                	mov    %ecx,%eax
   11efd:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11f01:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11f05:	89 44 24 14          	mov    %eax,0x14(%esp)
   11f09:	81 7c 24 14 ff 1f 00 	cmpl   $0x1fff,0x14(%esp)
   11f10:	00 
   11f11:	7e 0e                	jle    11f21 <new_block+0xa9>
	int i,j;

	if (!(sb = get_super(dev)))
		panic("trying to get new block from nonexistant device");
	j = 8192;
	for (i=0 ; i<8 ; i++)
   11f13:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   11f18:	83 7c 24 18 07       	cmpl   $0x7,0x18(%esp)
   11f1d:	7e 9b                	jle    11eba <new_block+0x42>
   11f1f:	eb 01                	jmp    11f22 <new_block+0xaa>
		if ((bh=sb->s_zmap[i]))
			if ((j=find_first_zero(bh->b_data))<8192)
				break;
   11f21:	90                   	nop
	if (i>=8 || !bh || j>=8192)
   11f22:	83 7c 24 18 07       	cmpl   $0x7,0x18(%esp)
   11f27:	7f 11                	jg     11f3a <new_block+0xc2>
   11f29:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   11f2e:	74 0a                	je     11f3a <new_block+0xc2>
   11f30:	81 7c 24 14 ff 1f 00 	cmpl   $0x1fff,0x14(%esp)
   11f37:	00 
   11f38:	7e 0a                	jle    11f44 <new_block+0xcc>
		return 0;
   11f3a:	b8 00 00 00 00       	mov    $0x0,%eax
   11f3f:	e9 f3 00 00 00       	jmp    12037 <new_block+0x1bf>
	if (set_bit(j,bh->b_data))
   11f44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11f48:	8b 08                	mov    (%eax),%ecx
   11f4a:	b8 00 00 00 00       	mov    $0x0,%eax
   11f4f:	8b 54 24 14          	mov    0x14(%esp),%edx
   11f53:	0f ab 11             	bts    %edx,(%ecx)
   11f56:	0f 92 c0             	setb   %al
   11f59:	89 c3                	mov    %eax,%ebx
   11f5b:	89 d8                	mov    %ebx,%eax
   11f5d:	85 c0                	test   %eax,%eax
   11f5f:	74 10                	je     11f71 <new_block+0xf9>
		panic("new_block: bit already set");
   11f61:	83 ec 0c             	sub    $0xc,%esp
   11f64:	68 30 8b 01 00       	push   $0x18b30
   11f69:	e8 60 68 ff ff       	call   87ce <panic>
   11f6e:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   11f71:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11f75:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	j += i*8192 + sb->s_firstdatazone-1;
   11f79:	8b 44 24 18          	mov    0x18(%esp),%eax
   11f7d:	c1 e0 0d             	shl    $0xd,%eax
   11f80:	89 c2                	mov    %eax,%edx
   11f82:	8b 44 24 10          	mov    0x10(%esp),%eax
   11f86:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   11f8a:	0f b7 c0             	movzwl %ax,%eax
   11f8d:	01 d0                	add    %edx,%eax
   11f8f:	83 e8 01             	sub    $0x1,%eax
   11f92:	01 44 24 14          	add    %eax,0x14(%esp)
	if (j >= sb->s_nzones)
   11f96:	8b 44 24 10          	mov    0x10(%esp),%eax
   11f9a:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   11f9e:	0f b7 c0             	movzwl %ax,%eax
   11fa1:	3b 44 24 14          	cmp    0x14(%esp),%eax
   11fa5:	7f 0a                	jg     11fb1 <new_block+0x139>
		return 0;
   11fa7:	b8 00 00 00 00       	mov    $0x0,%eax
   11fac:	e9 86 00 00 00       	jmp    12037 <new_block+0x1bf>
	if (!(bh=getblk(dev,j)))
   11fb1:	83 ec 08             	sub    $0x8,%esp
   11fb4:	ff 74 24 1c          	pushl  0x1c(%esp)
   11fb8:	ff 74 24 3c          	pushl  0x3c(%esp)
   11fbc:	e8 16 ae ff ff       	call   cdd7 <getblk>
   11fc1:	83 c4 10             	add    $0x10,%esp
   11fc4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   11fc8:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   11fcd:	75 10                	jne    11fdf <new_block+0x167>
		panic("new_block: cannot get block");
   11fcf:	83 ec 0c             	sub    $0xc,%esp
   11fd2:	68 4b 8b 01 00       	push   $0x18b4b
   11fd7:	e8 f2 67 ff ff       	call   87ce <panic>
   11fdc:	83 c4 10             	add    $0x10,%esp
	if (bh->b_count != 1)
   11fdf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11fe3:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   11fe7:	3c 01                	cmp    $0x1,%al
   11fe9:	74 10                	je     11ffb <new_block+0x183>
		panic("new block: count is != 1");
   11feb:	83 ec 0c             	sub    $0xc,%esp
   11fee:	68 67 8b 01 00       	push   $0x18b67
   11ff3:	e8 d6 67 ff ff       	call   87ce <panic>
   11ff8:	83 c4 10             	add    $0x10,%esp
	clear_block(bh->b_data);
   11ffb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11fff:	8b 00                	mov    (%eax),%eax
   12001:	89 c3                	mov    %eax,%ebx
   12003:	b8 00 00 00 00       	mov    $0x0,%eax
   12008:	ba 00 01 00 00       	mov    $0x100,%edx
   1200d:	89 d1                	mov    %edx,%ecx
   1200f:	89 df                	mov    %ebx,%edi
   12011:	fc                   	cld    
   12012:	f3 ab                	rep stos %eax,%es:(%edi)
	bh->b_uptodate = 1;
   12014:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12018:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
	bh->b_dirt = 1;
   1201c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12020:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   12024:	83 ec 0c             	sub    $0xc,%esp
   12027:	ff 74 24 28          	pushl  0x28(%esp)
   1202b:	e8 60 af ff ff       	call   cf90 <brelse>
   12030:	83 c4 10             	add    $0x10,%esp
	return j;
   12033:	8b 44 24 14          	mov    0x14(%esp),%eax
}
   12037:	83 c4 20             	add    $0x20,%esp
   1203a:	5b                   	pop    %ebx
   1203b:	5e                   	pop    %esi
   1203c:	5f                   	pop    %edi
   1203d:	c3                   	ret    

0001203e <free_inode>:

void free_inode(struct m_inode * inode)
{
   1203e:	53                   	push   %ebx
   1203f:	83 ec 18             	sub    $0x18,%esp
	struct super_block * sb;
	struct buffer_head * bh;

	if (!inode)
   12042:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   12047:	0f 84 68 01 00 00    	je     121b5 <free_inode+0x177>
		return;
	if (!inode->i_dev) {
   1204d:	8b 44 24 20          	mov    0x20(%esp),%eax
   12051:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   12055:	66 85 c0             	test   %ax,%ax
   12058:	75 15                	jne    1206f <free_inode+0x31>
		memset(inode,0,sizeof(*inode));
   1205a:	6a 38                	push   $0x38
   1205c:	6a 00                	push   $0x0
   1205e:	ff 74 24 28          	pushl  0x28(%esp)
   12062:	e8 6b fc ff ff       	call   11cd2 <memset>
   12067:	83 c4 0c             	add    $0xc,%esp
		return;
   1206a:	e9 47 01 00 00       	jmp    121b6 <free_inode+0x178>
	}
	if (inode->i_count>1) {
   1206f:	8b 44 24 20          	mov    0x20(%esp),%eax
   12073:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   12077:	66 83 f8 01          	cmp    $0x1,%ax
   1207b:	76 2c                	jbe    120a9 <free_inode+0x6b>
		printk("trying to free inode with count=%d\n",inode->i_count);
   1207d:	8b 44 24 20          	mov    0x20(%esp),%eax
   12081:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   12085:	0f b7 c0             	movzwl %ax,%eax
   12088:	83 ec 08             	sub    $0x8,%esp
   1208b:	50                   	push   %eax
   1208c:	68 80 8b 01 00       	push   $0x18b80
   12091:	e8 77 67 ff ff       	call   880d <printk>
   12096:	83 c4 10             	add    $0x10,%esp
		panic("free_inode");
   12099:	83 ec 0c             	sub    $0xc,%esp
   1209c:	68 a4 8b 01 00       	push   $0x18ba4
   120a1:	e8 28 67 ff ff       	call   87ce <panic>
   120a6:	83 c4 10             	add    $0x10,%esp
	}
	if (inode->i_nlinks)
   120a9:	8b 44 24 20          	mov    0x20(%esp),%eax
   120ad:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   120b1:	84 c0                	test   %al,%al
   120b3:	74 10                	je     120c5 <free_inode+0x87>
		panic("trying to free inode with links");
   120b5:	83 ec 0c             	sub    $0xc,%esp
   120b8:	68 b0 8b 01 00       	push   $0x18bb0
   120bd:	e8 0c 67 ff ff       	call   87ce <panic>
   120c2:	83 c4 10             	add    $0x10,%esp
	if (!(sb = get_super(inode->i_dev)))
   120c5:	8b 44 24 20          	mov    0x20(%esp),%eax
   120c9:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   120cd:	0f b7 c0             	movzwl %ax,%eax
   120d0:	83 ec 0c             	sub    $0xc,%esp
   120d3:	50                   	push   %eax
   120d4:	e8 7a b3 ff ff       	call   d453 <get_super>
   120d9:	83 c4 10             	add    $0x10,%esp
   120dc:	89 44 24 0c          	mov    %eax,0xc(%esp)
   120e0:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   120e5:	75 10                	jne    120f7 <free_inode+0xb9>
		panic("trying to free inode on nonexistent device");
   120e7:	83 ec 0c             	sub    $0xc,%esp
   120ea:	68 d0 8b 01 00       	push   $0x18bd0
   120ef:	e8 da 66 ff ff       	call   87ce <panic>
   120f4:	83 c4 10             	add    $0x10,%esp
	if (inode->i_num < 1 || inode->i_num > sb->s_ninodes)
   120f7:	8b 44 24 20          	mov    0x20(%esp),%eax
   120fb:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
   120ff:	66 85 c0             	test   %ax,%ax
   12102:	74 14                	je     12118 <free_inode+0xda>
   12104:	8b 44 24 20          	mov    0x20(%esp),%eax
   12108:	0f b7 50 2e          	movzwl 0x2e(%eax),%edx
   1210c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12110:	0f b7 00             	movzwl (%eax),%eax
   12113:	66 39 c2             	cmp    %ax,%dx
   12116:	76 10                	jbe    12128 <free_inode+0xea>
		panic("trying to free inode 0 or nonexistant inode");
   12118:	83 ec 0c             	sub    $0xc,%esp
   1211b:	68 fc 8b 01 00       	push   $0x18bfc
   12120:	e8 a9 66 ff ff       	call   87ce <panic>
   12125:	83 c4 10             	add    $0x10,%esp
	if (!(bh=sb->s_imap[inode->i_num>>13]))
   12128:	8b 44 24 20          	mov    0x20(%esp),%eax
   1212c:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
   12130:	66 c1 e8 0d          	shr    $0xd,%ax
   12134:	0f b7 d0             	movzwl %ax,%edx
   12137:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1213b:	83 c2 04             	add    $0x4,%edx
   1213e:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   12142:	89 44 24 08          	mov    %eax,0x8(%esp)
   12146:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1214b:	75 10                	jne    1215d <free_inode+0x11f>
		panic("nonexistent imap in superblock");
   1214d:	83 ec 0c             	sub    $0xc,%esp
   12150:	68 28 8c 01 00       	push   $0x18c28
   12155:	e8 74 66 ff ff       	call   87ce <panic>
   1215a:	83 c4 10             	add    $0x10,%esp
	if (clear_bit(inode->i_num&8191,bh->b_data))
   1215d:	8b 44 24 20          	mov    0x20(%esp),%eax
   12161:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
   12165:	0f b7 c0             	movzwl %ax,%eax
   12168:	25 ff 1f 00 00       	and    $0x1fff,%eax
   1216d:	89 c1                	mov    %eax,%ecx
   1216f:	8b 44 24 08          	mov    0x8(%esp),%eax
   12173:	8b 10                	mov    (%eax),%edx
   12175:	b8 00 00 00 00       	mov    $0x0,%eax
   1217a:	0f b3 0a             	btr    %ecx,(%edx)
   1217d:	0f 93 c0             	setae  %al
   12180:	89 c3                	mov    %eax,%ebx
   12182:	89 d8                	mov    %ebx,%eax
   12184:	85 c0                	test   %eax,%eax
   12186:	74 10                	je     12198 <free_inode+0x15a>
		printk("free_inode: bit already cleared.\n\r");
   12188:	83 ec 0c             	sub    $0xc,%esp
   1218b:	68 48 8c 01 00       	push   $0x18c48
   12190:	e8 78 66 ff ff       	call   880d <printk>
   12195:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   12198:	8b 44 24 08          	mov    0x8(%esp),%eax
   1219c:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	memset(inode,0,sizeof(*inode));
   121a0:	83 ec 04             	sub    $0x4,%esp
   121a3:	6a 38                	push   $0x38
   121a5:	6a 00                	push   $0x0
   121a7:	ff 74 24 2c          	pushl  0x2c(%esp)
   121ab:	e8 22 fb ff ff       	call   11cd2 <memset>
   121b0:	83 c4 10             	add    $0x10,%esp
   121b3:	eb 01                	jmp    121b6 <free_inode+0x178>
{
	struct super_block * sb;
	struct buffer_head * bh;

	if (!inode)
		return;
   121b5:	90                   	nop
		panic("nonexistent imap in superblock");
	if (clear_bit(inode->i_num&8191,bh->b_data))
		printk("free_inode: bit already cleared.\n\r");
	bh->b_dirt = 1;
	memset(inode,0,sizeof(*inode));
}
   121b6:	83 c4 18             	add    $0x18,%esp
   121b9:	5b                   	pop    %ebx
   121ba:	c3                   	ret    

000121bb <new_inode>:

struct m_inode * new_inode(int dev)
{
   121bb:	56                   	push   %esi
   121bc:	53                   	push   %ebx
   121bd:	83 ec 24             	sub    $0x24,%esp
	struct m_inode * inode;
	struct super_block * sb;
	struct buffer_head * bh;
	int i,j;

	if (!(inode=get_empty_inode()))
   121c0:	e8 55 a0 ff ff       	call   c21a <get_empty_inode>
   121c5:	89 44 24 10          	mov    %eax,0x10(%esp)
   121c9:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   121ce:	75 0a                	jne    121da <new_inode+0x1f>
		return NULL;
   121d0:	b8 00 00 00 00       	mov    $0x0,%eax
   121d5:	e9 d1 01 00 00       	jmp    123ab <new_inode+0x1f0>
	if (!(sb = get_super(dev)))
   121da:	83 ec 0c             	sub    $0xc,%esp
   121dd:	ff 74 24 3c          	pushl  0x3c(%esp)
   121e1:	e8 6d b2 ff ff       	call   d453 <get_super>
   121e6:	83 c4 10             	add    $0x10,%esp
   121e9:	89 44 24 0c          	mov    %eax,0xc(%esp)
   121ed:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   121f2:	75 10                	jne    12204 <new_inode+0x49>
		panic("new_inode with unknown device");
   121f4:	83 ec 0c             	sub    $0xc,%esp
   121f7:	68 6b 8c 01 00       	push   $0x18c6b
   121fc:	e8 cd 65 ff ff       	call   87ce <panic>
   12201:	83 c4 10             	add    $0x10,%esp
	j = 8192;
   12204:	c7 44 24 14 00 20 00 	movl   $0x2000,0x14(%esp)
   1220b:	00 
	for (i=0 ; i<8 ; i++)
   1220c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   12213:	00 
   12214:	eb 5e                	jmp    12274 <new_inode+0xb9>
		if ((bh=sb->s_imap[i]))
   12216:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1221a:	8b 54 24 18          	mov    0x18(%esp),%edx
   1221e:	83 c2 04             	add    $0x4,%edx
   12221:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   12225:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   12229:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   1222e:	74 3f                	je     1226f <new_inode+0xb4>
			if ((j=find_first_zero(bh->b_data))<8192)
   12230:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12234:	8b 00                	mov    (%eax),%eax
   12236:	ba 00 00 00 00       	mov    $0x0,%edx
   1223b:	89 d1                	mov    %edx,%ecx
   1223d:	89 c6                	mov    %eax,%esi
   1223f:	fc                   	cld    
   12240:	ad                   	lods   %ds:(%esi),%eax
   12241:	f7 d0                	not    %eax
   12243:	0f bc d0             	bsf    %eax,%edx
   12246:	74 04                	je     1224c <new_inode+0x91>
   12248:	01 d1                	add    %edx,%ecx
   1224a:	eb 0b                	jmp    12257 <new_inode+0x9c>
   1224c:	83 c1 20             	add    $0x20,%ecx
   1224f:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
   12255:	7c e9                	jl     12240 <new_inode+0x85>
   12257:	89 c8                	mov    %ecx,%eax
   12259:	89 44 24 08          	mov    %eax,0x8(%esp)
   1225d:	8b 44 24 08          	mov    0x8(%esp),%eax
   12261:	89 44 24 14          	mov    %eax,0x14(%esp)
   12265:	81 7c 24 14 ff 1f 00 	cmpl   $0x1fff,0x14(%esp)
   1226c:	00 
   1226d:	7e 0e                	jle    1227d <new_inode+0xc2>
	if (!(inode=get_empty_inode()))
		return NULL;
	if (!(sb = get_super(dev)))
		panic("new_inode with unknown device");
	j = 8192;
	for (i=0 ; i<8 ; i++)
   1226f:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   12274:	83 7c 24 18 07       	cmpl   $0x7,0x18(%esp)
   12279:	7e 9b                	jle    12216 <new_inode+0x5b>
   1227b:	eb 01                	jmp    1227e <new_inode+0xc3>
		if ((bh=sb->s_imap[i]))
			if ((j=find_first_zero(bh->b_data))<8192)
				break;
   1227d:	90                   	nop
	if (!bh || j >= 8192 || j+i*8192 > sb->s_ninodes) {
   1227e:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   12283:	74 27                	je     122ac <new_inode+0xf1>
   12285:	81 7c 24 14 ff 1f 00 	cmpl   $0x1fff,0x14(%esp)
   1228c:	00 
   1228d:	7f 1d                	jg     122ac <new_inode+0xf1>
   1228f:	8b 44 24 18          	mov    0x18(%esp),%eax
   12293:	c1 e0 0d             	shl    $0xd,%eax
   12296:	89 c2                	mov    %eax,%edx
   12298:	8b 44 24 14          	mov    0x14(%esp),%eax
   1229c:	01 c2                	add    %eax,%edx
   1229e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   122a2:	0f b7 00             	movzwl (%eax),%eax
   122a5:	0f b7 c0             	movzwl %ax,%eax
   122a8:	39 c2                	cmp    %eax,%edx
   122aa:	7e 19                	jle    122c5 <new_inode+0x10a>
		iput(inode);
   122ac:	83 ec 0c             	sub    $0xc,%esp
   122af:	ff 74 24 1c          	pushl  0x1c(%esp)
   122b3:	e8 b9 9d ff ff       	call   c071 <iput>
   122b8:	83 c4 10             	add    $0x10,%esp
		return NULL;
   122bb:	b8 00 00 00 00       	mov    $0x0,%eax
   122c0:	e9 e6 00 00 00       	jmp    123ab <new_inode+0x1f0>
	}
	if (set_bit(j,bh->b_data))
   122c5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   122c9:	8b 08                	mov    (%eax),%ecx
   122cb:	b8 00 00 00 00       	mov    $0x0,%eax
   122d0:	8b 54 24 14          	mov    0x14(%esp),%edx
   122d4:	0f ab 11             	bts    %edx,(%ecx)
   122d7:	0f 92 c0             	setb   %al
   122da:	89 c3                	mov    %eax,%ebx
   122dc:	89 d8                	mov    %ebx,%eax
   122de:	85 c0                	test   %eax,%eax
   122e0:	74 10                	je     122f2 <new_inode+0x137>
		panic("new_inode: bit already set");
   122e2:	83 ec 0c             	sub    $0xc,%esp
   122e5:	68 89 8c 01 00       	push   $0x18c89
   122ea:	e8 df 64 ff ff       	call   87ce <panic>
   122ef:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   122f2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   122f6:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	inode->i_count=1;
   122fa:	8b 44 24 10          	mov    0x10(%esp),%eax
   122fe:	66 c7 40 30 01 00    	movw   $0x1,0x30(%eax)
	inode->i_nlinks=1;
   12304:	8b 44 24 10          	mov    0x10(%esp),%eax
   12308:	c6 40 0d 01          	movb   $0x1,0xd(%eax)
	inode->i_dev=dev;
   1230c:	8b 44 24 30          	mov    0x30(%esp),%eax
   12310:	89 c2                	mov    %eax,%edx
   12312:	8b 44 24 10          	mov    0x10(%esp),%eax
   12316:	66 89 50 2c          	mov    %dx,0x2c(%eax)
	inode->i_uid=current->euid;
   1231a:	a1 40 f1 01 00       	mov    0x1f140,%eax
   1231f:	0f b7 90 42 02 00 00 	movzwl 0x242(%eax),%edx
   12326:	8b 44 24 10          	mov    0x10(%esp),%eax
   1232a:	66 89 50 02          	mov    %dx,0x2(%eax)
	inode->i_gid=current->egid;
   1232e:	a1 40 f1 01 00       	mov    0x1f140,%eax
   12333:	0f b7 80 48 02 00 00 	movzwl 0x248(%eax),%eax
   1233a:	89 c2                	mov    %eax,%edx
   1233c:	8b 44 24 10          	mov    0x10(%esp),%eax
   12340:	88 50 0c             	mov    %dl,0xc(%eax)
	inode->i_dirt=1;
   12343:	8b 44 24 10          	mov    0x10(%esp),%eax
   12347:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	inode->i_num = j + i*8192;
   1234b:	8b 44 24 18          	mov    0x18(%esp),%eax
   1234f:	c1 e0 0d             	shl    $0xd,%eax
   12352:	89 c2                	mov    %eax,%edx
   12354:	8b 44 24 14          	mov    0x14(%esp),%eax
   12358:	01 c2                	add    %eax,%edx
   1235a:	8b 44 24 10          	mov    0x10(%esp),%eax
   1235e:	66 89 50 2e          	mov    %dx,0x2e(%eax)
	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
   12362:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   12368:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   1236d:	89 c8                	mov    %ecx,%eax
   1236f:	f7 ea                	imul   %edx
   12371:	c1 fa 05             	sar    $0x5,%edx
   12374:	89 c8                	mov    %ecx,%eax
   12376:	c1 f8 1f             	sar    $0x1f,%eax
   12379:	29 c2                	sub    %eax,%edx
   1237b:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   12380:	01 d0                	add    %edx,%eax
   12382:	89 c2                	mov    %eax,%edx
   12384:	8b 44 24 10          	mov    0x10(%esp),%eax
   12388:	89 50 28             	mov    %edx,0x28(%eax)
   1238b:	8b 44 24 10          	mov    0x10(%esp),%eax
   1238f:	8b 50 28             	mov    0x28(%eax),%edx
   12392:	8b 44 24 10          	mov    0x10(%esp),%eax
   12396:	89 50 24             	mov    %edx,0x24(%eax)
   12399:	8b 44 24 10          	mov    0x10(%esp),%eax
   1239d:	8b 50 24             	mov    0x24(%eax),%edx
   123a0:	8b 44 24 10          	mov    0x10(%esp),%eax
   123a4:	89 50 08             	mov    %edx,0x8(%eax)
	return inode;
   123a7:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   123ab:	83 c4 24             	add    $0x24,%esp
   123ae:	5b                   	pop    %ebx
   123af:	5e                   	pop    %esi
   123b0:	c3                   	ret    

000123b1 <dupfd>:
#include <sys/stat.h>

extern int sys_close(int fd);

static int dupfd(unsigned int fd, unsigned int arg)
{
   123b1:	56                   	push   %esi
   123b2:	53                   	push   %ebx
	if (fd >= NR_OPEN || !current->filp[fd])
   123b3:	83 7c 24 0c 13       	cmpl   $0x13,0xc(%esp)
   123b8:	77 16                	ja     123d0 <dupfd+0x1f>
   123ba:	a1 40 f1 01 00       	mov    0x1f140,%eax
   123bf:	8b 54 24 0c          	mov    0xc(%esp),%edx
   123c3:	81 c2 a0 00 00 00    	add    $0xa0,%edx
   123c9:	8b 04 90             	mov    (%eax,%edx,4),%eax
   123cc:	85 c0                	test   %eax,%eax
   123ce:	75 0a                	jne    123da <dupfd+0x29>
		return -EBADF;
   123d0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   123d5:	e9 af 00 00 00       	jmp    12489 <dupfd+0xd8>
	if (arg >= NR_OPEN)
   123da:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   123df:	76 25                	jbe    12406 <dupfd+0x55>
		return -EINVAL;
   123e1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   123e6:	e9 9e 00 00 00       	jmp    12489 <dupfd+0xd8>
	while (arg < NR_OPEN)
		if (current->filp[arg])
   123eb:	a1 40 f1 01 00       	mov    0x1f140,%eax
   123f0:	8b 54 24 10          	mov    0x10(%esp),%edx
   123f4:	81 c2 a0 00 00 00    	add    $0xa0,%edx
   123fa:	8b 04 90             	mov    (%eax,%edx,4),%eax
   123fd:	85 c0                	test   %eax,%eax
   123ff:	74 0e                	je     1240f <dupfd+0x5e>
			arg++;
   12401:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
{
	if (fd >= NR_OPEN || !current->filp[fd])
		return -EBADF;
	if (arg >= NR_OPEN)
		return -EINVAL;
	while (arg < NR_OPEN)
   12406:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   1240b:	76 de                	jbe    123eb <dupfd+0x3a>
   1240d:	eb 01                	jmp    12410 <dupfd+0x5f>
		if (current->filp[arg])
			arg++;
		else
			break;
   1240f:	90                   	nop
	if (arg >= NR_OPEN)
   12410:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   12415:	76 07                	jbe    1241e <dupfd+0x6d>
		return -EMFILE;
   12417:	b8 e8 ff ff ff       	mov    $0xffffffe8,%eax
   1241c:	eb 6b                	jmp    12489 <dupfd+0xd8>
	current->close_on_exec &= ~(1<<arg);
   1241e:	a1 40 f1 01 00       	mov    0x1f140,%eax
   12423:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
   12429:	8b 9a 7c 02 00 00    	mov    0x27c(%edx),%ebx
   1242f:	8b 54 24 10          	mov    0x10(%esp),%edx
   12433:	be 01 00 00 00       	mov    $0x1,%esi
   12438:	89 d1                	mov    %edx,%ecx
   1243a:	d3 e6                	shl    %cl,%esi
   1243c:	89 f2                	mov    %esi,%edx
   1243e:	f7 d2                	not    %edx
   12440:	21 da                	and    %ebx,%edx
   12442:	89 90 7c 02 00 00    	mov    %edx,0x27c(%eax)
	(current->filp[arg] = current->filp[fd])->f_count++;
   12448:	a1 40 f1 01 00       	mov    0x1f140,%eax
   1244d:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
   12453:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   12457:	81 c1 a0 00 00 00    	add    $0xa0,%ecx
   1245d:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
   12460:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   12464:	81 c1 a0 00 00 00    	add    $0xa0,%ecx
   1246a:	89 14 88             	mov    %edx,(%eax,%ecx,4)
   1246d:	8b 54 24 10          	mov    0x10(%esp),%edx
   12471:	81 c2 a0 00 00 00    	add    $0xa0,%edx
   12477:	8b 04 90             	mov    (%eax,%edx,4),%eax
   1247a:	0f b7 50 04          	movzwl 0x4(%eax),%edx
   1247e:	83 c2 01             	add    $0x1,%edx
   12481:	66 89 50 04          	mov    %dx,0x4(%eax)
	return arg;
   12485:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   12489:	5b                   	pop    %ebx
   1248a:	5e                   	pop    %esi
   1248b:	c3                   	ret    

0001248c <sys_dup2>:

int sys_dup2(unsigned int oldfd, unsigned int newfd)
{
   1248c:	83 ec 0c             	sub    $0xc,%esp
	sys_close(newfd);
   1248f:	8b 44 24 14          	mov    0x14(%esp),%eax
   12493:	83 ec 0c             	sub    $0xc,%esp
   12496:	50                   	push   %eax
   12497:	e8 b1 90 ff ff       	call   b54d <sys_close>
   1249c:	83 c4 10             	add    $0x10,%esp
	return dupfd(oldfd,newfd);
   1249f:	83 ec 08             	sub    $0x8,%esp
   124a2:	ff 74 24 1c          	pushl  0x1c(%esp)
   124a6:	ff 74 24 1c          	pushl  0x1c(%esp)
   124aa:	e8 02 ff ff ff       	call   123b1 <dupfd>
   124af:	83 c4 10             	add    $0x10,%esp
}
   124b2:	83 c4 0c             	add    $0xc,%esp
   124b5:	c3                   	ret    

000124b6 <sys_dup>:

int sys_dup(unsigned int fildes)
{
	return dupfd(fildes,0);
   124b6:	6a 00                	push   $0x0
   124b8:	ff 74 24 08          	pushl  0x8(%esp)
   124bc:	e8 f0 fe ff ff       	call   123b1 <dupfd>
   124c1:	83 c4 08             	add    $0x8,%esp
}
   124c4:	c3                   	ret    

000124c5 <sys_fcntl>:

int sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg)
{	
   124c5:	56                   	push   %esi
   124c6:	53                   	push   %ebx
   124c7:	83 ec 10             	sub    $0x10,%esp
	struct file * filp;

	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
   124ca:	83 7c 24 1c 13       	cmpl   $0x13,0x1c(%esp)
   124cf:	77 1d                	ja     124ee <sys_fcntl+0x29>
   124d1:	a1 40 f1 01 00       	mov    0x1f140,%eax
   124d6:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   124da:	81 c2 a0 00 00 00    	add    $0xa0,%edx
   124e0:	8b 04 90             	mov    (%eax,%edx,4),%eax
   124e3:	89 44 24 0c          	mov    %eax,0xc(%esp)
   124e7:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   124ec:	75 0a                	jne    124f8 <sys_fcntl+0x33>
		return -EBADF;
   124ee:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   124f3:	e9 03 01 00 00       	jmp    125fb <sys_fcntl+0x136>
	switch (cmd) {
   124f8:	83 7c 24 20 07       	cmpl   $0x7,0x20(%esp)
   124fd:	0f 87 f3 00 00 00    	ja     125f6 <sys_fcntl+0x131>
   12503:	8b 44 24 20          	mov    0x20(%esp),%eax
   12507:	c1 e0 02             	shl    $0x2,%eax
   1250a:	05 a4 8c 01 00       	add    $0x18ca4,%eax
   1250f:	8b 00                	mov    (%eax),%eax
   12511:	ff e0                	jmp    *%eax
		case F_DUPFD:
			return dupfd(fd,arg);
   12513:	ff 74 24 24          	pushl  0x24(%esp)
   12517:	ff 74 24 20          	pushl  0x20(%esp)
   1251b:	e8 91 fe ff ff       	call   123b1 <dupfd>
   12520:	83 c4 08             	add    $0x8,%esp
   12523:	e9 d3 00 00 00       	jmp    125fb <sys_fcntl+0x136>
		case F_GETFD:
			return (current->close_on_exec>>fd)&1;
   12528:	a1 40 f1 01 00       	mov    0x1f140,%eax
   1252d:	8b 90 7c 02 00 00    	mov    0x27c(%eax),%edx
   12533:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12537:	89 c1                	mov    %eax,%ecx
   12539:	d3 ea                	shr    %cl,%edx
   1253b:	89 d0                	mov    %edx,%eax
   1253d:	83 e0 01             	and    $0x1,%eax
   12540:	e9 b6 00 00 00       	jmp    125fb <sys_fcntl+0x136>
		case F_SETFD:
			if (arg&1)
   12545:	8b 44 24 24          	mov    0x24(%esp),%eax
   12549:	83 e0 01             	and    $0x1,%eax
   1254c:	85 c0                	test   %eax,%eax
   1254e:	74 2a                	je     1257a <sys_fcntl+0xb5>
				current->close_on_exec |= (1<<fd);
   12550:	a1 40 f1 01 00       	mov    0x1f140,%eax
   12555:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
   1255b:	8b 9a 7c 02 00 00    	mov    0x27c(%edx),%ebx
   12561:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   12565:	be 01 00 00 00       	mov    $0x1,%esi
   1256a:	89 d1                	mov    %edx,%ecx
   1256c:	d3 e6                	shl    %cl,%esi
   1256e:	89 f2                	mov    %esi,%edx
   12570:	09 da                	or     %ebx,%edx
   12572:	89 90 7c 02 00 00    	mov    %edx,0x27c(%eax)
   12578:	eb 2a                	jmp    125a4 <sys_fcntl+0xdf>
			else
				current->close_on_exec &= ~(1<<fd);
   1257a:	a1 40 f1 01 00       	mov    0x1f140,%eax
   1257f:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
   12585:	8b 9a 7c 02 00 00    	mov    0x27c(%edx),%ebx
   1258b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1258f:	be 01 00 00 00       	mov    $0x1,%esi
   12594:	89 d1                	mov    %edx,%ecx
   12596:	d3 e6                	shl    %cl,%esi
   12598:	89 f2                	mov    %esi,%edx
   1259a:	f7 d2                	not    %edx
   1259c:	21 da                	and    %ebx,%edx
   1259e:	89 90 7c 02 00 00    	mov    %edx,0x27c(%eax)
			return 0;
   125a4:	b8 00 00 00 00       	mov    $0x0,%eax
   125a9:	eb 50                	jmp    125fb <sys_fcntl+0x136>
		case F_GETFL:
			return filp->f_flags;
   125ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
   125af:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   125b3:	0f b7 c0             	movzwl %ax,%eax
   125b6:	eb 43                	jmp    125fb <sys_fcntl+0x136>
		case F_SETFL:
			filp->f_flags &= ~(O_APPEND | O_NONBLOCK);
   125b8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   125bc:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   125c0:	80 e4 f3             	and    $0xf3,%ah
   125c3:	89 c2                	mov    %eax,%edx
   125c5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   125c9:	66 89 50 02          	mov    %dx,0x2(%eax)
			filp->f_flags |= arg & (O_APPEND | O_NONBLOCK);
   125cd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   125d1:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   125d5:	8b 54 24 24          	mov    0x24(%esp),%edx
   125d9:	66 81 e2 00 0c       	and    $0xc00,%dx
   125de:	09 c2                	or     %eax,%edx
   125e0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   125e4:	66 89 50 02          	mov    %dx,0x2(%eax)
			return 0;
   125e8:	b8 00 00 00 00       	mov    $0x0,%eax
   125ed:	eb 0c                	jmp    125fb <sys_fcntl+0x136>
		case F_GETLK:	case F_SETLK:	case F_SETLKW:
			return -1;
   125ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   125f4:	eb 05                	jmp    125fb <sys_fcntl+0x136>
		default:
			return -1;
   125f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
   125fb:	83 c4 10             	add    $0x10,%esp
   125fe:	5b                   	pop    %ebx
   125ff:	5e                   	pop    %esi
   12600:	c3                   	ret    

00012601 <sys_ioctl>:
	NULL,		/* /dev/lp */
	NULL};		/* named pipes */
	

int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
{	
   12601:	83 ec 1c             	sub    $0x1c,%esp
	struct file * filp;
	int dev,mode;

	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
   12604:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
   12609:	77 1d                	ja     12628 <sys_ioctl+0x27>
   1260b:	a1 40 f1 01 00       	mov    0x1f140,%eax
   12610:	8b 54 24 20          	mov    0x20(%esp),%edx
   12614:	81 c2 a0 00 00 00    	add    $0xa0,%edx
   1261a:	8b 04 90             	mov    (%eax,%edx,4),%eax
   1261d:	89 44 24 0c          	mov    %eax,0xc(%esp)
   12621:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   12626:	75 0a                	jne    12632 <sys_ioctl+0x31>
		return -EBADF;
   12628:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   1262d:	e9 9a 00 00 00       	jmp    126cc <sys_ioctl+0xcb>
	mode=filp->f_inode->i_mode;
   12632:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12636:	8b 40 08             	mov    0x8(%eax),%eax
   12639:	0f b7 00             	movzwl (%eax),%eax
   1263c:	0f b7 c0             	movzwl %ax,%eax
   1263f:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (!S_ISCHR(mode) && !S_ISBLK(mode))
   12643:	8b 44 24 08          	mov    0x8(%esp),%eax
   12647:	25 00 f0 00 00       	and    $0xf000,%eax
   1264c:	3d 00 20 00 00       	cmp    $0x2000,%eax
   12651:	74 17                	je     1266a <sys_ioctl+0x69>
   12653:	8b 44 24 08          	mov    0x8(%esp),%eax
   12657:	25 00 f0 00 00       	and    $0xf000,%eax
   1265c:	3d 00 60 00 00       	cmp    $0x6000,%eax
   12661:	74 07                	je     1266a <sys_ioctl+0x69>
		return -EINVAL;
   12663:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   12668:	eb 62                	jmp    126cc <sys_ioctl+0xcb>
	dev = filp->f_inode->i_zone[0];
   1266a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1266e:	8b 40 08             	mov    0x8(%eax),%eax
   12671:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   12675:	0f b7 c0             	movzwl %ax,%eax
   12678:	89 44 24 04          	mov    %eax,0x4(%esp)
	if (MAJOR(dev) >= NRDEVS)
   1267c:	8b 44 24 04          	mov    0x4(%esp),%eax
   12680:	c1 e8 08             	shr    $0x8,%eax
   12683:	83 f8 07             	cmp    $0x7,%eax
   12686:	76 07                	jbe    1268f <sys_ioctl+0x8e>
		return -ENODEV;
   12688:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   1268d:	eb 3d                	jmp    126cc <sys_ioctl+0xcb>
	if (!ioctl_table[MAJOR(dev)])
   1268f:	8b 44 24 04          	mov    0x4(%esp),%eax
   12693:	c1 e8 08             	shr    $0x8,%eax
   12696:	8b 04 85 40 f3 01 00 	mov    0x1f340(,%eax,4),%eax
   1269d:	85 c0                	test   %eax,%eax
   1269f:	75 07                	jne    126a8 <sys_ioctl+0xa7>
		return -ENOTTY;
   126a1:	b8 e7 ff ff ff       	mov    $0xffffffe7,%eax
   126a6:	eb 24                	jmp    126cc <sys_ioctl+0xcb>
	return ioctl_table[MAJOR(dev)](dev,cmd,arg);
   126a8:	8b 44 24 04          	mov    0x4(%esp),%eax
   126ac:	c1 e8 08             	shr    $0x8,%eax
   126af:	8b 04 85 40 f3 01 00 	mov    0x1f340(,%eax,4),%eax
   126b6:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   126ba:	8b 54 24 24          	mov    0x24(%esp),%edx
   126be:	83 ec 04             	sub    $0x4,%esp
   126c1:	51                   	push   %ecx
   126c2:	52                   	push   %edx
   126c3:	ff 74 24 10          	pushl  0x10(%esp)
   126c7:	ff d0                	call   *%eax
   126c9:	83 c4 10             	add    $0x10,%esp
}
   126cc:	83 c4 1c             	add    $0x1c,%esp
   126cf:	c3                   	ret    

000126d0 <free_ind>:
#include <linux/sched.h>

#include <sys/stat.h>

static void free_ind(int dev,int block)
{
   126d0:	83 ec 1c             	sub    $0x1c,%esp
	struct buffer_head * bh;
	unsigned short * p;
	int i;

	if (!block)
   126d3:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   126d8:	0f 84 90 00 00 00    	je     1276e <free_ind+0x9e>
		return;
	if ((bh=bread(dev,block))) {
   126de:	83 ec 08             	sub    $0x8,%esp
   126e1:	ff 74 24 2c          	pushl  0x2c(%esp)
   126e5:	ff 74 24 2c          	pushl  0x2c(%esp)
   126e9:	e8 f8 a8 ff ff       	call   cfe6 <bread>
   126ee:	83 c4 10             	add    $0x10,%esp
   126f1:	89 44 24 04          	mov    %eax,0x4(%esp)
   126f5:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   126fa:	74 5d                	je     12759 <free_ind+0x89>
		p = (unsigned short *) bh->b_data;
   126fc:	8b 44 24 04          	mov    0x4(%esp),%eax
   12700:	8b 00                	mov    (%eax),%eax
   12702:	89 44 24 0c          	mov    %eax,0xc(%esp)
		for (i=0;i<512;i++,p++)
   12706:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   1270d:	00 
   1270e:	eb 30                	jmp    12740 <free_ind+0x70>
			if (*p)
   12710:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12714:	0f b7 00             	movzwl (%eax),%eax
   12717:	66 85 c0             	test   %ax,%ax
   1271a:	74 1a                	je     12736 <free_ind+0x66>
				free_block(dev,*p);
   1271c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12720:	0f b7 00             	movzwl (%eax),%eax
   12723:	0f b7 c0             	movzwl %ax,%eax
   12726:	83 ec 08             	sub    $0x8,%esp
   12729:	50                   	push   %eax
   1272a:	ff 74 24 2c          	pushl  0x2c(%esp)
   1272e:	e8 c4 f5 ff ff       	call   11cf7 <free_block>
   12733:	83 c4 10             	add    $0x10,%esp

	if (!block)
		return;
	if ((bh=bread(dev,block))) {
		p = (unsigned short *) bh->b_data;
		for (i=0;i<512;i++,p++)
   12736:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   1273b:	83 44 24 0c 02       	addl   $0x2,0xc(%esp)
   12740:	81 7c 24 08 ff 01 00 	cmpl   $0x1ff,0x8(%esp)
   12747:	00 
   12748:	7e c6                	jle    12710 <free_ind+0x40>
			if (*p)
				free_block(dev,*p);
		brelse(bh);
   1274a:	83 ec 0c             	sub    $0xc,%esp
   1274d:	ff 74 24 10          	pushl  0x10(%esp)
   12751:	e8 3a a8 ff ff       	call   cf90 <brelse>
   12756:	83 c4 10             	add    $0x10,%esp
	}
	free_block(dev,block);
   12759:	83 ec 08             	sub    $0x8,%esp
   1275c:	ff 74 24 2c          	pushl  0x2c(%esp)
   12760:	ff 74 24 2c          	pushl  0x2c(%esp)
   12764:	e8 8e f5 ff ff       	call   11cf7 <free_block>
   12769:	83 c4 10             	add    $0x10,%esp
   1276c:	eb 01                	jmp    1276f <free_ind+0x9f>
	struct buffer_head * bh;
	unsigned short * p;
	int i;

	if (!block)
		return;
   1276e:	90                   	nop
			if (*p)
				free_block(dev,*p);
		brelse(bh);
	}
	free_block(dev,block);
}
   1276f:	83 c4 1c             	add    $0x1c,%esp
   12772:	c3                   	ret    

00012773 <free_dind>:

static void free_dind(int dev,int block)
{
   12773:	83 ec 1c             	sub    $0x1c,%esp
	struct buffer_head * bh;
	unsigned short * p;
	int i;

	if (!block)
   12776:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   1277b:	0f 84 90 00 00 00    	je     12811 <free_dind+0x9e>
		return;
	if ((bh=bread(dev,block))) {
   12781:	83 ec 08             	sub    $0x8,%esp
   12784:	ff 74 24 2c          	pushl  0x2c(%esp)
   12788:	ff 74 24 2c          	pushl  0x2c(%esp)
   1278c:	e8 55 a8 ff ff       	call   cfe6 <bread>
   12791:	83 c4 10             	add    $0x10,%esp
   12794:	89 44 24 04          	mov    %eax,0x4(%esp)
   12798:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   1279d:	74 5d                	je     127fc <free_dind+0x89>
		p = (unsigned short *) bh->b_data;
   1279f:	8b 44 24 04          	mov    0x4(%esp),%eax
   127a3:	8b 00                	mov    (%eax),%eax
   127a5:	89 44 24 0c          	mov    %eax,0xc(%esp)
		for (i=0;i<512;i++,p++)
   127a9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   127b0:	00 
   127b1:	eb 30                	jmp    127e3 <free_dind+0x70>
			if (*p)
   127b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   127b7:	0f b7 00             	movzwl (%eax),%eax
   127ba:	66 85 c0             	test   %ax,%ax
   127bd:	74 1a                	je     127d9 <free_dind+0x66>
				free_ind(dev,*p);
   127bf:	8b 44 24 0c          	mov    0xc(%esp),%eax
   127c3:	0f b7 00             	movzwl (%eax),%eax
   127c6:	0f b7 c0             	movzwl %ax,%eax
   127c9:	83 ec 08             	sub    $0x8,%esp
   127cc:	50                   	push   %eax
   127cd:	ff 74 24 2c          	pushl  0x2c(%esp)
   127d1:	e8 fa fe ff ff       	call   126d0 <free_ind>
   127d6:	83 c4 10             	add    $0x10,%esp

	if (!block)
		return;
	if ((bh=bread(dev,block))) {
		p = (unsigned short *) bh->b_data;
		for (i=0;i<512;i++,p++)
   127d9:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   127de:	83 44 24 0c 02       	addl   $0x2,0xc(%esp)
   127e3:	81 7c 24 08 ff 01 00 	cmpl   $0x1ff,0x8(%esp)
   127ea:	00 
   127eb:	7e c6                	jle    127b3 <free_dind+0x40>
			if (*p)
				free_ind(dev,*p);
		brelse(bh);
   127ed:	83 ec 0c             	sub    $0xc,%esp
   127f0:	ff 74 24 10          	pushl  0x10(%esp)
   127f4:	e8 97 a7 ff ff       	call   cf90 <brelse>
   127f9:	83 c4 10             	add    $0x10,%esp
	}
	free_block(dev,block);
   127fc:	83 ec 08             	sub    $0x8,%esp
   127ff:	ff 74 24 2c          	pushl  0x2c(%esp)
   12803:	ff 74 24 2c          	pushl  0x2c(%esp)
   12807:	e8 eb f4 ff ff       	call   11cf7 <free_block>
   1280c:	83 c4 10             	add    $0x10,%esp
   1280f:	eb 01                	jmp    12812 <free_dind+0x9f>
	struct buffer_head * bh;
	unsigned short * p;
	int i;

	if (!block)
		return;
   12811:	90                   	nop
			if (*p)
				free_ind(dev,*p);
		brelse(bh);
	}
	free_block(dev,block);
}
   12812:	83 c4 1c             	add    $0x1c,%esp
   12815:	c3                   	ret    

00012816 <truncate>:

void truncate(struct m_inode * inode)
{
   12816:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
   12819:	8b 44 24 20          	mov    0x20(%esp),%eax
   1281d:	0f b7 00             	movzwl (%eax),%eax
   12820:	0f b7 c0             	movzwl %ax,%eax
   12823:	25 00 f0 00 00       	and    $0xf000,%eax
   12828:	3d 00 80 00 00       	cmp    $0x8000,%eax
   1282d:	74 1a                	je     12849 <truncate+0x33>
   1282f:	8b 44 24 20          	mov    0x20(%esp),%eax
   12833:	0f b7 00             	movzwl (%eax),%eax
   12836:	0f b7 c0             	movzwl %ax,%eax
   12839:	25 00 f0 00 00       	and    $0xf000,%eax
   1283e:	3d 00 40 00 00       	cmp    $0x4000,%eax
   12843:	0f 85 0b 01 00 00    	jne    12954 <truncate+0x13e>
		return;
	for (i=0;i<7;i++)
   12849:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   12850:	00 
   12851:	eb 4e                	jmp    128a1 <truncate+0x8b>
		if (inode->i_zone[i]) {
   12853:	8b 44 24 20          	mov    0x20(%esp),%eax
   12857:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1285b:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
   12860:	66 85 c0             	test   %ax,%ax
   12863:	74 37                	je     1289c <truncate+0x86>
			free_block(inode->i_dev,inode->i_zone[i]);
   12865:	8b 44 24 20          	mov    0x20(%esp),%eax
   12869:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1286d:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
   12872:	0f b7 d0             	movzwl %ax,%edx
   12875:	8b 44 24 20          	mov    0x20(%esp),%eax
   12879:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1287d:	0f b7 c0             	movzwl %ax,%eax
   12880:	83 ec 08             	sub    $0x8,%esp
   12883:	52                   	push   %edx
   12884:	50                   	push   %eax
   12885:	e8 6d f4 ff ff       	call   11cf7 <free_block>
   1288a:	83 c4 10             	add    $0x10,%esp
			inode->i_zone[i]=0;
   1288d:	8b 44 24 20          	mov    0x20(%esp),%eax
   12891:	8b 54 24 0c          	mov    0xc(%esp),%edx
   12895:	66 c7 44 50 0e 00 00 	movw   $0x0,0xe(%eax,%edx,2)
{
	int i;

	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
		return;
	for (i=0;i<7;i++)
   1289c:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   128a1:	83 7c 24 0c 06       	cmpl   $0x6,0xc(%esp)
   128a6:	7e ab                	jle    12853 <truncate+0x3d>
		if (inode->i_zone[i]) {
			free_block(inode->i_dev,inode->i_zone[i]);
			inode->i_zone[i]=0;
		}
	free_ind(inode->i_dev,inode->i_zone[7]);
   128a8:	8b 44 24 20          	mov    0x20(%esp),%eax
   128ac:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   128b0:	0f b7 d0             	movzwl %ax,%edx
   128b3:	8b 44 24 20          	mov    0x20(%esp),%eax
   128b7:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   128bb:	0f b7 c0             	movzwl %ax,%eax
   128be:	83 ec 08             	sub    $0x8,%esp
   128c1:	52                   	push   %edx
   128c2:	50                   	push   %eax
   128c3:	e8 08 fe ff ff       	call   126d0 <free_ind>
   128c8:	83 c4 10             	add    $0x10,%esp
	free_dind(inode->i_dev,inode->i_zone[8]);
   128cb:	8b 44 24 20          	mov    0x20(%esp),%eax
   128cf:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
   128d3:	0f b7 d0             	movzwl %ax,%edx
   128d6:	8b 44 24 20          	mov    0x20(%esp),%eax
   128da:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   128de:	0f b7 c0             	movzwl %ax,%eax
   128e1:	83 ec 08             	sub    $0x8,%esp
   128e4:	52                   	push   %edx
   128e5:	50                   	push   %eax
   128e6:	e8 88 fe ff ff       	call   12773 <free_dind>
   128eb:	83 c4 10             	add    $0x10,%esp
	inode->i_zone[7] = inode->i_zone[8] = 0;
   128ee:	8b 44 24 20          	mov    0x20(%esp),%eax
   128f2:	66 c7 40 1e 00 00    	movw   $0x0,0x1e(%eax)
   128f8:	8b 44 24 20          	mov    0x20(%esp),%eax
   128fc:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
   12900:	8b 44 24 20          	mov    0x20(%esp),%eax
   12904:	66 89 50 1c          	mov    %dx,0x1c(%eax)
	inode->i_size = 0;
   12908:	8b 44 24 20          	mov    0x20(%esp),%eax
   1290c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	inode->i_dirt = 1;
   12913:	8b 44 24 20          	mov    0x20(%esp),%eax
   12917:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
   1291b:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   12921:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   12926:	89 c8                	mov    %ecx,%eax
   12928:	f7 ea                	imul   %edx
   1292a:	c1 fa 05             	sar    $0x5,%edx
   1292d:	89 c8                	mov    %ecx,%eax
   1292f:	c1 f8 1f             	sar    $0x1f,%eax
   12932:	29 c2                	sub    %eax,%edx
   12934:	a1 e4 1e 02 00       	mov    0x21ee4,%eax
   12939:	01 d0                	add    %edx,%eax
   1293b:	89 c2                	mov    %eax,%edx
   1293d:	8b 44 24 20          	mov    0x20(%esp),%eax
   12941:	89 50 28             	mov    %edx,0x28(%eax)
   12944:	8b 44 24 20          	mov    0x20(%esp),%eax
   12948:	8b 50 28             	mov    0x28(%eax),%edx
   1294b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1294f:	89 50 08             	mov    %edx,0x8(%eax)
   12952:	eb 01                	jmp    12955 <truncate+0x13f>
void truncate(struct m_inode * inode)
{
	int i;

	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
		return;
   12954:	90                   	nop
	free_dind(inode->i_dev,inode->i_zone[8]);
	inode->i_zone[7] = inode->i_zone[8] = 0;
	inode->i_size = 0;
	inode->i_dirt = 1;
	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
}
   12955:	83 c4 1c             	add    $0x1c,%esp
   12958:	c3                   	ret    

00012959 <lock_buffer>:
	{ NULL, NULL },		/* dev tty */
	{ NULL, NULL }		/* dev lp */
};

static inline void lock_buffer(struct buffer_head * bh)
{
   12959:	83 ec 0c             	sub    $0xc,%esp
	cli();
   1295c:	fa                   	cli    
	while (bh->b_lock)
   1295d:	eb 13                	jmp    12972 <lock_buffer+0x19>
		sleep_on(&bh->b_wait);
   1295f:	8b 44 24 10          	mov    0x10(%esp),%eax
   12963:	83 c0 10             	add    $0x10,%eax
   12966:	83 ec 0c             	sub    $0xc,%esp
   12969:	50                   	push   %eax
   1296a:	e8 03 45 ff ff       	call   6e72 <sleep_on>
   1296f:	83 c4 10             	add    $0x10,%esp
};

static inline void lock_buffer(struct buffer_head * bh)
{
	cli();
	while (bh->b_lock)
   12972:	8b 44 24 10          	mov    0x10(%esp),%eax
   12976:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1297a:	84 c0                	test   %al,%al
   1297c:	75 e1                	jne    1295f <lock_buffer+0x6>
		sleep_on(&bh->b_wait);
	bh->b_lock=1;
   1297e:	8b 44 24 10          	mov    0x10(%esp),%eax
   12982:	c6 40 0d 01          	movb   $0x1,0xd(%eax)
	sti();
   12986:	fb                   	sti    
}
   12987:	90                   	nop
   12988:	83 c4 0c             	add    $0xc,%esp
   1298b:	c3                   	ret    

0001298c <unlock_buffer>:

static inline void unlock_buffer(struct buffer_head * bh)
{
   1298c:	83 ec 0c             	sub    $0xc,%esp
	if (!bh->b_lock)
   1298f:	8b 44 24 10          	mov    0x10(%esp),%eax
   12993:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   12997:	84 c0                	test   %al,%al
   12999:	75 10                	jne    129ab <unlock_buffer+0x1f>
		printk("ll_rw_block.c: buffer not locked\n\r");
   1299b:	83 ec 0c             	sub    $0xc,%esp
   1299e:	68 c4 8c 01 00       	push   $0x18cc4
   129a3:	e8 65 5e ff ff       	call   880d <printk>
   129a8:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   129ab:	8b 44 24 10          	mov    0x10(%esp),%eax
   129af:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	wake_up(&bh->b_wait);
   129b3:	8b 44 24 10          	mov    0x10(%esp),%eax
   129b7:	83 c0 10             	add    $0x10,%eax
   129ba:	83 ec 0c             	sub    $0xc,%esp
   129bd:	50                   	push   %eax
   129be:	e8 b6 45 ff ff       	call   6f79 <wake_up>
   129c3:	83 c4 10             	add    $0x10,%esp
}
   129c6:	90                   	nop
   129c7:	83 c4 0c             	add    $0xc,%esp
   129ca:	c3                   	ret    

000129cb <add_request>:
 * add-request adds a request to the linked list.
 * It disables interrupts so that it can muck with the
 * request-lists in peace.
 */
static void add_request(struct blk_dev_struct * dev, struct request * req)
{
   129cb:	83 ec 1c             	sub    $0x1c,%esp
	struct request * tmp;

	req->next = NULL;
   129ce:	8b 44 24 24          	mov    0x24(%esp),%eax
   129d2:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	cli();
   129d9:	fa                   	cli    
	if (req->bh)
   129da:	8b 44 24 24          	mov    0x24(%esp),%eax
   129de:	8b 40 1c             	mov    0x1c(%eax),%eax
   129e1:	85 c0                	test   %eax,%eax
   129e3:	74 0b                	je     129f0 <add_request+0x25>
		req->bh->b_dirt = 0;
   129e5:	8b 44 24 24          	mov    0x24(%esp),%eax
   129e9:	8b 40 1c             	mov    0x1c(%eax),%eax
   129ec:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	if (!(tmp = dev->current_request)) {
   129f0:	8b 44 24 20          	mov    0x20(%esp),%eax
   129f4:	8b 40 04             	mov    0x4(%eax),%eax
   129f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
   129fb:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   12a00:	0f 85 54 01 00 00    	jne    12b5a <add_request+0x18f>
		dev->current_request = req;
   12a06:	8b 44 24 20          	mov    0x20(%esp),%eax
   12a0a:	8b 54 24 24          	mov    0x24(%esp),%edx
   12a0e:	89 50 04             	mov    %edx,0x4(%eax)
		sti();
   12a11:	fb                   	sti    
		(dev->request_fn)();
   12a12:	8b 44 24 20          	mov    0x20(%esp),%eax
   12a16:	8b 00                	mov    (%eax),%eax
   12a18:	ff d0                	call   *%eax
		return;
   12a1a:	e9 64 01 00 00       	jmp    12b83 <add_request+0x1b8>
	}
	for ( ; tmp->next ; tmp=tmp->next)
		if ((IN_ORDER(tmp,req) || 
   12a1f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12a23:	8b 50 04             	mov    0x4(%eax),%edx
   12a26:	8b 44 24 24          	mov    0x24(%esp),%eax
   12a2a:	8b 40 04             	mov    0x4(%eax),%eax
   12a2d:	39 c2                	cmp    %eax,%edx
   12a2f:	0f 8c b5 00 00 00    	jl     12aea <add_request+0x11f>
   12a35:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12a39:	8b 50 04             	mov    0x4(%eax),%edx
   12a3c:	8b 44 24 24          	mov    0x24(%esp),%eax
   12a40:	8b 40 04             	mov    0x4(%eax),%eax
   12a43:	39 c2                	cmp    %eax,%edx
   12a45:	75 36                	jne    12a7d <add_request+0xb2>
   12a47:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12a4b:	8b 10                	mov    (%eax),%edx
   12a4d:	8b 44 24 24          	mov    0x24(%esp),%eax
   12a51:	8b 00                	mov    (%eax),%eax
   12a53:	39 c2                	cmp    %eax,%edx
   12a55:	0f 8c 8f 00 00 00    	jl     12aea <add_request+0x11f>
   12a5b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12a5f:	8b 10                	mov    (%eax),%edx
   12a61:	8b 44 24 24          	mov    0x24(%esp),%eax
   12a65:	8b 00                	mov    (%eax),%eax
   12a67:	39 c2                	cmp    %eax,%edx
   12a69:	75 12                	jne    12a7d <add_request+0xb2>
   12a6b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12a6f:	8b 50 0c             	mov    0xc(%eax),%edx
   12a72:	8b 44 24 24          	mov    0x24(%esp),%eax
   12a76:	8b 40 0c             	mov    0xc(%eax),%eax
   12a79:	39 c2                	cmp    %eax,%edx
   12a7b:	72 6d                	jb     12aea <add_request+0x11f>
		    !IN_ORDER(tmp,tmp->next)) &&
   12a7d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12a81:	8b 50 04             	mov    0x4(%eax),%edx
   12a84:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12a88:	8b 40 20             	mov    0x20(%eax),%eax
   12a8b:	8b 40 04             	mov    0x4(%eax),%eax
		sti();
		(dev->request_fn)();
		return;
	}
	for ( ; tmp->next ; tmp=tmp->next)
		if ((IN_ORDER(tmp,req) || 
   12a8e:	39 c2                	cmp    %eax,%edx
   12a90:	0f 8c b9 00 00 00    	jl     12b4f <add_request+0x184>
		    !IN_ORDER(tmp,tmp->next)) &&
   12a96:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12a9a:	8b 50 04             	mov    0x4(%eax),%edx
   12a9d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12aa1:	8b 40 20             	mov    0x20(%eax),%eax
   12aa4:	8b 40 04             	mov    0x4(%eax),%eax
   12aa7:	39 c2                	cmp    %eax,%edx
   12aa9:	75 3f                	jne    12aea <add_request+0x11f>
   12aab:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12aaf:	8b 10                	mov    (%eax),%edx
   12ab1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12ab5:	8b 40 20             	mov    0x20(%eax),%eax
   12ab8:	8b 00                	mov    (%eax),%eax
   12aba:	39 c2                	cmp    %eax,%edx
   12abc:	0f 8c 8d 00 00 00    	jl     12b4f <add_request+0x184>
   12ac2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12ac6:	8b 10                	mov    (%eax),%edx
   12ac8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12acc:	8b 40 20             	mov    0x20(%eax),%eax
   12acf:	8b 00                	mov    (%eax),%eax
   12ad1:	39 c2                	cmp    %eax,%edx
   12ad3:	75 15                	jne    12aea <add_request+0x11f>
   12ad5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12ad9:	8b 50 0c             	mov    0xc(%eax),%edx
   12adc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12ae0:	8b 40 20             	mov    0x20(%eax),%eax
   12ae3:	8b 40 0c             	mov    0xc(%eax),%eax
   12ae6:	39 c2                	cmp    %eax,%edx
   12ae8:	72 65                	jb     12b4f <add_request+0x184>
		    IN_ORDER(req,tmp->next))
   12aea:	8b 44 24 24          	mov    0x24(%esp),%eax
   12aee:	8b 50 04             	mov    0x4(%eax),%edx
   12af1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12af5:	8b 40 20             	mov    0x20(%eax),%eax
   12af8:	8b 40 04             	mov    0x4(%eax),%eax
		(dev->request_fn)();
		return;
	}
	for ( ; tmp->next ; tmp=tmp->next)
		if ((IN_ORDER(tmp,req) || 
		    !IN_ORDER(tmp,tmp->next)) &&
   12afb:	39 c2                	cmp    %eax,%edx
   12afd:	7c 6a                	jl     12b69 <add_request+0x19e>
		    IN_ORDER(req,tmp->next))
   12aff:	8b 44 24 24          	mov    0x24(%esp),%eax
   12b03:	8b 50 04             	mov    0x4(%eax),%edx
   12b06:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12b0a:	8b 40 20             	mov    0x20(%eax),%eax
   12b0d:	8b 40 04             	mov    0x4(%eax),%eax
   12b10:	39 c2                	cmp    %eax,%edx
   12b12:	75 3b                	jne    12b4f <add_request+0x184>
   12b14:	8b 44 24 24          	mov    0x24(%esp),%eax
   12b18:	8b 10                	mov    (%eax),%edx
   12b1a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12b1e:	8b 40 20             	mov    0x20(%eax),%eax
   12b21:	8b 00                	mov    (%eax),%eax
   12b23:	39 c2                	cmp    %eax,%edx
   12b25:	7c 42                	jl     12b69 <add_request+0x19e>
   12b27:	8b 44 24 24          	mov    0x24(%esp),%eax
   12b2b:	8b 10                	mov    (%eax),%edx
   12b2d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12b31:	8b 40 20             	mov    0x20(%eax),%eax
   12b34:	8b 00                	mov    (%eax),%eax
   12b36:	39 c2                	cmp    %eax,%edx
   12b38:	75 15                	jne    12b4f <add_request+0x184>
   12b3a:	8b 44 24 24          	mov    0x24(%esp),%eax
   12b3e:	8b 50 0c             	mov    0xc(%eax),%edx
   12b41:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12b45:	8b 40 20             	mov    0x20(%eax),%eax
   12b48:	8b 40 0c             	mov    0xc(%eax),%eax
   12b4b:	39 c2                	cmp    %eax,%edx
   12b4d:	72 1a                	jb     12b69 <add_request+0x19e>
		dev->current_request = req;
		sti();
		(dev->request_fn)();
		return;
	}
	for ( ; tmp->next ; tmp=tmp->next)
   12b4f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12b53:	8b 40 20             	mov    0x20(%eax),%eax
   12b56:	89 44 24 0c          	mov    %eax,0xc(%esp)
   12b5a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12b5e:	8b 40 20             	mov    0x20(%eax),%eax
   12b61:	85 c0                	test   %eax,%eax
   12b63:	0f 85 b6 fe ff ff    	jne    12a1f <add_request+0x54>
		if ((IN_ORDER(tmp,req) || 
		    !IN_ORDER(tmp,tmp->next)) &&
		    IN_ORDER(req,tmp->next))
			break;
	req->next=tmp->next;
   12b69:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12b6d:	8b 50 20             	mov    0x20(%eax),%edx
   12b70:	8b 44 24 24          	mov    0x24(%esp),%eax
   12b74:	89 50 20             	mov    %edx,0x20(%eax)
	tmp->next=req;
   12b77:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12b7b:	8b 54 24 24          	mov    0x24(%esp),%edx
   12b7f:	89 50 20             	mov    %edx,0x20(%eax)
	sti();
   12b82:	fb                   	sti    
}
   12b83:	83 c4 1c             	add    $0x1c,%esp
   12b86:	c3                   	ret    

00012b87 <make_request>:

static void make_request(int major,int rw, struct buffer_head * bh)
{
   12b87:	83 ec 1c             	sub    $0x1c,%esp
	struct request * req;
	int rw_ahead;

/* WRITEA/READA is special case - it is not really needed, so if the */
/* buffer is locked, we just forget about it, else it's a normal read */
	if ((rw_ahead = (rw == READA || rw == WRITEA))) {
   12b8a:	83 7c 24 24 02       	cmpl   $0x2,0x24(%esp)
   12b8f:	74 07                	je     12b98 <make_request+0x11>
   12b91:	83 7c 24 24 03       	cmpl   $0x3,0x24(%esp)
   12b96:	75 07                	jne    12b9f <make_request+0x18>
   12b98:	b8 01 00 00 00       	mov    $0x1,%eax
   12b9d:	eb 05                	jmp    12ba4 <make_request+0x1d>
   12b9f:	b8 00 00 00 00       	mov    $0x0,%eax
   12ba4:	89 44 24 08          	mov    %eax,0x8(%esp)
   12ba8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   12bad:	74 29                	je     12bd8 <make_request+0x51>
		if (bh->b_lock)
   12baf:	8b 44 24 28          	mov    0x28(%esp),%eax
   12bb3:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   12bb7:	84 c0                	test   %al,%al
   12bb9:	0f 85 7d 01 00 00    	jne    12d3c <make_request+0x1b5>
			return;
		if (rw == READA)
   12bbf:	83 7c 24 24 02       	cmpl   $0x2,0x24(%esp)
   12bc4:	75 0a                	jne    12bd0 <make_request+0x49>
			rw = READ;
   12bc6:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
   12bcd:	00 
   12bce:	eb 08                	jmp    12bd8 <make_request+0x51>
		else
			rw = WRITE;
   12bd0:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
   12bd7:	00 
	}
	if (rw!=READ && rw!=WRITE)
   12bd8:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   12bdd:	74 17                	je     12bf6 <make_request+0x6f>
   12bdf:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
   12be4:	74 10                	je     12bf6 <make_request+0x6f>
		panic("Bad block dev command, must be R/W/RA/WA");
   12be6:	83 ec 0c             	sub    $0xc,%esp
   12be9:	68 e8 8c 01 00       	push   $0x18ce8
   12bee:	e8 db 5b ff ff       	call   87ce <panic>
   12bf3:	83 c4 10             	add    $0x10,%esp
	lock_buffer(bh);
   12bf6:	83 ec 0c             	sub    $0xc,%esp
   12bf9:	ff 74 24 34          	pushl  0x34(%esp)
   12bfd:	e8 57 fd ff ff       	call   12959 <lock_buffer>
   12c02:	83 c4 10             	add    $0x10,%esp
	if ((rw == WRITE && !bh->b_dirt) || (rw == READ && bh->b_uptodate)) {
   12c05:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
   12c0a:	75 0c                	jne    12c18 <make_request+0x91>
   12c0c:	8b 44 24 28          	mov    0x28(%esp),%eax
   12c10:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   12c14:	84 c0                	test   %al,%al
   12c16:	74 13                	je     12c2b <make_request+0xa4>
   12c18:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   12c1d:	75 20                	jne    12c3f <make_request+0xb8>
   12c1f:	8b 44 24 28          	mov    0x28(%esp),%eax
   12c23:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
   12c27:	84 c0                	test   %al,%al
   12c29:	74 14                	je     12c3f <make_request+0xb8>
		unlock_buffer(bh);
   12c2b:	83 ec 0c             	sub    $0xc,%esp
   12c2e:	ff 74 24 34          	pushl  0x34(%esp)
   12c32:	e8 55 fd ff ff       	call   1298c <unlock_buffer>
   12c37:	83 c4 10             	add    $0x10,%esp
		return;
   12c3a:	e9 fe 00 00 00       	jmp    12d3d <make_request+0x1b6>
repeat:
/* we don't allow the write-requests to fill up the queue completely:
 * we want some room for reads: they take precedence. The last third
 * of the requests are only for reads.
 */
	if (rw == READ)
   12c3f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   12c44:	75 0a                	jne    12c50 <make_request+0xc9>
		req = request+NR_REQUEST;
   12c46:	c7 44 24 0c 60 5f 02 	movl   $0x25f60,0xc(%esp)
   12c4d:	00 
   12c4e:	eb 14                	jmp    12c64 <make_request+0xdd>
	else
		req = request+((NR_REQUEST*2)/3);
   12c50:	c7 44 24 0c d4 5d 02 	movl   $0x25dd4,0xc(%esp)
   12c57:	00 
/* find an empty request */
	while (--req >= request)
   12c58:	eb 0a                	jmp    12c64 <make_request+0xdd>
		if (req->dev<0)
   12c5a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12c5e:	8b 00                	mov    (%eax),%eax
   12c60:	85 c0                	test   %eax,%eax
   12c62:	78 11                	js     12c75 <make_request+0xee>
	if (rw == READ)
		req = request+NR_REQUEST;
	else
		req = request+((NR_REQUEST*2)/3);
/* find an empty request */
	while (--req >= request)
   12c64:	83 6c 24 0c 24       	subl   $0x24,0xc(%esp)
   12c69:	81 7c 24 0c e0 5a 02 	cmpl   $0x25ae0,0xc(%esp)
   12c70:	00 
   12c71:	73 e7                	jae    12c5a <make_request+0xd3>
   12c73:	eb 01                	jmp    12c76 <make_request+0xef>
		if (req->dev<0)
			break;
   12c75:	90                   	nop
/* if none found, sleep on new requests: check for rw_ahead */
	if (req < request) {
   12c76:	81 7c 24 0c e0 5a 02 	cmpl   $0x25ae0,0xc(%esp)
   12c7d:	00 
   12c7e:	73 2d                	jae    12cad <make_request+0x126>
		if (rw_ahead) {
   12c80:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   12c85:	74 14                	je     12c9b <make_request+0x114>
			unlock_buffer(bh);
   12c87:	83 ec 0c             	sub    $0xc,%esp
   12c8a:	ff 74 24 34          	pushl  0x34(%esp)
   12c8e:	e8 f9 fc ff ff       	call   1298c <unlock_buffer>
   12c93:	83 c4 10             	add    $0x10,%esp
			return;
   12c96:	e9 a2 00 00 00       	jmp    12d3d <make_request+0x1b6>
		}
		sleep_on(&wait_for_request);
   12c9b:	83 ec 0c             	sub    $0xc,%esp
   12c9e:	68 80 3c 02 00       	push   $0x23c80
   12ca3:	e8 ca 41 ff ff       	call   6e72 <sleep_on>
   12ca8:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   12cab:	eb 92                	jmp    12c3f <make_request+0xb8>
	}
/* fill up the request-info, and add it to the queue */
	req->dev = bh->b_dev;
   12cad:	8b 44 24 28          	mov    0x28(%esp),%eax
   12cb1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   12cb5:	0f b7 d0             	movzwl %ax,%edx
   12cb8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12cbc:	89 10                	mov    %edx,(%eax)
	req->cmd = rw;
   12cbe:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12cc2:	8b 54 24 24          	mov    0x24(%esp),%edx
   12cc6:	89 50 04             	mov    %edx,0x4(%eax)
	req->errors=0;
   12cc9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12ccd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	req->sector = bh->b_blocknr<<1;
   12cd4:	8b 44 24 28          	mov    0x28(%esp),%eax
   12cd8:	8b 40 04             	mov    0x4(%eax),%eax
   12cdb:	8d 14 00             	lea    (%eax,%eax,1),%edx
   12cde:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12ce2:	89 50 0c             	mov    %edx,0xc(%eax)
	req->nr_sectors = 2;
   12ce5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12ce9:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	req->buffer = bh->b_data;
   12cf0:	8b 44 24 28          	mov    0x28(%esp),%eax
   12cf4:	8b 10                	mov    (%eax),%edx
   12cf6:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12cfa:	89 50 14             	mov    %edx,0x14(%eax)
	req->waiting = NULL;
   12cfd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12d01:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	req->bh = bh;
   12d08:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12d0c:	8b 54 24 28          	mov    0x28(%esp),%edx
   12d10:	89 50 1c             	mov    %edx,0x1c(%eax)
	req->next = NULL;
   12d13:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12d17:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	add_request(major+blk_dev,req);
   12d1e:	8b 44 24 20          	mov    0x20(%esp),%eax
   12d22:	c1 e0 03             	shl    $0x3,%eax
   12d25:	05 a0 3c 02 00       	add    $0x23ca0,%eax
   12d2a:	83 ec 08             	sub    $0x8,%esp
   12d2d:	ff 74 24 14          	pushl  0x14(%esp)
   12d31:	50                   	push   %eax
   12d32:	e8 94 fc ff ff       	call   129cb <add_request>
   12d37:	83 c4 10             	add    $0x10,%esp
   12d3a:	eb 01                	jmp    12d3d <make_request+0x1b6>

/* WRITEA/READA is special case - it is not really needed, so if the */
/* buffer is locked, we just forget about it, else it's a normal read */
	if ((rw_ahead = (rw == READA || rw == WRITEA))) {
		if (bh->b_lock)
			return;
   12d3c:	90                   	nop
	req->buffer = bh->b_data;
	req->waiting = NULL;
	req->bh = bh;
	req->next = NULL;
	add_request(major+blk_dev,req);
}
   12d3d:	83 c4 1c             	add    $0x1c,%esp
   12d40:	c3                   	ret    

00012d41 <ll_rw_block>:

void ll_rw_block(int rw, struct buffer_head * bh)
{
   12d41:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int major;

	if ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
   12d44:	8b 44 24 24          	mov    0x24(%esp),%eax
   12d48:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   12d4c:	66 c1 e8 08          	shr    $0x8,%ax
   12d50:	0f b7 c0             	movzwl %ax,%eax
   12d53:	89 44 24 0c          	mov    %eax,0xc(%esp)
   12d57:	83 7c 24 0c 06       	cmpl   $0x6,0xc(%esp)
   12d5c:	77 0f                	ja     12d6d <ll_rw_block+0x2c>
	!(blk_dev[major].request_fn)) {
   12d5e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12d62:	8b 04 c5 a0 3c 02 00 	mov    0x23ca0(,%eax,8),%eax

void ll_rw_block(int rw, struct buffer_head * bh)
{
	unsigned int major;

	if ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
   12d69:	85 c0                	test   %eax,%eax
   12d6b:	75 12                	jne    12d7f <ll_rw_block+0x3e>
	!(blk_dev[major].request_fn)) {
		printk("Trying to read nonexistent block-device\n\r");
   12d6d:	83 ec 0c             	sub    $0xc,%esp
   12d70:	68 14 8d 01 00       	push   $0x18d14
   12d75:	e8 93 5a ff ff       	call   880d <printk>
   12d7a:	83 c4 10             	add    $0x10,%esp
		return;
   12d7d:	eb 18                	jmp    12d97 <ll_rw_block+0x56>
	}
	make_request(major,rw,bh);
   12d7f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   12d83:	83 ec 04             	sub    $0x4,%esp
   12d86:	ff 74 24 28          	pushl  0x28(%esp)
   12d8a:	ff 74 24 28          	pushl  0x28(%esp)
   12d8e:	50                   	push   %eax
   12d8f:	e8 f3 fd ff ff       	call   12b87 <make_request>
   12d94:	83 c4 10             	add    $0x10,%esp
}
   12d97:	83 c4 1c             	add    $0x1c,%esp
   12d9a:	c3                   	ret    

00012d9b <blk_dev_init>:

void blk_dev_init(void)
{
   12d9b:	83 ec 10             	sub    $0x10,%esp
	int i;

	for (i=0 ; i<NR_REQUEST ; i++) {
   12d9e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   12da5:	00 
   12da6:	eb 37                	jmp    12ddf <blk_dev_init+0x44>
		request[i].dev = -1;
   12da8:	8b 54 24 0c          	mov    0xc(%esp),%edx
   12dac:	89 d0                	mov    %edx,%eax
   12dae:	c1 e0 03             	shl    $0x3,%eax
   12db1:	01 d0                	add    %edx,%eax
   12db3:	c1 e0 02             	shl    $0x2,%eax
   12db6:	05 e0 5a 02 00       	add    $0x25ae0,%eax
   12dbb:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
		request[i].next = NULL;
   12dc1:	8b 54 24 0c          	mov    0xc(%esp),%edx
   12dc5:	89 d0                	mov    %edx,%eax
   12dc7:	c1 e0 03             	shl    $0x3,%eax
   12dca:	01 d0                	add    %edx,%eax
   12dcc:	c1 e0 02             	shl    $0x2,%eax
   12dcf:	05 00 5b 02 00       	add    $0x25b00,%eax
   12dd4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

void blk_dev_init(void)
{
	int i;

	for (i=0 ; i<NR_REQUEST ; i++) {
   12dda:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   12ddf:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
   12de4:	7e c2                	jle    12da8 <blk_dev_init+0xd>
		request[i].dev = -1;
		request[i].next = NULL;
	}
}
   12de6:	90                   	nop
   12de7:	83 c4 10             	add    $0x10,%esp
   12dea:	c3                   	ret    

00012deb <unlock_buffer>:
void (*DEVICE_INTR)(void) = NULL;
#endif
static void (DEVICE_REQUEST)(void);

static inline void unlock_buffer(struct buffer_head * bh)
{
   12deb:	83 ec 0c             	sub    $0xc,%esp
	if (!bh->b_lock)
   12dee:	8b 44 24 10          	mov    0x10(%esp),%eax
   12df2:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   12df6:	84 c0                	test   %al,%al
   12df8:	75 10                	jne    12e0a <unlock_buffer+0x1f>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   12dfa:	83 ec 0c             	sub    $0xc,%esp
   12dfd:	68 40 8d 01 00       	push   $0x18d40
   12e02:	e8 06 5a ff ff       	call   880d <printk>
   12e07:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   12e0a:	8b 44 24 10          	mov    0x10(%esp),%eax
   12e0e:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	wake_up(&bh->b_wait);
   12e12:	8b 44 24 10          	mov    0x10(%esp),%eax
   12e16:	83 c0 10             	add    $0x10,%eax
   12e19:	83 ec 0c             	sub    $0xc,%esp
   12e1c:	50                   	push   %eax
   12e1d:	e8 57 41 ff ff       	call   6f79 <wake_up>
   12e22:	83 c4 10             	add    $0x10,%esp
}
   12e25:	90                   	nop
   12e26:	83 c4 0c             	add    $0xc,%esp
   12e29:	c3                   	ret    

00012e2a <end_request>:

static inline void end_request(int uptodate)
{
   12e2a:	83 ec 0c             	sub    $0xc,%esp
	DEVICE_OFF(CURRENT->dev);
   12e2d:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12e32:	8b 00                	mov    (%eax),%eax
   12e34:	83 e0 03             	and    $0x3,%eax
   12e37:	83 ec 0c             	sub    $0xc,%esp
   12e3a:	50                   	push   %eax
   12e3b:	e8 72 42 ff ff       	call   70b2 <floppy_off>
   12e40:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->bh) {
   12e43:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12e48:	8b 40 1c             	mov    0x1c(%eax),%eax
   12e4b:	85 c0                	test   %eax,%eax
   12e4d:	74 23                	je     12e72 <end_request+0x48>
		CURRENT->bh->b_uptodate = uptodate;
   12e4f:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12e54:	8b 40 1c             	mov    0x1c(%eax),%eax
   12e57:	8b 54 24 10          	mov    0x10(%esp),%edx
   12e5b:	88 50 0a             	mov    %dl,0xa(%eax)
		unlock_buffer(CURRENT->bh);
   12e5e:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12e63:	8b 40 1c             	mov    0x1c(%eax),%eax
   12e66:	83 ec 0c             	sub    $0xc,%esp
   12e69:	50                   	push   %eax
   12e6a:	e8 7c ff ff ff       	call   12deb <unlock_buffer>
   12e6f:	83 c4 10             	add    $0x10,%esp
	}
	if (!uptodate) {
   12e72:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   12e77:	75 34                	jne    12ead <end_request+0x83>
		printk(DEVICE_NAME " I/O error\n\r");
   12e79:	83 ec 0c             	sub    $0xc,%esp
   12e7c:	68 64 8d 01 00       	push   $0x18d64
   12e81:	e8 87 59 ff ff       	call   880d <printk>
   12e86:	83 c4 10             	add    $0x10,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
			CURRENT->bh->b_blocknr);
   12e89:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12e8e:	8b 40 1c             	mov    0x1c(%eax),%eax
		CURRENT->bh->b_uptodate = uptodate;
		unlock_buffer(CURRENT->bh);
	}
	if (!uptodate) {
		printk(DEVICE_NAME " I/O error\n\r");
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   12e91:	8b 50 04             	mov    0x4(%eax),%edx
   12e94:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12e99:	8b 00                	mov    (%eax),%eax
   12e9b:	83 ec 04             	sub    $0x4,%esp
   12e9e:	52                   	push   %edx
   12e9f:	50                   	push   %eax
   12ea0:	68 77 8d 01 00       	push   $0x18d77
   12ea5:	e8 63 59 ff ff       	call   880d <printk>
   12eaa:	83 c4 10             	add    $0x10,%esp
			CURRENT->bh->b_blocknr);
	}
	wake_up(&CURRENT->waiting);
   12ead:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12eb2:	83 c0 18             	add    $0x18,%eax
   12eb5:	83 ec 0c             	sub    $0xc,%esp
   12eb8:	50                   	push   %eax
   12eb9:	e8 bb 40 ff ff       	call   6f79 <wake_up>
   12ebe:	83 c4 10             	add    $0x10,%esp
	wake_up(&wait_for_request);
   12ec1:	83 ec 0c             	sub    $0xc,%esp
   12ec4:	68 80 3c 02 00       	push   $0x23c80
   12ec9:	e8 ab 40 ff ff       	call   6f79 <wake_up>
   12ece:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   12ed1:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12ed6:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   12edc:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12ee1:	8b 40 20             	mov    0x20(%eax),%eax
   12ee4:	a3 b4 3c 02 00       	mov    %eax,0x23cb4
}
   12ee9:	90                   	nop
   12eea:	83 c4 0c             	add    $0xc,%esp
   12eed:	c3                   	ret    

00012eee <floppy_deselect>:
static unsigned char command = 0;
unsigned char selected = 0;
struct task_struct * wait_on_floppy_select = NULL;

void floppy_deselect(unsigned int nr)
{
   12eee:	83 ec 0c             	sub    $0xc,%esp
	if (nr != (current_DOR & 3))
   12ef1:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
   12ef8:	0f b6 c0             	movzbl %al,%eax
   12efb:	83 e0 03             	and    $0x3,%eax
   12efe:	3b 44 24 10          	cmp    0x10(%esp),%eax
   12f02:	74 10                	je     12f14 <floppy_deselect+0x26>
		printk("floppy_deselect: drive not selected\n\r");
   12f04:	83 ec 0c             	sub    $0xc,%esp
   12f07:	68 8c 8d 01 00       	push   $0x18d8c
   12f0c:	e8 fc 58 ff ff       	call   880d <printk>
   12f11:	83 c4 10             	add    $0x10,%esp
	selected = 0;
   12f14:	c6 05 dc 3c 02 00 00 	movb   $0x0,0x23cdc
	wake_up(&wait_on_floppy_select);
   12f1b:	83 ec 0c             	sub    $0xc,%esp
   12f1e:	68 e0 3c 02 00       	push   $0x23ce0
   12f23:	e8 51 40 ff ff       	call   6f79 <wake_up>
   12f28:	83 c4 10             	add    $0x10,%esp
}
   12f2b:	90                   	nop
   12f2c:	83 c4 0c             	add    $0xc,%esp
   12f2f:	c3                   	ret    

00012f30 <floppy_change>:
 * here, sleep etc. Note that floppy-on tries to set current_DOR to point
 * to the desired drive, but it will probably not survive the sleep if
 * several floppies are used at the same time: thus the loop.
 */
int floppy_change(unsigned int nr)
{
   12f30:	83 ec 1c             	sub    $0x1c,%esp
repeat:
	floppy_on(nr);
   12f33:	83 ec 0c             	sub    $0xc,%esp
   12f36:	ff 74 24 2c          	pushl  0x2c(%esp)
   12f3a:	e8 3c 41 ff ff       	call   707b <floppy_on>
   12f3f:	83 c4 10             	add    $0x10,%esp
	while ((current_DOR & 3) != nr && selected)
   12f42:	eb 10                	jmp    12f54 <floppy_change+0x24>
		interruptible_sleep_on(&wait_on_floppy_select);
   12f44:	83 ec 0c             	sub    $0xc,%esp
   12f47:	68 e0 3c 02 00       	push   $0x23ce0
   12f4c:	e8 8f 3f ff ff       	call   6ee0 <interruptible_sleep_on>
   12f51:	83 c4 10             	add    $0x10,%esp
 */
int floppy_change(unsigned int nr)
{
repeat:
	floppy_on(nr);
	while ((current_DOR & 3) != nr && selected)
   12f54:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
   12f5b:	0f b6 c0             	movzbl %al,%eax
   12f5e:	83 e0 03             	and    $0x3,%eax
   12f61:	3b 44 24 20          	cmp    0x20(%esp),%eax
   12f65:	74 0b                	je     12f72 <floppy_change+0x42>
   12f67:	0f b6 05 dc 3c 02 00 	movzbl 0x23cdc,%eax
   12f6e:	84 c0                	test   %al,%al
   12f70:	75 d2                	jne    12f44 <floppy_change+0x14>
		interruptible_sleep_on(&wait_on_floppy_select);
	if ((current_DOR & 3) != nr)
   12f72:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
   12f79:	0f b6 c0             	movzbl %al,%eax
   12f7c:	83 e0 03             	and    $0x3,%eax
   12f7f:	3b 44 24 20          	cmp    0x20(%esp),%eax
   12f83:	74 02                	je     12f87 <floppy_change+0x57>
		goto repeat;
   12f85:	eb ac                	jmp    12f33 <floppy_change+0x3>
	if (inb(FD_DIR) & 0x80) {
   12f87:	b8 f7 03 00 00       	mov    $0x3f7,%eax
   12f8c:	89 c2                	mov    %eax,%edx
   12f8e:	ec                   	in     (%dx),%al
   12f8f:	88 44 24 0f          	mov    %al,0xf(%esp)
   12f93:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   12f98:	84 c0                	test   %al,%al
   12f9a:	79 16                	jns    12fb2 <floppy_change+0x82>
		floppy_off(nr);
   12f9c:	83 ec 0c             	sub    $0xc,%esp
   12f9f:	ff 74 24 2c          	pushl  0x2c(%esp)
   12fa3:	e8 0a 41 ff ff       	call   70b2 <floppy_off>
   12fa8:	83 c4 10             	add    $0x10,%esp
		return 1;
   12fab:	b8 01 00 00 00       	mov    $0x1,%eax
   12fb0:	eb 14                	jmp    12fc6 <floppy_change+0x96>
	}
	floppy_off(nr);
   12fb2:	83 ec 0c             	sub    $0xc,%esp
   12fb5:	ff 74 24 2c          	pushl  0x2c(%esp)
   12fb9:	e8 f4 40 ff ff       	call   70b2 <floppy_off>
   12fbe:	83 c4 10             	add    $0x10,%esp
	return 0;
   12fc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12fc6:	83 c4 1c             	add    $0x1c,%esp
   12fc9:	c3                   	ret    

00012fca <setup_DMA>:
__asm__("cld ; rep ; movsl" \
	::"c" (BLOCK_SIZE/4),"S" ((long)(from)),"D" ((long)(to)) \
	)

static void setup_DMA(void)
{
   12fca:	57                   	push   %edi
   12fcb:	56                   	push   %esi
   12fcc:	53                   	push   %ebx
   12fcd:	83 ec 10             	sub    $0x10,%esp
	long addr = (long) CURRENT->buffer;
   12fd0:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12fd5:	8b 40 14             	mov    0x14(%eax),%eax
   12fd8:	89 44 24 0c          	mov    %eax,0xc(%esp)

	cli();
   12fdc:	fa                   	cli    
	if (addr >= 0x100000) {
   12fdd:	81 7c 24 0c ff ff 0f 	cmpl   $0xfffff,0xc(%esp)
   12fe4:	00 
   12fe5:	7e 30                	jle    13017 <setup_DMA+0x4d>
		addr = (long) tmp_floppy_area;
   12fe7:	c7 44 24 0c 00 50 00 	movl   $0x5000,0xc(%esp)
   12fee:	00 
		if (command == FD_WRITE)
   12fef:	0f b6 05 fc 3c 02 00 	movzbl 0x23cfc,%eax
   12ff6:	3c c5                	cmp    $0xc5,%al
   12ff8:	75 1d                	jne    13017 <setup_DMA+0x4d>
			copy_buffer(CURRENT->buffer,tmp_floppy_area);
   12ffa:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   12fff:	8b 40 14             	mov    0x14(%eax),%eax
   13002:	89 c2                	mov    %eax,%edx
   13004:	bb 00 50 00 00       	mov    $0x5000,%ebx
   13009:	b8 00 01 00 00       	mov    $0x100,%eax
   1300e:	89 c1                	mov    %eax,%ecx
   13010:	89 d6                	mov    %edx,%esi
   13012:	89 df                	mov    %ebx,%edi
   13014:	fc                   	cld    
   13015:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	}
/* mask DMA 2 */
	immoutb_p(4|2,10);
   13017:	b8 06 00 00 00       	mov    $0x6,%eax
   1301c:	e6 0a                	out    %al,$0xa
   1301e:	eb 00                	jmp    13020 <setup_DMA+0x56>
   13020:	eb 00                	jmp    13022 <setup_DMA+0x58>
/* output command byte. I don't know why, but everyone (minix, */
/* sanches & canton) output this twice, first to 12 then to 11 */
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
	"outb %%al,$11\n\tjmp 1f\n1:\tjmp 1f\n1:"::
	"a" ((char) ((command == FD_READ)?DMA_READ:DMA_WRITE)));
   13022:	0f b6 05 fc 3c 02 00 	movzbl 0x23cfc,%eax
   13029:	3c e6                	cmp    $0xe6,%al
   1302b:	75 07                	jne    13034 <setup_DMA+0x6a>
   1302d:	b8 46 00 00 00       	mov    $0x46,%eax
   13032:	eb 05                	jmp    13039 <setup_DMA+0x6f>
   13034:	b8 4a 00 00 00       	mov    $0x4a,%eax
	}
/* mask DMA 2 */
	immoutb_p(4|2,10);
/* output command byte. I don't know why, but everyone (minix, */
/* sanches & canton) output this twice, first to 12 then to 11 */
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   13039:	e6 0c                	out    %al,$0xc
   1303b:	eb 00                	jmp    1303d <setup_DMA+0x73>
   1303d:	eb 00                	jmp    1303f <setup_DMA+0x75>
   1303f:	e6 0b                	out    %al,$0xb
   13041:	eb 00                	jmp    13043 <setup_DMA+0x79>
   13043:	eb 00                	jmp    13045 <setup_DMA+0x7b>
	"outb %%al,$11\n\tjmp 1f\n1:\tjmp 1f\n1:"::
	"a" ((char) ((command == FD_READ)?DMA_READ:DMA_WRITE)));
/* 8 low bits of addr */
	immoutb_p(addr,4);
   13045:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13049:	e6 04                	out    %al,$0x4
   1304b:	eb 00                	jmp    1304d <setup_DMA+0x83>
   1304d:	eb 00                	jmp    1304f <setup_DMA+0x85>
	addr >>= 8;
   1304f:	c1 7c 24 0c 08       	sarl   $0x8,0xc(%esp)
/* bits 8-15 of addr */
	immoutb_p(addr,4);
   13054:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13058:	e6 04                	out    %al,$0x4
   1305a:	eb 00                	jmp    1305c <setup_DMA+0x92>
   1305c:	eb 00                	jmp    1305e <setup_DMA+0x94>
	addr >>= 8;
   1305e:	c1 7c 24 0c 08       	sarl   $0x8,0xc(%esp)
/* bits 16-19 of addr */
	immoutb_p(addr,0x81);
   13063:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13067:	e6 81                	out    %al,$0x81
   13069:	eb 00                	jmp    1306b <setup_DMA+0xa1>
   1306b:	eb 00                	jmp    1306d <setup_DMA+0xa3>
/* low 8 bits of count-1 (1024-1=0x3ff) */
	immoutb_p(0xff,5);
   1306d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13072:	e6 05                	out    %al,$0x5
   13074:	eb 00                	jmp    13076 <setup_DMA+0xac>
   13076:	eb 00                	jmp    13078 <setup_DMA+0xae>
/* high 8 bits of count-1 */
	immoutb_p(3,5);
   13078:	b8 03 00 00 00       	mov    $0x3,%eax
   1307d:	e6 05                	out    %al,$0x5
   1307f:	eb 00                	jmp    13081 <setup_DMA+0xb7>
   13081:	eb 00                	jmp    13083 <setup_DMA+0xb9>
/* activate DMA 2 */
	immoutb_p(0|2,10);
   13083:	b8 02 00 00 00       	mov    $0x2,%eax
   13088:	e6 0a                	out    %al,$0xa
   1308a:	eb 00                	jmp    1308c <setup_DMA+0xc2>
   1308c:	eb 00                	jmp    1308e <setup_DMA+0xc4>
	sti();
   1308e:	fb                   	sti    
}
   1308f:	90                   	nop
   13090:	83 c4 10             	add    $0x10,%esp
   13093:	5b                   	pop    %ebx
   13094:	5e                   	pop    %esi
   13095:	5f                   	pop    %edi
   13096:	c3                   	ret    

00013097 <output_byte>:

static void output_byte(char byte)
{
   13097:	83 ec 2c             	sub    $0x2c,%esp
   1309a:	8b 44 24 30          	mov    0x30(%esp),%eax
   1309e:	88 44 24 0c          	mov    %al,0xc(%esp)
	int counter;
	unsigned char status;

	if (reset)
   130a2:	a1 e8 3c 02 00       	mov    0x23ce8,%eax
   130a7:	85 c0                	test   %eax,%eax
   130a9:	75 65                	jne    13110 <output_byte+0x79>
		return;
	for(counter = 0 ; counter < 10000 ; counter++) {
   130ab:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   130b2:	00 
   130b3:	eb 35                	jmp    130ea <output_byte+0x53>
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   130b5:	b8 f4 03 00 00       	mov    $0x3f4,%eax
   130ba:	89 c2                	mov    %eax,%edx
   130bc:	ec                   	in     (%dx),%al
   130bd:	eb 00                	jmp    130bf <output_byte+0x28>
   130bf:	eb 00                	jmp    130c1 <output_byte+0x2a>
   130c1:	88 44 24 1b          	mov    %al,0x1b(%esp)
   130c5:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
   130ca:	83 e0 c0             	and    $0xffffffc0,%eax
   130cd:	88 44 24 1a          	mov    %al,0x1a(%esp)
		if (status == STATUS_READY) {
   130d1:	80 7c 24 1a 80       	cmpb   $0x80,0x1a(%esp)
   130d6:	75 0d                	jne    130e5 <output_byte+0x4e>
			outb(byte,FD_DATA);
   130d8:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
   130dd:	ba f5 03 00 00       	mov    $0x3f5,%edx
   130e2:	ee                   	out    %al,(%dx)
			return;
   130e3:	eb 2c                	jmp    13111 <output_byte+0x7a>
	int counter;
	unsigned char status;

	if (reset)
		return;
	for(counter = 0 ; counter < 10000 ; counter++) {
   130e5:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   130ea:	81 7c 24 1c 0f 27 00 	cmpl   $0x270f,0x1c(%esp)
   130f1:	00 
   130f2:	7e c1                	jle    130b5 <output_byte+0x1e>
		if (status == STATUS_READY) {
			outb(byte,FD_DATA);
			return;
		}
	}
	reset = 1;
   130f4:	c7 05 e8 3c 02 00 01 	movl   $0x1,0x23ce8
   130fb:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   130fe:	83 ec 0c             	sub    $0xc,%esp
   13101:	68 b2 8d 01 00       	push   $0x18db2
   13106:	e8 02 57 ff ff       	call   880d <printk>
   1310b:	83 c4 10             	add    $0x10,%esp
   1310e:	eb 01                	jmp    13111 <output_byte+0x7a>
{
	int counter;
	unsigned char status;

	if (reset)
		return;
   13110:	90                   	nop
			return;
		}
	}
	reset = 1;
	printk("Unable to send byte to FDC\n\r");
}
   13111:	83 c4 2c             	add    $0x2c,%esp
   13114:	c3                   	ret    

00013115 <result>:

static int result(void)
{
   13115:	83 ec 2c             	sub    $0x2c,%esp
	int i = 0, counter, status;
   13118:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   1311f:	00 

	if (reset)
   13120:	a1 e8 3c 02 00       	mov    0x23ce8,%eax
   13125:	85 c0                	test   %eax,%eax
   13127:	74 0a                	je     13133 <result+0x1e>
		return -1;
   13129:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1312e:	e9 a3 00 00 00       	jmp    131d6 <result+0xc1>
	for (counter = 0 ; counter < 10000 ; counter++) {
   13133:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   1313a:	00 
   1313b:	eb 6d                	jmp    131aa <result+0x95>
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   1313d:	b8 f4 03 00 00       	mov    $0x3f4,%eax
   13142:	89 c2                	mov    %eax,%edx
   13144:	ec                   	in     (%dx),%al
   13145:	eb 00                	jmp    13147 <result+0x32>
   13147:	eb 00                	jmp    13149 <result+0x34>
   13149:	88 44 24 17          	mov    %al,0x17(%esp)
   1314d:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
   13152:	0f b6 c0             	movzbl %al,%eax
   13155:	25 d0 00 00 00       	and    $0xd0,%eax
   1315a:	89 44 24 10          	mov    %eax,0x10(%esp)
		if (status == STATUS_READY)
   1315e:	81 7c 24 10 80 00 00 	cmpl   $0x80,0x10(%esp)
   13165:	00 
   13166:	75 06                	jne    1316e <result+0x59>
			return i;
   13168:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1316c:	eb 68                	jmp    131d6 <result+0xc1>
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
   1316e:	81 7c 24 10 d0 00 00 	cmpl   $0xd0,0x10(%esp)
   13175:	00 
   13176:	75 2d                	jne    131a5 <result+0x90>
			if (i >= MAX_REPLIES)
   13178:	83 7c 24 1c 06       	cmpl   $0x6,0x1c(%esp)
   1317d:	7f 37                	jg     131b6 <result+0xa1>
				break;
			reply_buffer[i++] = inb_p(FD_DATA);
   1317f:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   13183:	8d 41 01             	lea    0x1(%ecx),%eax
   13186:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1318a:	b8 f5 03 00 00       	mov    $0x3f5,%eax
   1318f:	89 c2                	mov    %eax,%edx
   13191:	ec                   	in     (%dx),%al
   13192:	eb 00                	jmp    13194 <result+0x7f>
   13194:	eb 00                	jmp    13196 <result+0x81>
   13196:	88 44 24 0f          	mov    %al,0xf(%esp)
   1319a:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1319f:	88 81 f0 3c 02 00    	mov    %al,0x23cf0(%ecx)
{
	int i = 0, counter, status;

	if (reset)
		return -1;
	for (counter = 0 ; counter < 10000 ; counter++) {
   131a5:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   131aa:	81 7c 24 18 0f 27 00 	cmpl   $0x270f,0x18(%esp)
   131b1:	00 
   131b2:	7e 89                	jle    1313d <result+0x28>
   131b4:	eb 01                	jmp    131b7 <result+0xa2>
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
		if (status == STATUS_READY)
			return i;
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
			if (i >= MAX_REPLIES)
				break;
   131b6:	90                   	nop
			reply_buffer[i++] = inb_p(FD_DATA);
		}
	}
	reset = 1;
   131b7:	c7 05 e8 3c 02 00 01 	movl   $0x1,0x23ce8
   131be:	00 00 00 
	printk("Getstatus times out\n\r");
   131c1:	83 ec 0c             	sub    $0xc,%esp
   131c4:	68 cf 8d 01 00       	push   $0x18dcf
   131c9:	e8 3f 56 ff ff       	call   880d <printk>
   131ce:	83 c4 10             	add    $0x10,%esp
	return -1;
   131d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   131d6:	83 c4 2c             	add    $0x2c,%esp
   131d9:	c3                   	ret    

000131da <bad_flp_intr>:

static void bad_flp_intr(void)
{
   131da:	83 ec 0c             	sub    $0xc,%esp
	CURRENT->errors++;
   131dd:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   131e2:	8b 50 08             	mov    0x8(%eax),%edx
   131e5:	83 c2 01             	add    $0x1,%edx
   131e8:	89 50 08             	mov    %edx,0x8(%eax)
	if (CURRENT->errors > MAX_ERRORS) {
   131eb:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   131f0:	8b 40 08             	mov    0x8(%eax),%eax
   131f3:	83 f8 08             	cmp    $0x8,%eax
   131f6:	7e 23                	jle    1321b <bad_flp_intr+0x41>
		floppy_deselect(current_drive);
   131f8:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   131ff:	0f b6 c0             	movzbl %al,%eax
   13202:	83 ec 0c             	sub    $0xc,%esp
   13205:	50                   	push   %eax
   13206:	e8 e3 fc ff ff       	call   12eee <floppy_deselect>
   1320b:	83 c4 10             	add    $0x10,%esp
		end_request(0);
   1320e:	83 ec 0c             	sub    $0xc,%esp
   13211:	6a 00                	push   $0x0
   13213:	e8 12 fc ff ff       	call   12e2a <end_request>
   13218:	83 c4 10             	add    $0x10,%esp
	}
	if (CURRENT->errors > MAX_ERRORS/2)
   1321b:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   13220:	8b 40 08             	mov    0x8(%eax),%eax
   13223:	83 f8 04             	cmp    $0x4,%eax
   13226:	7e 0c                	jle    13234 <bad_flp_intr+0x5a>
		reset = 1;
   13228:	c7 05 e8 3c 02 00 01 	movl   $0x1,0x23ce8
   1322f:	00 00 00 
	else
		recalibrate = 1;
}	
   13232:	eb 0a                	jmp    1323e <bad_flp_intr+0x64>
		end_request(0);
	}
	if (CURRENT->errors > MAX_ERRORS/2)
		reset = 1;
	else
		recalibrate = 1;
   13234:	c7 05 e4 3c 02 00 01 	movl   $0x1,0x23ce4
   1323b:	00 00 00 
}	
   1323e:	90                   	nop
   1323f:	83 c4 0c             	add    $0xc,%esp
   13242:	c3                   	ret    

00013243 <rw_interrupt>:
/*
 * Ok, this interrupt is called after a DMA read/write has succeeded,
 * so we check the results, and copy any buffers.
 */
static void rw_interrupt(void)
{
   13243:	57                   	push   %edi
   13244:	56                   	push   %esi
   13245:	53                   	push   %ebx
	if (result() != 7 || (ST0 & 0xf8) || (ST1 & 0xbf) || (ST2 & 0x73)) {
   13246:	e8 ca fe ff ff       	call   13115 <result>
   1324b:	83 f8 07             	cmp    $0x7,%eax
   1324e:	75 37                	jne    13287 <rw_interrupt+0x44>
   13250:	0f b6 05 f0 3c 02 00 	movzbl 0x23cf0,%eax
   13257:	0f b6 c0             	movzbl %al,%eax
   1325a:	25 f8 00 00 00       	and    $0xf8,%eax
   1325f:	85 c0                	test   %eax,%eax
   13261:	75 24                	jne    13287 <rw_interrupt+0x44>
   13263:	0f b6 05 f1 3c 02 00 	movzbl 0x23cf1,%eax
   1326a:	0f b6 c0             	movzbl %al,%eax
   1326d:	25 bf 00 00 00       	and    $0xbf,%eax
   13272:	85 c0                	test   %eax,%eax
   13274:	75 11                	jne    13287 <rw_interrupt+0x44>
   13276:	0f b6 05 f2 3c 02 00 	movzbl 0x23cf2,%eax
   1327d:	0f b6 c0             	movzbl %al,%eax
   13280:	83 e0 73             	and    $0x73,%eax
   13283:	85 c0                	test   %eax,%eax
   13285:	74 5d                	je     132e4 <rw_interrupt+0xa1>
		if (ST1 & 0x02) {
   13287:	0f b6 05 f1 3c 02 00 	movzbl 0x23cf1,%eax
   1328e:	0f b6 c0             	movzbl %al,%eax
   13291:	83 e0 02             	and    $0x2,%eax
   13294:	85 c0                	test   %eax,%eax
   13296:	74 40                	je     132d8 <rw_interrupt+0x95>
			printk("Drive %d is write protected\n\r",current_drive);
   13298:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   1329f:	0f b6 c0             	movzbl %al,%eax
   132a2:	83 ec 08             	sub    $0x8,%esp
   132a5:	50                   	push   %eax
   132a6:	68 e5 8d 01 00       	push   $0x18de5
   132ab:	e8 5d 55 ff ff       	call   880d <printk>
   132b0:	83 c4 10             	add    $0x10,%esp
			floppy_deselect(current_drive);
   132b3:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   132ba:	0f b6 c0             	movzbl %al,%eax
   132bd:	83 ec 0c             	sub    $0xc,%esp
   132c0:	50                   	push   %eax
   132c1:	e8 28 fc ff ff       	call   12eee <floppy_deselect>
   132c6:	83 c4 10             	add    $0x10,%esp
			end_request(0);
   132c9:	83 ec 0c             	sub    $0xc,%esp
   132cc:	6a 00                	push   $0x0
   132ce:	e8 57 fb ff ff       	call   12e2a <end_request>
   132d3:	83 c4 10             	add    $0x10,%esp
   132d6:	eb 05                	jmp    132dd <rw_interrupt+0x9a>
		} else
			bad_flp_intr();
   132d8:	e8 fd fe ff ff       	call   131da <bad_flp_intr>
		do_fd_request();
   132dd:	e8 5f 05 00 00       	call   13841 <do_fd_request>
		return;
   132e2:	eb 5f                	jmp    13343 <rw_interrupt+0x100>
	}
	if (command == FD_READ && (unsigned long)(CURRENT->buffer) >= 0x100000)
   132e4:	0f b6 05 fc 3c 02 00 	movzbl 0x23cfc,%eax
   132eb:	3c e6                	cmp    $0xe6,%al
   132ed:	75 2c                	jne    1331b <rw_interrupt+0xd8>
   132ef:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   132f4:	8b 40 14             	mov    0x14(%eax),%eax
   132f7:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
   132fc:	76 1d                	jbe    1331b <rw_interrupt+0xd8>
		copy_buffer(tmp_floppy_area,CURRENT->buffer);
   132fe:	ba 00 50 00 00       	mov    $0x5000,%edx
   13303:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   13308:	8b 40 14             	mov    0x14(%eax),%eax
   1330b:	89 c3                	mov    %eax,%ebx
   1330d:	b8 00 01 00 00       	mov    $0x100,%eax
   13312:	89 c1                	mov    %eax,%ecx
   13314:	89 d6                	mov    %edx,%esi
   13316:	89 df                	mov    %ebx,%edi
   13318:	fc                   	cld    
   13319:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	floppy_deselect(current_drive);
   1331b:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   13322:	0f b6 c0             	movzbl %al,%eax
   13325:	83 ec 0c             	sub    $0xc,%esp
   13328:	50                   	push   %eax
   13329:	e8 c0 fb ff ff       	call   12eee <floppy_deselect>
   1332e:	83 c4 10             	add    $0x10,%esp
	end_request(1);
   13331:	83 ec 0c             	sub    $0xc,%esp
   13334:	6a 01                	push   $0x1
   13336:	e8 ef fa ff ff       	call   12e2a <end_request>
   1333b:	83 c4 10             	add    $0x10,%esp
	do_fd_request();
   1333e:	e8 fe 04 00 00       	call   13841 <do_fd_request>
}
   13343:	5b                   	pop    %ebx
   13344:	5e                   	pop    %esi
   13345:	5f                   	pop    %edi
   13346:	c3                   	ret    

00013347 <setup_rw_floppy>:

static inline void setup_rw_floppy(void)
{
   13347:	83 ec 0c             	sub    $0xc,%esp
	setup_DMA();
   1334a:	e8 7b fc ff ff       	call   12fca <setup_DMA>
	do_floppy = rw_interrupt;
   1334f:	c7 05 d8 3c 02 00 43 	movl   $0x13243,0x23cd8
   13356:	32 01 00 
	output_byte(command);
   13359:	0f b6 05 fc 3c 02 00 	movzbl 0x23cfc,%eax
   13360:	0f be c0             	movsbl %al,%eax
   13363:	83 ec 0c             	sub    $0xc,%esp
   13366:	50                   	push   %eax
   13367:	e8 2b fd ff ff       	call   13097 <output_byte>
   1336c:	83 c4 10             	add    $0x10,%esp
	output_byte(head<<2 | current_drive);
   1336f:	0f b6 05 f9 3c 02 00 	movzbl 0x23cf9,%eax
   13376:	0f b6 c0             	movzbl %al,%eax
   13379:	c1 e0 02             	shl    $0x2,%eax
   1337c:	89 c2                	mov    %eax,%edx
   1337e:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   13385:	09 d0                	or     %edx,%eax
   13387:	0f be c0             	movsbl %al,%eax
   1338a:	83 ec 0c             	sub    $0xc,%esp
   1338d:	50                   	push   %eax
   1338e:	e8 04 fd ff ff       	call   13097 <output_byte>
   13393:	83 c4 10             	add    $0x10,%esp
	output_byte(track);
   13396:	0f b6 05 fa 3c 02 00 	movzbl 0x23cfa,%eax
   1339d:	0f be c0             	movsbl %al,%eax
   133a0:	83 ec 0c             	sub    $0xc,%esp
   133a3:	50                   	push   %eax
   133a4:	e8 ee fc ff ff       	call   13097 <output_byte>
   133a9:	83 c4 10             	add    $0x10,%esp
	output_byte(head);
   133ac:	0f b6 05 f9 3c 02 00 	movzbl 0x23cf9,%eax
   133b3:	0f be c0             	movsbl %al,%eax
   133b6:	83 ec 0c             	sub    $0xc,%esp
   133b9:	50                   	push   %eax
   133ba:	e8 d8 fc ff ff       	call   13097 <output_byte>
   133bf:	83 c4 10             	add    $0x10,%esp
	output_byte(sector);
   133c2:	0f b6 05 f8 3c 02 00 	movzbl 0x23cf8,%eax
   133c9:	0f be c0             	movsbl %al,%eax
   133cc:	83 ec 0c             	sub    $0xc,%esp
   133cf:	50                   	push   %eax
   133d0:	e8 c2 fc ff ff       	call   13097 <output_byte>
   133d5:	83 c4 10             	add    $0x10,%esp
	output_byte(2);		/* sector size = 512 */
   133d8:	83 ec 0c             	sub    $0xc,%esp
   133db:	6a 02                	push   $0x2
   133dd:	e8 b5 fc ff ff       	call   13097 <output_byte>
   133e2:	83 c4 10             	add    $0x10,%esp
	output_byte(floppy->sect);
   133e5:	a1 28 f4 01 00       	mov    0x1f428,%eax
   133ea:	8b 40 04             	mov    0x4(%eax),%eax
   133ed:	0f be c0             	movsbl %al,%eax
   133f0:	83 ec 0c             	sub    $0xc,%esp
   133f3:	50                   	push   %eax
   133f4:	e8 9e fc ff ff       	call   13097 <output_byte>
   133f9:	83 c4 10             	add    $0x10,%esp
	output_byte(floppy->gap);
   133fc:	a1 28 f4 01 00       	mov    0x1f428,%eax
   13401:	0f b6 40 14          	movzbl 0x14(%eax),%eax
   13405:	0f be c0             	movsbl %al,%eax
   13408:	83 ec 0c             	sub    $0xc,%esp
   1340b:	50                   	push   %eax
   1340c:	e8 86 fc ff ff       	call   13097 <output_byte>
   13411:	83 c4 10             	add    $0x10,%esp
	output_byte(0xFF);	/* sector size (0xff when n!=0 ?) */
   13414:	83 ec 0c             	sub    $0xc,%esp
   13417:	6a ff                	push   $0xffffffff
   13419:	e8 79 fc ff ff       	call   13097 <output_byte>
   1341e:	83 c4 10             	add    $0x10,%esp
	if (reset)
   13421:	a1 e8 3c 02 00       	mov    0x23ce8,%eax
   13426:	85 c0                	test   %eax,%eax
   13428:	74 05                	je     1342f <setup_rw_floppy+0xe8>
		do_fd_request();
   1342a:	e8 12 04 00 00       	call   13841 <do_fd_request>
}
   1342f:	90                   	nop
   13430:	83 c4 0c             	add    $0xc,%esp
   13433:	c3                   	ret    

00013434 <seek_interrupt>:
 * This is the routine called after every seek (or recalibrate) interrupt
 * from the floppy controller. Note that the "unexpected interrupt" routine
 * also does a recalibrate, but doesn't come here.
 */
static void seek_interrupt(void)
{
   13434:	83 ec 0c             	sub    $0xc,%esp
/* sense drive status */
	output_byte(FD_SENSEI);
   13437:	83 ec 0c             	sub    $0xc,%esp
   1343a:	6a 08                	push   $0x8
   1343c:	e8 56 fc ff ff       	call   13097 <output_byte>
   13441:	83 c4 10             	add    $0x10,%esp
	if (result() != 2 || (ST0 & 0xF8) != 0x20 || ST1 != seek_track) {
   13444:	e8 cc fc ff ff       	call   13115 <result>
   13449:	83 f8 02             	cmp    $0x2,%eax
   1344c:	75 26                	jne    13474 <seek_interrupt+0x40>
   1344e:	0f b6 05 f0 3c 02 00 	movzbl 0x23cf0,%eax
   13455:	0f b6 c0             	movzbl %al,%eax
   13458:	25 f8 00 00 00       	and    $0xf8,%eax
   1345d:	83 f8 20             	cmp    $0x20,%eax
   13460:	75 12                	jne    13474 <seek_interrupt+0x40>
   13462:	0f b6 15 f1 3c 02 00 	movzbl 0x23cf1,%edx
   13469:	0f b6 05 fb 3c 02 00 	movzbl 0x23cfb,%eax
   13470:	38 c2                	cmp    %al,%dl
   13472:	74 0c                	je     13480 <seek_interrupt+0x4c>
		bad_flp_intr();
   13474:	e8 61 fd ff ff       	call   131da <bad_flp_intr>
		do_fd_request();
   13479:	e8 c3 03 00 00       	call   13841 <do_fd_request>
		return;
   1347e:	eb 11                	jmp    13491 <seek_interrupt+0x5d>
	}
	current_track = ST1;
   13480:	0f b6 05 f1 3c 02 00 	movzbl 0x23cf1,%eax
   13487:	a2 2c f4 01 00       	mov    %al,0x1f42c
	setup_rw_floppy();
   1348c:	e8 b6 fe ff ff       	call   13347 <setup_rw_floppy>
}
   13491:	83 c4 0c             	add    $0xc,%esp
   13494:	c3                   	ret    

00013495 <transfer>:
 * This routine is called when everything should be correctly set up
 * for the transfer (ie floppy motor is on and the correct floppy is
 * selected).
 */
static void transfer(void)
{
   13495:	83 ec 0c             	sub    $0xc,%esp
	if (cur_spec1 != floppy->spec1) {
   13498:	a1 28 f4 01 00       	mov    0x1f428,%eax
   1349d:	0f b6 40 16          	movzbl 0x16(%eax),%eax
   134a1:	0f b6 d0             	movzbl %al,%edx
   134a4:	a1 20 f4 01 00       	mov    0x1f420,%eax
   134a9:	39 c2                	cmp    %eax,%edx
   134ab:	74 3f                	je     134ec <transfer+0x57>
		cur_spec1 = floppy->spec1;
   134ad:	a1 28 f4 01 00       	mov    0x1f428,%eax
   134b2:	0f b6 40 16          	movzbl 0x16(%eax),%eax
   134b6:	0f b6 c0             	movzbl %al,%eax
   134b9:	a3 20 f4 01 00       	mov    %eax,0x1f420
		output_byte(FD_SPECIFY);
   134be:	83 ec 0c             	sub    $0xc,%esp
   134c1:	6a 03                	push   $0x3
   134c3:	e8 cf fb ff ff       	call   13097 <output_byte>
   134c8:	83 c4 10             	add    $0x10,%esp
		output_byte(cur_spec1);		/* hut etc */
   134cb:	a1 20 f4 01 00       	mov    0x1f420,%eax
   134d0:	0f be c0             	movsbl %al,%eax
   134d3:	83 ec 0c             	sub    $0xc,%esp
   134d6:	50                   	push   %eax
   134d7:	e8 bb fb ff ff       	call   13097 <output_byte>
   134dc:	83 c4 10             	add    $0x10,%esp
		output_byte(6);			/* Head load time =6ms, DMA */
   134df:	83 ec 0c             	sub    $0xc,%esp
   134e2:	6a 06                	push   $0x6
   134e4:	e8 ae fb ff ff       	call   13097 <output_byte>
   134e9:	83 c4 10             	add    $0x10,%esp
	}
	if (cur_rate != floppy->rate)
   134ec:	a1 28 f4 01 00       	mov    0x1f428,%eax
   134f1:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   134f5:	0f b6 d0             	movzbl %al,%edx
   134f8:	a1 24 f4 01 00       	mov    0x1f424,%eax
   134fd:	39 c2                	cmp    %eax,%edx
   134ff:	74 20                	je     13521 <transfer+0x8c>
		outb_p(cur_rate = floppy->rate,FD_DCR);
   13501:	a1 28 f4 01 00       	mov    0x1f428,%eax
   13506:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1350a:	0f b6 c0             	movzbl %al,%eax
   1350d:	a3 24 f4 01 00       	mov    %eax,0x1f424
   13512:	a1 24 f4 01 00       	mov    0x1f424,%eax
   13517:	ba f7 03 00 00       	mov    $0x3f7,%edx
   1351c:	ee                   	out    %al,(%dx)
   1351d:	eb 00                	jmp    1351f <transfer+0x8a>
   1351f:	eb 00                	jmp    13521 <transfer+0x8c>
	if (reset) {
   13521:	a1 e8 3c 02 00       	mov    0x23ce8,%eax
   13526:	85 c0                	test   %eax,%eax
   13528:	74 0a                	je     13534 <transfer+0x9f>
		do_fd_request();
   1352a:	e8 12 03 00 00       	call   13841 <do_fd_request>
		return;
   1352f:	e9 b6 00 00 00       	jmp    135ea <transfer+0x155>
	}
	if (!seek) {
   13534:	a1 ec 3c 02 00       	mov    0x23cec,%eax
   13539:	85 c0                	test   %eax,%eax
   1353b:	75 0a                	jne    13547 <transfer+0xb2>
		setup_rw_floppy();
   1353d:	e8 05 fe ff ff       	call   13347 <setup_rw_floppy>
		return;
   13542:	e9 a3 00 00 00       	jmp    135ea <transfer+0x155>
	}
	do_floppy = seek_interrupt;
   13547:	c7 05 d8 3c 02 00 34 	movl   $0x13434,0x23cd8
   1354e:	34 01 00 
	if (seek_track) {
   13551:	0f b6 05 fb 3c 02 00 	movzbl 0x23cfb,%eax
   13558:	84 c0                	test   %al,%al
   1355a:	74 4c                	je     135a8 <transfer+0x113>
		output_byte(FD_SEEK);
   1355c:	83 ec 0c             	sub    $0xc,%esp
   1355f:	6a 0f                	push   $0xf
   13561:	e8 31 fb ff ff       	call   13097 <output_byte>
   13566:	83 c4 10             	add    $0x10,%esp
		output_byte(head<<2 | current_drive);
   13569:	0f b6 05 f9 3c 02 00 	movzbl 0x23cf9,%eax
   13570:	0f b6 c0             	movzbl %al,%eax
   13573:	c1 e0 02             	shl    $0x2,%eax
   13576:	89 c2                	mov    %eax,%edx
   13578:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   1357f:	09 d0                	or     %edx,%eax
   13581:	0f be c0             	movsbl %al,%eax
   13584:	83 ec 0c             	sub    $0xc,%esp
   13587:	50                   	push   %eax
   13588:	e8 0a fb ff ff       	call   13097 <output_byte>
   1358d:	83 c4 10             	add    $0x10,%esp
		output_byte(seek_track);
   13590:	0f b6 05 fb 3c 02 00 	movzbl 0x23cfb,%eax
   13597:	0f be c0             	movsbl %al,%eax
   1359a:	83 ec 0c             	sub    $0xc,%esp
   1359d:	50                   	push   %eax
   1359e:	e8 f4 fa ff ff       	call   13097 <output_byte>
   135a3:	83 c4 10             	add    $0x10,%esp
   135a6:	eb 34                	jmp    135dc <transfer+0x147>
	} else {
		output_byte(FD_RECALIBRATE);
   135a8:	83 ec 0c             	sub    $0xc,%esp
   135ab:	6a 07                	push   $0x7
   135ad:	e8 e5 fa ff ff       	call   13097 <output_byte>
   135b2:	83 c4 10             	add    $0x10,%esp
		output_byte(head<<2 | current_drive);
   135b5:	0f b6 05 f9 3c 02 00 	movzbl 0x23cf9,%eax
   135bc:	0f b6 c0             	movzbl %al,%eax
   135bf:	c1 e0 02             	shl    $0x2,%eax
   135c2:	89 c2                	mov    %eax,%edx
   135c4:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   135cb:	09 d0                	or     %edx,%eax
   135cd:	0f be c0             	movsbl %al,%eax
   135d0:	83 ec 0c             	sub    $0xc,%esp
   135d3:	50                   	push   %eax
   135d4:	e8 be fa ff ff       	call   13097 <output_byte>
   135d9:	83 c4 10             	add    $0x10,%esp
	}
	if (reset)
   135dc:	a1 e8 3c 02 00       	mov    0x23ce8,%eax
   135e1:	85 c0                	test   %eax,%eax
   135e3:	74 05                	je     135ea <transfer+0x155>
		do_fd_request();
   135e5:	e8 57 02 00 00       	call   13841 <do_fd_request>
}
   135ea:	83 c4 0c             	add    $0xc,%esp
   135ed:	c3                   	ret    

000135ee <recal_interrupt>:

/*
 * Special case - used after a unexpected interrupt (or reset)
 */
static void recal_interrupt(void)
{
   135ee:	83 ec 0c             	sub    $0xc,%esp
	output_byte(FD_SENSEI);
   135f1:	83 ec 0c             	sub    $0xc,%esp
   135f4:	6a 08                	push   $0x8
   135f6:	e8 9c fa ff ff       	call   13097 <output_byte>
   135fb:	83 c4 10             	add    $0x10,%esp
	if (result()!=2 || (ST0 & 0xE0) == 0x60)
   135fe:	e8 12 fb ff ff       	call   13115 <result>
   13603:	83 f8 02             	cmp    $0x2,%eax
   13606:	75 14                	jne    1361c <recal_interrupt+0x2e>
   13608:	0f b6 05 f0 3c 02 00 	movzbl 0x23cf0,%eax
   1360f:	0f b6 c0             	movzbl %al,%eax
   13612:	25 e0 00 00 00       	and    $0xe0,%eax
   13617:	83 f8 60             	cmp    $0x60,%eax
   1361a:	75 0c                	jne    13628 <recal_interrupt+0x3a>
		reset = 1;
   1361c:	c7 05 e8 3c 02 00 01 	movl   $0x1,0x23ce8
   13623:	00 00 00 
   13626:	eb 0a                	jmp    13632 <recal_interrupt+0x44>
	else
		recalibrate = 0;
   13628:	c7 05 e4 3c 02 00 00 	movl   $0x0,0x23ce4
   1362f:	00 00 00 
	do_fd_request();
   13632:	e8 0a 02 00 00       	call   13841 <do_fd_request>
}
   13637:	90                   	nop
   13638:	83 c4 0c             	add    $0xc,%esp
   1363b:	c3                   	ret    

0001363c <unexpected_floppy_interrupt>:

void unexpected_floppy_interrupt(void)
{
   1363c:	83 ec 0c             	sub    $0xc,%esp
	output_byte(FD_SENSEI);
   1363f:	83 ec 0c             	sub    $0xc,%esp
   13642:	6a 08                	push   $0x8
   13644:	e8 4e fa ff ff       	call   13097 <output_byte>
   13649:	83 c4 10             	add    $0x10,%esp
	if (result()!=2 || (ST0 & 0xE0) == 0x60)
   1364c:	e8 c4 fa ff ff       	call   13115 <result>
   13651:	83 f8 02             	cmp    $0x2,%eax
   13654:	75 14                	jne    1366a <unexpected_floppy_interrupt+0x2e>
   13656:	0f b6 05 f0 3c 02 00 	movzbl 0x23cf0,%eax
   1365d:	0f b6 c0             	movzbl %al,%eax
   13660:	25 e0 00 00 00       	and    $0xe0,%eax
   13665:	83 f8 60             	cmp    $0x60,%eax
   13668:	75 0c                	jne    13676 <unexpected_floppy_interrupt+0x3a>
		reset = 1;
   1366a:	c7 05 e8 3c 02 00 01 	movl   $0x1,0x23ce8
   13671:	00 00 00 
   13674:	eb 0a                	jmp    13680 <unexpected_floppy_interrupt+0x44>
	else
		recalibrate = 1;
   13676:	c7 05 e4 3c 02 00 01 	movl   $0x1,0x23ce4
   1367d:	00 00 00 
}
   13680:	90                   	nop
   13681:	83 c4 0c             	add    $0xc,%esp
   13684:	c3                   	ret    

00013685 <recalibrate_floppy>:

static void recalibrate_floppy(void)
{
   13685:	83 ec 0c             	sub    $0xc,%esp
	recalibrate = 0;
   13688:	c7 05 e4 3c 02 00 00 	movl   $0x0,0x23ce4
   1368f:	00 00 00 
	current_track = 0;
   13692:	c6 05 2c f4 01 00 00 	movb   $0x0,0x1f42c
	do_floppy = recal_interrupt;
   13699:	c7 05 d8 3c 02 00 ee 	movl   $0x135ee,0x23cd8
   136a0:	35 01 00 
	output_byte(FD_RECALIBRATE);
   136a3:	83 ec 0c             	sub    $0xc,%esp
   136a6:	6a 07                	push   $0x7
   136a8:	e8 ea f9 ff ff       	call   13097 <output_byte>
   136ad:	83 c4 10             	add    $0x10,%esp
	current_drive = CURRENT_DEV;
   136b0:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   136b5:	8b 00                	mov    (%eax),%eax
   136b7:	83 e0 03             	and    $0x3,%eax
   136ba:	a2 f7 3c 02 00       	mov    %al,0x23cf7
	output_byte(head<<2 | current_drive);
   136bf:	0f b6 05 f9 3c 02 00 	movzbl 0x23cf9,%eax
   136c6:	0f b6 c0             	movzbl %al,%eax
   136c9:	c1 e0 02             	shl    $0x2,%eax
   136cc:	89 c2                	mov    %eax,%edx
   136ce:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   136d5:	09 d0                	or     %edx,%eax
   136d7:	0f be c0             	movsbl %al,%eax
   136da:	83 ec 0c             	sub    $0xc,%esp
   136dd:	50                   	push   %eax
   136de:	e8 b4 f9 ff ff       	call   13097 <output_byte>
   136e3:	83 c4 10             	add    $0x10,%esp
	if (reset)
   136e6:	a1 e8 3c 02 00       	mov    0x23ce8,%eax
   136eb:	85 c0                	test   %eax,%eax
   136ed:	74 05                	je     136f4 <recalibrate_floppy+0x6f>
		do_fd_request();
   136ef:	e8 4d 01 00 00       	call   13841 <do_fd_request>
}
   136f4:	90                   	nop
   136f5:	83 c4 0c             	add    $0xc,%esp
   136f8:	c3                   	ret    

000136f9 <reset_interrupt>:

static void reset_interrupt(void)
{
   136f9:	83 ec 0c             	sub    $0xc,%esp
	output_byte(FD_SENSEI);
   136fc:	83 ec 0c             	sub    $0xc,%esp
   136ff:	6a 08                	push   $0x8
   13701:	e8 91 f9 ff ff       	call   13097 <output_byte>
   13706:	83 c4 10             	add    $0x10,%esp
	(void) result();
   13709:	e8 07 fa ff ff       	call   13115 <result>
	output_byte(FD_SPECIFY);
   1370e:	83 ec 0c             	sub    $0xc,%esp
   13711:	6a 03                	push   $0x3
   13713:	e8 7f f9 ff ff       	call   13097 <output_byte>
   13718:	83 c4 10             	add    $0x10,%esp
	output_byte(cur_spec1);		/* hut etc */
   1371b:	a1 20 f4 01 00       	mov    0x1f420,%eax
   13720:	0f be c0             	movsbl %al,%eax
   13723:	83 ec 0c             	sub    $0xc,%esp
   13726:	50                   	push   %eax
   13727:	e8 6b f9 ff ff       	call   13097 <output_byte>
   1372c:	83 c4 10             	add    $0x10,%esp
	output_byte(6);			/* Head load time =6ms, DMA */
   1372f:	83 ec 0c             	sub    $0xc,%esp
   13732:	6a 06                	push   $0x6
   13734:	e8 5e f9 ff ff       	call   13097 <output_byte>
   13739:	83 c4 10             	add    $0x10,%esp
	do_fd_request();
   1373c:	e8 00 01 00 00       	call   13841 <do_fd_request>
}
   13741:	90                   	nop
   13742:	83 c4 0c             	add    $0xc,%esp
   13745:	c3                   	ret    

00013746 <reset_floppy>:

/*
 * reset is done by pulling bit 2 of DOR low for a while.
 */
static void reset_floppy(void)
{
   13746:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	reset = 0;
   13749:	c7 05 e8 3c 02 00 00 	movl   $0x0,0x23ce8
   13750:	00 00 00 
	cur_spec1 = -1;
   13753:	c7 05 20 f4 01 00 ff 	movl   $0xffffffff,0x1f420
   1375a:	ff ff ff 
	cur_rate = -1;
   1375d:	c7 05 24 f4 01 00 ff 	movl   $0xffffffff,0x1f424
   13764:	ff ff ff 
	recalibrate = 1;
   13767:	c7 05 e4 3c 02 00 01 	movl   $0x1,0x23ce4
   1376e:	00 00 00 
	printk("Reset-floppy called\n\r");
   13771:	83 ec 0c             	sub    $0xc,%esp
   13774:	68 03 8e 01 00       	push   $0x18e03
   13779:	e8 8f 50 ff ff       	call   880d <printk>
   1377e:	83 c4 10             	add    $0x10,%esp
	cli();
   13781:	fa                   	cli    
	do_floppy = reset_interrupt;
   13782:	c7 05 d8 3c 02 00 f9 	movl   $0x136f9,0x23cd8
   13789:	36 01 00 
	outb_p(current_DOR & ~0x04,FD_DOR);
   1378c:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
   13793:	0f b6 c0             	movzbl %al,%eax
   13796:	83 e0 fb             	and    $0xfffffffb,%eax
   13799:	ba f2 03 00 00       	mov    $0x3f2,%edx
   1379e:	ee                   	out    %al,(%dx)
   1379f:	eb 00                	jmp    137a1 <reset_floppy+0x5b>
   137a1:	eb 00                	jmp    137a3 <reset_floppy+0x5d>
	for (i=0 ; i<100 ; i++)
   137a3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   137aa:	00 
   137ab:	eb 06                	jmp    137b3 <reset_floppy+0x6d>
		__asm__("nop");
   137ad:	90                   	nop
	recalibrate = 1;
	printk("Reset-floppy called\n\r");
	cli();
	do_floppy = reset_interrupt;
	outb_p(current_DOR & ~0x04,FD_DOR);
	for (i=0 ; i<100 ; i++)
   137ae:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   137b3:	83 7c 24 0c 63       	cmpl   $0x63,0xc(%esp)
   137b8:	7e f3                	jle    137ad <reset_floppy+0x67>
		__asm__("nop");
	outb(current_DOR,FD_DOR);
   137ba:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
   137c1:	ba f2 03 00 00       	mov    $0x3f2,%edx
   137c6:	ee                   	out    %al,(%dx)
	sti();
   137c7:	fb                   	sti    
}
   137c8:	90                   	nop
   137c9:	83 c4 1c             	add    $0x1c,%esp
   137cc:	c3                   	ret    

000137cd <floppy_on_interrupt>:

static void floppy_on_interrupt(void)
{
   137cd:	83 ec 0c             	sub    $0xc,%esp
/* We cannot do a floppy-select, as that might sleep. We just force it */
	selected = 1;
   137d0:	c6 05 dc 3c 02 00 01 	movb   $0x1,0x23cdc
	if (current_drive != (current_DOR & 3)) {
   137d7:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   137de:	0f b6 c0             	movzbl %al,%eax
   137e1:	0f b6 15 68 f2 01 00 	movzbl 0x1f268,%edx
   137e8:	0f b6 d2             	movzbl %dl,%edx
   137eb:	83 e2 03             	and    $0x3,%edx
   137ee:	39 d0                	cmp    %edx,%eax
   137f0:	74 45                	je     13837 <floppy_on_interrupt+0x6a>
		current_DOR &= 0xFC;
   137f2:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
   137f9:	83 e0 fc             	and    $0xfffffffc,%eax
   137fc:	a2 68 f2 01 00       	mov    %al,0x1f268
		current_DOR |= current_drive;
   13801:	0f b6 15 68 f2 01 00 	movzbl 0x1f268,%edx
   13808:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   1380f:	09 d0                	or     %edx,%eax
   13811:	a2 68 f2 01 00       	mov    %al,0x1f268
		outb(current_DOR,FD_DOR);
   13816:	0f b6 05 68 f2 01 00 	movzbl 0x1f268,%eax
   1381d:	ba f2 03 00 00       	mov    $0x3f2,%edx
   13822:	ee                   	out    %al,(%dx)
		add_timer(2,&transfer);
   13823:	83 ec 08             	sub    $0x8,%esp
   13826:	68 95 34 01 00       	push   $0x13495
   1382b:	6a 02                	push   $0x2
   1382d:	e8 71 39 ff ff       	call   71a3 <add_timer>
   13832:	83 c4 10             	add    $0x10,%esp
	} else
		transfer();
}
   13835:	eb 05                	jmp    1383c <floppy_on_interrupt+0x6f>
		current_DOR &= 0xFC;
		current_DOR |= current_drive;
		outb(current_DOR,FD_DOR);
		add_timer(2,&transfer);
	} else
		transfer();
   13837:	e8 59 fc ff ff       	call   13495 <transfer>
}
   1383c:	90                   	nop
   1383d:	83 c4 0c             	add    $0xc,%esp
   13840:	c3                   	ret    

00013841 <do_fd_request>:

void do_fd_request(void)
{
   13841:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int block;

	seek = 0;
   13844:	c7 05 ec 3c 02 00 00 	movl   $0x0,0x23cec
   1384b:	00 00 00 
	if (reset) {
   1384e:	a1 e8 3c 02 00       	mov    0x23ce8,%eax
   13853:	85 c0                	test   %eax,%eax
   13855:	74 0a                	je     13861 <do_fd_request+0x20>
		reset_floppy();
   13857:	e8 ea fe ff ff       	call   13746 <reset_floppy>
		return;
   1385c:	e9 fe 01 00 00       	jmp    13a5f <do_fd_request+0x21e>
	}
	if (recalibrate) {
   13861:	a1 e4 3c 02 00       	mov    0x23ce4,%eax
   13866:	85 c0                	test   %eax,%eax
   13868:	74 0a                	je     13874 <do_fd_request+0x33>
		recalibrate_floppy();
   1386a:	e8 16 fe ff ff       	call   13685 <recalibrate_floppy>
		return;
   1386f:	e9 eb 01 00 00       	jmp    13a5f <do_fd_request+0x21e>
	}
	INIT_REQUEST;
   13874:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   13879:	85 c0                	test   %eax,%eax
   1387b:	0f 84 dd 01 00 00    	je     13a5e <do_fd_request+0x21d>
   13881:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   13886:	8b 00                	mov    (%eax),%eax
   13888:	c1 e8 08             	shr    $0x8,%eax
   1388b:	83 f8 02             	cmp    $0x2,%eax
   1388e:	74 10                	je     138a0 <do_fd_request+0x5f>
   13890:	83 ec 0c             	sub    $0xc,%esp
   13893:	68 1c 8e 01 00       	push   $0x18e1c
   13898:	e8 31 4f ff ff       	call   87ce <panic>
   1389d:	83 c4 10             	add    $0x10,%esp
   138a0:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   138a5:	8b 40 1c             	mov    0x1c(%eax),%eax
   138a8:	85 c0                	test   %eax,%eax
   138aa:	74 20                	je     138cc <do_fd_request+0x8b>
   138ac:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   138b1:	8b 40 1c             	mov    0x1c(%eax),%eax
   138b4:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   138b8:	84 c0                	test   %al,%al
   138ba:	75 10                	jne    138cc <do_fd_request+0x8b>
   138bc:	83 ec 0c             	sub    $0xc,%esp
   138bf:	68 3b 8e 01 00       	push   $0x18e3b
   138c4:	e8 05 4f ff ff       	call   87ce <panic>
   138c9:	83 c4 10             	add    $0x10,%esp
	floppy = (MINOR(CURRENT->dev)>>2) + floppy_type;
   138cc:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   138d1:	8b 00                	mov    (%eax),%eax
   138d3:	0f b6 c0             	movzbl %al,%eax
   138d6:	c1 f8 02             	sar    $0x2,%eax
   138d9:	89 c2                	mov    %eax,%edx
   138db:	89 d0                	mov    %edx,%eax
   138dd:	01 c0                	add    %eax,%eax
   138df:	01 d0                	add    %edx,%eax
   138e1:	c1 e0 03             	shl    $0x3,%eax
   138e4:	05 60 f3 01 00       	add    $0x1f360,%eax
   138e9:	a3 28 f4 01 00       	mov    %eax,0x1f428
	if (current_drive != CURRENT_DEV)
   138ee:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   138f5:	0f b6 d0             	movzbl %al,%edx
   138f8:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   138fd:	8b 00                	mov    (%eax),%eax
   138ff:	83 e0 03             	and    $0x3,%eax
   13902:	39 c2                	cmp    %eax,%edx
   13904:	74 0a                	je     13910 <do_fd_request+0xcf>
		seek = 1;
   13906:	c7 05 ec 3c 02 00 01 	movl   $0x1,0x23cec
   1390d:	00 00 00 
	current_drive = CURRENT_DEV;
   13910:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   13915:	8b 00                	mov    (%eax),%eax
   13917:	83 e0 03             	and    $0x3,%eax
   1391a:	a2 f7 3c 02 00       	mov    %al,0x23cf7
	block = CURRENT->sector;
   1391f:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   13924:	8b 40 0c             	mov    0xc(%eax),%eax
   13927:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (block+2 > floppy->size) {
   1392b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1392f:	8d 50 02             	lea    0x2(%eax),%edx
   13932:	a1 28 f4 01 00       	mov    0x1f428,%eax
   13937:	8b 00                	mov    (%eax),%eax
   13939:	39 c2                	cmp    %eax,%edx
   1393b:	76 12                	jbe    1394f <do_fd_request+0x10e>
		end_request(0);
   1393d:	83 ec 0c             	sub    $0xc,%esp
   13940:	6a 00                	push   $0x0
   13942:	e8 e3 f4 ff ff       	call   12e2a <end_request>
   13947:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   1394a:	e9 25 ff ff ff       	jmp    13874 <do_fd_request+0x33>
	}
	sector = block % floppy->sect;
   1394f:	a1 28 f4 01 00       	mov    0x1f428,%eax
   13954:	8b 48 04             	mov    0x4(%eax),%ecx
   13957:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1395b:	ba 00 00 00 00       	mov    $0x0,%edx
   13960:	f7 f1                	div    %ecx
   13962:	89 d0                	mov    %edx,%eax
   13964:	a2 f8 3c 02 00       	mov    %al,0x23cf8
	block /= floppy->sect;
   13969:	a1 28 f4 01 00       	mov    0x1f428,%eax
   1396e:	8b 48 04             	mov    0x4(%eax),%ecx
   13971:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13975:	ba 00 00 00 00       	mov    $0x0,%edx
   1397a:	f7 f1                	div    %ecx
   1397c:	89 44 24 0c          	mov    %eax,0xc(%esp)
	head = block % floppy->head;
   13980:	a1 28 f4 01 00       	mov    0x1f428,%eax
   13985:	8b 48 08             	mov    0x8(%eax),%ecx
   13988:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1398c:	ba 00 00 00 00       	mov    $0x0,%edx
   13991:	f7 f1                	div    %ecx
   13993:	89 d0                	mov    %edx,%eax
   13995:	a2 f9 3c 02 00       	mov    %al,0x23cf9
	track = block / floppy->head;
   1399a:	a1 28 f4 01 00       	mov    0x1f428,%eax
   1399f:	8b 48 08             	mov    0x8(%eax),%ecx
   139a2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   139a6:	ba 00 00 00 00       	mov    $0x0,%edx
   139ab:	f7 f1                	div    %ecx
   139ad:	a2 fa 3c 02 00       	mov    %al,0x23cfa
	seek_track = track << floppy->stretch;
   139b2:	0f b6 05 fa 3c 02 00 	movzbl 0x23cfa,%eax
   139b9:	0f b6 d0             	movzbl %al,%edx
   139bc:	a1 28 f4 01 00       	mov    0x1f428,%eax
   139c1:	8b 40 10             	mov    0x10(%eax),%eax
   139c4:	89 c1                	mov    %eax,%ecx
   139c6:	d3 e2                	shl    %cl,%edx
   139c8:	89 d0                	mov    %edx,%eax
   139ca:	a2 fb 3c 02 00       	mov    %al,0x23cfb
	if (seek_track != current_track)
   139cf:	0f b6 15 fb 3c 02 00 	movzbl 0x23cfb,%edx
   139d6:	0f b6 05 2c f4 01 00 	movzbl 0x1f42c,%eax
   139dd:	38 c2                	cmp    %al,%dl
   139df:	74 0a                	je     139eb <do_fd_request+0x1aa>
		seek = 1;
   139e1:	c7 05 ec 3c 02 00 01 	movl   $0x1,0x23cec
   139e8:	00 00 00 
	sector++;
   139eb:	0f b6 05 f8 3c 02 00 	movzbl 0x23cf8,%eax
   139f2:	83 c0 01             	add    $0x1,%eax
   139f5:	a2 f8 3c 02 00       	mov    %al,0x23cf8
	if (CURRENT->cmd == READ)
   139fa:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   139ff:	8b 40 04             	mov    0x4(%eax),%eax
   13a02:	85 c0                	test   %eax,%eax
   13a04:	75 09                	jne    13a0f <do_fd_request+0x1ce>
		command = FD_READ;
   13a06:	c6 05 fc 3c 02 00 e6 	movb   $0xe6,0x23cfc
   13a0d:	eb 26                	jmp    13a35 <do_fd_request+0x1f4>
	else if (CURRENT->cmd == WRITE)
   13a0f:	a1 b4 3c 02 00       	mov    0x23cb4,%eax
   13a14:	8b 40 04             	mov    0x4(%eax),%eax
   13a17:	83 f8 01             	cmp    $0x1,%eax
   13a1a:	75 09                	jne    13a25 <do_fd_request+0x1e4>
		command = FD_WRITE;
   13a1c:	c6 05 fc 3c 02 00 c5 	movb   $0xc5,0x23cfc
   13a23:	eb 10                	jmp    13a35 <do_fd_request+0x1f4>
	else
		panic("do_fd_request: unknown command");
   13a25:	83 ec 0c             	sub    $0xc,%esp
   13a28:	68 54 8e 01 00       	push   $0x18e54
   13a2d:	e8 9c 4d ff ff       	call   87ce <panic>
   13a32:	83 c4 10             	add    $0x10,%esp
	add_timer(ticks_to_floppy_on(current_drive),&floppy_on_interrupt);
   13a35:	0f b6 05 f7 3c 02 00 	movzbl 0x23cf7,%eax
   13a3c:	0f b6 c0             	movzbl %al,%eax
   13a3f:	83 ec 0c             	sub    $0xc,%esp
   13a42:	50                   	push   %eax
   13a43:	e8 5a 35 ff ff       	call   6fa2 <ticks_to_floppy_on>
   13a48:	83 c4 10             	add    $0x10,%esp
   13a4b:	83 ec 08             	sub    $0x8,%esp
   13a4e:	68 cd 37 01 00       	push   $0x137cd
   13a53:	50                   	push   %eax
   13a54:	e8 4a 37 ff ff       	call   71a3 <add_timer>
   13a59:	83 c4 10             	add    $0x10,%esp
   13a5c:	eb 01                	jmp    13a5f <do_fd_request+0x21e>
	}
	if (recalibrate) {
		recalibrate_floppy();
		return;
	}
	INIT_REQUEST;
   13a5e:	90                   	nop
	else if (CURRENT->cmd == WRITE)
		command = FD_WRITE;
	else
		panic("do_fd_request: unknown command");
	add_timer(ticks_to_floppy_on(current_drive),&floppy_on_interrupt);
}
   13a5f:	83 c4 1c             	add    $0x1c,%esp
   13a62:	c3                   	ret    

00013a63 <floppy_init>:

void floppy_init(void)
{
   13a63:	53                   	push   %ebx
   13a64:	83 ec 10             	sub    $0x10,%esp
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   13a67:	c7 05 b0 3c 02 00 41 	movl   $0x13841,0x23cb0
   13a6e:	38 01 00 
	set_trap_gate(0x26,&floppy_interrupt);
   13a71:	b9 e8 55 00 00       	mov    $0x55e8,%ecx
   13a76:	bb ec 55 00 00       	mov    $0x55ec,%ebx
   13a7b:	ba d0 77 00 00       	mov    $0x77d0,%edx
   13a80:	b8 00 00 08 00       	mov    $0x80000,%eax
   13a85:	66 89 d0             	mov    %dx,%ax
   13a88:	66 ba 00 8f          	mov    $0x8f00,%dx
   13a8c:	89 01                	mov    %eax,(%ecx)
   13a8e:	89 13                	mov    %edx,(%ebx)
	outb(inb_p(0x21)&~0x40,0x21);
   13a90:	b8 21 00 00 00       	mov    $0x21,%eax
   13a95:	89 c2                	mov    %eax,%edx
   13a97:	ec                   	in     (%dx),%al
   13a98:	eb 00                	jmp    13a9a <floppy_init+0x37>
   13a9a:	eb 00                	jmp    13a9c <floppy_init+0x39>
   13a9c:	88 44 24 0f          	mov    %al,0xf(%esp)
   13aa0:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   13aa5:	0f b6 c0             	movzbl %al,%eax
   13aa8:	83 e0 bf             	and    $0xffffffbf,%eax
   13aab:	ba 21 00 00 00       	mov    $0x21,%edx
   13ab0:	ee                   	out    %al,(%dx)
}
   13ab1:	90                   	nop
   13ab2:	83 c4 10             	add    $0x10,%esp
   13ab5:	5b                   	pop    %ebx
   13ab6:	c3                   	ret    

00013ab7 <unlock_buffer>:
void (*DEVICE_INTR)(void) = NULL;
#endif
static void (DEVICE_REQUEST)(void);

static inline void unlock_buffer(struct buffer_head * bh)
{
   13ab7:	83 ec 0c             	sub    $0xc,%esp
	if (!bh->b_lock)
   13aba:	8b 44 24 10          	mov    0x10(%esp),%eax
   13abe:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   13ac2:	84 c0                	test   %al,%al
   13ac4:	75 10                	jne    13ad6 <unlock_buffer+0x1f>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   13ac6:	83 ec 0c             	sub    $0xc,%esp
   13ac9:	68 74 8e 01 00       	push   $0x18e74
   13ace:	e8 3a 4d ff ff       	call   880d <printk>
   13ad3:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   13ad6:	8b 44 24 10          	mov    0x10(%esp),%eax
   13ada:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	wake_up(&bh->b_wait);
   13ade:	8b 44 24 10          	mov    0x10(%esp),%eax
   13ae2:	83 c0 10             	add    $0x10,%eax
   13ae5:	83 ec 0c             	sub    $0xc,%esp
   13ae8:	50                   	push   %eax
   13ae9:	e8 8b 34 ff ff       	call   6f79 <wake_up>
   13aee:	83 c4 10             	add    $0x10,%esp
}
   13af1:	90                   	nop
   13af2:	83 c4 0c             	add    $0xc,%esp
   13af5:	c3                   	ret    

00013af6 <end_request>:

static inline void end_request(int uptodate)
{
   13af6:	83 ec 0c             	sub    $0xc,%esp
	DEVICE_OFF(CURRENT->dev);
	if (CURRENT->bh) {
   13af9:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   13afe:	8b 40 1c             	mov    0x1c(%eax),%eax
   13b01:	85 c0                	test   %eax,%eax
   13b03:	74 23                	je     13b28 <end_request+0x32>
		CURRENT->bh->b_uptodate = uptodate;
   13b05:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   13b0a:	8b 40 1c             	mov    0x1c(%eax),%eax
   13b0d:	8b 54 24 10          	mov    0x10(%esp),%edx
   13b11:	88 50 0a             	mov    %dl,0xa(%eax)
		unlock_buffer(CURRENT->bh);
   13b14:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   13b19:	8b 40 1c             	mov    0x1c(%eax),%eax
   13b1c:	83 ec 0c             	sub    $0xc,%esp
   13b1f:	50                   	push   %eax
   13b20:	e8 92 ff ff ff       	call   13ab7 <unlock_buffer>
   13b25:	83 c4 10             	add    $0x10,%esp
	}
	if (!uptodate) {
   13b28:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   13b2d:	75 34                	jne    13b63 <end_request+0x6d>
		printk(DEVICE_NAME " I/O error\n\r");
   13b2f:	83 ec 0c             	sub    $0xc,%esp
   13b32:	68 9a 8e 01 00       	push   $0x18e9a
   13b37:	e8 d1 4c ff ff       	call   880d <printk>
   13b3c:	83 c4 10             	add    $0x10,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
			CURRENT->bh->b_blocknr);
   13b3f:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   13b44:	8b 40 1c             	mov    0x1c(%eax),%eax
		CURRENT->bh->b_uptodate = uptodate;
		unlock_buffer(CURRENT->bh);
	}
	if (!uptodate) {
		printk(DEVICE_NAME " I/O error\n\r");
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   13b47:	8b 50 04             	mov    0x4(%eax),%edx
   13b4a:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   13b4f:	8b 00                	mov    (%eax),%eax
   13b51:	83 ec 04             	sub    $0x4,%esp
   13b54:	52                   	push   %edx
   13b55:	50                   	push   %eax
   13b56:	68 af 8e 01 00       	push   $0x18eaf
   13b5b:	e8 ad 4c ff ff       	call   880d <printk>
   13b60:	83 c4 10             	add    $0x10,%esp
			CURRENT->bh->b_blocknr);
	}
	wake_up(&CURRENT->waiting);
   13b63:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   13b68:	83 c0 18             	add    $0x18,%eax
   13b6b:	83 ec 0c             	sub    $0xc,%esp
   13b6e:	50                   	push   %eax
   13b6f:	e8 05 34 ff ff       	call   6f79 <wake_up>
   13b74:	83 c4 10             	add    $0x10,%esp
	wake_up(&wait_for_request);
   13b77:	83 ec 0c             	sub    $0xc,%esp
   13b7a:	68 80 3c 02 00       	push   $0x23c80
   13b7f:	e8 f5 33 ff ff       	call   6f79 <wake_up>
   13b84:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   13b87:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   13b8c:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   13b92:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   13b97:	8b 40 20             	mov    0x20(%eax),%eax
   13b9a:	a3 bc 3c 02 00       	mov    %eax,0x23cbc
}
   13b9f:	90                   	nop
   13ba0:	83 c4 0c             	add    $0xc,%esp
   13ba3:	c3                   	ret    

00013ba4 <sys_setup>:
extern void hd_interrupt(void);
extern void rd_load(void);

/* This may be used only once, enforced by 'static int callable' */
int sys_setup(void * BIOS)
{
   13ba4:	53                   	push   %ebx
   13ba5:	83 ec 28             	sub    $0x28,%esp
	int i,drive;
	unsigned char cmos_disks;
	struct partition *p;
	struct buffer_head * bh;

	if (!callable)
   13ba8:	a1 30 f4 01 00       	mov    0x1f430,%eax
   13bad:	85 c0                	test   %eax,%eax
   13baf:	75 0a                	jne    13bbb <sys_setup+0x17>
		return -1;
   13bb1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13bb6:	e9 a6 03 00 00       	jmp    13f61 <sys_setup+0x3bd>
	callable = 0;
   13bbb:	c7 05 30 f4 01 00 00 	movl   $0x0,0x1f430
   13bc2:	00 00 00 
#ifndef HD_TYPE
	for (drive=0 ; drive<2 ; drive++) {
   13bc5:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   13bcc:	00 
   13bcd:	e9 cd 00 00 00       	jmp    13c9f <sys_setup+0xfb>
		hd_info[drive].cyl = *(unsigned short *) BIOS;
   13bd2:	8b 44 24 30          	mov    0x30(%esp),%eax
   13bd6:	0f b7 00             	movzwl (%eax),%eax
   13bd9:	0f b7 c8             	movzwl %ax,%ecx
   13bdc:	8b 54 24 18          	mov    0x18(%esp),%edx
   13be0:	89 d0                	mov    %edx,%eax
   13be2:	01 c0                	add    %eax,%eax
   13be4:	01 d0                	add    %edx,%eax
   13be6:	c1 e0 03             	shl    $0x3,%eax
   13be9:	05 28 3d 02 00       	add    $0x23d28,%eax
   13bee:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].head = *(unsigned char *) (2+BIOS);
   13bf0:	8b 44 24 30          	mov    0x30(%esp),%eax
   13bf4:	83 c0 02             	add    $0x2,%eax
   13bf7:	0f b6 00             	movzbl (%eax),%eax
   13bfa:	0f b6 c8             	movzbl %al,%ecx
   13bfd:	8b 54 24 18          	mov    0x18(%esp),%edx
   13c01:	89 d0                	mov    %edx,%eax
   13c03:	01 c0                	add    %eax,%eax
   13c05:	01 d0                	add    %edx,%eax
   13c07:	c1 e0 03             	shl    $0x3,%eax
   13c0a:	05 20 3d 02 00       	add    $0x23d20,%eax
   13c0f:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);
   13c11:	8b 44 24 30          	mov    0x30(%esp),%eax
   13c15:	83 c0 05             	add    $0x5,%eax
   13c18:	0f b7 00             	movzwl (%eax),%eax
   13c1b:	0f b7 c8             	movzwl %ax,%ecx
   13c1e:	8b 54 24 18          	mov    0x18(%esp),%edx
   13c22:	89 d0                	mov    %edx,%eax
   13c24:	01 c0                	add    %eax,%eax
   13c26:	01 d0                	add    %edx,%eax
   13c28:	c1 e0 03             	shl    $0x3,%eax
   13c2b:	05 2c 3d 02 00       	add    $0x23d2c,%eax
   13c30:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].ctl = *(unsigned char *) (8+BIOS);
   13c32:	8b 44 24 30          	mov    0x30(%esp),%eax
   13c36:	83 c0 08             	add    $0x8,%eax
   13c39:	0f b6 00             	movzbl (%eax),%eax
   13c3c:	0f b6 c8             	movzbl %al,%ecx
   13c3f:	8b 54 24 18          	mov    0x18(%esp),%edx
   13c43:	89 d0                	mov    %edx,%eax
   13c45:	01 c0                	add    %eax,%eax
   13c47:	01 d0                	add    %edx,%eax
   13c49:	c1 e0 03             	shl    $0x3,%eax
   13c4c:	05 34 3d 02 00       	add    $0x23d34,%eax
   13c51:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].lzone = *(unsigned short *) (12+BIOS);
   13c53:	8b 44 24 30          	mov    0x30(%esp),%eax
   13c57:	83 c0 0c             	add    $0xc,%eax
   13c5a:	0f b7 00             	movzwl (%eax),%eax
   13c5d:	0f b7 c8             	movzwl %ax,%ecx
   13c60:	8b 54 24 18          	mov    0x18(%esp),%edx
   13c64:	89 d0                	mov    %edx,%eax
   13c66:	01 c0                	add    %eax,%eax
   13c68:	01 d0                	add    %edx,%eax
   13c6a:	c1 e0 03             	shl    $0x3,%eax
   13c6d:	05 30 3d 02 00       	add    $0x23d30,%eax
   13c72:	89 08                	mov    %ecx,(%eax)
		hd_info[drive].sect = *(unsigned char *) (14+BIOS);
   13c74:	8b 44 24 30          	mov    0x30(%esp),%eax
   13c78:	83 c0 0e             	add    $0xe,%eax
   13c7b:	0f b6 00             	movzbl (%eax),%eax
   13c7e:	0f b6 c8             	movzbl %al,%ecx
   13c81:	8b 54 24 18          	mov    0x18(%esp),%edx
   13c85:	89 d0                	mov    %edx,%eax
   13c87:	01 c0                	add    %eax,%eax
   13c89:	01 d0                	add    %edx,%eax
   13c8b:	c1 e0 03             	shl    $0x3,%eax
   13c8e:	05 24 3d 02 00       	add    $0x23d24,%eax
   13c93:	89 08                	mov    %ecx,(%eax)
		BIOS += 16;
   13c95:	83 44 24 30 10       	addl   $0x10,0x30(%esp)

	if (!callable)
		return -1;
	callable = 0;
#ifndef HD_TYPE
	for (drive=0 ; drive<2 ; drive++) {
   13c9a:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   13c9f:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
   13ca4:	0f 8e 28 ff ff ff    	jle    13bd2 <sys_setup+0x2e>
		hd_info[drive].ctl = *(unsigned char *) (8+BIOS);
		hd_info[drive].lzone = *(unsigned short *) (12+BIOS);
		hd_info[drive].sect = *(unsigned char *) (14+BIOS);
		BIOS += 16;
	}
	if (hd_info[1].cyl)
   13caa:	a1 40 3d 02 00       	mov    0x23d40,%eax
   13caf:	85 c0                	test   %eax,%eax
   13cb1:	74 0c                	je     13cbf <sys_setup+0x11b>
		NR_HD=2;
   13cb3:	c7 05 58 3d 02 00 02 	movl   $0x2,0x23d58
   13cba:	00 00 00 
   13cbd:	eb 0a                	jmp    13cc9 <sys_setup+0x125>
	else
		NR_HD=1;
   13cbf:	c7 05 58 3d 02 00 01 	movl   $0x1,0x23d58
   13cc6:	00 00 00 
#endif
	for (i=0 ; i<NR_HD ; i++) {
   13cc9:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   13cd0:	00 
   13cd1:	eb 70                	jmp    13d43 <sys_setup+0x19f>
		hd[i*5].start_sect = 0;
   13cd3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13cd7:	89 d0                	mov    %edx,%eax
   13cd9:	c1 e0 02             	shl    $0x2,%eax
   13cdc:	01 d0                	add    %edx,%eax
   13cde:	c7 04 c5 60 3d 02 00 	movl   $0x0,0x23d60(,%eax,8)
   13ce5:	00 00 00 00 
		hd[i*5].nr_sects = hd_info[i].head*
   13ce9:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13ced:	89 d0                	mov    %edx,%eax
   13cef:	c1 e0 02             	shl    $0x2,%eax
   13cf2:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   13cf5:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13cf9:	89 d0                	mov    %edx,%eax
   13cfb:	01 c0                	add    %eax,%eax
   13cfd:	01 d0                	add    %edx,%eax
   13cff:	c1 e0 03             	shl    $0x3,%eax
   13d02:	05 20 3d 02 00       	add    $0x23d20,%eax
   13d07:	8b 18                	mov    (%eax),%ebx
				hd_info[i].sect*hd_info[i].cyl;
   13d09:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13d0d:	89 d0                	mov    %edx,%eax
   13d0f:	01 c0                	add    %eax,%eax
   13d11:	01 d0                	add    %edx,%eax
   13d13:	c1 e0 03             	shl    $0x3,%eax
   13d16:	05 24 3d 02 00       	add    $0x23d24,%eax
   13d1b:	8b 00                	mov    (%eax),%eax
	else
		NR_HD=1;
#endif
	for (i=0 ; i<NR_HD ; i++) {
		hd[i*5].start_sect = 0;
		hd[i*5].nr_sects = hd_info[i].head*
   13d1d:	0f af d8             	imul   %eax,%ebx
				hd_info[i].sect*hd_info[i].cyl;
   13d20:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13d24:	89 d0                	mov    %edx,%eax
   13d26:	01 c0                	add    %eax,%eax
   13d28:	01 d0                	add    %edx,%eax
   13d2a:	c1 e0 03             	shl    $0x3,%eax
   13d2d:	05 28 3d 02 00       	add    $0x23d28,%eax
   13d32:	8b 00                	mov    (%eax),%eax
   13d34:	0f af c3             	imul   %ebx,%eax
	else
		NR_HD=1;
#endif
	for (i=0 ; i<NR_HD ; i++) {
		hd[i*5].start_sect = 0;
		hd[i*5].nr_sects = hd_info[i].head*
   13d37:	89 04 cd 64 3d 02 00 	mov    %eax,0x23d64(,%ecx,8)
	if (hd_info[1].cyl)
		NR_HD=2;
	else
		NR_HD=1;
#endif
	for (i=0 ; i<NR_HD ; i++) {
   13d3e:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   13d43:	a1 58 3d 02 00       	mov    0x23d58,%eax
   13d48:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
   13d4c:	7c 85                	jl     13cd3 <sys_setup+0x12f>
		an AT controller hard disk for that drive.

		
	*/

	if ((cmos_disks = CMOS_READ(0x12)) & 0xf0)
   13d4e:	b8 92 00 00 00       	mov    $0x92,%eax
   13d53:	ba 70 00 00 00       	mov    $0x70,%edx
   13d58:	ee                   	out    %al,(%dx)
   13d59:	eb 00                	jmp    13d5b <sys_setup+0x1b7>
   13d5b:	eb 00                	jmp    13d5d <sys_setup+0x1b9>
   13d5d:	b8 71 00 00 00       	mov    $0x71,%eax
   13d62:	89 c2                	mov    %eax,%edx
   13d64:	ec                   	in     (%dx),%al
   13d65:	eb 00                	jmp    13d67 <sys_setup+0x1c3>
   13d67:	eb 00                	jmp    13d69 <sys_setup+0x1c5>
   13d69:	88 44 24 13          	mov    %al,0x13(%esp)
   13d6d:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
   13d72:	88 44 24 12          	mov    %al,0x12(%esp)
   13d76:	0f b6 44 24 12       	movzbl 0x12(%esp),%eax
   13d7b:	25 f0 00 00 00       	and    $0xf0,%eax
   13d80:	85 c0                	test   %eax,%eax
   13d82:	74 24                	je     13da8 <sys_setup+0x204>
		if (cmos_disks & 0x0f)
   13d84:	0f b6 44 24 12       	movzbl 0x12(%esp),%eax
   13d89:	83 e0 0f             	and    $0xf,%eax
   13d8c:	85 c0                	test   %eax,%eax
   13d8e:	74 0c                	je     13d9c <sys_setup+0x1f8>
			NR_HD = 2;
   13d90:	c7 05 58 3d 02 00 02 	movl   $0x2,0x23d58
   13d97:	00 00 00 
   13d9a:	eb 16                	jmp    13db2 <sys_setup+0x20e>
		else
			NR_HD = 1;
   13d9c:	c7 05 58 3d 02 00 01 	movl   $0x1,0x23d58
   13da3:	00 00 00 
   13da6:	eb 0a                	jmp    13db2 <sys_setup+0x20e>
	else
		NR_HD = 0;
   13da8:	c7 05 58 3d 02 00 00 	movl   $0x0,0x23d58
   13daf:	00 00 00 
	for (i = NR_HD ; i < 2 ; i++) {
   13db2:	a1 58 3d 02 00       	mov    0x23d58,%eax
   13db7:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   13dbb:	eb 31                	jmp    13dee <sys_setup+0x24a>
		hd[i*5].start_sect = 0;
   13dbd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13dc1:	89 d0                	mov    %edx,%eax
   13dc3:	c1 e0 02             	shl    $0x2,%eax
   13dc6:	01 d0                	add    %edx,%eax
   13dc8:	c7 04 c5 60 3d 02 00 	movl   $0x0,0x23d60(,%eax,8)
   13dcf:	00 00 00 00 
		hd[i*5].nr_sects = 0;
   13dd3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   13dd7:	89 d0                	mov    %edx,%eax
   13dd9:	c1 e0 02             	shl    $0x2,%eax
   13ddc:	01 d0                	add    %edx,%eax
   13dde:	c7 04 c5 64 3d 02 00 	movl   $0x0,0x23d64(,%eax,8)
   13de5:	00 00 00 00 
			NR_HD = 2;
		else
			NR_HD = 1;
	else
		NR_HD = 0;
	for (i = NR_HD ; i < 2 ; i++) {
   13de9:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   13dee:	83 7c 24 1c 01       	cmpl   $0x1,0x1c(%esp)
   13df3:	7e c8                	jle    13dbd <sys_setup+0x219>
		hd[i*5].start_sect = 0;
		hd[i*5].nr_sects = 0;
	}
	for (drive=0 ; drive<NR_HD ; drive++) {
   13df5:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   13dfc:	00 
   13dfd:	e9 11 01 00 00       	jmp    13f13 <sys_setup+0x36f>
		if (!(bh = bread(0x300 + drive*5,0))) {
   13e02:	8b 54 24 18          	mov    0x18(%esp),%edx
   13e06:	89 d0                	mov    %edx,%eax
   13e08:	c1 e0 02             	shl    $0x2,%eax
   13e0b:	01 d0                	add    %edx,%eax
   13e0d:	05 00 03 00 00       	add    $0x300,%eax
   13e12:	83 ec 08             	sub    $0x8,%esp
   13e15:	6a 00                	push   $0x0
   13e17:	50                   	push   %eax
   13e18:	e8 c9 91 ff ff       	call   cfe6 <bread>
   13e1d:	83 c4 10             	add    $0x10,%esp
   13e20:	89 44 24 0c          	mov    %eax,0xc(%esp)
   13e24:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   13e29:	75 24                	jne    13e4f <sys_setup+0x2ab>
			printk("Unable to read partition table of drive %d\n\r",
   13e2b:	83 ec 08             	sub    $0x8,%esp
   13e2e:	ff 74 24 20          	pushl  0x20(%esp)
   13e32:	68 c4 8e 01 00       	push   $0x18ec4
   13e37:	e8 d1 49 ff ff       	call   880d <printk>
   13e3c:	83 c4 10             	add    $0x10,%esp
				drive);
			panic("");
   13e3f:	83 ec 0c             	sub    $0xc,%esp
   13e42:	68 f1 8e 01 00       	push   $0x18ef1
   13e47:	e8 82 49 ff ff       	call   87ce <panic>
   13e4c:	83 c4 10             	add    $0x10,%esp
		}
		if (bh->b_data[510] != 0x55 || (unsigned char)
   13e4f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13e53:	8b 00                	mov    (%eax),%eax
   13e55:	05 fe 01 00 00       	add    $0x1fe,%eax
   13e5a:	0f b6 00             	movzbl (%eax),%eax
   13e5d:	3c 55                	cmp    $0x55,%al
   13e5f:	75 12                	jne    13e73 <sys_setup+0x2cf>
		    bh->b_data[511] != 0xAA) {
   13e61:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13e65:	8b 00                	mov    (%eax),%eax
   13e67:	05 ff 01 00 00       	add    $0x1ff,%eax
   13e6c:	0f b6 00             	movzbl (%eax),%eax
		if (!(bh = bread(0x300 + drive*5,0))) {
			printk("Unable to read partition table of drive %d\n\r",
				drive);
			panic("");
		}
		if (bh->b_data[510] != 0x55 || (unsigned char)
   13e6f:	3c aa                	cmp    $0xaa,%al
   13e71:	74 24                	je     13e97 <sys_setup+0x2f3>
		    bh->b_data[511] != 0xAA) {
			printk("Bad partition table on drive %d\n\r",drive);
   13e73:	83 ec 08             	sub    $0x8,%esp
   13e76:	ff 74 24 20          	pushl  0x20(%esp)
   13e7a:	68 f4 8e 01 00       	push   $0x18ef4
   13e7f:	e8 89 49 ff ff       	call   880d <printk>
   13e84:	83 c4 10             	add    $0x10,%esp
			panic("");
   13e87:	83 ec 0c             	sub    $0xc,%esp
   13e8a:	68 f1 8e 01 00       	push   $0x18ef1
   13e8f:	e8 3a 49 ff ff       	call   87ce <panic>
   13e94:	83 c4 10             	add    $0x10,%esp
		}
		p = 0x1BE + (void *)bh->b_data;
   13e97:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13e9b:	8b 00                	mov    (%eax),%eax
   13e9d:	05 be 01 00 00       	add    $0x1be,%eax
   13ea2:	89 44 24 14          	mov    %eax,0x14(%esp)
		for (i=1;i<5;i++,p++) {
   13ea6:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
   13ead:	00 
   13eae:	eb 48                	jmp    13ef8 <sys_setup+0x354>
			hd[i+5*drive].start_sect = p->start_sect;
   13eb0:	8b 54 24 18          	mov    0x18(%esp),%edx
   13eb4:	89 d0                	mov    %edx,%eax
   13eb6:	c1 e0 02             	shl    $0x2,%eax
   13eb9:	01 c2                	add    %eax,%edx
   13ebb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   13ebf:	01 c2                	add    %eax,%edx
   13ec1:	8b 44 24 14          	mov    0x14(%esp),%eax
   13ec5:	8b 40 08             	mov    0x8(%eax),%eax
   13ec8:	89 04 d5 60 3d 02 00 	mov    %eax,0x23d60(,%edx,8)
			hd[i+5*drive].nr_sects = p->nr_sects;
   13ecf:	8b 54 24 18          	mov    0x18(%esp),%edx
   13ed3:	89 d0                	mov    %edx,%eax
   13ed5:	c1 e0 02             	shl    $0x2,%eax
   13ed8:	01 c2                	add    %eax,%edx
   13eda:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   13ede:	01 c2                	add    %eax,%edx
   13ee0:	8b 44 24 14          	mov    0x14(%esp),%eax
   13ee4:	8b 40 0c             	mov    0xc(%eax),%eax
   13ee7:	89 04 d5 64 3d 02 00 	mov    %eax,0x23d64(,%edx,8)
		    bh->b_data[511] != 0xAA) {
			printk("Bad partition table on drive %d\n\r",drive);
			panic("");
		}
		p = 0x1BE + (void *)bh->b_data;
		for (i=1;i<5;i++,p++) {
   13eee:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   13ef3:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
   13ef8:	83 7c 24 1c 04       	cmpl   $0x4,0x1c(%esp)
   13efd:	7e b1                	jle    13eb0 <sys_setup+0x30c>
			hd[i+5*drive].start_sect = p->start_sect;
			hd[i+5*drive].nr_sects = p->nr_sects;
		}
		brelse(bh);
   13eff:	83 ec 0c             	sub    $0xc,%esp
   13f02:	ff 74 24 18          	pushl  0x18(%esp)
   13f06:	e8 85 90 ff ff       	call   cf90 <brelse>
   13f0b:	83 c4 10             	add    $0x10,%esp
		NR_HD = 0;
	for (i = NR_HD ; i < 2 ; i++) {
		hd[i*5].start_sect = 0;
		hd[i*5].nr_sects = 0;
	}
	for (drive=0 ; drive<NR_HD ; drive++) {
   13f0e:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
   13f13:	a1 58 3d 02 00       	mov    0x23d58,%eax
   13f18:	39 44 24 18          	cmp    %eax,0x18(%esp)
   13f1c:	0f 8c e0 fe ff ff    	jl     13e02 <sys_setup+0x25e>
			hd[i+5*drive].start_sect = p->start_sect;
			hd[i+5*drive].nr_sects = p->nr_sects;
		}
		brelse(bh);
	}
	if (NR_HD)
   13f22:	a1 58 3d 02 00       	mov    0x23d58,%eax
   13f27:	85 c0                	test   %eax,%eax
   13f29:	74 27                	je     13f52 <sys_setup+0x3ae>
		printk("Partition table%s ok.\n\r",(NR_HD>1)?"s":"");
   13f2b:	a1 58 3d 02 00       	mov    0x23d58,%eax
   13f30:	83 f8 01             	cmp    $0x1,%eax
   13f33:	7e 07                	jle    13f3c <sys_setup+0x398>
   13f35:	b8 16 8f 01 00       	mov    $0x18f16,%eax
   13f3a:	eb 05                	jmp    13f41 <sys_setup+0x39d>
   13f3c:	b8 f1 8e 01 00       	mov    $0x18ef1,%eax
   13f41:	83 ec 08             	sub    $0x8,%esp
   13f44:	50                   	push   %eax
   13f45:	68 18 8f 01 00       	push   $0x18f18
   13f4a:	e8 be 48 ff ff       	call   880d <printk>
   13f4f:	83 c4 10             	add    $0x10,%esp
	rd_load();
   13f52:	e8 c6 0a 00 00       	call   14a1d <rd_load>
	mount_root();
   13f57:	e8 e4 9c ff ff       	call   dc40 <mount_root>
	return (0);
   13f5c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13f61:	83 c4 28             	add    $0x28,%esp
   13f64:	5b                   	pop    %ebx
   13f65:	c3                   	ret    

00013f66 <controller_ready>:

static int controller_ready(void)
{
   13f66:	83 ec 10             	sub    $0x10,%esp
	int retries=100000;
   13f69:	c7 44 24 0c a0 86 01 	movl   $0x186a0,0xc(%esp)
   13f70:	00 

	while (--retries && (inb_p(HD_STATUS)&0x80));
   13f71:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
   13f76:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   13f7b:	74 19                	je     13f96 <controller_ready+0x30>
   13f7d:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   13f82:	89 c2                	mov    %eax,%edx
   13f84:	ec                   	in     (%dx),%al
   13f85:	eb 00                	jmp    13f87 <controller_ready+0x21>
   13f87:	eb 00                	jmp    13f89 <controller_ready+0x23>
   13f89:	88 44 24 0b          	mov    %al,0xb(%esp)
   13f8d:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   13f92:	84 c0                	test   %al,%al
   13f94:	78 db                	js     13f71 <controller_ready+0xb>
	return (retries);
   13f96:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   13f9a:	83 c4 10             	add    $0x10,%esp
   13f9d:	c3                   	ret    

00013f9e <win_result>:

static int win_result(void)
{
   13f9e:	83 ec 10             	sub    $0x10,%esp
	int i=inb_p(HD_STATUS);
   13fa1:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   13fa6:	89 c2                	mov    %eax,%edx
   13fa8:	ec                   	in     (%dx),%al
   13fa9:	eb 00                	jmp    13fab <win_result+0xd>
   13fab:	eb 00                	jmp    13fad <win_result+0xf>
   13fad:	88 44 24 0f          	mov    %al,0xf(%esp)
   13fb1:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   13fb6:	0f b6 c0             	movzbl %al,%eax
   13fb9:	89 44 24 08          	mov    %eax,0x8(%esp)

	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
   13fbd:	8b 44 24 08          	mov    0x8(%esp),%eax
   13fc1:	25 f1 00 00 00       	and    $0xf1,%eax
   13fc6:	83 f8 50             	cmp    $0x50,%eax
   13fc9:	75 07                	jne    13fd2 <win_result+0x34>
		== (READY_STAT | SEEK_STAT))
		return(0); /* ok */
   13fcb:	b8 00 00 00 00       	mov    $0x0,%eax
   13fd0:	eb 28                	jmp    13ffa <win_result+0x5c>
	if (i&1) i=inb(HD_ERROR);
   13fd2:	8b 44 24 08          	mov    0x8(%esp),%eax
   13fd6:	83 e0 01             	and    $0x1,%eax
   13fd9:	85 c0                	test   %eax,%eax
   13fdb:	74 18                	je     13ff5 <win_result+0x57>
   13fdd:	b8 f1 01 00 00       	mov    $0x1f1,%eax
   13fe2:	89 c2                	mov    %eax,%edx
   13fe4:	ec                   	in     (%dx),%al
   13fe5:	88 44 24 07          	mov    %al,0x7(%esp)
   13fe9:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
   13fee:	0f b6 c0             	movzbl %al,%eax
   13ff1:	89 44 24 08          	mov    %eax,0x8(%esp)
	return (1);
   13ff5:	b8 01 00 00 00       	mov    $0x1,%eax
}
   13ffa:	83 c4 10             	add    $0x10,%esp
   13ffd:	c3                   	ret    

00013ffe <hd_out>:

static void hd_out(unsigned int drive,unsigned int nsect,unsigned int sect,
		unsigned int head,unsigned int cyl,unsigned int cmd,
		void (*intr_addr)(void))
{
   13ffe:	83 ec 0c             	sub    $0xc,%esp
	register int port asm("dx");

	if (drive>1 || head>15)
   14001:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
   14006:	77 07                	ja     1400f <hd_out+0x11>
   14008:	83 7c 24 1c 0f       	cmpl   $0xf,0x1c(%esp)
   1400d:	76 10                	jbe    1401f <hd_out+0x21>
		panic("Trying to write bad sector");
   1400f:	83 ec 0c             	sub    $0xc,%esp
   14012:	68 30 8f 01 00       	push   $0x18f30
   14017:	e8 b2 47 ff ff       	call   87ce <panic>
   1401c:	83 c4 10             	add    $0x10,%esp
	if (!controller_ready())
   1401f:	e8 42 ff ff ff       	call   13f66 <controller_ready>
   14024:	85 c0                	test   %eax,%eax
   14026:	75 10                	jne    14038 <hd_out+0x3a>
		panic("HD controller not ready");
   14028:	83 ec 0c             	sub    $0xc,%esp
   1402b:	68 4b 8f 01 00       	push   $0x18f4b
   14030:	e8 99 47 ff ff       	call   87ce <panic>
   14035:	83 c4 10             	add    $0x10,%esp
	do_hd = intr_addr;
   14038:	8b 44 24 28          	mov    0x28(%esp),%eax
   1403c:	a3 00 3d 02 00       	mov    %eax,0x23d00
	outb_p(hd_info[drive].ctl,HD_CMD);
   14041:	8b 54 24 10          	mov    0x10(%esp),%edx
   14045:	89 d0                	mov    %edx,%eax
   14047:	01 c0                	add    %eax,%eax
   14049:	01 d0                	add    %edx,%eax
   1404b:	c1 e0 03             	shl    $0x3,%eax
   1404e:	05 34 3d 02 00       	add    $0x23d34,%eax
   14053:	8b 00                	mov    (%eax),%eax
   14055:	ba f6 03 00 00       	mov    $0x3f6,%edx
   1405a:	ee                   	out    %al,(%dx)
   1405b:	eb 00                	jmp    1405d <hd_out+0x5f>
   1405d:	eb 00                	jmp    1405f <hd_out+0x61>
	port=HD_DATA;
   1405f:	ba f0 01 00 00       	mov    $0x1f0,%edx
	outb_p(hd_info[drive].wpcom>>2,++port);
   14064:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   14068:	89 c8                	mov    %ecx,%eax
   1406a:	01 c0                	add    %eax,%eax
   1406c:	01 c8                	add    %ecx,%eax
   1406e:	c1 e0 03             	shl    $0x3,%eax
   14071:	05 2c 3d 02 00       	add    $0x23d2c,%eax
   14076:	8b 00                	mov    (%eax),%eax
   14078:	c1 f8 02             	sar    $0x2,%eax
   1407b:	83 c2 01             	add    $0x1,%edx
   1407e:	ee                   	out    %al,(%dx)
   1407f:	eb 00                	jmp    14081 <hd_out+0x83>
   14081:	eb 00                	jmp    14083 <hd_out+0x85>
	outb_p(nsect,++port);
   14083:	89 d0                	mov    %edx,%eax
   14085:	83 c0 01             	add    $0x1,%eax
   14088:	89 c2                	mov    %eax,%edx
   1408a:	8b 44 24 14          	mov    0x14(%esp),%eax
   1408e:	ee                   	out    %al,(%dx)
   1408f:	eb 00                	jmp    14091 <hd_out+0x93>
   14091:	eb 00                	jmp    14093 <hd_out+0x95>
	outb_p(sect,++port);
   14093:	89 d0                	mov    %edx,%eax
   14095:	83 c0 01             	add    $0x1,%eax
   14098:	89 c2                	mov    %eax,%edx
   1409a:	8b 44 24 18          	mov    0x18(%esp),%eax
   1409e:	ee                   	out    %al,(%dx)
   1409f:	eb 00                	jmp    140a1 <hd_out+0xa3>
   140a1:	eb 00                	jmp    140a3 <hd_out+0xa5>
	outb_p(cyl,++port);
   140a3:	89 d0                	mov    %edx,%eax
   140a5:	83 c0 01             	add    $0x1,%eax
   140a8:	89 c2                	mov    %eax,%edx
   140aa:	8b 44 24 20          	mov    0x20(%esp),%eax
   140ae:	ee                   	out    %al,(%dx)
   140af:	eb 00                	jmp    140b1 <hd_out+0xb3>
   140b1:	eb 00                	jmp    140b3 <hd_out+0xb5>
	outb_p(cyl>>8,++port);
   140b3:	8b 44 24 20          	mov    0x20(%esp),%eax
   140b7:	c1 e8 08             	shr    $0x8,%eax
   140ba:	83 c2 01             	add    $0x1,%edx
   140bd:	ee                   	out    %al,(%dx)
   140be:	eb 00                	jmp    140c0 <hd_out+0xc2>
   140c0:	eb 00                	jmp    140c2 <hd_out+0xc4>
	outb_p(0xA0|(drive<<4)|head,++port);
   140c2:	8b 44 24 10          	mov    0x10(%esp),%eax
   140c6:	c1 e0 04             	shl    $0x4,%eax
   140c9:	0b 44 24 1c          	or     0x1c(%esp),%eax
   140cd:	0c a0                	or     $0xa0,%al
   140cf:	83 c2 01             	add    $0x1,%edx
   140d2:	ee                   	out    %al,(%dx)
   140d3:	eb 00                	jmp    140d5 <hd_out+0xd7>
   140d5:	eb 00                	jmp    140d7 <hd_out+0xd9>
	outb(cmd,++port);
   140d7:	89 d0                	mov    %edx,%eax
   140d9:	83 c0 01             	add    $0x1,%eax
   140dc:	89 c2                	mov    %eax,%edx
   140de:	8b 44 24 24          	mov    0x24(%esp),%eax
   140e2:	ee                   	out    %al,(%dx)
}
   140e3:	90                   	nop
   140e4:	83 c4 0c             	add    $0xc,%esp
   140e7:	c3                   	ret    

000140e8 <drive_busy>:

static int drive_busy(void)
{
   140e8:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int i;

	for (i = 0; i < 10000; i++)
   140eb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   140f2:	00 
   140f3:	eb 27                	jmp    1411c <drive_busy+0x34>
		if (READY_STAT == (inb_p(HD_STATUS) & (BUSY_STAT|READY_STAT)))
   140f5:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   140fa:	89 c2                	mov    %eax,%edx
   140fc:	ec                   	in     (%dx),%al
   140fd:	eb 00                	jmp    140ff <drive_busy+0x17>
   140ff:	eb 00                	jmp    14101 <drive_busy+0x19>
   14101:	88 44 24 0b          	mov    %al,0xb(%esp)
   14105:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   1410a:	0f b6 c0             	movzbl %al,%eax
   1410d:	25 c0 00 00 00       	and    $0xc0,%eax
   14112:	83 f8 40             	cmp    $0x40,%eax
   14115:	74 11                	je     14128 <drive_busy+0x40>

static int drive_busy(void)
{
	unsigned int i;

	for (i = 0; i < 10000; i++)
   14117:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1411c:	81 7c 24 0c 0f 27 00 	cmpl   $0x270f,0xc(%esp)
   14123:	00 
   14124:	76 cf                	jbe    140f5 <drive_busy+0xd>
   14126:	eb 01                	jmp    14129 <drive_busy+0x41>
		if (READY_STAT == (inb_p(HD_STATUS) & (BUSY_STAT|READY_STAT)))
			break;
   14128:	90                   	nop
	i = inb(HD_STATUS);
   14129:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   1412e:	89 c2                	mov    %eax,%edx
   14130:	ec                   	in     (%dx),%al
   14131:	88 44 24 0a          	mov    %al,0xa(%esp)
   14135:	0f b6 44 24 0a       	movzbl 0xa(%esp),%eax
   1413a:	0f b6 c0             	movzbl %al,%eax
   1413d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	i &= BUSY_STAT | READY_STAT | SEEK_STAT;
   14141:	81 64 24 0c d0 00 00 	andl   $0xd0,0xc(%esp)
   14148:	00 
	if (i == (READY_STAT | SEEK_STAT))
   14149:	83 7c 24 0c 50       	cmpl   $0x50,0xc(%esp)
   1414e:	75 07                	jne    14157 <drive_busy+0x6f>
		return(0);
   14150:	b8 00 00 00 00       	mov    $0x0,%eax
   14155:	eb 15                	jmp    1416c <drive_busy+0x84>
	printk("HD controller times out\n\r");
   14157:	83 ec 0c             	sub    $0xc,%esp
   1415a:	68 63 8f 01 00       	push   $0x18f63
   1415f:	e8 a9 46 ff ff       	call   880d <printk>
   14164:	83 c4 10             	add    $0x10,%esp
	return(1);
   14167:	b8 01 00 00 00       	mov    $0x1,%eax
}
   1416c:	83 c4 1c             	add    $0x1c,%esp
   1416f:	c3                   	ret    

00014170 <reset_controller>:

static void reset_controller(void)
{
   14170:	83 ec 1c             	sub    $0x1c,%esp
	int	i;

	outb(4,HD_CMD);
   14173:	b8 04 00 00 00       	mov    $0x4,%eax
   14178:	ba f6 03 00 00       	mov    $0x3f6,%edx
   1417d:	ee                   	out    %al,(%dx)
	for(i = 0; i < 100; i++) nop();
   1417e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   14185:	00 
   14186:	eb 06                	jmp    1418e <reset_controller+0x1e>
   14188:	90                   	nop
   14189:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1418e:	83 7c 24 0c 63       	cmpl   $0x63,0xc(%esp)
   14193:	7e f3                	jle    14188 <reset_controller+0x18>
	outb(hd_info[0].ctl & 0x0f ,HD_CMD);
   14195:	a1 34 3d 02 00       	mov    0x23d34,%eax
   1419a:	83 e0 0f             	and    $0xf,%eax
   1419d:	ba f6 03 00 00       	mov    $0x3f6,%edx
   141a2:	ee                   	out    %al,(%dx)
	if (drive_busy())
   141a3:	e8 40 ff ff ff       	call   140e8 <drive_busy>
   141a8:	85 c0                	test   %eax,%eax
   141aa:	74 10                	je     141bc <reset_controller+0x4c>
		printk("HD-controller still busy\n\r");
   141ac:	83 ec 0c             	sub    $0xc,%esp
   141af:	68 7d 8f 01 00       	push   $0x18f7d
   141b4:	e8 54 46 ff ff       	call   880d <printk>
   141b9:	83 c4 10             	add    $0x10,%esp
	if ((i = inb(HD_ERROR)) != 1)
   141bc:	b8 f1 01 00 00       	mov    $0x1f1,%eax
   141c1:	89 c2                	mov    %eax,%edx
   141c3:	ec                   	in     (%dx),%al
   141c4:	88 44 24 0b          	mov    %al,0xb(%esp)
   141c8:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   141cd:	0f b6 c0             	movzbl %al,%eax
   141d0:	89 44 24 0c          	mov    %eax,0xc(%esp)
   141d4:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
   141d9:	74 14                	je     141ef <reset_controller+0x7f>
		printk("HD-controller reset failed: %02x\n\r",i);
   141db:	83 ec 08             	sub    $0x8,%esp
   141de:	ff 74 24 14          	pushl  0x14(%esp)
   141e2:	68 98 8f 01 00       	push   $0x18f98
   141e7:	e8 21 46 ff ff       	call   880d <printk>
   141ec:	83 c4 10             	add    $0x10,%esp
}
   141ef:	90                   	nop
   141f0:	83 c4 1c             	add    $0x1c,%esp
   141f3:	c3                   	ret    

000141f4 <reset_hd>:

static void reset_hd(int nr)
{
   141f4:	56                   	push   %esi
   141f5:	53                   	push   %ebx
   141f6:	83 ec 04             	sub    $0x4,%esp
	reset_controller();
   141f9:	e8 72 ff ff ff       	call   14170 <reset_controller>
	hd_out(nr,hd_info[nr].sect,hd_info[nr].sect,hd_info[nr].head-1,
		hd_info[nr].cyl,WIN_SPECIFY,&recal_intr);
   141fe:	8b 54 24 10          	mov    0x10(%esp),%edx
   14202:	89 d0                	mov    %edx,%eax
   14204:	01 c0                	add    %eax,%eax
   14206:	01 d0                	add    %edx,%eax
   14208:	c1 e0 03             	shl    $0x3,%eax
   1420b:	05 28 3d 02 00       	add    $0x23d28,%eax
   14210:	8b 00                	mov    (%eax),%eax
}

static void reset_hd(int nr)
{
	reset_controller();
	hd_out(nr,hd_info[nr].sect,hd_info[nr].sect,hd_info[nr].head-1,
   14212:	89 c6                	mov    %eax,%esi
   14214:	8b 54 24 10          	mov    0x10(%esp),%edx
   14218:	89 d0                	mov    %edx,%eax
   1421a:	01 c0                	add    %eax,%eax
   1421c:	01 d0                	add    %edx,%eax
   1421e:	c1 e0 03             	shl    $0x3,%eax
   14221:	05 20 3d 02 00       	add    $0x23d20,%eax
   14226:	8b 00                	mov    (%eax),%eax
   14228:	83 e8 01             	sub    $0x1,%eax
   1422b:	89 c3                	mov    %eax,%ebx
   1422d:	8b 54 24 10          	mov    0x10(%esp),%edx
   14231:	89 d0                	mov    %edx,%eax
   14233:	01 c0                	add    %eax,%eax
   14235:	01 d0                	add    %edx,%eax
   14237:	c1 e0 03             	shl    $0x3,%eax
   1423a:	05 24 3d 02 00       	add    $0x23d24,%eax
   1423f:	8b 00                	mov    (%eax),%eax
   14241:	89 c1                	mov    %eax,%ecx
   14243:	8b 54 24 10          	mov    0x10(%esp),%edx
   14247:	89 d0                	mov    %edx,%eax
   14249:	01 c0                	add    %eax,%eax
   1424b:	01 d0                	add    %edx,%eax
   1424d:	c1 e0 03             	shl    $0x3,%eax
   14250:	05 24 3d 02 00       	add    $0x23d24,%eax
   14255:	8b 00                	mov    (%eax),%eax
   14257:	89 c2                	mov    %eax,%edx
   14259:	8b 44 24 10          	mov    0x10(%esp),%eax
   1425d:	83 ec 04             	sub    $0x4,%esp
   14260:	68 00 44 01 00       	push   $0x14400
   14265:	68 91 00 00 00       	push   $0x91
   1426a:	56                   	push   %esi
   1426b:	53                   	push   %ebx
   1426c:	51                   	push   %ecx
   1426d:	52                   	push   %edx
   1426e:	50                   	push   %eax
   1426f:	e8 8a fd ff ff       	call   13ffe <hd_out>
   14274:	83 c4 20             	add    $0x20,%esp
		hd_info[nr].cyl,WIN_SPECIFY,&recal_intr);
}
   14277:	90                   	nop
   14278:	83 c4 04             	add    $0x4,%esp
   1427b:	5b                   	pop    %ebx
   1427c:	5e                   	pop    %esi
   1427d:	c3                   	ret    

0001427e <unexpected_hd_interrupt>:

void unexpected_hd_interrupt(void)
{
   1427e:	83 ec 0c             	sub    $0xc,%esp
	printk("Unexpected HD interrupt\n\r");
   14281:	83 ec 0c             	sub    $0xc,%esp
   14284:	68 bb 8f 01 00       	push   $0x18fbb
   14289:	e8 7f 45 ff ff       	call   880d <printk>
   1428e:	83 c4 10             	add    $0x10,%esp
}
   14291:	90                   	nop
   14292:	83 c4 0c             	add    $0xc,%esp
   14295:	c3                   	ret    

00014296 <bad_rw_intr>:

static void bad_rw_intr(void)
{
   14296:	83 ec 0c             	sub    $0xc,%esp
	if (++CURRENT->errors >= MAX_ERRORS)
   14299:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   1429e:	8b 50 08             	mov    0x8(%eax),%edx
   142a1:	83 c2 01             	add    $0x1,%edx
   142a4:	89 50 08             	mov    %edx,0x8(%eax)
   142a7:	8b 40 08             	mov    0x8(%eax),%eax
   142aa:	83 f8 06             	cmp    $0x6,%eax
   142ad:	7e 0d                	jle    142bc <bad_rw_intr+0x26>
		end_request(0);
   142af:	83 ec 0c             	sub    $0xc,%esp
   142b2:	6a 00                	push   $0x0
   142b4:	e8 3d f8 ff ff       	call   13af6 <end_request>
   142b9:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->errors > MAX_ERRORS/2)
   142bc:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   142c1:	8b 40 08             	mov    0x8(%eax),%eax
   142c4:	83 f8 03             	cmp    $0x3,%eax
   142c7:	7e 0a                	jle    142d3 <bad_rw_intr+0x3d>
		reset = 1;
   142c9:	c7 05 54 3d 02 00 01 	movl   $0x1,0x23d54
   142d0:	00 00 00 
}
   142d3:	90                   	nop
   142d4:	83 c4 0c             	add    $0xc,%esp
   142d7:	c3                   	ret    

000142d8 <read_intr>:

static void read_intr(void)
{
   142d8:	57                   	push   %edi
   142d9:	83 ec 08             	sub    $0x8,%esp
	if (win_result()) {
   142dc:	e8 bd fc ff ff       	call   13f9e <win_result>
   142e1:	85 c0                	test   %eax,%eax
   142e3:	74 0c                	je     142f1 <read_intr+0x19>
		bad_rw_intr();
   142e5:	e8 ac ff ff ff       	call   14296 <bad_rw_intr>
		do_hd_request();
   142ea:	e8 2c 01 00 00       	call   1441b <do_hd_request>
		return;
   142ef:	eb 7c                	jmp    1436d <read_intr+0x95>
	}
	port_read(HD_DATA,CURRENT->buffer,256);
   142f1:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   142f6:	8b 40 14             	mov    0x14(%eax),%eax
   142f9:	ba f0 01 00 00       	mov    $0x1f0,%edx
   142fe:	b9 00 01 00 00       	mov    $0x100,%ecx
   14303:	89 c7                	mov    %eax,%edi
   14305:	fc                   	cld    
   14306:	f3 66 6d             	rep insw (%dx),%es:(%edi)
	CURRENT->errors = 0;
   14309:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   1430e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	CURRENT->buffer += 512;
   14315:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   1431a:	8b 15 bc 3c 02 00    	mov    0x23cbc,%edx
   14320:	8b 52 14             	mov    0x14(%edx),%edx
   14323:	81 c2 00 02 00 00    	add    $0x200,%edx
   14329:	89 50 14             	mov    %edx,0x14(%eax)
	CURRENT->sector++;
   1432c:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   14331:	8b 50 0c             	mov    0xc(%eax),%edx
   14334:	83 c2 01             	add    $0x1,%edx
   14337:	89 50 0c             	mov    %edx,0xc(%eax)
	if (--CURRENT->nr_sectors) {
   1433a:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   1433f:	8b 50 10             	mov    0x10(%eax),%edx
   14342:	83 ea 01             	sub    $0x1,%edx
   14345:	89 50 10             	mov    %edx,0x10(%eax)
   14348:	8b 40 10             	mov    0x10(%eax),%eax
   1434b:	85 c0                	test   %eax,%eax
   1434d:	74 0c                	je     1435b <read_intr+0x83>
		do_hd = &read_intr;
   1434f:	c7 05 00 3d 02 00 d8 	movl   $0x142d8,0x23d00
   14356:	42 01 00 
		return;
   14359:	eb 12                	jmp    1436d <read_intr+0x95>
	}
	end_request(1);
   1435b:	83 ec 0c             	sub    $0xc,%esp
   1435e:	6a 01                	push   $0x1
   14360:	e8 91 f7 ff ff       	call   13af6 <end_request>
   14365:	83 c4 10             	add    $0x10,%esp
	do_hd_request();
   14368:	e8 ae 00 00 00       	call   1441b <do_hd_request>
}
   1436d:	83 c4 08             	add    $0x8,%esp
   14370:	5f                   	pop    %edi
   14371:	c3                   	ret    

00014372 <write_intr>:

static void write_intr(void)
{
   14372:	56                   	push   %esi
   14373:	83 ec 08             	sub    $0x8,%esp
	if (win_result()) {
   14376:	e8 23 fc ff ff       	call   13f9e <win_result>
   1437b:	85 c0                	test   %eax,%eax
   1437d:	74 0c                	je     1438b <write_intr+0x19>
		bad_rw_intr();
   1437f:	e8 12 ff ff ff       	call   14296 <bad_rw_intr>
		do_hd_request();
   14384:	e8 92 00 00 00       	call   1441b <do_hd_request>
		return;
   14389:	eb 70                	jmp    143fb <write_intr+0x89>
	}
	if (--CURRENT->nr_sectors) {
   1438b:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   14390:	8b 50 10             	mov    0x10(%eax),%edx
   14393:	83 ea 01             	sub    $0x1,%edx
   14396:	89 50 10             	mov    %edx,0x10(%eax)
   14399:	8b 40 10             	mov    0x10(%eax),%eax
   1439c:	85 c0                	test   %eax,%eax
   1439e:	74 49                	je     143e9 <write_intr+0x77>
		CURRENT->sector++;
   143a0:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   143a5:	8b 50 0c             	mov    0xc(%eax),%edx
   143a8:	83 c2 01             	add    $0x1,%edx
   143ab:	89 50 0c             	mov    %edx,0xc(%eax)
		CURRENT->buffer += 512;
   143ae:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   143b3:	8b 15 bc 3c 02 00    	mov    0x23cbc,%edx
   143b9:	8b 52 14             	mov    0x14(%edx),%edx
   143bc:	81 c2 00 02 00 00    	add    $0x200,%edx
   143c2:	89 50 14             	mov    %edx,0x14(%eax)
		do_hd = &write_intr;
   143c5:	c7 05 00 3d 02 00 72 	movl   $0x14372,0x23d00
   143cc:	43 01 00 
		port_write(HD_DATA,CURRENT->buffer,256);
   143cf:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   143d4:	8b 40 14             	mov    0x14(%eax),%eax
   143d7:	ba f0 01 00 00       	mov    $0x1f0,%edx
   143dc:	b9 00 01 00 00       	mov    $0x100,%ecx
   143e1:	89 c6                	mov    %eax,%esi
   143e3:	fc                   	cld    
   143e4:	f3 66 6f             	rep outsw %ds:(%esi),(%dx)
		return;
   143e7:	eb 12                	jmp    143fb <write_intr+0x89>
	}
	end_request(1);
   143e9:	83 ec 0c             	sub    $0xc,%esp
   143ec:	6a 01                	push   $0x1
   143ee:	e8 03 f7 ff ff       	call   13af6 <end_request>
   143f3:	83 c4 10             	add    $0x10,%esp
	do_hd_request();
   143f6:	e8 20 00 00 00       	call   1441b <do_hd_request>
}
   143fb:	83 c4 08             	add    $0x8,%esp
   143fe:	5e                   	pop    %esi
   143ff:	c3                   	ret    

00014400 <recal_intr>:

static void recal_intr(void)
{
   14400:	83 ec 0c             	sub    $0xc,%esp
	if (win_result())
   14403:	e8 96 fb ff ff       	call   13f9e <win_result>
   14408:	85 c0                	test   %eax,%eax
   1440a:	74 05                	je     14411 <recal_intr+0x11>
		bad_rw_intr();
   1440c:	e8 85 fe ff ff       	call   14296 <bad_rw_intr>
	do_hd_request();
   14411:	e8 05 00 00 00       	call   1441b <do_hd_request>
}
   14416:	90                   	nop
   14417:	83 c4 0c             	add    $0xc,%esp
   1441a:	c3                   	ret    

0001441b <do_hd_request>:

void do_hd_request(void)
{
   1441b:	56                   	push   %esi
   1441c:	83 ec 38             	sub    $0x38,%esp
	int i,r = 0;
   1441f:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
   14426:	00 
	unsigned int block,dev;
	unsigned int sec,head,cyl;
	unsigned int nsect;

	INIT_REQUEST;
   14427:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   1442c:	85 c0                	test   %eax,%eax
   1442e:	0f 84 c8 02 00 00    	je     146fc <do_hd_request+0x2e1>
   14434:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   14439:	8b 00                	mov    (%eax),%eax
   1443b:	c1 e8 08             	shr    $0x8,%eax
   1443e:	83 f8 03             	cmp    $0x3,%eax
   14441:	74 10                	je     14453 <do_hd_request+0x38>
   14443:	83 ec 0c             	sub    $0xc,%esp
   14446:	68 d8 8f 01 00       	push   $0x18fd8
   1444b:	e8 7e 43 ff ff       	call   87ce <panic>
   14450:	83 c4 10             	add    $0x10,%esp
   14453:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   14458:	8b 40 1c             	mov    0x1c(%eax),%eax
   1445b:	85 c0                	test   %eax,%eax
   1445d:	74 20                	je     1447f <do_hd_request+0x64>
   1445f:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   14464:	8b 40 1c             	mov    0x1c(%eax),%eax
   14467:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   1446b:	84 c0                	test   %al,%al
   1446d:	75 10                	jne    1447f <do_hd_request+0x64>
   1446f:	83 ec 0c             	sub    $0xc,%esp
   14472:	68 f9 8f 01 00       	push   $0x18ff9
   14477:	e8 52 43 ff ff       	call   87ce <panic>
   1447c:	83 c4 10             	add    $0x10,%esp
	dev = MINOR(CURRENT->dev);
   1447f:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   14484:	8b 00                	mov    (%eax),%eax
   14486:	25 ff 00 00 00       	and    $0xff,%eax
   1448b:	89 44 24 24          	mov    %eax,0x24(%esp)
	block = CURRENT->sector;
   1448f:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   14494:	8b 40 0c             	mov    0xc(%eax),%eax
   14497:	89 44 24 20          	mov    %eax,0x20(%esp)
	if (dev >= 5*NR_HD || (block+2) > (hd[dev].start_sect + hd[dev].nr_sects - 1)) {
   1449b:	8b 15 58 3d 02 00    	mov    0x23d58,%edx
   144a1:	89 d0                	mov    %edx,%eax
   144a3:	c1 e0 02             	shl    $0x2,%eax
   144a6:	01 d0                	add    %edx,%eax
   144a8:	3b 44 24 24          	cmp    0x24(%esp),%eax
   144ac:	76 26                	jbe    144d4 <do_hd_request+0xb9>
   144ae:	8b 44 24 20          	mov    0x20(%esp),%eax
   144b2:	8d 48 02             	lea    0x2(%eax),%ecx
   144b5:	8b 44 24 24          	mov    0x24(%esp),%eax
   144b9:	8b 14 c5 60 3d 02 00 	mov    0x23d60(,%eax,8),%edx
   144c0:	8b 44 24 24          	mov    0x24(%esp),%eax
   144c4:	8b 04 c5 64 3d 02 00 	mov    0x23d64(,%eax,8),%eax
   144cb:	01 d0                	add    %edx,%eax
   144cd:	83 e8 01             	sub    $0x1,%eax
   144d0:	39 c1                	cmp    %eax,%ecx
   144d2:	76 12                	jbe    144e6 <do_hd_request+0xcb>
		end_request(0);
   144d4:	83 ec 0c             	sub    $0xc,%esp
   144d7:	6a 00                	push   $0x0
   144d9:	e8 18 f6 ff ff       	call   13af6 <end_request>
   144de:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   144e1:	e9 41 ff ff ff       	jmp    14427 <do_hd_request+0xc>
	}
	block += hd[dev].start_sect;
   144e6:	8b 44 24 24          	mov    0x24(%esp),%eax
   144ea:	8b 04 c5 60 3d 02 00 	mov    0x23d60(,%eax,8),%eax
   144f1:	01 44 24 20          	add    %eax,0x20(%esp)
	dev /= 5;
   144f5:	8b 44 24 24          	mov    0x24(%esp),%eax
   144f9:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   144fe:	f7 e2                	mul    %edx
   14500:	89 d0                	mov    %edx,%eax
   14502:	c1 e8 02             	shr    $0x2,%eax
   14505:	89 44 24 24          	mov    %eax,0x24(%esp)
	__asm__("divl %4":"=a" (block),"=d" (sec):"0" (block),"1" (0),
		"r" (hd_info[dev].sect));
   14509:	8b 54 24 24          	mov    0x24(%esp),%edx
   1450d:	89 d0                	mov    %edx,%eax
   1450f:	01 c0                	add    %eax,%eax
   14511:	01 d0                	add    %edx,%eax
   14513:	c1 e0 03             	shl    $0x3,%eax
   14516:	05 24 3d 02 00       	add    $0x23d24,%eax
   1451b:	8b 08                	mov    (%eax),%ecx
		end_request(0);
		goto repeat;
	}
	block += hd[dev].start_sect;
	dev /= 5;
	__asm__("divl %4":"=a" (block),"=d" (sec):"0" (block),"1" (0),
   1451d:	8b 44 24 20          	mov    0x20(%esp),%eax
   14521:	ba 00 00 00 00       	mov    $0x0,%edx
   14526:	f7 f1                	div    %ecx
   14528:	89 44 24 20          	mov    %eax,0x20(%esp)
   1452c:	89 54 24 1c          	mov    %edx,0x1c(%esp)
		"r" (hd_info[dev].sect));
	__asm__("divl %4":"=a" (cyl),"=d" (head):"0" (block),"1" (0),
		"r" (hd_info[dev].head));
   14530:	8b 54 24 24          	mov    0x24(%esp),%edx
   14534:	89 d0                	mov    %edx,%eax
   14536:	01 c0                	add    %eax,%eax
   14538:	01 d0                	add    %edx,%eax
   1453a:	c1 e0 03             	shl    $0x3,%eax
   1453d:	05 20 3d 02 00       	add    $0x23d20,%eax
   14542:	8b 08                	mov    (%eax),%ecx
	}
	block += hd[dev].start_sect;
	dev /= 5;
	__asm__("divl %4":"=a" (block),"=d" (sec):"0" (block),"1" (0),
		"r" (hd_info[dev].sect));
	__asm__("divl %4":"=a" (cyl),"=d" (head):"0" (block),"1" (0),
   14544:	8b 44 24 20          	mov    0x20(%esp),%eax
   14548:	ba 00 00 00 00       	mov    $0x0,%edx
   1454d:	f7 f1                	div    %ecx
   1454f:	89 44 24 18          	mov    %eax,0x18(%esp)
   14553:	89 54 24 14          	mov    %edx,0x14(%esp)
		"r" (hd_info[dev].head));
	sec++;
   14557:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
	nsect = CURRENT->nr_sectors;
   1455c:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   14561:	8b 40 10             	mov    0x10(%eax),%eax
   14564:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (reset) {
   14568:	a1 54 3d 02 00       	mov    0x23d54,%eax
   1456d:	85 c0                	test   %eax,%eax
   1456f:	74 43                	je     145b4 <do_hd_request+0x199>
		reset = 0;
   14571:	c7 05 54 3d 02 00 00 	movl   $0x0,0x23d54
   14578:	00 00 00 
		recalibrate = 1;
   1457b:	c7 05 50 3d 02 00 01 	movl   $0x1,0x23d50
   14582:	00 00 00 
		reset_hd(CURRENT_DEV);
   14585:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   1458a:	8b 00                	mov    (%eax),%eax
   1458c:	0f b6 c8             	movzbl %al,%ecx
   1458f:	ba 67 66 66 66       	mov    $0x66666667,%edx
   14594:	89 c8                	mov    %ecx,%eax
   14596:	f7 ea                	imul   %edx
   14598:	d1 fa                	sar    %edx
   1459a:	89 c8                	mov    %ecx,%eax
   1459c:	c1 f8 1f             	sar    $0x1f,%eax
   1459f:	29 c2                	sub    %eax,%edx
   145a1:	89 d0                	mov    %edx,%eax
   145a3:	83 ec 0c             	sub    $0xc,%esp
   145a6:	50                   	push   %eax
   145a7:	e8 48 fc ff ff       	call   141f4 <reset_hd>
   145ac:	83 c4 10             	add    $0x10,%esp
		return;
   145af:	e9 49 01 00 00       	jmp    146fd <do_hd_request+0x2e2>
	}
	if (recalibrate) {
   145b4:	a1 50 3d 02 00       	mov    0x23d50,%eax
   145b9:	85 c0                	test   %eax,%eax
   145bb:	74 58                	je     14615 <do_hd_request+0x1fa>
		recalibrate = 0;
   145bd:	c7 05 50 3d 02 00 00 	movl   $0x0,0x23d50
   145c4:	00 00 00 
		hd_out(dev,hd_info[CURRENT_DEV].sect,0,0,0,
   145c7:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   145cc:	8b 00                	mov    (%eax),%eax
   145ce:	0f b6 c8             	movzbl %al,%ecx
   145d1:	ba 67 66 66 66       	mov    $0x66666667,%edx
   145d6:	89 c8                	mov    %ecx,%eax
   145d8:	f7 ea                	imul   %edx
   145da:	d1 fa                	sar    %edx
   145dc:	89 c8                	mov    %ecx,%eax
   145de:	c1 f8 1f             	sar    $0x1f,%eax
   145e1:	29 c2                	sub    %eax,%edx
   145e3:	89 d0                	mov    %edx,%eax
   145e5:	01 c0                	add    %eax,%eax
   145e7:	01 d0                	add    %edx,%eax
   145e9:	c1 e0 03             	shl    $0x3,%eax
   145ec:	05 24 3d 02 00       	add    $0x23d24,%eax
   145f1:	8b 00                	mov    (%eax),%eax
   145f3:	83 ec 04             	sub    $0x4,%esp
   145f6:	68 00 44 01 00       	push   $0x14400
   145fb:	6a 10                	push   $0x10
   145fd:	6a 00                	push   $0x0
   145ff:	6a 00                	push   $0x0
   14601:	6a 00                	push   $0x0
   14603:	50                   	push   %eax
   14604:	ff 74 24 40          	pushl  0x40(%esp)
   14608:	e8 f1 f9 ff ff       	call   13ffe <hd_out>
   1460d:	83 c4 20             	add    $0x20,%esp
			WIN_RESTORE,&recal_intr);
		return;
   14610:	e9 e8 00 00 00       	jmp    146fd <do_hd_request+0x2e2>
	}	
	if (CURRENT->cmd == WRITE) {
   14615:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   1461a:	8b 40 04             	mov    0x4(%eax),%eax
   1461d:	83 f8 01             	cmp    $0x1,%eax
   14620:	0f 85 90 00 00 00    	jne    146b6 <do_hd_request+0x29b>
		hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&write_intr);
   14626:	83 ec 04             	sub    $0x4,%esp
   14629:	68 72 43 01 00       	push   $0x14372
   1462e:	6a 30                	push   $0x30
   14630:	ff 74 24 24          	pushl  0x24(%esp)
   14634:	ff 74 24 24          	pushl  0x24(%esp)
   14638:	ff 74 24 30          	pushl  0x30(%esp)
   1463c:	ff 74 24 28          	pushl  0x28(%esp)
   14640:	ff 74 24 40          	pushl  0x40(%esp)
   14644:	e8 b5 f9 ff ff       	call   13ffe <hd_out>
   14649:	83 c4 20             	add    $0x20,%esp
		for(i=0 ; i<3000 && !(r=inb_p(HD_STATUS)&DRQ_STAT) ; i++)
   1464c:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
   14653:	00 
   14654:	eb 05                	jmp    1465b <do_hd_request+0x240>
   14656:	83 44 24 2c 01       	addl   $0x1,0x2c(%esp)
   1465b:	81 7c 24 2c b7 0b 00 	cmpl   $0xbb7,0x2c(%esp)
   14662:	00 
   14663:	7f 26                	jg     1468b <do_hd_request+0x270>
   14665:	b8 f7 01 00 00       	mov    $0x1f7,%eax
   1466a:	89 c2                	mov    %eax,%edx
   1466c:	ec                   	in     (%dx),%al
   1466d:	eb 00                	jmp    1466f <do_hd_request+0x254>
   1466f:	eb 00                	jmp    14671 <do_hd_request+0x256>
   14671:	88 44 24 0f          	mov    %al,0xf(%esp)
   14675:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1467a:	0f b6 c0             	movzbl %al,%eax
   1467d:	83 e0 08             	and    $0x8,%eax
   14680:	89 44 24 28          	mov    %eax,0x28(%esp)
   14684:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   14689:	74 cb                	je     14656 <do_hd_request+0x23b>
			/* nothing */ ;
		if (!r) {
   1468b:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   14690:	75 0a                	jne    1469c <do_hd_request+0x281>
			bad_rw_intr();
   14692:	e8 ff fb ff ff       	call   14296 <bad_rw_intr>
			goto repeat;
   14697:	e9 8b fd ff ff       	jmp    14427 <do_hd_request+0xc>
		}
		port_write(HD_DATA,CURRENT->buffer,256);
   1469c:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   146a1:	8b 40 14             	mov    0x14(%eax),%eax
   146a4:	ba f0 01 00 00       	mov    $0x1f0,%edx
   146a9:	b9 00 01 00 00       	mov    $0x100,%ecx
   146ae:	89 c6                	mov    %eax,%esi
   146b0:	fc                   	cld    
   146b1:	f3 66 6f             	rep outsw %ds:(%esi),(%dx)
   146b4:	eb 47                	jmp    146fd <do_hd_request+0x2e2>
	} else if (CURRENT->cmd == READ) {
   146b6:	a1 bc 3c 02 00       	mov    0x23cbc,%eax
   146bb:	8b 40 04             	mov    0x4(%eax),%eax
   146be:	85 c0                	test   %eax,%eax
   146c0:	75 28                	jne    146ea <do_hd_request+0x2cf>
		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&read_intr);
   146c2:	83 ec 04             	sub    $0x4,%esp
   146c5:	68 d8 42 01 00       	push   $0x142d8
   146ca:	6a 20                	push   $0x20
   146cc:	ff 74 24 24          	pushl  0x24(%esp)
   146d0:	ff 74 24 24          	pushl  0x24(%esp)
   146d4:	ff 74 24 30          	pushl  0x30(%esp)
   146d8:	ff 74 24 28          	pushl  0x28(%esp)
   146dc:	ff 74 24 40          	pushl  0x40(%esp)
   146e0:	e8 19 f9 ff ff       	call   13ffe <hd_out>
   146e5:	83 c4 20             	add    $0x20,%esp
   146e8:	eb 13                	jmp    146fd <do_hd_request+0x2e2>
	} else
		panic("unknown hd-command");
   146ea:	83 ec 0c             	sub    $0xc,%esp
   146ed:	68 14 90 01 00       	push   $0x19014
   146f2:	e8 d7 40 ff ff       	call   87ce <panic>
   146f7:	83 c4 10             	add    $0x10,%esp
   146fa:	eb 01                	jmp    146fd <do_hd_request+0x2e2>
	int i,r = 0;
	unsigned int block,dev;
	unsigned int sec,head,cyl;
	unsigned int nsect;

	INIT_REQUEST;
   146fc:	90                   	nop
		port_write(HD_DATA,CURRENT->buffer,256);
	} else if (CURRENT->cmd == READ) {
		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&read_intr);
	} else
		panic("unknown hd-command");
}
   146fd:	83 c4 38             	add    $0x38,%esp
   14700:	5e                   	pop    %esi
   14701:	c3                   	ret    

00014702 <hd_init>:

void hd_init(void)
{
   14702:	53                   	push   %ebx
   14703:	83 ec 10             	sub    $0x10,%esp
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   14706:	c7 05 b8 3c 02 00 1b 	movl   $0x1441b,0x23cb8
   1470d:	44 01 00 
	set_intr_gate(0x2E,&hd_interrupt);
   14710:	b9 28 56 00 00       	mov    $0x5628,%ecx
   14715:	bb 2c 56 00 00       	mov    $0x562c,%ebx
   1471a:	ba 94 77 00 00       	mov    $0x7794,%edx
   1471f:	b8 00 00 08 00       	mov    $0x80000,%eax
   14724:	66 89 d0             	mov    %dx,%ax
   14727:	66 ba 00 8e          	mov    $0x8e00,%dx
   1472b:	89 01                	mov    %eax,(%ecx)
   1472d:	89 13                	mov    %edx,(%ebx)
	outb_p(inb_p(0x21)&0xfb,0x21);
   1472f:	b8 21 00 00 00       	mov    $0x21,%eax
   14734:	89 c2                	mov    %eax,%edx
   14736:	ec                   	in     (%dx),%al
   14737:	eb 00                	jmp    14739 <hd_init+0x37>
   14739:	eb 00                	jmp    1473b <hd_init+0x39>
   1473b:	88 44 24 0f          	mov    %al,0xf(%esp)
   1473f:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   14744:	0f b6 c0             	movzbl %al,%eax
   14747:	25 fb 00 00 00       	and    $0xfb,%eax
   1474c:	ba 21 00 00 00       	mov    $0x21,%edx
   14751:	ee                   	out    %al,(%dx)
   14752:	eb 00                	jmp    14754 <hd_init+0x52>
   14754:	eb 00                	jmp    14756 <hd_init+0x54>
	outb(inb_p(0xA1)&0xbf,0xA1);
   14756:	b8 a1 00 00 00       	mov    $0xa1,%eax
   1475b:	89 c2                	mov    %eax,%edx
   1475d:	ec                   	in     (%dx),%al
   1475e:	eb 00                	jmp    14760 <hd_init+0x5e>
   14760:	eb 00                	jmp    14762 <hd_init+0x60>
   14762:	88 44 24 0e          	mov    %al,0xe(%esp)
   14766:	0f b6 44 24 0e       	movzbl 0xe(%esp),%eax
   1476b:	0f b6 c0             	movzbl %al,%eax
   1476e:	25 bf 00 00 00       	and    $0xbf,%eax
   14773:	ba a1 00 00 00       	mov    $0xa1,%edx
   14778:	ee                   	out    %al,(%dx)
}
   14779:	90                   	nop
   1477a:	83 c4 10             	add    $0x10,%esp
   1477d:	5b                   	pop    %ebx
   1477e:	c3                   	ret    

0001477f <memcpy>:
	);
return __res;
}

static inline void * memcpy(void * dest,const void * src, int n)
{
   1477f:	57                   	push   %edi
   14780:	56                   	push   %esi
   14781:	53                   	push   %ebx
__asm__ ("cld\n\t"
   14782:	8b 44 24 18          	mov    0x18(%esp),%eax
   14786:	8b 54 24 14          	mov    0x14(%esp),%edx
   1478a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   1478e:	89 c1                	mov    %eax,%ecx
   14790:	89 d6                	mov    %edx,%esi
   14792:	89 df                	mov    %ebx,%edi
   14794:	fc                   	cld    
   14795:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	"rep\n\t"
	"movsb"
	::"c" (n),"S" (src),"D" (dest)
	);
return dest;
   14797:	8b 44 24 10          	mov    0x10(%esp),%eax
}
   1479b:	5b                   	pop    %ebx
   1479c:	5e                   	pop    %esi
   1479d:	5f                   	pop    %edi
   1479e:	c3                   	ret    

0001479f <unlock_buffer>:
void (*DEVICE_INTR)(void) = NULL;
#endif
static void (DEVICE_REQUEST)(void);

static inline void unlock_buffer(struct buffer_head * bh)
{
   1479f:	83 ec 0c             	sub    $0xc,%esp
	if (!bh->b_lock)
   147a2:	8b 44 24 10          	mov    0x10(%esp),%eax
   147a6:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   147aa:	84 c0                	test   %al,%al
   147ac:	75 10                	jne    147be <unlock_buffer+0x1f>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   147ae:	83 ec 0c             	sub    $0xc,%esp
   147b1:	68 28 90 01 00       	push   $0x19028
   147b6:	e8 52 40 ff ff       	call   880d <printk>
   147bb:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   147be:	8b 44 24 10          	mov    0x10(%esp),%eax
   147c2:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	wake_up(&bh->b_wait);
   147c6:	8b 44 24 10          	mov    0x10(%esp),%eax
   147ca:	83 c0 10             	add    $0x10,%eax
   147cd:	83 ec 0c             	sub    $0xc,%esp
   147d0:	50                   	push   %eax
   147d1:	e8 a3 27 ff ff       	call   6f79 <wake_up>
   147d6:	83 c4 10             	add    $0x10,%esp
}
   147d9:	90                   	nop
   147da:	83 c4 0c             	add    $0xc,%esp
   147dd:	c3                   	ret    

000147de <end_request>:

static inline void end_request(int uptodate)
{
   147de:	83 ec 0c             	sub    $0xc,%esp
	DEVICE_OFF(CURRENT->dev);
	if (CURRENT->bh) {
   147e1:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   147e6:	8b 40 1c             	mov    0x1c(%eax),%eax
   147e9:	85 c0                	test   %eax,%eax
   147eb:	74 23                	je     14810 <end_request+0x32>
		CURRENT->bh->b_uptodate = uptodate;
   147ed:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   147f2:	8b 40 1c             	mov    0x1c(%eax),%eax
   147f5:	8b 54 24 10          	mov    0x10(%esp),%edx
   147f9:	88 50 0a             	mov    %dl,0xa(%eax)
		unlock_buffer(CURRENT->bh);
   147fc:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   14801:	8b 40 1c             	mov    0x1c(%eax),%eax
   14804:	83 ec 0c             	sub    $0xc,%esp
   14807:	50                   	push   %eax
   14808:	e8 92 ff ff ff       	call   1479f <unlock_buffer>
   1480d:	83 c4 10             	add    $0x10,%esp
	}
	if (!uptodate) {
   14810:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   14815:	75 34                	jne    1484b <end_request+0x6d>
		printk(DEVICE_NAME " I/O error\n\r");
   14817:	83 ec 0c             	sub    $0xc,%esp
   1481a:	68 4d 90 01 00       	push   $0x1904d
   1481f:	e8 e9 3f ff ff       	call   880d <printk>
   14824:	83 c4 10             	add    $0x10,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
			CURRENT->bh->b_blocknr);
   14827:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   1482c:	8b 40 1c             	mov    0x1c(%eax),%eax
		CURRENT->bh->b_uptodate = uptodate;
		unlock_buffer(CURRENT->bh);
	}
	if (!uptodate) {
		printk(DEVICE_NAME " I/O error\n\r");
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   1482f:	8b 50 04             	mov    0x4(%eax),%edx
   14832:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   14837:	8b 00                	mov    (%eax),%eax
   14839:	83 ec 04             	sub    $0x4,%esp
   1483c:	52                   	push   %edx
   1483d:	50                   	push   %eax
   1483e:	68 61 90 01 00       	push   $0x19061
   14843:	e8 c5 3f ff ff       	call   880d <printk>
   14848:	83 c4 10             	add    $0x10,%esp
			CURRENT->bh->b_blocknr);
	}
	wake_up(&CURRENT->waiting);
   1484b:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   14850:	83 c0 18             	add    $0x18,%eax
   14853:	83 ec 0c             	sub    $0xc,%esp
   14856:	50                   	push   %eax
   14857:	e8 1d 27 ff ff       	call   6f79 <wake_up>
   1485c:	83 c4 10             	add    $0x10,%esp
	wake_up(&wait_for_request);
   1485f:	83 ec 0c             	sub    $0xc,%esp
   14862:	68 80 3c 02 00       	push   $0x23c80
   14867:	e8 0d 27 ff ff       	call   6f79 <wake_up>
   1486c:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   1486f:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   14874:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   1487a:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   1487f:	8b 40 20             	mov    0x20(%eax),%eax
   14882:	a3 ac 3c 02 00       	mov    %eax,0x23cac
}
   14887:	90                   	nop
   14888:	83 c4 0c             	add    $0xc,%esp
   1488b:	c3                   	ret    

0001488c <do_rd_request>:

char	*rd_start;
int	rd_length = 0;

void do_rd_request(void)
{
   1488c:	83 ec 1c             	sub    $0x1c,%esp
	int	len;
	char	*addr;

	INIT_REQUEST;
   1488f:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   14894:	85 c0                	test   %eax,%eax
   14896:	0f 84 25 01 00 00    	je     149c1 <do_rd_request+0x135>
   1489c:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   148a1:	8b 00                	mov    (%eax),%eax
   148a3:	c1 e8 08             	shr    $0x8,%eax
   148a6:	83 f8 01             	cmp    $0x1,%eax
   148a9:	74 10                	je     148bb <do_rd_request+0x2f>
   148ab:	83 ec 0c             	sub    $0xc,%esp
   148ae:	68 78 90 01 00       	push   $0x19078
   148b3:	e8 16 3f ff ff       	call   87ce <panic>
   148b8:	83 c4 10             	add    $0x10,%esp
   148bb:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   148c0:	8b 40 1c             	mov    0x1c(%eax),%eax
   148c3:	85 c0                	test   %eax,%eax
   148c5:	74 20                	je     148e7 <do_rd_request+0x5b>
   148c7:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   148cc:	8b 40 1c             	mov    0x1c(%eax),%eax
   148cf:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   148d3:	84 c0                	test   %al,%al
   148d5:	75 10                	jne    148e7 <do_rd_request+0x5b>
   148d7:	83 ec 0c             	sub    $0xc,%esp
   148da:	68 98 90 01 00       	push   $0x19098
   148df:	e8 ea 3e ff ff       	call   87ce <panic>
   148e4:	83 c4 10             	add    $0x10,%esp
	addr = rd_start + (CURRENT->sector << 9);
   148e7:	8b 15 60 5f 02 00    	mov    0x25f60,%edx
   148ed:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   148f2:	8b 40 0c             	mov    0xc(%eax),%eax
   148f5:	c1 e0 09             	shl    $0x9,%eax
   148f8:	01 d0                	add    %edx,%eax
   148fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
	len = CURRENT->nr_sectors << 9;
   148fe:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   14903:	8b 40 10             	mov    0x10(%eax),%eax
   14906:	c1 e0 09             	shl    $0x9,%eax
   14909:	89 44 24 08          	mov    %eax,0x8(%esp)
	if ((MINOR(CURRENT->dev) != 1) || (addr+len > rd_start+rd_length)) {
   1490d:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   14912:	8b 00                	mov    (%eax),%eax
   14914:	0f b6 c0             	movzbl %al,%eax
   14917:	83 f8 01             	cmp    $0x1,%eax
   1491a:	75 1c                	jne    14938 <do_rd_request+0xac>
   1491c:	8b 54 24 08          	mov    0x8(%esp),%edx
   14920:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14924:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   14927:	a1 60 5f 02 00       	mov    0x25f60,%eax
   1492c:	8b 15 b0 3d 02 00    	mov    0x23db0,%edx
   14932:	01 d0                	add    %edx,%eax
   14934:	39 c1                	cmp    %eax,%ecx
   14936:	76 12                	jbe    1494a <do_rd_request+0xbe>
		end_request(0);
   14938:	83 ec 0c             	sub    $0xc,%esp
   1493b:	6a 00                	push   $0x0
   1493d:	e8 9c fe ff ff       	call   147de <end_request>
   14942:	83 c4 10             	add    $0x10,%esp
		goto repeat;
   14945:	e9 45 ff ff ff       	jmp    1488f <do_rd_request+0x3>
	}
	if (CURRENT-> cmd == WRITE) {
   1494a:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   1494f:	8b 40 04             	mov    0x4(%eax),%eax
   14952:	83 f8 01             	cmp    $0x1,%eax
   14955:	75 1e                	jne    14975 <do_rd_request+0xe9>
		(void) memcpy(addr,
			      CURRENT->buffer,
   14957:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   1495c:	8b 40 14             	mov    0x14(%eax),%eax
	if ((MINOR(CURRENT->dev) != 1) || (addr+len > rd_start+rd_length)) {
		end_request(0);
		goto repeat;
	}
	if (CURRENT-> cmd == WRITE) {
		(void) memcpy(addr,
   1495f:	83 ec 04             	sub    $0x4,%esp
   14962:	ff 74 24 0c          	pushl  0xc(%esp)
   14966:	50                   	push   %eax
   14967:	ff 74 24 18          	pushl  0x18(%esp)
   1496b:	e8 0f fe ff ff       	call   1477f <memcpy>
   14970:	83 c4 10             	add    $0x10,%esp
   14973:	eb 3a                	jmp    149af <do_rd_request+0x123>
			      CURRENT->buffer,
			      len);
	} else if (CURRENT->cmd == READ) {
   14975:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   1497a:	8b 40 04             	mov    0x4(%eax),%eax
   1497d:	85 c0                	test   %eax,%eax
   1497f:	75 1e                	jne    1499f <do_rd_request+0x113>
		(void) memcpy(CURRENT->buffer, 
   14981:	a1 ac 3c 02 00       	mov    0x23cac,%eax
   14986:	8b 40 14             	mov    0x14(%eax),%eax
   14989:	83 ec 04             	sub    $0x4,%esp
   1498c:	ff 74 24 0c          	pushl  0xc(%esp)
   14990:	ff 74 24 14          	pushl  0x14(%esp)
   14994:	50                   	push   %eax
   14995:	e8 e5 fd ff ff       	call   1477f <memcpy>
   1499a:	83 c4 10             	add    $0x10,%esp
   1499d:	eb 10                	jmp    149af <do_rd_request+0x123>
			      addr,
			      len);
	} else
		panic("unknown ramdisk-command");
   1499f:	83 ec 0c             	sub    $0xc,%esp
   149a2:	68 b2 90 01 00       	push   $0x190b2
   149a7:	e8 22 3e ff ff       	call   87ce <panic>
   149ac:	83 c4 10             	add    $0x10,%esp
	end_request(1);
   149af:	83 ec 0c             	sub    $0xc,%esp
   149b2:	6a 01                	push   $0x1
   149b4:	e8 25 fe ff ff       	call   147de <end_request>
   149b9:	83 c4 10             	add    $0x10,%esp
	goto repeat;
   149bc:	e9 ce fe ff ff       	jmp    1488f <do_rd_request+0x3>
void do_rd_request(void)
{
	int	len;
	char	*addr;

	INIT_REQUEST;
   149c1:	90                   	nop
			      len);
	} else
		panic("unknown ramdisk-command");
	end_request(1);
	goto repeat;
}
   149c2:	83 c4 1c             	add    $0x1c,%esp
   149c5:	c3                   	ret    

000149c6 <rd_init>:

/*
 * Returns amount of memory which needs to be reserved.
 */
long rd_init(long mem_start, int length)
{
   149c6:	83 ec 10             	sub    $0x10,%esp
	int	i;
	char	*cp;

	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   149c9:	c7 05 a8 3c 02 00 8c 	movl   $0x1488c,0x23ca8
   149d0:	48 01 00 
	rd_start = (char *) mem_start;
   149d3:	8b 44 24 14          	mov    0x14(%esp),%eax
   149d7:	a3 60 5f 02 00       	mov    %eax,0x25f60
	rd_length = length;
   149dc:	8b 44 24 18          	mov    0x18(%esp),%eax
   149e0:	a3 b0 3d 02 00       	mov    %eax,0x23db0
	cp = rd_start;
   149e5:	a1 60 5f 02 00       	mov    0x25f60,%eax
   149ea:	89 44 24 08          	mov    %eax,0x8(%esp)
	for (i=0; i < length; i++)
   149ee:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   149f5:	00 
   149f6:	eb 13                	jmp    14a0b <rd_init+0x45>
		*cp++ = '\0';
   149f8:	8b 44 24 08          	mov    0x8(%esp),%eax
   149fc:	8d 50 01             	lea    0x1(%eax),%edx
   149ff:	89 54 24 08          	mov    %edx,0x8(%esp)
   14a03:	c6 00 00             	movb   $0x0,(%eax)

	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
	rd_start = (char *) mem_start;
	rd_length = length;
	cp = rd_start;
	for (i=0; i < length; i++)
   14a06:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   14a0b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14a0f:	3b 44 24 18          	cmp    0x18(%esp),%eax
   14a13:	7c e3                	jl     149f8 <rd_init+0x32>
		*cp++ = '\0';
	return(length);
   14a15:	8b 44 24 18          	mov    0x18(%esp),%eax
}
   14a19:	83 c4 10             	add    $0x10,%esp
   14a1c:	c3                   	ret    

00014a1d <rd_load>:
 * If the root device is the ram disk, try to load it.
 * In order to do this, the root device is originally set to the
 * floppy, and we later change it to be ram disk.
 */
void rd_load(void)
{
   14a1d:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	struct buffer_head *bh;
	struct super_block	s;
	int		block = ramdisk_start;
   14a23:	c7 44 24 78 00 01 00 	movl   $0x100,0x78(%esp)
   14a2a:	00 
	int		i = 1;
   14a2b:	c7 44 24 74 01 00 00 	movl   $0x1,0x74(%esp)
   14a32:	00 
	int		nblocks;
	char		*cp;		/* Move pointer */
	
	if (!rd_length)
   14a33:	a1 b0 3d 02 00       	mov    0x23db0,%eax
   14a38:	85 c0                	test   %eax,%eax
   14a3a:	0f 84 23 02 00 00    	je     14c63 <rd_load+0x246>
		return;
	printk("Ram disk: %d bytes, starting at 0x%x\n", rd_length,
   14a40:	a1 60 5f 02 00       	mov    0x25f60,%eax
   14a45:	89 c2                	mov    %eax,%edx
   14a47:	a1 b0 3d 02 00       	mov    0x23db0,%eax
   14a4c:	83 ec 04             	sub    $0x4,%esp
   14a4f:	52                   	push   %edx
   14a50:	50                   	push   %eax
   14a51:	68 cc 90 01 00       	push   $0x190cc
   14a56:	e8 b2 3d ff ff       	call   880d <printk>
   14a5b:	83 c4 10             	add    $0x10,%esp
		(int) rd_start);
	if (MAJOR(ROOT_DEV) != 2)
   14a5e:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
   14a63:	c1 e8 08             	shr    $0x8,%eax
   14a66:	83 f8 02             	cmp    $0x2,%eax
   14a69:	0f 85 f7 01 00 00    	jne    14c66 <rd_load+0x249>
		return;
	bh = breada(ROOT_DEV,block+1,block,block+2,-1);
   14a6f:	8b 44 24 78          	mov    0x78(%esp),%eax
   14a73:	8d 48 02             	lea    0x2(%eax),%ecx
   14a76:	8b 44 24 78          	mov    0x78(%esp),%eax
   14a7a:	8d 50 01             	lea    0x1(%eax),%edx
   14a7d:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
   14a82:	83 ec 0c             	sub    $0xc,%esp
   14a85:	6a ff                	push   $0xffffffff
   14a87:	51                   	push   %ecx
   14a88:	ff b4 24 8c 00 00 00 	pushl  0x8c(%esp)
   14a8f:	52                   	push   %edx
   14a90:	50                   	push   %eax
   14a91:	e8 0c 87 ff ff       	call   d1a2 <breada>
   14a96:	83 c4 20             	add    $0x20,%esp
   14a99:	89 44 24 7c          	mov    %eax,0x7c(%esp)
	if (!bh) {
   14a9d:	83 7c 24 7c 00       	cmpl   $0x0,0x7c(%esp)
   14aa2:	75 15                	jne    14ab9 <rd_load+0x9c>
		printk("Disk error while looking for ramdisk!\n");
   14aa4:	83 ec 0c             	sub    $0xc,%esp
   14aa7:	68 f4 90 01 00       	push   $0x190f4
   14aac:	e8 5c 3d ff ff       	call   880d <printk>
   14ab1:	83 c4 10             	add    $0x10,%esp
		return;
   14ab4:	e9 b1 01 00 00       	jmp    14c6a <rd_load+0x24d>
	}
	*((struct d_super_block *) &s) = *((struct d_super_block *) bh->b_data);
   14ab9:	89 e0                	mov    %esp,%eax
   14abb:	8b 54 24 7c          	mov    0x7c(%esp),%edx
   14abf:	8b 12                	mov    (%edx),%edx
   14ac1:	8b 0a                	mov    (%edx),%ecx
   14ac3:	89 08                	mov    %ecx,(%eax)
   14ac5:	8b 4a 04             	mov    0x4(%edx),%ecx
   14ac8:	89 48 04             	mov    %ecx,0x4(%eax)
   14acb:	8b 4a 08             	mov    0x8(%edx),%ecx
   14ace:	89 48 08             	mov    %ecx,0x8(%eax)
   14ad1:	8b 4a 0c             	mov    0xc(%edx),%ecx
   14ad4:	89 48 0c             	mov    %ecx,0xc(%eax)
   14ad7:	8b 52 10             	mov    0x10(%edx),%edx
   14ada:	89 50 10             	mov    %edx,0x10(%eax)
	brelse(bh);
   14add:	83 ec 0c             	sub    $0xc,%esp
   14ae0:	ff b4 24 88 00 00 00 	pushl  0x88(%esp)
   14ae7:	e8 a4 84 ff ff       	call   cf90 <brelse>
   14aec:	83 c4 10             	add    $0x10,%esp
	if (s.s_magic != SUPER_MAGIC)
   14aef:	0f b7 44 24 10       	movzwl 0x10(%esp),%eax
   14af4:	66 3d 7f 13          	cmp    $0x137f,%ax
   14af8:	0f 85 6b 01 00 00    	jne    14c69 <rd_load+0x24c>
		/* No ram disk image present, assume normal floppy boot */
		return;
	nblocks = s.s_nzones << s.s_log_zone_size;
   14afe:	0f b7 44 24 02       	movzwl 0x2(%esp),%eax
   14b03:	0f b7 d0             	movzwl %ax,%edx
   14b06:	0f b7 44 24 0a       	movzwl 0xa(%esp),%eax
   14b0b:	0f b7 c0             	movzwl %ax,%eax
   14b0e:	89 c1                	mov    %eax,%ecx
   14b10:	d3 e2                	shl    %cl,%edx
   14b12:	89 d0                	mov    %edx,%eax
   14b14:	89 44 24 70          	mov    %eax,0x70(%esp)
	if (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {
   14b18:	a1 b0 3d 02 00       	mov    0x23db0,%eax
   14b1d:	c1 f8 0a             	sar    $0xa,%eax
   14b20:	3b 44 24 70          	cmp    0x70(%esp),%eax
   14b24:	7d 22                	jge    14b48 <rd_load+0x12b>
		printk("Ram disk image too big!  (%d blocks, %d avail)\n", 
   14b26:	a1 b0 3d 02 00       	mov    0x23db0,%eax
   14b2b:	c1 f8 0a             	sar    $0xa,%eax
   14b2e:	83 ec 04             	sub    $0x4,%esp
   14b31:	50                   	push   %eax
   14b32:	ff 74 24 78          	pushl  0x78(%esp)
   14b36:	68 1c 91 01 00       	push   $0x1911c
   14b3b:	e8 cd 3c ff ff       	call   880d <printk>
   14b40:	83 c4 10             	add    $0x10,%esp
			nblocks, rd_length >> BLOCK_SIZE_BITS);
		return;
   14b43:	e9 22 01 00 00       	jmp    14c6a <rd_load+0x24d>
	}
	printk("Loading %d bytes into ram disk... 0000k", 
   14b48:	8b 44 24 70          	mov    0x70(%esp),%eax
   14b4c:	c1 e0 0a             	shl    $0xa,%eax
   14b4f:	83 ec 08             	sub    $0x8,%esp
   14b52:	50                   	push   %eax
   14b53:	68 4c 91 01 00       	push   $0x1914c
   14b58:	e8 b0 3c ff ff       	call   880d <printk>
   14b5d:	83 c4 10             	add    $0x10,%esp
		nblocks << BLOCK_SIZE_BITS);
	cp = rd_start;
   14b60:	a1 60 5f 02 00       	mov    0x25f60,%eax
   14b65:	89 44 24 6c          	mov    %eax,0x6c(%esp)
	while (nblocks) {
   14b69:	e9 ce 00 00 00       	jmp    14c3c <rd_load+0x21f>
		if (nblocks > 2) 
   14b6e:	83 7c 24 70 02       	cmpl   $0x2,0x70(%esp)
   14b73:	7e 30                	jle    14ba5 <rd_load+0x188>
			bh = breada(ROOT_DEV, block, block+1, block+2, -1);
   14b75:	8b 44 24 78          	mov    0x78(%esp),%eax
   14b79:	8d 48 02             	lea    0x2(%eax),%ecx
   14b7c:	8b 44 24 78          	mov    0x78(%esp),%eax
   14b80:	8d 50 01             	lea    0x1(%eax),%edx
   14b83:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
   14b88:	83 ec 0c             	sub    $0xc,%esp
   14b8b:	6a ff                	push   $0xffffffff
   14b8d:	51                   	push   %ecx
   14b8e:	52                   	push   %edx
   14b8f:	ff b4 24 90 00 00 00 	pushl  0x90(%esp)
   14b96:	50                   	push   %eax
   14b97:	e8 06 86 ff ff       	call   d1a2 <breada>
   14b9c:	83 c4 20             	add    $0x20,%esp
   14b9f:	89 44 24 7c          	mov    %eax,0x7c(%esp)
   14ba3:	eb 1c                	jmp    14bc1 <rd_load+0x1a4>
		else
			bh = bread(ROOT_DEV, block);
   14ba5:	a1 6c 3c 02 00       	mov    0x23c6c,%eax
   14baa:	83 ec 08             	sub    $0x8,%esp
   14bad:	ff b4 24 80 00 00 00 	pushl  0x80(%esp)
   14bb4:	50                   	push   %eax
   14bb5:	e8 2c 84 ff ff       	call   cfe6 <bread>
   14bba:	83 c4 10             	add    $0x10,%esp
   14bbd:	89 44 24 7c          	mov    %eax,0x7c(%esp)
		if (!bh) {
   14bc1:	83 7c 24 7c 00       	cmpl   $0x0,0x7c(%esp)
   14bc6:	75 1c                	jne    14be4 <rd_load+0x1c7>
			printk("I/O error on block %d, aborting load\n", 
   14bc8:	83 ec 08             	sub    $0x8,%esp
   14bcb:	ff b4 24 80 00 00 00 	pushl  0x80(%esp)
   14bd2:	68 74 91 01 00       	push   $0x19174
   14bd7:	e8 31 3c ff ff       	call   880d <printk>
   14bdc:	83 c4 10             	add    $0x10,%esp
				block);
			return;
   14bdf:	e9 86 00 00 00       	jmp    14c6a <rd_load+0x24d>
		}
		(void) memcpy(cp, bh->b_data, BLOCK_SIZE);
   14be4:	8b 44 24 7c          	mov    0x7c(%esp),%eax
   14be8:	8b 00                	mov    (%eax),%eax
   14bea:	83 ec 04             	sub    $0x4,%esp
   14bed:	68 00 04 00 00       	push   $0x400
   14bf2:	50                   	push   %eax
   14bf3:	ff 74 24 78          	pushl  0x78(%esp)
   14bf7:	e8 83 fb ff ff       	call   1477f <memcpy>
   14bfc:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   14bff:	83 ec 0c             	sub    $0xc,%esp
   14c02:	ff b4 24 88 00 00 00 	pushl  0x88(%esp)
   14c09:	e8 82 83 ff ff       	call   cf90 <brelse>
   14c0e:	83 c4 10             	add    $0x10,%esp
		printk("\010\010\010\010\010%4dk",i);
   14c11:	83 ec 08             	sub    $0x8,%esp
   14c14:	ff 74 24 7c          	pushl  0x7c(%esp)
   14c18:	68 9a 91 01 00       	push   $0x1919a
   14c1d:	e8 eb 3b ff ff       	call   880d <printk>
   14c22:	83 c4 10             	add    $0x10,%esp
		cp += BLOCK_SIZE;
   14c25:	81 44 24 6c 00 04 00 	addl   $0x400,0x6c(%esp)
   14c2c:	00 
		block++;
   14c2d:	83 44 24 78 01       	addl   $0x1,0x78(%esp)
		nblocks--;
   14c32:	83 6c 24 70 01       	subl   $0x1,0x70(%esp)
		i++;
   14c37:	83 44 24 74 01       	addl   $0x1,0x74(%esp)
		return;
	}
	printk("Loading %d bytes into ram disk... 0000k", 
		nblocks << BLOCK_SIZE_BITS);
	cp = rd_start;
	while (nblocks) {
   14c3c:	83 7c 24 70 00       	cmpl   $0x0,0x70(%esp)
   14c41:	0f 85 27 ff ff ff    	jne    14b6e <rd_load+0x151>
		cp += BLOCK_SIZE;
		block++;
		nblocks--;
		i++;
	}
	printk("\010\010\010\010\010done \n");
   14c47:	83 ec 0c             	sub    $0xc,%esp
   14c4a:	68 a4 91 01 00       	push   $0x191a4
   14c4f:	e8 b9 3b ff ff       	call   880d <printk>
   14c54:	83 c4 10             	add    $0x10,%esp
	ROOT_DEV=0x0101;
   14c57:	c7 05 6c 3c 02 00 01 	movl   $0x101,0x23c6c
   14c5e:	01 00 00 
   14c61:	eb 07                	jmp    14c6a <rd_load+0x24d>
	int		i = 1;
	int		nblocks;
	char		*cp;		/* Move pointer */
	
	if (!rd_length)
		return;
   14c63:	90                   	nop
   14c64:	eb 04                	jmp    14c6a <rd_load+0x24d>
	printk("Ram disk: %d bytes, starting at 0x%x\n", rd_length,
		(int) rd_start);
	if (MAJOR(ROOT_DEV) != 2)
		return;
   14c66:	90                   	nop
   14c67:	eb 01                	jmp    14c6a <rd_load+0x24d>
	}
	*((struct d_super_block *) &s) = *((struct d_super_block *) bh->b_data);
	brelse(bh);
	if (s.s_magic != SUPER_MAGIC)
		/* No ram disk image present, assume normal floppy boot */
		return;
   14c69:	90                   	nop
		nblocks--;
		i++;
	}
	printk("\010\010\010\010\010done \n");
	ROOT_DEV=0x0101;
}
   14c6a:	81 c4 8c 00 00 00    	add    $0x8c,%esp
   14c70:	c3                   	ret    

00014c71 <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
   14c71:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
   14c72:	8b 44 24 08          	mov    0x8(%esp),%eax
   14c76:	64 8a 00             	mov    %fs:(%eax),%al
   14c79:	89 c3                	mov    %eax,%ebx
	return _v;
   14c7b:	89 d8                	mov    %ebx,%eax
}
   14c7d:	5b                   	pop    %ebx
   14c7e:	c3                   	ret    

00014c7f <put_fs_byte>:
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
	return _v;
}

static inline void put_fs_byte(char val,char *addr)
{
   14c7f:	83 ec 04             	sub    $0x4,%esp
   14c82:	8b 44 24 08          	mov    0x8(%esp),%eax
   14c86:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
   14c89:	0f b6 04 24          	movzbl (%esp),%eax
   14c8d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   14c91:	64 88 02             	mov    %al,%fs:(%edx)
}
   14c94:	90                   	nop
   14c95:	83 c4 04             	add    $0x4,%esp
   14c98:	c3                   	ret    

00014c99 <tty_init>:
	&tty_table[1].read_q, &tty_table[1].write_q,
	&tty_table[2].read_q, &tty_table[2].write_q
	};

void tty_init(void)
{
   14c99:	83 ec 0c             	sub    $0xc,%esp
	rs_init();
   14c9c:	e8 74 28 00 00       	call   17515 <rs_init>
	con_init();
   14ca1:	e8 4f 1d 00 00       	call   169f5 <con_init>
}
   14ca6:	90                   	nop
   14ca7:	83 c4 0c             	add    $0xc,%esp
   14caa:	c3                   	ret    

00014cab <tty_intr>:

void tty_intr(struct tty_struct * tty, int mask)
{
   14cab:	83 ec 10             	sub    $0x10,%esp
	int i;

	if (tty->pgrp <= 0)
   14cae:	8b 44 24 14          	mov    0x14(%esp),%eax
   14cb2:	8b 40 24             	mov    0x24(%eax),%eax
   14cb5:	85 c0                	test   %eax,%eax
   14cb7:	7e 63                	jle    14d1c <tty_intr+0x71>
		return;
	for (i=0;i<NR_TASKS;i++)
   14cb9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   14cc0:	00 
   14cc1:	eb 50                	jmp    14d13 <tty_intr+0x68>
		if (task[i] && task[i]->pgrp==tty->pgrp)
   14cc3:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14cc7:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
   14cce:	85 c0                	test   %eax,%eax
   14cd0:	74 3c                	je     14d0e <tty_intr+0x63>
   14cd2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14cd6:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
   14cdd:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
   14ce3:	8b 44 24 14          	mov    0x14(%esp),%eax
   14ce7:	8b 40 24             	mov    0x24(%eax),%eax
   14cea:	39 c2                	cmp    %eax,%edx
   14cec:	75 20                	jne    14d0e <tty_intr+0x63>
			task[i]->signal |= mask;
   14cee:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14cf2:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
   14cf9:	8b 54 24 0c          	mov    0xc(%esp),%edx
   14cfd:	8b 14 95 60 f1 01 00 	mov    0x1f160(,%edx,4),%edx
   14d04:	8b 52 0c             	mov    0xc(%edx),%edx
   14d07:	0b 54 24 18          	or     0x18(%esp),%edx
   14d0b:	89 50 0c             	mov    %edx,0xc(%eax)
{
	int i;

	if (tty->pgrp <= 0)
		return;
	for (i=0;i<NR_TASKS;i++)
   14d0e:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   14d13:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
   14d18:	7e a9                	jle    14cc3 <tty_intr+0x18>
   14d1a:	eb 01                	jmp    14d1d <tty_intr+0x72>
void tty_intr(struct tty_struct * tty, int mask)
{
	int i;

	if (tty->pgrp <= 0)
		return;
   14d1c:	90                   	nop
	for (i=0;i<NR_TASKS;i++)
		if (task[i] && task[i]->pgrp==tty->pgrp)
			task[i]->signal |= mask;
}
   14d1d:	83 c4 10             	add    $0x10,%esp
   14d20:	c3                   	ret    

00014d21 <sleep_if_empty>:

static void sleep_if_empty(struct tty_queue * queue)
{
   14d21:	83 ec 0c             	sub    $0xc,%esp
	cli();
   14d24:	fa                   	cli    
	while (!current->signal && EMPTY(*queue))
   14d25:	eb 13                	jmp    14d3a <sleep_if_empty+0x19>
		interruptible_sleep_on(&queue->proc_list);
   14d27:	8b 44 24 10          	mov    0x10(%esp),%eax
   14d2b:	83 c0 0c             	add    $0xc,%eax
   14d2e:	83 ec 0c             	sub    $0xc,%esp
   14d31:	50                   	push   %eax
   14d32:	e8 a9 21 ff ff       	call   6ee0 <interruptible_sleep_on>
   14d37:	83 c4 10             	add    $0x10,%esp
}

static void sleep_if_empty(struct tty_queue * queue)
{
	cli();
	while (!current->signal && EMPTY(*queue))
   14d3a:	a1 40 f1 01 00       	mov    0x1f140,%eax
   14d3f:	8b 40 0c             	mov    0xc(%eax),%eax
   14d42:	85 c0                	test   %eax,%eax
   14d44:	75 12                	jne    14d58 <sleep_if_empty+0x37>
   14d46:	8b 44 24 10          	mov    0x10(%esp),%eax
   14d4a:	8b 50 04             	mov    0x4(%eax),%edx
   14d4d:	8b 44 24 10          	mov    0x10(%esp),%eax
   14d51:	8b 40 08             	mov    0x8(%eax),%eax
   14d54:	39 c2                	cmp    %eax,%edx
   14d56:	74 cf                	je     14d27 <sleep_if_empty+0x6>
		interruptible_sleep_on(&queue->proc_list);
	sti();
   14d58:	fb                   	sti    
}
   14d59:	90                   	nop
   14d5a:	83 c4 0c             	add    $0xc,%esp
   14d5d:	c3                   	ret    

00014d5e <sleep_if_full>:

static void sleep_if_full(struct tty_queue * queue)
{
   14d5e:	83 ec 0c             	sub    $0xc,%esp
	if (!FULL(*queue))
   14d61:	8b 44 24 10          	mov    0x10(%esp),%eax
   14d65:	8b 50 08             	mov    0x8(%eax),%edx
   14d68:	8b 44 24 10          	mov    0x10(%esp),%eax
   14d6c:	8b 40 04             	mov    0x4(%eax),%eax
   14d6f:	29 c2                	sub    %eax,%edx
   14d71:	89 d0                	mov    %edx,%eax
   14d73:	83 e8 01             	sub    $0x1,%eax
   14d76:	25 ff 03 00 00       	and    $0x3ff,%eax
   14d7b:	85 c0                	test   %eax,%eax
   14d7d:	75 44                	jne    14dc3 <sleep_if_full+0x65>
		return;
	cli();
   14d7f:	fa                   	cli    
	while (!current->signal && LEFT(*queue)<128)
   14d80:	eb 13                	jmp    14d95 <sleep_if_full+0x37>
		interruptible_sleep_on(&queue->proc_list);
   14d82:	8b 44 24 10          	mov    0x10(%esp),%eax
   14d86:	83 c0 0c             	add    $0xc,%eax
   14d89:	83 ec 0c             	sub    $0xc,%esp
   14d8c:	50                   	push   %eax
   14d8d:	e8 4e 21 ff ff       	call   6ee0 <interruptible_sleep_on>
   14d92:	83 c4 10             	add    $0x10,%esp
static void sleep_if_full(struct tty_queue * queue)
{
	if (!FULL(*queue))
		return;
	cli();
	while (!current->signal && LEFT(*queue)<128)
   14d95:	a1 40 f1 01 00       	mov    0x1f140,%eax
   14d9a:	8b 40 0c             	mov    0xc(%eax),%eax
   14d9d:	85 c0                	test   %eax,%eax
   14d9f:	75 1f                	jne    14dc0 <sleep_if_full+0x62>
   14da1:	8b 44 24 10          	mov    0x10(%esp),%eax
   14da5:	8b 50 08             	mov    0x8(%eax),%edx
   14da8:	8b 44 24 10          	mov    0x10(%esp),%eax
   14dac:	8b 40 04             	mov    0x4(%eax),%eax
   14daf:	29 c2                	sub    %eax,%edx
   14db1:	89 d0                	mov    %edx,%eax
   14db3:	83 e8 01             	sub    $0x1,%eax
   14db6:	25 ff 03 00 00       	and    $0x3ff,%eax
   14dbb:	83 f8 7f             	cmp    $0x7f,%eax
   14dbe:	76 c2                	jbe    14d82 <sleep_if_full+0x24>
		interruptible_sleep_on(&queue->proc_list);
	sti();
   14dc0:	fb                   	sti    
   14dc1:	eb 01                	jmp    14dc4 <sleep_if_full+0x66>
}

static void sleep_if_full(struct tty_queue * queue)
{
	if (!FULL(*queue))
		return;
   14dc3:	90                   	nop
	cli();
	while (!current->signal && LEFT(*queue)<128)
		interruptible_sleep_on(&queue->proc_list);
	sti();
}
   14dc4:	83 c4 0c             	add    $0xc,%esp
   14dc7:	c3                   	ret    

00014dc8 <wait_for_keypress>:

void wait_for_keypress(void)
{
   14dc8:	83 ec 0c             	sub    $0xc,%esp
	sleep_if_empty(&tty_table[0].secondary);
   14dcb:	83 ec 0c             	sub    $0xc,%esp
   14dce:	68 90 fc 01 00       	push   $0x1fc90
   14dd3:	e8 49 ff ff ff       	call   14d21 <sleep_if_empty>
   14dd8:	83 c4 10             	add    $0x10,%esp
}
   14ddb:	90                   	nop
   14ddc:	83 c4 0c             	add    $0xc,%esp
   14ddf:	c3                   	ret    

00014de0 <copy_to_cooked>:

void copy_to_cooked(struct tty_struct * tty)
{
   14de0:	83 ec 1c             	sub    $0x1c,%esp
	signed char c;

	while (!EMPTY(tty->read_q) && !FULL(tty->secondary)) {
   14de3:	e9 b8 05 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
		GETCH(tty->read_q,c);
   14de8:	8b 44 24 20          	mov    0x20(%esp),%eax
   14dec:	8b 40 38             	mov    0x38(%eax),%eax
   14def:	8b 54 24 20          	mov    0x20(%esp),%edx
   14df3:	0f b6 44 02 40       	movzbl 0x40(%edx,%eax,1),%eax
   14df8:	88 44 24 0f          	mov    %al,0xf(%esp)
   14dfc:	8b 44 24 20          	mov    0x20(%esp),%eax
   14e00:	8b 40 38             	mov    0x38(%eax),%eax
   14e03:	83 c0 01             	add    $0x1,%eax
   14e06:	25 ff 03 00 00       	and    $0x3ff,%eax
   14e0b:	89 c2                	mov    %eax,%edx
   14e0d:	8b 44 24 20          	mov    0x20(%esp),%eax
   14e11:	89 50 38             	mov    %edx,0x38(%eax)
		if (c==13)
   14e14:	80 7c 24 0f 0d       	cmpb   $0xd,0xf(%esp)
   14e19:	75 2a                	jne    14e45 <copy_to_cooked+0x65>
			if (I_CRNL(tty))
   14e1b:	8b 44 24 20          	mov    0x20(%esp),%eax
   14e1f:	8b 00                	mov    (%eax),%eax
   14e21:	25 00 01 00 00       	and    $0x100,%eax
   14e26:	85 c0                	test   %eax,%eax
   14e28:	74 07                	je     14e31 <copy_to_cooked+0x51>
				c=10;
   14e2a:	c6 44 24 0f 0a       	movb   $0xa,0xf(%esp)
   14e2f:	eb 2d                	jmp    14e5e <copy_to_cooked+0x7e>
			else if (I_NOCR(tty))
   14e31:	8b 44 24 20          	mov    0x20(%esp),%eax
   14e35:	8b 00                	mov    (%eax),%eax
   14e37:	25 80 00 00 00       	and    $0x80,%eax
   14e3c:	85 c0                	test   %eax,%eax
   14e3e:	74 1e                	je     14e5e <copy_to_cooked+0x7e>
				continue;
   14e40:	e9 5b 05 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
			else ;
		else if (c==10 && I_NLCR(tty))
   14e45:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   14e4a:	75 12                	jne    14e5e <copy_to_cooked+0x7e>
   14e4c:	8b 44 24 20          	mov    0x20(%esp),%eax
   14e50:	8b 00                	mov    (%eax),%eax
   14e52:	83 e0 40             	and    $0x40,%eax
   14e55:	85 c0                	test   %eax,%eax
   14e57:	74 05                	je     14e5e <copy_to_cooked+0x7e>
			c=13;
   14e59:	c6 44 24 0f 0d       	movb   $0xd,0xf(%esp)
		if (I_UCLC(tty))
   14e5e:	8b 44 24 20          	mov    0x20(%esp),%eax
   14e62:	8b 00                	mov    (%eax),%eax
   14e64:	25 00 02 00 00       	and    $0x200,%eax
   14e69:	85 c0                	test   %eax,%eax
   14e6b:	74 40                	je     14ead <copy_to_cooked+0xcd>
			c=tolower(c);
   14e6d:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   14e72:	a2 64 5f 02 00       	mov    %al,0x25f64
   14e77:	0f b6 05 64 5f 02 00 	movzbl 0x25f64,%eax
   14e7e:	0f be c0             	movsbl %al,%eax
   14e81:	83 c0 01             	add    $0x1,%eax
   14e84:	05 a0 19 02 00       	add    $0x219a0,%eax
   14e89:	0f b6 00             	movzbl (%eax),%eax
   14e8c:	0f b6 c0             	movzbl %al,%eax
   14e8f:	83 e0 01             	and    $0x1,%eax
   14e92:	85 c0                	test   %eax,%eax
   14e94:	74 0c                	je     14ea2 <copy_to_cooked+0xc2>
   14e96:	0f b6 05 64 5f 02 00 	movzbl 0x25f64,%eax
   14e9d:	83 c0 20             	add    $0x20,%eax
   14ea0:	eb 07                	jmp    14ea9 <copy_to_cooked+0xc9>
   14ea2:	0f b6 05 64 5f 02 00 	movzbl 0x25f64,%eax
   14ea9:	88 44 24 0f          	mov    %al,0xf(%esp)
		if (L_CANON(tty)) {
   14ead:	8b 44 24 20          	mov    0x20(%esp),%eax
   14eb1:	8b 40 0c             	mov    0xc(%eax),%eax
   14eb4:	83 e0 02             	and    $0x2,%eax
   14eb7:	85 c0                	test   %eax,%eax
   14eb9:	0f 84 b2 02 00 00    	je     15171 <copy_to_cooked+0x391>
			if (c==KILL_CHAR(tty)) {
   14ebf:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   14ec4:	8b 44 24 20          	mov    0x20(%esp),%eax
   14ec8:	0f b6 40 14          	movzbl 0x14(%eax),%eax
   14ecc:	0f b6 c0             	movzbl %al,%eax
   14ecf:	39 c2                	cmp    %eax,%edx
   14ed1:	0f 85 1f 01 00 00    	jne    14ff6 <copy_to_cooked+0x216>
				/* deal with killing the input line */
				while(!(EMPTY(tty->secondary) ||
   14ed7:	e9 b2 00 00 00       	jmp    14f8e <copy_to_cooked+0x1ae>
				        (c=LAST(tty->secondary))==10 ||
				        c==EOF_CHAR(tty))) {
					if (L_ECHO(tty)) {
   14edc:	8b 44 24 20          	mov    0x20(%esp),%eax
   14ee0:	8b 40 0c             	mov    0xc(%eax),%eax
   14ee3:	83 e0 08             	and    $0x8,%eax
   14ee6:	85 c0                	test   %eax,%eax
   14ee8:	0f 84 82 00 00 00    	je     14f70 <copy_to_cooked+0x190>
						if (c<32)
   14eee:	80 7c 24 0f 1f       	cmpb   $0x1f,0xf(%esp)
   14ef3:	7f 34                	jg     14f29 <copy_to_cooked+0x149>
							PUTCH(127,tty->write_q);
   14ef5:	8b 44 24 20          	mov    0x20(%esp),%eax
   14ef9:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   14eff:	8b 54 24 20          	mov    0x20(%esp),%edx
   14f03:	c6 84 02 50 04 00 00 	movb   $0x7f,0x450(%edx,%eax,1)
   14f0a:	7f 
   14f0b:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f0f:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   14f15:	83 c0 01             	add    $0x1,%eax
   14f18:	25 ff 03 00 00       	and    $0x3ff,%eax
   14f1d:	89 c2                	mov    %eax,%edx
   14f1f:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f23:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
						PUTCH(127,tty->write_q);
   14f29:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f2d:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   14f33:	8b 54 24 20          	mov    0x20(%esp),%edx
   14f37:	c6 84 02 50 04 00 00 	movb   $0x7f,0x450(%edx,%eax,1)
   14f3e:	7f 
   14f3f:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f43:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   14f49:	83 c0 01             	add    $0x1,%eax
   14f4c:	25 ff 03 00 00       	and    $0x3ff,%eax
   14f51:	89 c2                	mov    %eax,%edx
   14f53:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f57:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
						tty->write(tty);
   14f5d:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f61:	8b 40 2c             	mov    0x2c(%eax),%eax
   14f64:	83 ec 0c             	sub    $0xc,%esp
   14f67:	ff 74 24 2c          	pushl  0x2c(%esp)
   14f6b:	ff d0                	call   *%eax
   14f6d:	83 c4 10             	add    $0x10,%esp
					}
					DEC(tty->secondary.head);
   14f70:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f74:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
   14f7a:	83 e8 01             	sub    $0x1,%eax
   14f7d:	25 ff 03 00 00       	and    $0x3ff,%eax
   14f82:	89 c2                	mov    %eax,%edx
   14f84:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f88:	89 90 54 08 00 00    	mov    %edx,0x854(%eax)
		if (I_UCLC(tty))
			c=tolower(c);
		if (L_CANON(tty)) {
			if (c==KILL_CHAR(tty)) {
				/* deal with killing the input line */
				while(!(EMPTY(tty->secondary) ||
   14f8e:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f92:	8b 90 54 08 00 00    	mov    0x854(%eax),%edx
   14f98:	8b 44 24 20          	mov    0x20(%esp),%eax
   14f9c:	8b 80 58 08 00 00    	mov    0x858(%eax),%eax
   14fa2:	39 c2                	cmp    %eax,%edx
   14fa4:	0f 84 f6 03 00 00    	je     153a0 <copy_to_cooked+0x5c0>
				        (c=LAST(tty->secondary))==10 ||
   14faa:	8b 44 24 20          	mov    0x20(%esp),%eax
   14fae:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
   14fb4:	83 e8 01             	sub    $0x1,%eax
   14fb7:	25 ff 03 00 00       	and    $0x3ff,%eax
   14fbc:	89 c2                	mov    %eax,%edx
   14fbe:	8b 44 24 20          	mov    0x20(%esp),%eax
   14fc2:	0f b6 84 10 60 08 00 	movzbl 0x860(%eax,%edx,1),%eax
   14fc9:	00 
   14fca:	88 44 24 0f          	mov    %al,0xf(%esp)
		if (I_UCLC(tty))
			c=tolower(c);
		if (L_CANON(tty)) {
			if (c==KILL_CHAR(tty)) {
				/* deal with killing the input line */
				while(!(EMPTY(tty->secondary) ||
   14fce:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   14fd3:	0f 84 c7 03 00 00    	je     153a0 <copy_to_cooked+0x5c0>
				        (c=LAST(tty->secondary))==10 ||
				        c==EOF_CHAR(tty))) {
   14fd9:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   14fde:	8b 44 24 20          	mov    0x20(%esp),%eax
   14fe2:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   14fe6:	0f b6 c0             	movzbl %al,%eax
		if (I_UCLC(tty))
			c=tolower(c);
		if (L_CANON(tty)) {
			if (c==KILL_CHAR(tty)) {
				/* deal with killing the input line */
				while(!(EMPTY(tty->secondary) ||
   14fe9:	39 c2                	cmp    %eax,%edx
   14feb:	0f 85 eb fe ff ff    	jne    14edc <copy_to_cooked+0xfc>
						PUTCH(127,tty->write_q);
						tty->write(tty);
					}
					DEC(tty->secondary.head);
				}
				continue;
   14ff1:	e9 aa 03 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
			}
			if (c==ERASE_CHAR(tty)) {
   14ff6:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   14ffb:	8b 44 24 20          	mov    0x20(%esp),%eax
   14fff:	0f b6 40 13          	movzbl 0x13(%eax),%eax
   15003:	0f b6 c0             	movzbl %al,%eax
   15006:	39 c2                	cmp    %eax,%edx
   15008:	0f 85 1b 01 00 00    	jne    15129 <copy_to_cooked+0x349>
				if (EMPTY(tty->secondary) ||
   1500e:	8b 44 24 20          	mov    0x20(%esp),%eax
   15012:	8b 90 54 08 00 00    	mov    0x854(%eax),%edx
   15018:	8b 44 24 20          	mov    0x20(%esp),%eax
   1501c:	8b 80 58 08 00 00    	mov    0x858(%eax),%eax
   15022:	39 c2                	cmp    %eax,%edx
   15024:	0f 84 76 03 00 00    	je     153a0 <copy_to_cooked+0x5c0>
				   (c=LAST(tty->secondary))==10 ||
   1502a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1502e:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
   15034:	83 e8 01             	sub    $0x1,%eax
   15037:	25 ff 03 00 00       	and    $0x3ff,%eax
   1503c:	89 c2                	mov    %eax,%edx
   1503e:	8b 44 24 20          	mov    0x20(%esp),%eax
   15042:	0f b6 84 10 60 08 00 	movzbl 0x860(%eax,%edx,1),%eax
   15049:	00 
   1504a:	88 44 24 0f          	mov    %al,0xf(%esp)
					DEC(tty->secondary.head);
				}
				continue;
			}
			if (c==ERASE_CHAR(tty)) {
				if (EMPTY(tty->secondary) ||
   1504e:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   15053:	0f 84 47 03 00 00    	je     153a0 <copy_to_cooked+0x5c0>
				   (c=LAST(tty->secondary))==10 ||
				   c==EOF_CHAR(tty))
   15059:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1505e:	8b 44 24 20          	mov    0x20(%esp),%eax
   15062:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   15066:	0f b6 c0             	movzbl %al,%eax
				}
				continue;
			}
			if (c==ERASE_CHAR(tty)) {
				if (EMPTY(tty->secondary) ||
				   (c=LAST(tty->secondary))==10 ||
   15069:	39 c2                	cmp    %eax,%edx
   1506b:	75 05                	jne    15072 <copy_to_cooked+0x292>
				   c==EOF_CHAR(tty))
					continue;
   1506d:	e9 2e 03 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
				if (L_ECHO(tty)) {
   15072:	8b 44 24 20          	mov    0x20(%esp),%eax
   15076:	8b 40 0c             	mov    0xc(%eax),%eax
   15079:	83 e0 08             	and    $0x8,%eax
   1507c:	85 c0                	test   %eax,%eax
   1507e:	0f 84 82 00 00 00    	je     15106 <copy_to_cooked+0x326>
					if (c<32)
   15084:	80 7c 24 0f 1f       	cmpb   $0x1f,0xf(%esp)
   15089:	7f 34                	jg     150bf <copy_to_cooked+0x2df>
						PUTCH(127,tty->write_q);
   1508b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1508f:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15095:	8b 54 24 20          	mov    0x20(%esp),%edx
   15099:	c6 84 02 50 04 00 00 	movb   $0x7f,0x450(%edx,%eax,1)
   150a0:	7f 
   150a1:	8b 44 24 20          	mov    0x20(%esp),%eax
   150a5:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   150ab:	83 c0 01             	add    $0x1,%eax
   150ae:	25 ff 03 00 00       	and    $0x3ff,%eax
   150b3:	89 c2                	mov    %eax,%edx
   150b5:	8b 44 24 20          	mov    0x20(%esp),%eax
   150b9:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
					PUTCH(127,tty->write_q);
   150bf:	8b 44 24 20          	mov    0x20(%esp),%eax
   150c3:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   150c9:	8b 54 24 20          	mov    0x20(%esp),%edx
   150cd:	c6 84 02 50 04 00 00 	movb   $0x7f,0x450(%edx,%eax,1)
   150d4:	7f 
   150d5:	8b 44 24 20          	mov    0x20(%esp),%eax
   150d9:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   150df:	83 c0 01             	add    $0x1,%eax
   150e2:	25 ff 03 00 00       	and    $0x3ff,%eax
   150e7:	89 c2                	mov    %eax,%edx
   150e9:	8b 44 24 20          	mov    0x20(%esp),%eax
   150ed:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
					tty->write(tty);
   150f3:	8b 44 24 20          	mov    0x20(%esp),%eax
   150f7:	8b 40 2c             	mov    0x2c(%eax),%eax
   150fa:	83 ec 0c             	sub    $0xc,%esp
   150fd:	ff 74 24 2c          	pushl  0x2c(%esp)
   15101:	ff d0                	call   *%eax
   15103:	83 c4 10             	add    $0x10,%esp
				}
				DEC(tty->secondary.head);
   15106:	8b 44 24 20          	mov    0x20(%esp),%eax
   1510a:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
   15110:	83 e8 01             	sub    $0x1,%eax
   15113:	25 ff 03 00 00       	and    $0x3ff,%eax
   15118:	89 c2                	mov    %eax,%edx
   1511a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1511e:	89 90 54 08 00 00    	mov    %edx,0x854(%eax)
				continue;
   15124:	e9 77 02 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
			}
			if (c==STOP_CHAR(tty)) {
   15129:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   1512e:	8b 44 24 20          	mov    0x20(%esp),%eax
   15132:	0f b6 40 1a          	movzbl 0x1a(%eax),%eax
   15136:	0f b6 c0             	movzbl %al,%eax
   15139:	39 c2                	cmp    %eax,%edx
   1513b:	75 10                	jne    1514d <copy_to_cooked+0x36d>
				tty->stopped=1;
   1513d:	8b 44 24 20          	mov    0x20(%esp),%eax
   15141:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
				continue;
   15148:	e9 53 02 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
			}
			if (c==START_CHAR(tty)) {
   1514d:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   15152:	8b 44 24 20          	mov    0x20(%esp),%eax
   15156:	0f b6 40 19          	movzbl 0x19(%eax),%eax
   1515a:	0f b6 c0             	movzbl %al,%eax
   1515d:	39 c2                	cmp    %eax,%edx
   1515f:	75 10                	jne    15171 <copy_to_cooked+0x391>
				tty->stopped=0;
   15161:	8b 44 24 20          	mov    0x20(%esp),%eax
   15165:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
				continue;
   1516c:	e9 2f 02 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
			}
		}
		if (L_ISIG(tty)) {
   15171:	8b 44 24 20          	mov    0x20(%esp),%eax
   15175:	8b 40 0c             	mov    0xc(%eax),%eax
   15178:	83 e0 01             	and    $0x1,%eax
   1517b:	85 c0                	test   %eax,%eax
   1517d:	74 54                	je     151d3 <copy_to_cooked+0x3f3>
			if (c==INTR_CHAR(tty)) {
   1517f:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   15184:	8b 44 24 20          	mov    0x20(%esp),%eax
   15188:	0f b6 40 11          	movzbl 0x11(%eax),%eax
   1518c:	0f b6 c0             	movzbl %al,%eax
   1518f:	39 c2                	cmp    %eax,%edx
   15191:	75 16                	jne    151a9 <copy_to_cooked+0x3c9>
				tty_intr(tty,INTMASK);
   15193:	83 ec 08             	sub    $0x8,%esp
   15196:	6a 02                	push   $0x2
   15198:	ff 74 24 2c          	pushl  0x2c(%esp)
   1519c:	e8 0a fb ff ff       	call   14cab <tty_intr>
   151a1:	83 c4 10             	add    $0x10,%esp
				continue;
   151a4:	e9 f7 01 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
			}
			if (c==QUIT_CHAR(tty)) {
   151a9:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   151ae:	8b 44 24 20          	mov    0x20(%esp),%eax
   151b2:	0f b6 40 12          	movzbl 0x12(%eax),%eax
   151b6:	0f b6 c0             	movzbl %al,%eax
   151b9:	39 c2                	cmp    %eax,%edx
   151bb:	75 16                	jne    151d3 <copy_to_cooked+0x3f3>
				tty_intr(tty,QUITMASK);
   151bd:	83 ec 08             	sub    $0x8,%esp
   151c0:	6a 04                	push   $0x4
   151c2:	ff 74 24 2c          	pushl  0x2c(%esp)
   151c6:	e8 e0 fa ff ff       	call   14cab <tty_intr>
   151cb:	83 c4 10             	add    $0x10,%esp
				continue;
   151ce:	e9 cd 01 00 00       	jmp    153a0 <copy_to_cooked+0x5c0>
			}
		}
		if (c==10 || c==EOF_CHAR(tty))
   151d3:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   151d8:	74 14                	je     151ee <copy_to_cooked+0x40e>
   151da:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   151df:	8b 44 24 20          	mov    0x20(%esp),%eax
   151e3:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   151e7:	0f b6 c0             	movzbl %al,%eax
   151ea:	39 c2                	cmp    %eax,%edx
   151ec:	75 17                	jne    15205 <copy_to_cooked+0x425>
			tty->secondary.data++;
   151ee:	8b 44 24 20          	mov    0x20(%esp),%eax
   151f2:	8b 80 50 08 00 00    	mov    0x850(%eax),%eax
   151f8:	8d 50 01             	lea    0x1(%eax),%edx
   151fb:	8b 44 24 20          	mov    0x20(%esp),%eax
   151ff:	89 90 50 08 00 00    	mov    %edx,0x850(%eax)
		if (L_ECHO(tty)) {
   15205:	8b 44 24 20          	mov    0x20(%esp),%eax
   15209:	8b 40 0c             	mov    0xc(%eax),%eax
   1520c:	83 e0 08             	and    $0x8,%eax
   1520f:	85 c0                	test   %eax,%eax
   15211:	0f 84 51 01 00 00    	je     15368 <copy_to_cooked+0x588>
			if (c==10) {
   15217:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1521c:	75 6d                	jne    1528b <copy_to_cooked+0x4ab>
				PUTCH(10,tty->write_q);
   1521e:	8b 44 24 20          	mov    0x20(%esp),%eax
   15222:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15228:	8b 54 24 20          	mov    0x20(%esp),%edx
   1522c:	c6 84 02 50 04 00 00 	movb   $0xa,0x450(%edx,%eax,1)
   15233:	0a 
   15234:	8b 44 24 20          	mov    0x20(%esp),%eax
   15238:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   1523e:	83 c0 01             	add    $0x1,%eax
   15241:	25 ff 03 00 00       	and    $0x3ff,%eax
   15246:	89 c2                	mov    %eax,%edx
   15248:	8b 44 24 20          	mov    0x20(%esp),%eax
   1524c:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
				PUTCH(13,tty->write_q);
   15252:	8b 44 24 20          	mov    0x20(%esp),%eax
   15256:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   1525c:	8b 54 24 20          	mov    0x20(%esp),%edx
   15260:	c6 84 02 50 04 00 00 	movb   $0xd,0x450(%edx,%eax,1)
   15267:	0d 
   15268:	8b 44 24 20          	mov    0x20(%esp),%eax
   1526c:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15272:	83 c0 01             	add    $0x1,%eax
   15275:	25 ff 03 00 00       	and    $0x3ff,%eax
   1527a:	89 c2                	mov    %eax,%edx
   1527c:	8b 44 24 20          	mov    0x20(%esp),%eax
   15280:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
   15286:	e9 ca 00 00 00       	jmp    15355 <copy_to_cooked+0x575>
			} else if (c<32) {
   1528b:	80 7c 24 0f 1f       	cmpb   $0x1f,0xf(%esp)
   15290:	0f 8f 87 00 00 00    	jg     1531d <copy_to_cooked+0x53d>
				if (L_ECHOCTL(tty)) {
   15296:	8b 44 24 20          	mov    0x20(%esp),%eax
   1529a:	8b 40 0c             	mov    0xc(%eax),%eax
   1529d:	25 00 02 00 00       	and    $0x200,%eax
   152a2:	85 c0                	test   %eax,%eax
   152a4:	0f 84 ab 00 00 00    	je     15355 <copy_to_cooked+0x575>
					PUTCH('^',tty->write_q);
   152aa:	8b 44 24 20          	mov    0x20(%esp),%eax
   152ae:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   152b4:	8b 54 24 20          	mov    0x20(%esp),%edx
   152b8:	c6 84 02 50 04 00 00 	movb   $0x5e,0x450(%edx,%eax,1)
   152bf:	5e 
   152c0:	8b 44 24 20          	mov    0x20(%esp),%eax
   152c4:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   152ca:	83 c0 01             	add    $0x1,%eax
   152cd:	25 ff 03 00 00       	and    $0x3ff,%eax
   152d2:	89 c2                	mov    %eax,%edx
   152d4:	8b 44 24 20          	mov    0x20(%esp),%eax
   152d8:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
					PUTCH(c+64,tty->write_q);
   152de:	8b 44 24 20          	mov    0x20(%esp),%eax
   152e2:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   152e8:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
   152ed:	83 c2 40             	add    $0x40,%edx
   152f0:	89 d1                	mov    %edx,%ecx
   152f2:	8b 54 24 20          	mov    0x20(%esp),%edx
   152f6:	88 8c 02 50 04 00 00 	mov    %cl,0x450(%edx,%eax,1)
   152fd:	8b 44 24 20          	mov    0x20(%esp),%eax
   15301:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15307:	83 c0 01             	add    $0x1,%eax
   1530a:	25 ff 03 00 00       	and    $0x3ff,%eax
   1530f:	89 c2                	mov    %eax,%edx
   15311:	8b 44 24 20          	mov    0x20(%esp),%eax
   15315:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
   1531b:	eb 38                	jmp    15355 <copy_to_cooked+0x575>
				}
			} else
				PUTCH(c,tty->write_q);
   1531d:	8b 44 24 20          	mov    0x20(%esp),%eax
   15321:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15327:	8b 54 24 20          	mov    0x20(%esp),%edx
   1532b:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
   15330:	88 8c 02 50 04 00 00 	mov    %cl,0x450(%edx,%eax,1)
   15337:	8b 44 24 20          	mov    0x20(%esp),%eax
   1533b:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15341:	83 c0 01             	add    $0x1,%eax
   15344:	25 ff 03 00 00       	and    $0x3ff,%eax
   15349:	89 c2                	mov    %eax,%edx
   1534b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1534f:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
			tty->write(tty);
   15355:	8b 44 24 20          	mov    0x20(%esp),%eax
   15359:	8b 40 2c             	mov    0x2c(%eax),%eax
   1535c:	83 ec 0c             	sub    $0xc,%esp
   1535f:	ff 74 24 2c          	pushl  0x2c(%esp)
   15363:	ff d0                	call   *%eax
   15365:	83 c4 10             	add    $0x10,%esp
		}
		PUTCH(c,tty->secondary);
   15368:	8b 44 24 20          	mov    0x20(%esp),%eax
   1536c:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
   15372:	8b 54 24 20          	mov    0x20(%esp),%edx
   15376:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
   1537b:	88 8c 02 60 08 00 00 	mov    %cl,0x860(%edx,%eax,1)
   15382:	8b 44 24 20          	mov    0x20(%esp),%eax
   15386:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
   1538c:	83 c0 01             	add    $0x1,%eax
   1538f:	25 ff 03 00 00       	and    $0x3ff,%eax
   15394:	89 c2                	mov    %eax,%edx
   15396:	8b 44 24 20          	mov    0x20(%esp),%eax
   1539a:	89 90 54 08 00 00    	mov    %edx,0x854(%eax)

void copy_to_cooked(struct tty_struct * tty)
{
	signed char c;

	while (!EMPTY(tty->read_q) && !FULL(tty->secondary)) {
   153a0:	8b 44 24 20          	mov    0x20(%esp),%eax
   153a4:	8b 50 34             	mov    0x34(%eax),%edx
   153a7:	8b 44 24 20          	mov    0x20(%esp),%eax
   153ab:	8b 40 38             	mov    0x38(%eax),%eax
   153ae:	39 c2                	cmp    %eax,%edx
   153b0:	74 28                	je     153da <copy_to_cooked+0x5fa>
   153b2:	8b 44 24 20          	mov    0x20(%esp),%eax
   153b6:	8b 90 58 08 00 00    	mov    0x858(%eax),%edx
   153bc:	8b 44 24 20          	mov    0x20(%esp),%eax
   153c0:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
   153c6:	29 c2                	sub    %eax,%edx
   153c8:	89 d0                	mov    %edx,%eax
   153ca:	83 e8 01             	sub    $0x1,%eax
   153cd:	25 ff 03 00 00       	and    $0x3ff,%eax
   153d2:	85 c0                	test   %eax,%eax
   153d4:	0f 85 0e fa ff ff    	jne    14de8 <copy_to_cooked+0x8>
				PUTCH(c,tty->write_q);
			tty->write(tty);
		}
		PUTCH(c,tty->secondary);
	}
	wake_up(&tty->secondary.proc_list);
   153da:	8b 44 24 20          	mov    0x20(%esp),%eax
   153de:	05 5c 08 00 00       	add    $0x85c,%eax
   153e3:	83 ec 0c             	sub    $0xc,%esp
   153e6:	50                   	push   %eax
   153e7:	e8 8d 1b ff ff       	call   6f79 <wake_up>
   153ec:	83 c4 10             	add    $0x10,%esp
}
   153ef:	90                   	nop
   153f0:	83 c4 1c             	add    $0x1c,%esp
   153f3:	c3                   	ret    

000153f4 <tty_read>:

int tty_read(unsigned channel, char * buf, int nr)
{
   153f4:	83 ec 2c             	sub    $0x2c,%esp
	struct tty_struct * tty;
	char c, * b=buf;
   153f7:	8b 44 24 34          	mov    0x34(%esp),%eax
   153fb:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	int minimum,time,flag=0;
   153ff:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   15406:	00 
	long oldalarm;

	if (channel>2 || nr<0) return -1;
   15407:	83 7c 24 30 02       	cmpl   $0x2,0x30(%esp)
   1540c:	77 07                	ja     15415 <tty_read+0x21>
   1540e:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   15413:	79 0a                	jns    1541f <tty_read+0x2b>
   15415:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1541a:	e9 47 03 00 00       	jmp    15766 <tty_read+0x372>
	tty = &tty_table[channel];
   1541f:	8b 44 24 30          	mov    0x30(%esp),%eax
   15423:	69 c0 60 0c 00 00    	imul   $0xc60,%eax,%eax
   15429:	05 40 f4 01 00       	add    $0x1f440,%eax
   1542e:	89 44 24 10          	mov    %eax,0x10(%esp)
	oldalarm = current->alarm;
   15432:	a1 40 f1 01 00       	mov    0x1f140,%eax
   15437:	8b 80 4c 02 00 00    	mov    0x24c(%eax),%eax
   1543d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	time = 10L*tty->termios.c_cc[VTIME];
   15441:	8b 44 24 10          	mov    0x10(%esp),%eax
   15445:	0f b6 40 16          	movzbl 0x16(%eax),%eax
   15449:	0f b6 d0             	movzbl %al,%edx
   1544c:	89 d0                	mov    %edx,%eax
   1544e:	c1 e0 02             	shl    $0x2,%eax
   15451:	01 d0                	add    %edx,%eax
   15453:	01 c0                	add    %eax,%eax
   15455:	89 44 24 08          	mov    %eax,0x8(%esp)
	minimum = tty->termios.c_cc[VMIN];
   15459:	8b 44 24 10          	mov    0x10(%esp),%eax
   1545d:	0f b6 40 17          	movzbl 0x17(%eax),%eax
   15461:	0f b6 c0             	movzbl %al,%eax
   15464:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (time && !minimum) {
   15468:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1546d:	74 56                	je     154c5 <tty_read+0xd1>
   1546f:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   15474:	75 4f                	jne    154c5 <tty_read+0xd1>
		minimum=1;
   15476:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
   1547d:	00 
		if ((flag=(!oldalarm || time+jiffies<oldalarm)))
   1547e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   15483:	74 12                	je     15497 <tty_read+0xa3>
   15485:	8b 15 e0 1e 02 00    	mov    0x21ee0,%edx
   1548b:	8b 44 24 08          	mov    0x8(%esp),%eax
   1548f:	01 d0                	add    %edx,%eax
   15491:	3b 44 24 0c          	cmp    0xc(%esp),%eax
   15495:	7d 07                	jge    1549e <tty_read+0xaa>
   15497:	b8 01 00 00 00       	mov    $0x1,%eax
   1549c:	eb 05                	jmp    154a3 <tty_read+0xaf>
   1549e:	b8 00 00 00 00       	mov    $0x0,%eax
   154a3:	89 44 24 14          	mov    %eax,0x14(%esp)
   154a7:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   154ac:	74 17                	je     154c5 <tty_read+0xd1>
			current->alarm = time+jiffies;
   154ae:	a1 40 f1 01 00       	mov    0x1f140,%eax
   154b3:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   154b9:	8b 54 24 08          	mov    0x8(%esp),%edx
   154bd:	01 ca                	add    %ecx,%edx
   154bf:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
	}
	if (minimum>nr)
   154c5:	8b 44 24 18          	mov    0x18(%esp),%eax
   154c9:	3b 44 24 38          	cmp    0x38(%esp),%eax
   154cd:	0f 8e 48 02 00 00    	jle    1571b <tty_read+0x327>
		minimum=nr;
   154d3:	8b 44 24 38          	mov    0x38(%esp),%eax
   154d7:	89 44 24 18          	mov    %eax,0x18(%esp)
	while (nr>0) {
   154db:	e9 3b 02 00 00       	jmp    1571b <tty_read+0x327>
		if (flag && (current->signal & ALRMMASK)) {
   154e0:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   154e5:	74 2a                	je     15511 <tty_read+0x11d>
   154e7:	a1 40 f1 01 00       	mov    0x1f140,%eax
   154ec:	8b 40 0c             	mov    0xc(%eax),%eax
   154ef:	25 00 20 00 00       	and    $0x2000,%eax
   154f4:	85 c0                	test   %eax,%eax
   154f6:	74 19                	je     15511 <tty_read+0x11d>
			current->signal &= ~ALRMMASK;
   154f8:	a1 40 f1 01 00       	mov    0x1f140,%eax
   154fd:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
   15503:	8b 52 0c             	mov    0xc(%edx),%edx
   15506:	80 e6 df             	and    $0xdf,%dh
   15509:	89 50 0c             	mov    %edx,0xc(%eax)
			break;
   1550c:	e9 1b 02 00 00       	jmp    1572c <tty_read+0x338>
		}
		if (current->signal)
   15511:	a1 40 f1 01 00       	mov    0x1f140,%eax
   15516:	8b 40 0c             	mov    0xc(%eax),%eax
   15519:	85 c0                	test   %eax,%eax
   1551b:	0f 85 07 02 00 00    	jne    15728 <tty_read+0x334>
			break;
		if (EMPTY(tty->secondary) || (L_CANON(tty) &&
   15521:	8b 44 24 10          	mov    0x10(%esp),%eax
   15525:	8b 90 54 08 00 00    	mov    0x854(%eax),%edx
   1552b:	8b 44 24 10          	mov    0x10(%esp),%eax
   1552f:	8b 80 58 08 00 00    	mov    0x858(%eax),%eax
   15535:	39 c2                	cmp    %eax,%edx
   15537:	74 41                	je     1557a <tty_read+0x186>
   15539:	8b 44 24 10          	mov    0x10(%esp),%eax
   1553d:	8b 40 0c             	mov    0xc(%eax),%eax
   15540:	83 e0 02             	and    $0x2,%eax
   15543:	85 c0                	test   %eax,%eax
   15545:	74 4d                	je     15594 <tty_read+0x1a0>
		!tty->secondary.data && LEFT(tty->secondary)>20)) {
   15547:	8b 44 24 10          	mov    0x10(%esp),%eax
   1554b:	8b 80 50 08 00 00    	mov    0x850(%eax),%eax
			current->signal &= ~ALRMMASK;
			break;
		}
		if (current->signal)
			break;
		if (EMPTY(tty->secondary) || (L_CANON(tty) &&
   15551:	85 c0                	test   %eax,%eax
   15553:	75 3f                	jne    15594 <tty_read+0x1a0>
		!tty->secondary.data && LEFT(tty->secondary)>20)) {
   15555:	8b 44 24 10          	mov    0x10(%esp),%eax
   15559:	8b 90 58 08 00 00    	mov    0x858(%eax),%edx
   1555f:	8b 44 24 10          	mov    0x10(%esp),%eax
   15563:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
   15569:	29 c2                	sub    %eax,%edx
   1556b:	89 d0                	mov    %edx,%eax
   1556d:	83 e8 01             	sub    $0x1,%eax
   15570:	25 ff 03 00 00       	and    $0x3ff,%eax
   15575:	83 f8 14             	cmp    $0x14,%eax
   15578:	76 1a                	jbe    15594 <tty_read+0x1a0>
			sleep_if_empty(&tty->secondary);
   1557a:	8b 44 24 10          	mov    0x10(%esp),%eax
   1557e:	05 50 08 00 00       	add    $0x850,%eax
   15583:	83 ec 0c             	sub    $0xc,%esp
   15586:	50                   	push   %eax
   15587:	e8 95 f7 ff ff       	call   14d21 <sleep_if_empty>
   1558c:	83 c4 10             	add    $0x10,%esp
			continue;
   1558f:	e9 87 01 00 00       	jmp    1571b <tty_read+0x327>
		}
		do {
			GETCH(tty->secondary,c);
   15594:	8b 44 24 10          	mov    0x10(%esp),%eax
   15598:	8b 80 58 08 00 00    	mov    0x858(%eax),%eax
   1559e:	8b 54 24 10          	mov    0x10(%esp),%edx
   155a2:	0f b6 84 02 60 08 00 	movzbl 0x860(%edx,%eax,1),%eax
   155a9:	00 
   155aa:	88 44 24 07          	mov    %al,0x7(%esp)
   155ae:	8b 44 24 10          	mov    0x10(%esp),%eax
   155b2:	8b 80 58 08 00 00    	mov    0x858(%eax),%eax
   155b8:	83 c0 01             	add    $0x1,%eax
   155bb:	25 ff 03 00 00       	and    $0x3ff,%eax
   155c0:	89 c2                	mov    %eax,%edx
   155c2:	8b 44 24 10          	mov    0x10(%esp),%eax
   155c6:	89 90 58 08 00 00    	mov    %edx,0x858(%eax)
			if (c==EOF_CHAR(tty) || c==10)
   155cc:	0f be 54 24 07       	movsbl 0x7(%esp),%edx
   155d1:	8b 44 24 10          	mov    0x10(%esp),%eax
   155d5:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   155d9:	0f b6 c0             	movzbl %al,%eax
   155dc:	39 c2                	cmp    %eax,%edx
   155de:	74 07                	je     155e7 <tty_read+0x1f3>
   155e0:	80 7c 24 07 0a       	cmpb   $0xa,0x7(%esp)
   155e5:	75 17                	jne    155fe <tty_read+0x20a>
				tty->secondary.data--;
   155e7:	8b 44 24 10          	mov    0x10(%esp),%eax
   155eb:	8b 80 50 08 00 00    	mov    0x850(%eax),%eax
   155f1:	8d 50 ff             	lea    -0x1(%eax),%edx
   155f4:	8b 44 24 10          	mov    0x10(%esp),%eax
   155f8:	89 90 50 08 00 00    	mov    %edx,0x850(%eax)
			if (c==EOF_CHAR(tty) && L_CANON(tty))
   155fe:	0f be 54 24 07       	movsbl 0x7(%esp),%edx
   15603:	8b 44 24 10          	mov    0x10(%esp),%eax
   15607:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1560b:	0f b6 c0             	movzbl %al,%eax
   1560e:	39 c2                	cmp    %eax,%edx
   15610:	75 1f                	jne    15631 <tty_read+0x23d>
   15612:	8b 44 24 10          	mov    0x10(%esp),%eax
   15616:	8b 40 0c             	mov    0xc(%eax),%eax
   15619:	83 e0 02             	and    $0x2,%eax
   1561c:	85 c0                	test   %eax,%eax
   1561e:	74 11                	je     15631 <tty_read+0x23d>
				return (b-buf);
   15620:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   15624:	8b 44 24 34          	mov    0x34(%esp),%eax
   15628:	29 c2                	sub    %eax,%edx
   1562a:	89 d0                	mov    %edx,%eax
   1562c:	e9 35 01 00 00       	jmp    15766 <tty_read+0x372>
			else {
				put_fs_byte(c,b++);
   15631:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   15635:	8d 50 01             	lea    0x1(%eax),%edx
   15638:	89 54 24 1c          	mov    %edx,0x1c(%esp)
   1563c:	0f be 54 24 07       	movsbl 0x7(%esp),%edx
   15641:	83 ec 08             	sub    $0x8,%esp
   15644:	50                   	push   %eax
   15645:	52                   	push   %edx
   15646:	e8 34 f6 ff ff       	call   14c7f <put_fs_byte>
   1564b:	83 c4 10             	add    $0x10,%esp
				if (!--nr)
   1564e:	83 6c 24 38 01       	subl   $0x1,0x38(%esp)
   15653:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   15658:	74 25                	je     1567f <tty_read+0x28b>
					break;
			}
		} while (nr>0 && !EMPTY(tty->secondary));
   1565a:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   1565f:	7e 1f                	jle    15680 <tty_read+0x28c>
   15661:	8b 44 24 10          	mov    0x10(%esp),%eax
   15665:	8b 90 54 08 00 00    	mov    0x854(%eax),%edx
   1566b:	8b 44 24 10          	mov    0x10(%esp),%eax
   1566f:	8b 80 58 08 00 00    	mov    0x858(%eax),%eax
   15675:	39 c2                	cmp    %eax,%edx
   15677:	0f 85 17 ff ff ff    	jne    15594 <tty_read+0x1a0>
   1567d:	eb 01                	jmp    15680 <tty_read+0x28c>
			if (c==EOF_CHAR(tty) && L_CANON(tty))
				return (b-buf);
			else {
				put_fs_byte(c,b++);
				if (!--nr)
					break;
   1567f:	90                   	nop
			}
		} while (nr>0 && !EMPTY(tty->secondary));
		if (time && !L_CANON(tty)) {
   15680:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   15685:	74 66                	je     156ed <tty_read+0x2f9>
   15687:	8b 44 24 10          	mov    0x10(%esp),%eax
   1568b:	8b 40 0c             	mov    0xc(%eax),%eax
   1568e:	83 e0 02             	and    $0x2,%eax
   15691:	85 c0                	test   %eax,%eax
   15693:	75 58                	jne    156ed <tty_read+0x2f9>
			if ((flag=(!oldalarm || time+jiffies<oldalarm)))
   15695:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   1569a:	74 12                	je     156ae <tty_read+0x2ba>
   1569c:	8b 15 e0 1e 02 00    	mov    0x21ee0,%edx
   156a2:	8b 44 24 08          	mov    0x8(%esp),%eax
   156a6:	01 d0                	add    %edx,%eax
   156a8:	3b 44 24 0c          	cmp    0xc(%esp),%eax
   156ac:	7d 07                	jge    156b5 <tty_read+0x2c1>
   156ae:	b8 01 00 00 00       	mov    $0x1,%eax
   156b3:	eb 05                	jmp    156ba <tty_read+0x2c6>
   156b5:	b8 00 00 00 00       	mov    $0x0,%eax
   156ba:	89 44 24 14          	mov    %eax,0x14(%esp)
   156be:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   156c3:	74 19                	je     156de <tty_read+0x2ea>
				current->alarm = time+jiffies;
   156c5:	a1 40 f1 01 00       	mov    0x1f140,%eax
   156ca:	8b 0d e0 1e 02 00    	mov    0x21ee0,%ecx
   156d0:	8b 54 24 08          	mov    0x8(%esp),%edx
   156d4:	01 ca                	add    %ecx,%edx
   156d6:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
   156dc:	eb 0f                	jmp    156ed <tty_read+0x2f9>
			else
				current->alarm = oldalarm;
   156de:	a1 40 f1 01 00       	mov    0x1f140,%eax
   156e3:	8b 54 24 0c          	mov    0xc(%esp),%edx
   156e7:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
		}
		if (L_CANON(tty)) {
   156ed:	8b 44 24 10          	mov    0x10(%esp),%eax
   156f1:	8b 40 0c             	mov    0xc(%eax),%eax
   156f4:	83 e0 02             	and    $0x2,%eax
   156f7:	85 c0                	test   %eax,%eax
   156f9:	74 0e                	je     15709 <tty_read+0x315>
			if (b-buf)
   156fb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   156ff:	8b 44 24 34          	mov    0x34(%esp),%eax
   15703:	39 c2                	cmp    %eax,%edx
   15705:	74 14                	je     1571b <tty_read+0x327>
				break;
   15707:	eb 23                	jmp    1572c <tty_read+0x338>
		} else if (b-buf >= minimum)
   15709:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1570d:	8b 44 24 34          	mov    0x34(%esp),%eax
   15711:	29 c2                	sub    %eax,%edx
   15713:	89 d0                	mov    %edx,%eax
   15715:	3b 44 24 18          	cmp    0x18(%esp),%eax
   15719:	7d 10                	jge    1572b <tty_read+0x337>
		if ((flag=(!oldalarm || time+jiffies<oldalarm)))
			current->alarm = time+jiffies;
	}
	if (minimum>nr)
		minimum=nr;
	while (nr>0) {
   1571b:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   15720:	0f 8f ba fd ff ff    	jg     154e0 <tty_read+0xec>
   15726:	eb 04                	jmp    1572c <tty_read+0x338>
		if (flag && (current->signal & ALRMMASK)) {
			current->signal &= ~ALRMMASK;
			break;
		}
		if (current->signal)
			break;
   15728:	90                   	nop
   15729:	eb 01                	jmp    1572c <tty_read+0x338>
		}
		if (L_CANON(tty)) {
			if (b-buf)
				break;
		} else if (b-buf >= minimum)
			break;
   1572b:	90                   	nop
	}
	current->alarm = oldalarm;
   1572c:	a1 40 f1 01 00       	mov    0x1f140,%eax
   15731:	8b 54 24 0c          	mov    0xc(%esp),%edx
   15735:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
	if (current->signal && !(b-buf))
   1573b:	a1 40 f1 01 00       	mov    0x1f140,%eax
   15740:	8b 40 0c             	mov    0xc(%eax),%eax
   15743:	85 c0                	test   %eax,%eax
   15745:	74 13                	je     1575a <tty_read+0x366>
   15747:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1574b:	8b 44 24 34          	mov    0x34(%esp),%eax
   1574f:	39 c2                	cmp    %eax,%edx
   15751:	75 07                	jne    1575a <tty_read+0x366>
		return -EINTR;
   15753:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   15758:	eb 0c                	jmp    15766 <tty_read+0x372>
	return (b-buf);
   1575a:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1575e:	8b 44 24 34          	mov    0x34(%esp),%eax
   15762:	29 c2                	sub    %eax,%edx
   15764:	89 d0                	mov    %edx,%eax
}
   15766:	83 c4 2c             	add    $0x2c,%esp
   15769:	c3                   	ret    

0001576a <tty_write>:

int tty_write(unsigned channel, char * buf, int nr)
{
   1576a:	83 ec 1c             	sub    $0x1c,%esp
	static int cr_flag=0;
	struct tty_struct * tty;
	char c, *b=buf;
   1576d:	8b 44 24 24          	mov    0x24(%esp),%eax
   15771:	89 44 24 08          	mov    %eax,0x8(%esp)

	if (channel>2 || nr<0) return -1;
   15775:	83 7c 24 20 02       	cmpl   $0x2,0x20(%esp)
   1577a:	77 07                	ja     15783 <tty_write+0x19>
   1577c:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   15781:	79 0a                	jns    1578d <tty_write+0x23>
   15783:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15788:	e9 00 02 00 00       	jmp    1598d <tty_write+0x223>
	tty = channel + tty_table;
   1578d:	8b 44 24 20          	mov    0x20(%esp),%eax
   15791:	69 c0 60 0c 00 00    	imul   $0xc60,%eax,%eax
   15797:	05 40 f4 01 00       	add    $0x1f440,%eax
   1579c:	89 44 24 04          	mov    %eax,0x4(%esp)
	while (nr>0) {
   157a0:	e9 ce 01 00 00       	jmp    15973 <tty_write+0x209>
		sleep_if_full(&tty->write_q);
   157a5:	8b 44 24 04          	mov    0x4(%esp),%eax
   157a9:	05 40 04 00 00       	add    $0x440,%eax
   157ae:	83 ec 0c             	sub    $0xc,%esp
   157b1:	50                   	push   %eax
   157b2:	e8 a7 f5 ff ff       	call   14d5e <sleep_if_full>
   157b7:	83 c4 10             	add    $0x10,%esp
		if (current->signal)
   157ba:	a1 40 f1 01 00       	mov    0x1f140,%eax
   157bf:	8b 40 0c             	mov    0xc(%eax),%eax
   157c2:	85 c0                	test   %eax,%eax
   157c4:	0f 85 b6 01 00 00    	jne    15980 <tty_write+0x216>
			break;
		while (nr>0 && !FULL(tty->write_q)) {
   157ca:	e9 56 01 00 00       	jmp    15925 <tty_write+0x1bb>
			c=get_fs_byte(b);
   157cf:	83 ec 0c             	sub    $0xc,%esp
   157d2:	ff 74 24 14          	pushl  0x14(%esp)
   157d6:	e8 96 f4 ff ff       	call   14c71 <get_fs_byte>
   157db:	83 c4 10             	add    $0x10,%esp
   157de:	88 44 24 0f          	mov    %al,0xf(%esp)
			if (O_POST(tty)) {
   157e2:	8b 44 24 04          	mov    0x4(%esp),%eax
   157e6:	8b 40 04             	mov    0x4(%eax),%eax
   157e9:	83 e0 01             	and    $0x1,%eax
   157ec:	85 c0                	test   %eax,%eax
   157ee:	0f 84 e5 00 00 00    	je     158d9 <tty_write+0x16f>
				if (c=='\r' && O_CRNL(tty))
   157f4:	80 7c 24 0f 0d       	cmpb   $0xd,0xf(%esp)
   157f9:	75 15                	jne    15810 <tty_write+0xa6>
   157fb:	8b 44 24 04          	mov    0x4(%esp),%eax
   157ff:	8b 40 04             	mov    0x4(%eax),%eax
   15802:	83 e0 08             	and    $0x8,%eax
   15805:	85 c0                	test   %eax,%eax
   15807:	74 07                	je     15810 <tty_write+0xa6>
					c='\n';
   15809:	c6 44 24 0f 0a       	movb   $0xa,0xf(%esp)
   1580e:	eb 1a                	jmp    1582a <tty_write+0xc0>
				else if (c=='\n' && O_NLRET(tty))
   15810:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   15815:	75 13                	jne    1582a <tty_write+0xc0>
   15817:	8b 44 24 04          	mov    0x4(%esp),%eax
   1581b:	8b 40 04             	mov    0x4(%eax),%eax
   1581e:	83 e0 20             	and    $0x20,%eax
   15821:	85 c0                	test   %eax,%eax
   15823:	74 05                	je     1582a <tty_write+0xc0>
					c='\r';
   15825:	c6 44 24 0f 0d       	movb   $0xd,0xf(%esp)
				if (c=='\n' && !cr_flag && O_NLCR(tty)) {
   1582a:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1582f:	75 5a                	jne    1588b <tty_write+0x121>
   15831:	a1 b4 3d 02 00       	mov    0x23db4,%eax
   15836:	85 c0                	test   %eax,%eax
   15838:	75 51                	jne    1588b <tty_write+0x121>
   1583a:	8b 44 24 04          	mov    0x4(%esp),%eax
   1583e:	8b 40 04             	mov    0x4(%eax),%eax
   15841:	83 e0 04             	and    $0x4,%eax
   15844:	85 c0                	test   %eax,%eax
   15846:	74 43                	je     1588b <tty_write+0x121>
					cr_flag = 1;
   15848:	c7 05 b4 3d 02 00 01 	movl   $0x1,0x23db4
   1584f:	00 00 00 
					PUTCH(13,tty->write_q);
   15852:	8b 44 24 04          	mov    0x4(%esp),%eax
   15856:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   1585c:	8b 54 24 04          	mov    0x4(%esp),%edx
   15860:	c6 84 02 50 04 00 00 	movb   $0xd,0x450(%edx,%eax,1)
   15867:	0d 
   15868:	8b 44 24 04          	mov    0x4(%esp),%eax
   1586c:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15872:	83 c0 01             	add    $0x1,%eax
   15875:	25 ff 03 00 00       	and    $0x3ff,%eax
   1587a:	89 c2                	mov    %eax,%edx
   1587c:	8b 44 24 04          	mov    0x4(%esp),%eax
   15880:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
					continue;
   15886:	e9 9a 00 00 00       	jmp    15925 <tty_write+0x1bb>
				}
				if (O_LCUC(tty))
   1588b:	8b 44 24 04          	mov    0x4(%esp),%eax
   1588f:	8b 40 04             	mov    0x4(%eax),%eax
   15892:	83 e0 02             	and    $0x2,%eax
   15895:	85 c0                	test   %eax,%eax
   15897:	74 40                	je     158d9 <tty_write+0x16f>
					c=toupper(c);
   15899:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1589e:	a2 64 5f 02 00       	mov    %al,0x25f64
   158a3:	0f b6 05 64 5f 02 00 	movzbl 0x25f64,%eax
   158aa:	0f be c0             	movsbl %al,%eax
   158ad:	83 c0 01             	add    $0x1,%eax
   158b0:	05 a0 19 02 00       	add    $0x219a0,%eax
   158b5:	0f b6 00             	movzbl (%eax),%eax
   158b8:	0f b6 c0             	movzbl %al,%eax
   158bb:	83 e0 02             	and    $0x2,%eax
   158be:	85 c0                	test   %eax,%eax
   158c0:	74 0c                	je     158ce <tty_write+0x164>
   158c2:	0f b6 05 64 5f 02 00 	movzbl 0x25f64,%eax
   158c9:	83 e8 20             	sub    $0x20,%eax
   158cc:	eb 07                	jmp    158d5 <tty_write+0x16b>
   158ce:	0f b6 05 64 5f 02 00 	movzbl 0x25f64,%eax
   158d5:	88 44 24 0f          	mov    %al,0xf(%esp)
			}
			b++; nr--;
   158d9:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
   158de:	83 6c 24 28 01       	subl   $0x1,0x28(%esp)
			cr_flag = 0;
   158e3:	c7 05 b4 3d 02 00 00 	movl   $0x0,0x23db4
   158ea:	00 00 00 
			PUTCH(c,tty->write_q);
   158ed:	8b 44 24 04          	mov    0x4(%esp),%eax
   158f1:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   158f7:	8b 54 24 04          	mov    0x4(%esp),%edx
   158fb:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
   15900:	88 8c 02 50 04 00 00 	mov    %cl,0x450(%edx,%eax,1)
   15907:	8b 44 24 04          	mov    0x4(%esp),%eax
   1590b:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15911:	83 c0 01             	add    $0x1,%eax
   15914:	25 ff 03 00 00       	and    $0x3ff,%eax
   15919:	89 c2                	mov    %eax,%edx
   1591b:	8b 44 24 04          	mov    0x4(%esp),%eax
   1591f:	89 90 44 04 00 00    	mov    %edx,0x444(%eax)
	tty = channel + tty_table;
	while (nr>0) {
		sleep_if_full(&tty->write_q);
		if (current->signal)
			break;
		while (nr>0 && !FULL(tty->write_q)) {
   15925:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   1592a:	7e 28                	jle    15954 <tty_write+0x1ea>
   1592c:	8b 44 24 04          	mov    0x4(%esp),%eax
   15930:	8b 90 48 04 00 00    	mov    0x448(%eax),%edx
   15936:	8b 44 24 04          	mov    0x4(%esp),%eax
   1593a:	8b 80 44 04 00 00    	mov    0x444(%eax),%eax
   15940:	29 c2                	sub    %eax,%edx
   15942:	89 d0                	mov    %edx,%eax
   15944:	83 e8 01             	sub    $0x1,%eax
   15947:	25 ff 03 00 00       	and    $0x3ff,%eax
   1594c:	85 c0                	test   %eax,%eax
   1594e:	0f 85 7b fe ff ff    	jne    157cf <tty_write+0x65>
			}
			b++; nr--;
			cr_flag = 0;
			PUTCH(c,tty->write_q);
		}
		tty->write(tty);
   15954:	8b 44 24 04          	mov    0x4(%esp),%eax
   15958:	8b 40 2c             	mov    0x2c(%eax),%eax
   1595b:	83 ec 0c             	sub    $0xc,%esp
   1595e:	ff 74 24 10          	pushl  0x10(%esp)
   15962:	ff d0                	call   *%eax
   15964:	83 c4 10             	add    $0x10,%esp
		if (nr>0)
   15967:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   1596c:	7e 05                	jle    15973 <tty_write+0x209>
			schedule();
   1596e:	e8 36 13 ff ff       	call   6ca9 <schedule>
	struct tty_struct * tty;
	char c, *b=buf;

	if (channel>2 || nr<0) return -1;
	tty = channel + tty_table;
	while (nr>0) {
   15973:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   15978:	0f 8f 27 fe ff ff    	jg     157a5 <tty_write+0x3b>
   1597e:	eb 01                	jmp    15981 <tty_write+0x217>
		sleep_if_full(&tty->write_q);
		if (current->signal)
			break;
   15980:	90                   	nop
		}
		tty->write(tty);
		if (nr>0)
			schedule();
	}
	return (b-buf);
   15981:	8b 54 24 08          	mov    0x8(%esp),%edx
   15985:	8b 44 24 24          	mov    0x24(%esp),%eax
   15989:	29 c2                	sub    %eax,%edx
   1598b:	89 d0                	mov    %edx,%eax
}
   1598d:	83 c4 1c             	add    $0x1c,%esp
   15990:	c3                   	ret    

00015991 <do_tty_interrupt>:
 * I don't think we sleep here under normal circumstances
 * anyway, which is good, as the task sleeping might be
 * totally innocent.
 */
void do_tty_interrupt(int tty)
{
   15991:	83 ec 0c             	sub    $0xc,%esp
	copy_to_cooked(tty_table+tty);
   15994:	8b 44 24 10          	mov    0x10(%esp),%eax
   15998:	69 c0 60 0c 00 00    	imul   $0xc60,%eax,%eax
   1599e:	05 40 f4 01 00       	add    $0x1f440,%eax
   159a3:	83 ec 0c             	sub    $0xc,%esp
   159a6:	50                   	push   %eax
   159a7:	e8 34 f4 ff ff       	call   14de0 <copy_to_cooked>
   159ac:	83 c4 10             	add    $0x10,%esp
}
   159af:	90                   	nop
   159b0:	83 c4 0c             	add    $0xc,%esp
   159b3:	c3                   	ret    

000159b4 <chr_dev_init>:

void chr_dev_init(void)
{
}
   159b4:	90                   	nop
   159b5:	c3                   	ret    

000159b6 <gotoxy>:
#define RESPONSE "\033[?1;2c"

/* NOTE! gotoxy thinks x==video_num_columns is ok */
static inline void gotoxy(unsigned int new_x,unsigned int new_y)
{
	if (new_x > video_num_columns || new_y >= video_num_lines)
   159b6:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   159bb:	39 44 24 04          	cmp    %eax,0x4(%esp)
   159bf:	77 42                	ja     15a03 <gotoxy+0x4d>
   159c1:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   159c6:	39 44 24 08          	cmp    %eax,0x8(%esp)
   159ca:	73 37                	jae    15a03 <gotoxy+0x4d>
		return;
	x=new_x;
   159cc:	8b 44 24 04          	mov    0x4(%esp),%eax
   159d0:	a3 f4 3d 02 00       	mov    %eax,0x23df4
	y=new_y;
   159d5:	8b 44 24 08          	mov    0x8(%esp),%eax
   159d9:	a3 f8 3d 02 00       	mov    %eax,0x23df8
	pos=origin + y*video_size_row + (x<<1);
   159de:	8b 15 f8 3d 02 00    	mov    0x23df8,%edx
   159e4:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   159e9:	0f af d0             	imul   %eax,%edx
   159ec:	a1 e8 3d 02 00       	mov    0x23de8,%eax
   159f1:	01 c2                	add    %eax,%edx
   159f3:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   159f8:	01 c0                	add    %eax,%eax
   159fa:	01 d0                	add    %edx,%eax
   159fc:	a3 f0 3d 02 00       	mov    %eax,0x23df0
   15a01:	eb 01                	jmp    15a04 <gotoxy+0x4e>

/* NOTE! gotoxy thinks x==video_num_columns is ok */
static inline void gotoxy(unsigned int new_x,unsigned int new_y)
{
	if (new_x > video_num_columns || new_y >= video_num_lines)
		return;
   15a03:	90                   	nop
	x=new_x;
	y=new_y;
	pos=origin + y*video_size_row + (x<<1);
}
   15a04:	c3                   	ret    

00015a05 <set_origin>:

static inline void set_origin(void)
{
	cli();
   15a05:	fa                   	cli    
	outb_p(12, video_port_reg);
   15a06:	0f b7 15 e0 3d 02 00 	movzwl 0x23de0,%edx
   15a0d:	b8 0c 00 00 00       	mov    $0xc,%eax
   15a12:	ee                   	out    %al,(%dx)
   15a13:	eb 00                	jmp    15a15 <set_origin+0x10>
   15a15:	eb 00                	jmp    15a17 <set_origin+0x12>
	outb_p(0xff&((origin-video_mem_start)>>9), video_port_val);
   15a17:	8b 15 e8 3d 02 00    	mov    0x23de8,%edx
   15a1d:	a1 d8 3d 02 00       	mov    0x23dd8,%eax
   15a22:	29 c2                	sub    %eax,%edx
   15a24:	89 d0                	mov    %edx,%eax
   15a26:	c1 e8 09             	shr    $0x9,%eax
   15a29:	0f b6 c0             	movzbl %al,%eax
   15a2c:	0f b7 15 e2 3d 02 00 	movzwl 0x23de2,%edx
   15a33:	ee                   	out    %al,(%dx)
   15a34:	eb 00                	jmp    15a36 <set_origin+0x31>
   15a36:	eb 00                	jmp    15a38 <set_origin+0x33>
	outb_p(13, video_port_reg);
   15a38:	0f b7 15 e0 3d 02 00 	movzwl 0x23de0,%edx
   15a3f:	b8 0d 00 00 00       	mov    $0xd,%eax
   15a44:	ee                   	out    %al,(%dx)
   15a45:	eb 00                	jmp    15a47 <set_origin+0x42>
   15a47:	eb 00                	jmp    15a49 <set_origin+0x44>
	outb_p(0xff&((origin-video_mem_start)>>1), video_port_val);
   15a49:	8b 15 e8 3d 02 00    	mov    0x23de8,%edx
   15a4f:	a1 d8 3d 02 00       	mov    0x23dd8,%eax
   15a54:	29 c2                	sub    %eax,%edx
   15a56:	89 d0                	mov    %edx,%eax
   15a58:	d1 e8                	shr    %eax
   15a5a:	0f b6 c0             	movzbl %al,%eax
   15a5d:	0f b7 15 e2 3d 02 00 	movzwl 0x23de2,%edx
   15a64:	ee                   	out    %al,(%dx)
   15a65:	eb 00                	jmp    15a67 <set_origin+0x62>
   15a67:	eb 00                	jmp    15a69 <set_origin+0x64>
	sti();
   15a69:	fb                   	sti    
}
   15a6a:	90                   	nop
   15a6b:	c3                   	ret    

00015a6c <scrup>:

static void scrup(void)
{
   15a6c:	57                   	push   %edi
   15a6d:	56                   	push   %esi
   15a6e:	53                   	push   %ebx
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   15a6f:	0f b6 05 c4 3d 02 00 	movzbl 0x23dc4,%eax
   15a76:	3c 21                	cmp    $0x21,%al
   15a78:	74 0f                	je     15a89 <scrup+0x1d>
   15a7a:	0f b6 05 c4 3d 02 00 	movzbl 0x23dc4,%eax
   15a81:	3c 20                	cmp    $0x20,%al
   15a83:	0f 85 71 01 00 00    	jne    15bfa <scrup+0x18e>
	{
		if (!top && bottom == video_num_lines) {
   15a89:	a1 fc 3d 02 00       	mov    0x23dfc,%eax
   15a8e:	85 c0                	test   %eax,%eax
   15a90:	0f 85 fc 00 00 00    	jne    15b92 <scrup+0x126>
   15a96:	8b 15 00 3e 02 00    	mov    0x23e00,%edx
   15a9c:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   15aa1:	39 c2                	cmp    %eax,%edx
   15aa3:	0f 85 e9 00 00 00    	jne    15b92 <scrup+0x126>
			origin += video_size_row;
   15aa9:	8b 15 e8 3d 02 00    	mov    0x23de8,%edx
   15aaf:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   15ab4:	01 d0                	add    %edx,%eax
   15ab6:	a3 e8 3d 02 00       	mov    %eax,0x23de8
			pos += video_size_row;
   15abb:	8b 15 f0 3d 02 00    	mov    0x23df0,%edx
   15ac1:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   15ac6:	01 d0                	add    %edx,%eax
   15ac8:	a3 f0 3d 02 00       	mov    %eax,0x23df0
			scr_end += video_size_row;
   15acd:	8b 15 ec 3d 02 00    	mov    0x23dec,%edx
   15ad3:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   15ad8:	01 d0                	add    %edx,%eax
   15ada:	a3 ec 3d 02 00       	mov    %eax,0x23dec
			if (scr_end > video_mem_end) {
   15adf:	8b 15 ec 3d 02 00    	mov    0x23dec,%edx
   15ae5:	a1 dc 3d 02 00       	mov    0x23ddc,%eax
   15aea:	39 c2                	cmp    %eax,%edx
   15aec:	76 77                	jbe    15b65 <scrup+0xf9>
				__asm__("cld\n\t"
   15aee:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
					"movsl\n\t"
					"movl video_num_columns,%1\n\t"
					"rep\n\t"
					"stosw"
					::"a" (video_erase_char),
					"c" ((video_num_lines-1)*video_num_columns>>1),
   15af5:	8b 15 d0 3d 02 00    	mov    0x23dd0,%edx
   15afb:	8d 4a ff             	lea    -0x1(%edx),%ecx
   15afe:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
   15b04:	0f af d1             	imul   %ecx,%edx
   15b07:	89 d1                	mov    %edx,%ecx
   15b09:	d1 e9                	shr    %ecx
		if (!top && bottom == video_num_lines) {
			origin += video_size_row;
			pos += video_size_row;
			scr_end += video_size_row;
			if (scr_end > video_mem_end) {
				__asm__("cld\n\t"
   15b0b:	8b 15 d8 3d 02 00    	mov    0x23dd8,%edx
   15b11:	8b 1d e8 3d 02 00    	mov    0x23de8,%ebx
   15b17:	89 d7                	mov    %edx,%edi
   15b19:	89 de                	mov    %ebx,%esi
   15b1b:	fc                   	cld    
   15b1c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15b1e:	8b 0d c8 3d 02 00    	mov    0x23dc8,%ecx
   15b24:	f3 66 ab             	rep stos %ax,%es:(%edi)
					::"a" (video_erase_char),
					"c" ((video_num_lines-1)*video_num_columns>>1),
					"D" (video_mem_start),
					"S" (origin)
					);
				scr_end -= origin-video_mem_start;
   15b27:	8b 15 d8 3d 02 00    	mov    0x23dd8,%edx
   15b2d:	a1 e8 3d 02 00       	mov    0x23de8,%eax
   15b32:	29 c2                	sub    %eax,%edx
   15b34:	a1 ec 3d 02 00       	mov    0x23dec,%eax
   15b39:	01 d0                	add    %edx,%eax
   15b3b:	a3 ec 3d 02 00       	mov    %eax,0x23dec
				pos -= origin-video_mem_start;
   15b40:	8b 15 d8 3d 02 00    	mov    0x23dd8,%edx
   15b46:	a1 e8 3d 02 00       	mov    0x23de8,%eax
   15b4b:	29 c2                	sub    %eax,%edx
   15b4d:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15b52:	01 d0                	add    %edx,%eax
   15b54:	a3 f0 3d 02 00       	mov    %eax,0x23df0
				origin = video_mem_start;
   15b59:	a1 d8 3d 02 00       	mov    0x23dd8,%eax
   15b5e:	a3 e8 3d 02 00       	mov    %eax,0x23de8
   15b63:	eb 23                	jmp    15b88 <scrup+0x11c>
			} else {
				__asm__("cld\n\t"
   15b65:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
   15b6c:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
					"rep\n\t"
					"stosw"
					::"a" (video_erase_char),
					"c" (video_num_columns),
					"D" (scr_end-video_size_row)
   15b72:	8b 1d ec 3d 02 00    	mov    0x23dec,%ebx
   15b78:	8b 0d cc 3d 02 00    	mov    0x23dcc,%ecx
   15b7e:	29 cb                	sub    %ecx,%ebx
					);
				scr_end -= origin-video_mem_start;
				pos -= origin-video_mem_start;
				origin = video_mem_start;
			} else {
				__asm__("cld\n\t"
   15b80:	89 d1                	mov    %edx,%ecx
   15b82:	89 df                	mov    %ebx,%edi
   15b84:	fc                   	cld    
   15b85:	f3 66 ab             	rep stos %ax,%es:(%edi)
					::"a" (video_erase_char),
					"c" (video_num_columns),
					"D" (scr_end-video_size_row)
					);
			}
			set_origin();
   15b88:	e8 78 fe ff ff       	call   15a05 <set_origin>

static void scrup(void)
{
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
	{
		if (!top && bottom == video_num_lines) {
   15b8d:	e9 ce 00 00 00       	jmp    15c60 <scrup+0x1f4>
					"D" (scr_end-video_size_row)
					);
			}
			set_origin();
		} else {
			__asm__("cld\n\t"
   15b92:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
				"movsl\n\t"
				"movl video_num_columns,%%ecx\n\t"
				"rep\n\t"
				"stosw"
				::"a" (video_erase_char),
				"c" ((bottom-top-1)*video_num_columns>>1),
   15b99:	8b 0d 00 3e 02 00    	mov    0x23e00,%ecx
   15b9f:	8b 15 fc 3d 02 00    	mov    0x23dfc,%edx
   15ba5:	29 d1                	sub    %edx,%ecx
   15ba7:	89 ca                	mov    %ecx,%edx
   15ba9:	8d 4a ff             	lea    -0x1(%edx),%ecx
   15bac:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
   15bb2:	0f af d1             	imul   %ecx,%edx
   15bb5:	d1 ea                	shr    %edx
				"D" (origin+video_size_row*top),
   15bb7:	8b 1d cc 3d 02 00    	mov    0x23dcc,%ebx
   15bbd:	8b 0d fc 3d 02 00    	mov    0x23dfc,%ecx
   15bc3:	0f af d9             	imul   %ecx,%ebx
   15bc6:	8b 0d e8 3d 02 00    	mov    0x23de8,%ecx
   15bcc:	01 cb                	add    %ecx,%ebx
				"S" (origin+video_size_row*(top+1))
   15bce:	8b 0d fc 3d 02 00    	mov    0x23dfc,%ecx
   15bd4:	8d 71 01             	lea    0x1(%ecx),%esi
   15bd7:	8b 0d cc 3d 02 00    	mov    0x23dcc,%ecx
   15bdd:	0f af f1             	imul   %ecx,%esi
   15be0:	8b 0d e8 3d 02 00    	mov    0x23de8,%ecx
   15be6:	01 ce                	add    %ecx,%esi
					"D" (scr_end-video_size_row)
					);
			}
			set_origin();
		} else {
			__asm__("cld\n\t"
   15be8:	89 d1                	mov    %edx,%ecx
   15bea:	89 df                	mov    %ebx,%edi
   15bec:	fc                   	cld    
   15bed:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15bef:	8b 0d c8 3d 02 00    	mov    0x23dc8,%ecx
   15bf5:	f3 66 ab             	rep stos %ax,%es:(%edi)

static void scrup(void)
{
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
	{
		if (!top && bottom == video_num_lines) {
   15bf8:	eb 66                	jmp    15c60 <scrup+0x1f4>
				);
		}
	}
	else		/* Not EGA/VGA */
	{
		__asm__("cld\n\t"
   15bfa:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
			"movsl\n\t"
			"movl video_num_columns,%%ecx\n\t"
			"rep\n\t"
			"stosw"
			::"a" (video_erase_char),
			"c" ((bottom-top-1)*video_num_columns>>1),
   15c01:	8b 0d 00 3e 02 00    	mov    0x23e00,%ecx
   15c07:	8b 15 fc 3d 02 00    	mov    0x23dfc,%edx
   15c0d:	29 d1                	sub    %edx,%ecx
   15c0f:	89 ca                	mov    %ecx,%edx
   15c11:	8d 4a ff             	lea    -0x1(%edx),%ecx
   15c14:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
   15c1a:	0f af d1             	imul   %ecx,%edx
   15c1d:	d1 ea                	shr    %edx
			"D" (origin+video_size_row*top),
   15c1f:	8b 1d cc 3d 02 00    	mov    0x23dcc,%ebx
   15c25:	8b 0d fc 3d 02 00    	mov    0x23dfc,%ecx
   15c2b:	0f af d9             	imul   %ecx,%ebx
   15c2e:	8b 0d e8 3d 02 00    	mov    0x23de8,%ecx
   15c34:	01 cb                	add    %ecx,%ebx
			"S" (origin+video_size_row*(top+1))
   15c36:	8b 0d fc 3d 02 00    	mov    0x23dfc,%ecx
   15c3c:	8d 71 01             	lea    0x1(%ecx),%esi
   15c3f:	8b 0d cc 3d 02 00    	mov    0x23dcc,%ecx
   15c45:	0f af f1             	imul   %ecx,%esi
   15c48:	8b 0d e8 3d 02 00    	mov    0x23de8,%ecx
   15c4e:	01 ce                	add    %ecx,%esi
				);
		}
	}
	else		/* Not EGA/VGA */
	{
		__asm__("cld\n\t"
   15c50:	89 d1                	mov    %edx,%ecx
   15c52:	89 df                	mov    %ebx,%edi
   15c54:	fc                   	cld    
   15c55:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15c57:	8b 0d c8 3d 02 00    	mov    0x23dc8,%ecx
   15c5d:	f3 66 ab             	rep stos %ax,%es:(%edi)
			"c" ((bottom-top-1)*video_num_columns>>1),
			"D" (origin+video_size_row*top),
			"S" (origin+video_size_row*(top+1))
			);
	}
}
   15c60:	90                   	nop
   15c61:	5b                   	pop    %ebx
   15c62:	5e                   	pop    %esi
   15c63:	5f                   	pop    %edi
   15c64:	c3                   	ret    

00015c65 <scrdown>:

static void scrdown(void)
{
   15c65:	57                   	push   %edi
   15c66:	56                   	push   %esi
   15c67:	53                   	push   %ebx
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   15c68:	0f b6 05 c4 3d 02 00 	movzbl 0x23dc4,%eax
   15c6f:	3c 21                	cmp    $0x21,%al
   15c71:	74 0b                	je     15c7e <scrdown+0x19>
   15c73:	0f b6 05 c4 3d 02 00 	movzbl 0x23dc4,%eax
   15c7a:	3c 20                	cmp    $0x20,%al
   15c7c:	75 71                	jne    15cef <scrdown+0x8a>
	{
		__asm__("std\n\t"
   15c7e:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
			"addl $2,%%edi\n\t"	/* %edi has been decremented by 4 */
			"movl video_num_columns,%%ecx\n\t"
			"rep\n\t"
			"stosw"
			::"a" (video_erase_char),
			"c" ((bottom-top-1)*video_num_columns>>1),
   15c85:	8b 0d 00 3e 02 00    	mov    0x23e00,%ecx
   15c8b:	8b 15 fc 3d 02 00    	mov    0x23dfc,%edx
   15c91:	29 d1                	sub    %edx,%ecx
   15c93:	89 ca                	mov    %ecx,%edx
   15c95:	8d 4a ff             	lea    -0x1(%edx),%ecx
   15c98:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
   15c9e:	0f af d1             	imul   %ecx,%edx
   15ca1:	d1 ea                	shr    %edx
			"D" (origin+video_size_row*bottom-4),
   15ca3:	8b 1d cc 3d 02 00    	mov    0x23dcc,%ebx
   15ca9:	8b 0d 00 3e 02 00    	mov    0x23e00,%ecx
   15caf:	0f af d9             	imul   %ecx,%ebx
   15cb2:	8b 0d e8 3d 02 00    	mov    0x23de8,%ecx
   15cb8:	01 d9                	add    %ebx,%ecx
   15cba:	8d 59 fc             	lea    -0x4(%ecx),%ebx
			"S" (origin+video_size_row*(bottom-1)-4)
   15cbd:	8b 0d 00 3e 02 00    	mov    0x23e00,%ecx
   15cc3:	8d 71 ff             	lea    -0x1(%ecx),%esi
   15cc6:	8b 0d cc 3d 02 00    	mov    0x23dcc,%ecx
   15ccc:	0f af f1             	imul   %ecx,%esi
   15ccf:	8b 0d e8 3d 02 00    	mov    0x23de8,%ecx
   15cd5:	01 f1                	add    %esi,%ecx
   15cd7:	8d 71 fc             	lea    -0x4(%ecx),%esi

static void scrdown(void)
{
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
	{
		__asm__("std\n\t"
   15cda:	89 d1                	mov    %edx,%ecx
   15cdc:	89 df                	mov    %ebx,%edi
   15cde:	fd                   	std    
   15cdf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15ce1:	83 c7 02             	add    $0x2,%edi
   15ce4:	8b 0d c8 3d 02 00    	mov    0x23dc8,%ecx
   15cea:	f3 66 ab             	rep stos %ax,%es:(%edi)
   15ced:	eb 6f                	jmp    15d5e <scrdown+0xf9>
			"S" (origin+video_size_row*(bottom-1)-4)
			);
	}
	else		/* Not EGA/VGA */
	{
		__asm__("std\n\t"
   15cef:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
			"addl $2,%%edi\n\t"	/* %edi has been decremented by 4 */
			"movl video_num_columns,%%ecx\n\t"
			"rep\n\t"
			"stosw"
			::"a" (video_erase_char),
			"c" ((bottom-top-1)*video_num_columns>>1),
   15cf6:	8b 0d 00 3e 02 00    	mov    0x23e00,%ecx
   15cfc:	8b 15 fc 3d 02 00    	mov    0x23dfc,%edx
   15d02:	29 d1                	sub    %edx,%ecx
   15d04:	89 ca                	mov    %ecx,%edx
   15d06:	8d 4a ff             	lea    -0x1(%edx),%ecx
   15d09:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
   15d0f:	0f af d1             	imul   %ecx,%edx
   15d12:	d1 ea                	shr    %edx
			"D" (origin+video_size_row*bottom-4),
   15d14:	8b 1d cc 3d 02 00    	mov    0x23dcc,%ebx
   15d1a:	8b 0d 00 3e 02 00    	mov    0x23e00,%ecx
   15d20:	0f af d9             	imul   %ecx,%ebx
   15d23:	8b 0d e8 3d 02 00    	mov    0x23de8,%ecx
   15d29:	01 d9                	add    %ebx,%ecx
   15d2b:	8d 59 fc             	lea    -0x4(%ecx),%ebx
			"S" (origin+video_size_row*(bottom-1)-4)
   15d2e:	8b 0d 00 3e 02 00    	mov    0x23e00,%ecx
   15d34:	8d 71 ff             	lea    -0x1(%ecx),%esi
   15d37:	8b 0d cc 3d 02 00    	mov    0x23dcc,%ecx
   15d3d:	0f af f1             	imul   %ecx,%esi
   15d40:	8b 0d e8 3d 02 00    	mov    0x23de8,%ecx
   15d46:	01 f1                	add    %esi,%ecx
   15d48:	8d 71 fc             	lea    -0x4(%ecx),%esi
			"S" (origin+video_size_row*(bottom-1)-4)
			);
	}
	else		/* Not EGA/VGA */
	{
		__asm__("std\n\t"
   15d4b:	89 d1                	mov    %edx,%ecx
   15d4d:	89 df                	mov    %ebx,%edi
   15d4f:	fd                   	std    
   15d50:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15d52:	83 c7 02             	add    $0x2,%edi
   15d55:	8b 0d c8 3d 02 00    	mov    0x23dc8,%ecx
   15d5b:	f3 66 ab             	rep stos %ax,%es:(%edi)
			"c" ((bottom-top-1)*video_num_columns>>1),
			"D" (origin+video_size_row*bottom-4),
			"S" (origin+video_size_row*(bottom-1)-4)
			);
	}
}
   15d5e:	90                   	nop
   15d5f:	5b                   	pop    %ebx
   15d60:	5e                   	pop    %esi
   15d61:	5f                   	pop    %edi
   15d62:	c3                   	ret    

00015d63 <lf>:

static void lf(void)
{
	if (y+1<bottom) {
   15d63:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   15d68:	8d 50 01             	lea    0x1(%eax),%edx
   15d6b:	a1 00 3e 02 00       	mov    0x23e00,%eax
   15d70:	39 c2                	cmp    %eax,%edx
   15d72:	73 21                	jae    15d95 <lf+0x32>
		y++;
   15d74:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   15d79:	83 c0 01             	add    $0x1,%eax
   15d7c:	a3 f8 3d 02 00       	mov    %eax,0x23df8
		pos += video_size_row;
   15d81:	8b 15 f0 3d 02 00    	mov    0x23df0,%edx
   15d87:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   15d8c:	01 d0                	add    %edx,%eax
   15d8e:	a3 f0 3d 02 00       	mov    %eax,0x23df0
		return;
   15d93:	eb 05                	jmp    15d9a <lf+0x37>
	}
	scrup();
   15d95:	e8 d2 fc ff ff       	call   15a6c <scrup>
}
   15d9a:	c3                   	ret    

00015d9b <ri>:

static void ri(void)
{
	if (y>top) {
   15d9b:	8b 15 f8 3d 02 00    	mov    0x23df8,%edx
   15da1:	a1 fc 3d 02 00       	mov    0x23dfc,%eax
   15da6:	39 c2                	cmp    %eax,%edx
   15da8:	76 23                	jbe    15dcd <ri+0x32>
		y--;
   15daa:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   15daf:	83 e8 01             	sub    $0x1,%eax
   15db2:	a3 f8 3d 02 00       	mov    %eax,0x23df8
		pos -= video_size_row;
   15db7:	8b 15 f0 3d 02 00    	mov    0x23df0,%edx
   15dbd:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   15dc2:	29 c2                	sub    %eax,%edx
   15dc4:	89 d0                	mov    %edx,%eax
   15dc6:	a3 f0 3d 02 00       	mov    %eax,0x23df0
		return;
   15dcb:	eb 05                	jmp    15dd2 <ri+0x37>
	}
	scrdown();
   15dcd:	e8 93 fe ff ff       	call   15c65 <scrdown>
}
   15dd2:	c3                   	ret    

00015dd3 <cr>:

static void cr(void)
{
	pos -= x<<1;
   15dd3:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15dd8:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   15dde:	01 d2                	add    %edx,%edx
   15de0:	29 d0                	sub    %edx,%eax
   15de2:	a3 f0 3d 02 00       	mov    %eax,0x23df0
	x=0;
   15de7:	c7 05 f4 3d 02 00 00 	movl   $0x0,0x23df4
   15dee:	00 00 00 
}
   15df1:	90                   	nop
   15df2:	c3                   	ret    

00015df3 <del>:

static void del(void)
{
	if (x) {
   15df3:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   15df8:	85 c0                	test   %eax,%eax
   15dfa:	74 2b                	je     15e27 <del+0x34>
		pos -= 2;
   15dfc:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15e01:	83 e8 02             	sub    $0x2,%eax
   15e04:	a3 f0 3d 02 00       	mov    %eax,0x23df0
		x--;
   15e09:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   15e0e:	83 e8 01             	sub    $0x1,%eax
   15e11:	a3 f4 3d 02 00       	mov    %eax,0x23df4
		*(unsigned short *)pos = video_erase_char;
   15e16:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15e1b:	89 c2                	mov    %eax,%edx
   15e1d:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
   15e24:	66 89 02             	mov    %ax,(%edx)
	}
}
   15e27:	90                   	nop
   15e28:	c3                   	ret    

00015e29 <csi_J>:

static void csi_J(int par)
{
   15e29:	57                   	push   %edi
   15e2a:	53                   	push   %ebx
   15e2b:	83 ec 10             	sub    $0x10,%esp
	long count;
	long start;

	switch (par) {
   15e2e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   15e32:	83 f8 01             	cmp    $0x1,%eax
   15e35:	74 2b                	je     15e62 <csi_J+0x39>
   15e37:	83 f8 02             	cmp    $0x2,%eax
   15e3a:	74 46                	je     15e82 <csi_J+0x59>
   15e3c:	85 c0                	test   %eax,%eax
   15e3e:	74 02                	je     15e42 <csi_J+0x19>
		case 2: /* erase whole display */
			count = video_num_columns * video_num_lines;
			start = origin;
			break;
		default:
			return;
   15e40:	eb 73                	jmp    15eb5 <csi_J+0x8c>
	long count;
	long start;

	switch (par) {
		case 0:	/* erase from cursor to end of display */
			count = (scr_end-pos)>>1;
   15e42:	8b 15 ec 3d 02 00    	mov    0x23dec,%edx
   15e48:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15e4d:	29 c2                	sub    %eax,%edx
   15e4f:	89 d0                	mov    %edx,%eax
   15e51:	d1 e8                	shr    %eax
   15e53:	89 44 24 0c          	mov    %eax,0xc(%esp)
			start = pos;
   15e57:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15e5c:	89 44 24 08          	mov    %eax,0x8(%esp)
			break;
   15e60:	eb 3c                	jmp    15e9e <csi_J+0x75>
		case 1:	/* erase from start to cursor */
			count = (pos-origin)>>1;
   15e62:	8b 15 f0 3d 02 00    	mov    0x23df0,%edx
   15e68:	a1 e8 3d 02 00       	mov    0x23de8,%eax
   15e6d:	29 c2                	sub    %eax,%edx
   15e6f:	89 d0                	mov    %edx,%eax
   15e71:	d1 e8                	shr    %eax
   15e73:	89 44 24 0c          	mov    %eax,0xc(%esp)
			start = origin;
   15e77:	a1 e8 3d 02 00       	mov    0x23de8,%eax
   15e7c:	89 44 24 08          	mov    %eax,0x8(%esp)
			break;
   15e80:	eb 1c                	jmp    15e9e <csi_J+0x75>
		case 2: /* erase whole display */
			count = video_num_columns * video_num_lines;
   15e82:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
   15e88:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   15e8d:	0f af c2             	imul   %edx,%eax
   15e90:	89 44 24 0c          	mov    %eax,0xc(%esp)
			start = origin;
   15e94:	a1 e8 3d 02 00       	mov    0x23de8,%eax
   15e99:	89 44 24 08          	mov    %eax,0x8(%esp)
			break;
   15e9d:	90                   	nop
		default:
			return;
	}
	__asm__("cld\n\t"
   15e9e:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
   15ea5:	8b 54 24 0c          	mov    0xc(%esp),%edx
   15ea9:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   15ead:	89 d1                	mov    %edx,%ecx
   15eaf:	89 df                	mov    %ebx,%edi
   15eb1:	fc                   	cld    
   15eb2:	f3 66 ab             	rep stos %ax,%es:(%edi)
		"rep\n\t"
		"stosw\n\t"
		::"c" (count),
		"D" (start),"a" (video_erase_char)
		);
}
   15eb5:	83 c4 10             	add    $0x10,%esp
   15eb8:	5b                   	pop    %ebx
   15eb9:	5f                   	pop    %edi
   15eba:	c3                   	ret    

00015ebb <csi_K>:

static void csi_K(int par)
{
   15ebb:	57                   	push   %edi
   15ebc:	53                   	push   %ebx
   15ebd:	83 ec 10             	sub    $0x10,%esp
	long count;
	long start;

	switch (par) {
   15ec0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   15ec4:	83 f8 01             	cmp    $0x1,%eax
   15ec7:	74 3b                	je     15f04 <csi_K+0x49>
   15ec9:	83 f8 02             	cmp    $0x2,%eax
   15ecc:	74 5f                	je     15f2d <csi_K+0x72>
   15ece:	85 c0                	test   %eax,%eax
   15ed0:	74 05                	je     15ed7 <csi_K+0x1c>
		case 2: /* erase whole line */
			start = pos - (x<<1);
			count = video_num_columns;
			break;
		default:
			return;
   15ed2:	e9 8d 00 00 00       	jmp    15f64 <csi_K+0xa9>
	long count;
	long start;

	switch (par) {
		case 0:	/* erase from cursor to end of line */
			if (x>=video_num_columns)
   15ed7:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   15edd:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   15ee2:	39 c2                	cmp    %eax,%edx
   15ee4:	73 7d                	jae    15f63 <csi_K+0xa8>
				return;
			count = video_num_columns-x;
   15ee6:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
   15eec:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   15ef1:	29 c2                	sub    %eax,%edx
   15ef3:	89 d0                	mov    %edx,%eax
   15ef5:	89 44 24 0c          	mov    %eax,0xc(%esp)
			start = pos;
   15ef9:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15efe:	89 44 24 08          	mov    %eax,0x8(%esp)
			break;
   15f02:	eb 46                	jmp    15f4a <csi_K+0x8f>
		case 1:	/* erase from start of line to cursor */
			start = pos - (x<<1);
   15f04:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15f09:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   15f0f:	01 d2                	add    %edx,%edx
   15f11:	29 d0                	sub    %edx,%eax
   15f13:	89 44 24 08          	mov    %eax,0x8(%esp)
			count = (x<video_num_columns)?x:video_num_columns;
   15f17:	8b 15 c8 3d 02 00    	mov    0x23dc8,%edx
   15f1d:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   15f22:	39 c2                	cmp    %eax,%edx
   15f24:	0f 46 c2             	cmovbe %edx,%eax
   15f27:	89 44 24 0c          	mov    %eax,0xc(%esp)
			break;
   15f2b:	eb 1d                	jmp    15f4a <csi_K+0x8f>
		case 2: /* erase whole line */
			start = pos - (x<<1);
   15f2d:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   15f32:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   15f38:	01 d2                	add    %edx,%edx
   15f3a:	29 d0                	sub    %edx,%eax
   15f3c:	89 44 24 08          	mov    %eax,0x8(%esp)
			count = video_num_columns;
   15f40:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   15f45:	89 44 24 0c          	mov    %eax,0xc(%esp)
			break;
   15f49:	90                   	nop
		default:
			return;
	}
	__asm__("cld\n\t"
   15f4a:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
   15f51:	8b 54 24 0c          	mov    0xc(%esp),%edx
   15f55:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   15f59:	89 d1                	mov    %edx,%ecx
   15f5b:	89 df                	mov    %ebx,%edi
   15f5d:	fc                   	cld    
   15f5e:	f3 66 ab             	rep stos %ax,%es:(%edi)
   15f61:	eb 01                	jmp    15f64 <csi_K+0xa9>
	long start;

	switch (par) {
		case 0:	/* erase from cursor to end of line */
			if (x>=video_num_columns)
				return;
   15f63:	90                   	nop
		"rep\n\t"
		"stosw\n\t"
		::"c" (count),
		"D" (start),"a" (video_erase_char)
		);
}
   15f64:	83 c4 10             	add    $0x10,%esp
   15f67:	5b                   	pop    %ebx
   15f68:	5f                   	pop    %edi
   15f69:	c3                   	ret    

00015f6a <csi_m>:

void csi_m(void)
{
   15f6a:	83 ec 10             	sub    $0x10,%esp
	int i;

	for (i=0;i<=npar;i++)
   15f6d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   15f74:	00 
   15f75:	eb 4a                	jmp    15fc1 <csi_m+0x57>
		switch (par[i]) {
   15f77:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15f7b:	8b 04 85 20 3e 02 00 	mov    0x23e20(,%eax,4),%eax
   15f82:	83 f8 1b             	cmp    $0x1b,%eax
   15f85:	77 35                	ja     15fbc <csi_m+0x52>
   15f87:	8b 04 85 b0 91 01 00 	mov    0x191b0(,%eax,4),%eax
   15f8e:	ff e0                	jmp    *%eax
			case 0:attr=0x07;break;
   15f90:	c6 05 78 19 02 00 07 	movb   $0x7,0x21978
   15f97:	eb 23                	jmp    15fbc <csi_m+0x52>
			case 1:attr=0x0f;break;
   15f99:	c6 05 78 19 02 00 0f 	movb   $0xf,0x21978
   15fa0:	eb 1a                	jmp    15fbc <csi_m+0x52>
			case 4:attr=0x0f;break;
   15fa2:	c6 05 78 19 02 00 0f 	movb   $0xf,0x21978
   15fa9:	eb 11                	jmp    15fbc <csi_m+0x52>
			case 7:attr=0x70;break;
   15fab:	c6 05 78 19 02 00 70 	movb   $0x70,0x21978
   15fb2:	eb 08                	jmp    15fbc <csi_m+0x52>
			case 27:attr=0x07;break;
   15fb4:	c6 05 78 19 02 00 07 	movb   $0x7,0x21978
   15fbb:	90                   	nop

void csi_m(void)
{
	int i;

	for (i=0;i<=npar;i++)
   15fbc:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   15fc1:	8b 54 24 0c          	mov    0xc(%esp),%edx
   15fc5:	a1 08 3e 02 00       	mov    0x23e08,%eax
   15fca:	39 c2                	cmp    %eax,%edx
   15fcc:	76 a9                	jbe    15f77 <csi_m+0xd>
			case 1:attr=0x0f;break;
			case 4:attr=0x0f;break;
			case 7:attr=0x70;break;
			case 27:attr=0x07;break;
		}
}
   15fce:	90                   	nop
   15fcf:	83 c4 10             	add    $0x10,%esp
   15fd2:	c3                   	ret    

00015fd3 <set_cursor>:

static inline void set_cursor(void)
{
	cli();
   15fd3:	fa                   	cli    
	outb_p(14, video_port_reg);
   15fd4:	0f b7 15 e0 3d 02 00 	movzwl 0x23de0,%edx
   15fdb:	b8 0e 00 00 00       	mov    $0xe,%eax
   15fe0:	ee                   	out    %al,(%dx)
   15fe1:	eb 00                	jmp    15fe3 <set_cursor+0x10>
   15fe3:	eb 00                	jmp    15fe5 <set_cursor+0x12>
	outb_p(0xff&((pos-video_mem_start)>>9), video_port_val);
   15fe5:	8b 15 f0 3d 02 00    	mov    0x23df0,%edx
   15feb:	a1 d8 3d 02 00       	mov    0x23dd8,%eax
   15ff0:	29 c2                	sub    %eax,%edx
   15ff2:	89 d0                	mov    %edx,%eax
   15ff4:	c1 e8 09             	shr    $0x9,%eax
   15ff7:	0f b6 c0             	movzbl %al,%eax
   15ffa:	0f b7 15 e2 3d 02 00 	movzwl 0x23de2,%edx
   16001:	ee                   	out    %al,(%dx)
   16002:	eb 00                	jmp    16004 <set_cursor+0x31>
   16004:	eb 00                	jmp    16006 <set_cursor+0x33>
	outb_p(15, video_port_reg);
   16006:	0f b7 15 e0 3d 02 00 	movzwl 0x23de0,%edx
   1600d:	b8 0f 00 00 00       	mov    $0xf,%eax
   16012:	ee                   	out    %al,(%dx)
   16013:	eb 00                	jmp    16015 <set_cursor+0x42>
   16015:	eb 00                	jmp    16017 <set_cursor+0x44>
	outb_p(0xff&((pos-video_mem_start)>>1), video_port_val);
   16017:	8b 15 f0 3d 02 00    	mov    0x23df0,%edx
   1601d:	a1 d8 3d 02 00       	mov    0x23dd8,%eax
   16022:	29 c2                	sub    %eax,%edx
   16024:	89 d0                	mov    %edx,%eax
   16026:	d1 e8                	shr    %eax
   16028:	0f b6 c0             	movzbl %al,%eax
   1602b:	0f b7 15 e2 3d 02 00 	movzwl 0x23de2,%edx
   16032:	ee                   	out    %al,(%dx)
   16033:	eb 00                	jmp    16035 <set_cursor+0x62>
   16035:	eb 00                	jmp    16037 <set_cursor+0x64>
	sti();
   16037:	fb                   	sti    
}
   16038:	90                   	nop
   16039:	c3                   	ret    

0001603a <respond>:

static void respond(struct tty_struct * tty)
{
   1603a:	83 ec 1c             	sub    $0x1c,%esp
	char * p = RESPONSE;
   1603d:	c7 44 24 0c 20 92 01 	movl   $0x19220,0xc(%esp)
   16044:	00 

	cli();
   16045:	fa                   	cli    
	while (*p) {
   16046:	eb 33                	jmp    1607b <respond+0x41>
		PUTCH(*p,tty->read_q);
   16048:	8b 44 24 20          	mov    0x20(%esp),%eax
   1604c:	8b 40 34             	mov    0x34(%eax),%eax
   1604f:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16053:	0f b6 0a             	movzbl (%edx),%ecx
   16056:	8b 54 24 20          	mov    0x20(%esp),%edx
   1605a:	88 4c 02 40          	mov    %cl,0x40(%edx,%eax,1)
   1605e:	8b 44 24 20          	mov    0x20(%esp),%eax
   16062:	8b 40 34             	mov    0x34(%eax),%eax
   16065:	83 c0 01             	add    $0x1,%eax
   16068:	25 ff 03 00 00       	and    $0x3ff,%eax
   1606d:	89 c2                	mov    %eax,%edx
   1606f:	8b 44 24 20          	mov    0x20(%esp),%eax
   16073:	89 50 34             	mov    %edx,0x34(%eax)
		p++;
   16076:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
static void respond(struct tty_struct * tty)
{
	char * p = RESPONSE;

	cli();
	while (*p) {
   1607b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1607f:	0f b6 00             	movzbl (%eax),%eax
   16082:	84 c0                	test   %al,%al
   16084:	75 c2                	jne    16048 <respond+0xe>
		PUTCH(*p,tty->read_q);
		p++;
	}
	sti();
   16086:	fb                   	sti    
	copy_to_cooked(tty);
   16087:	83 ec 0c             	sub    $0xc,%esp
   1608a:	ff 74 24 2c          	pushl  0x2c(%esp)
   1608e:	e8 4d ed ff ff       	call   14de0 <copy_to_cooked>
   16093:	83 c4 10             	add    $0x10,%esp
}
   16096:	90                   	nop
   16097:	83 c4 1c             	add    $0x1c,%esp
   1609a:	c3                   	ret    

0001609b <insert_char>:

static void insert_char(void)
{
   1609b:	83 ec 10             	sub    $0x10,%esp
	int i=x;
   1609e:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   160a3:	89 44 24 0c          	mov    %eax,0xc(%esp)
	unsigned short tmp, old = video_erase_char;
   160a7:	0f b7 05 e4 3d 02 00 	movzwl 0x23de4,%eax
   160ae:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
	unsigned short * p = (unsigned short *) pos;
   160b3:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   160b8:	89 44 24 04          	mov    %eax,0x4(%esp)

	while (i++<video_num_columns) {
   160bc:	eb 27                	jmp    160e5 <insert_char+0x4a>
		tmp=*p;
   160be:	8b 44 24 04          	mov    0x4(%esp),%eax
   160c2:	0f b7 00             	movzwl (%eax),%eax
   160c5:	66 89 44 24 02       	mov    %ax,0x2(%esp)
		*p=old;
   160ca:	8b 44 24 04          	mov    0x4(%esp),%eax
   160ce:	0f b7 54 24 0a       	movzwl 0xa(%esp),%edx
   160d3:	66 89 10             	mov    %dx,(%eax)
		old=tmp;
   160d6:	0f b7 44 24 02       	movzwl 0x2(%esp),%eax
   160db:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
		p++;
   160e0:	83 44 24 04 02       	addl   $0x2,0x4(%esp)
{
	int i=x;
	unsigned short tmp, old = video_erase_char;
	unsigned short * p = (unsigned short *) pos;

	while (i++<video_num_columns) {
   160e5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   160e9:	8d 50 01             	lea    0x1(%eax),%edx
   160ec:	89 54 24 0c          	mov    %edx,0xc(%esp)
   160f0:	89 c2                	mov    %eax,%edx
   160f2:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   160f7:	39 c2                	cmp    %eax,%edx
   160f9:	72 c3                	jb     160be <insert_char+0x23>
		tmp=*p;
		*p=old;
		old=tmp;
		p++;
	}
}
   160fb:	90                   	nop
   160fc:	83 c4 10             	add    $0x10,%esp
   160ff:	c3                   	ret    

00016100 <insert_line>:

static void insert_line(void)
{
   16100:	83 ec 10             	sub    $0x10,%esp
	int oldtop,oldbottom;

	oldtop=top;
   16103:	a1 fc 3d 02 00       	mov    0x23dfc,%eax
   16108:	89 44 24 0c          	mov    %eax,0xc(%esp)
	oldbottom=bottom;
   1610c:	a1 00 3e 02 00       	mov    0x23e00,%eax
   16111:	89 44 24 08          	mov    %eax,0x8(%esp)
	top=y;
   16115:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   1611a:	a3 fc 3d 02 00       	mov    %eax,0x23dfc
	bottom = video_num_lines;
   1611f:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   16124:	a3 00 3e 02 00       	mov    %eax,0x23e00
	scrdown();
   16129:	e8 37 fb ff ff       	call   15c65 <scrdown>
	top=oldtop;
   1612e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16132:	a3 fc 3d 02 00       	mov    %eax,0x23dfc
	bottom=oldbottom;
   16137:	8b 44 24 08          	mov    0x8(%esp),%eax
   1613b:	a3 00 3e 02 00       	mov    %eax,0x23e00
}
   16140:	90                   	nop
   16141:	83 c4 10             	add    $0x10,%esp
   16144:	c3                   	ret    

00016145 <delete_char>:

static void delete_char(void)
{
   16145:	83 ec 10             	sub    $0x10,%esp
	int i;
	unsigned short * p = (unsigned short *) pos;
   16148:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   1614d:	89 44 24 08          	mov    %eax,0x8(%esp)

	if (x>=video_num_columns)
   16151:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   16157:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   1615c:	39 c2                	cmp    %eax,%edx
   1615e:	73 41                	jae    161a1 <delete_char+0x5c>
		return;
	i = x;
   16160:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   16165:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (++i < video_num_columns) {
   16169:	eb 14                	jmp    1617f <delete_char+0x3a>
		*p = *(p+1);
   1616b:	8b 44 24 08          	mov    0x8(%esp),%eax
   1616f:	0f b7 50 02          	movzwl 0x2(%eax),%edx
   16173:	8b 44 24 08          	mov    0x8(%esp),%eax
   16177:	66 89 10             	mov    %dx,(%eax)
		p++;
   1617a:	83 44 24 08 02       	addl   $0x2,0x8(%esp)
	unsigned short * p = (unsigned short *) pos;

	if (x>=video_num_columns)
		return;
	i = x;
	while (++i < video_num_columns) {
   1617f:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   16184:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16188:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   1618d:	39 c2                	cmp    %eax,%edx
   1618f:	72 da                	jb     1616b <delete_char+0x26>
		*p = *(p+1);
		p++;
	}
	*p = video_erase_char;
   16191:	0f b7 15 e4 3d 02 00 	movzwl 0x23de4,%edx
   16198:	8b 44 24 08          	mov    0x8(%esp),%eax
   1619c:	66 89 10             	mov    %dx,(%eax)
   1619f:	eb 01                	jmp    161a2 <delete_char+0x5d>
{
	int i;
	unsigned short * p = (unsigned short *) pos;

	if (x>=video_num_columns)
		return;
   161a1:	90                   	nop
	while (++i < video_num_columns) {
		*p = *(p+1);
		p++;
	}
	*p = video_erase_char;
}
   161a2:	83 c4 10             	add    $0x10,%esp
   161a5:	c3                   	ret    

000161a6 <delete_line>:

static void delete_line(void)
{
   161a6:	83 ec 10             	sub    $0x10,%esp
	int oldtop,oldbottom;

	oldtop=top;
   161a9:	a1 fc 3d 02 00       	mov    0x23dfc,%eax
   161ae:	89 44 24 0c          	mov    %eax,0xc(%esp)
	oldbottom=bottom;
   161b2:	a1 00 3e 02 00       	mov    0x23e00,%eax
   161b7:	89 44 24 08          	mov    %eax,0x8(%esp)
	top=y;
   161bb:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   161c0:	a3 fc 3d 02 00       	mov    %eax,0x23dfc
	bottom = video_num_lines;
   161c5:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   161ca:	a3 00 3e 02 00       	mov    %eax,0x23e00
	scrup();
   161cf:	e8 98 f8 ff ff       	call   15a6c <scrup>
	top=oldtop;
   161d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   161d8:	a3 fc 3d 02 00       	mov    %eax,0x23dfc
	bottom=oldbottom;
   161dd:	8b 44 24 08          	mov    0x8(%esp),%eax
   161e1:	a3 00 3e 02 00       	mov    %eax,0x23e00
}
   161e6:	90                   	nop
   161e7:	83 c4 10             	add    $0x10,%esp
   161ea:	c3                   	ret    

000161eb <csi_at>:

static void csi_at(unsigned int nr)
{
	if (nr > video_num_columns)
   161eb:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   161f0:	39 44 24 04          	cmp    %eax,0x4(%esp)
   161f4:	76 0b                	jbe    16201 <csi_at+0x16>
		nr = video_num_columns;
   161f6:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   161fb:	89 44 24 04          	mov    %eax,0x4(%esp)
   161ff:	eb 16                	jmp    16217 <csi_at+0x2c>
	else if (!nr)
   16201:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   16206:	75 0f                	jne    16217 <csi_at+0x2c>
		nr = 1;
   16208:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
   1620f:	00 
	while (nr--)
   16210:	eb 05                	jmp    16217 <csi_at+0x2c>
		insert_char();
   16212:	e8 84 fe ff ff       	call   1609b <insert_char>
{
	if (nr > video_num_columns)
		nr = video_num_columns;
	else if (!nr)
		nr = 1;
	while (nr--)
   16217:	8b 44 24 04          	mov    0x4(%esp),%eax
   1621b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1621e:	89 54 24 04          	mov    %edx,0x4(%esp)
   16222:	85 c0                	test   %eax,%eax
   16224:	75 ec                	jne    16212 <csi_at+0x27>
		insert_char();
}
   16226:	90                   	nop
   16227:	c3                   	ret    

00016228 <csi_L>:

static void csi_L(unsigned int nr)
{
	if (nr > video_num_lines)
   16228:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   1622d:	39 44 24 04          	cmp    %eax,0x4(%esp)
   16231:	76 0b                	jbe    1623e <csi_L+0x16>
		nr = video_num_lines;
   16233:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   16238:	89 44 24 04          	mov    %eax,0x4(%esp)
   1623c:	eb 16                	jmp    16254 <csi_L+0x2c>
	else if (!nr)
   1623e:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   16243:	75 0f                	jne    16254 <csi_L+0x2c>
		nr = 1;
   16245:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
   1624c:	00 
	while (nr--)
   1624d:	eb 05                	jmp    16254 <csi_L+0x2c>
		insert_line();
   1624f:	e8 ac fe ff ff       	call   16100 <insert_line>
{
	if (nr > video_num_lines)
		nr = video_num_lines;
	else if (!nr)
		nr = 1;
	while (nr--)
   16254:	8b 44 24 04          	mov    0x4(%esp),%eax
   16258:	8d 50 ff             	lea    -0x1(%eax),%edx
   1625b:	89 54 24 04          	mov    %edx,0x4(%esp)
   1625f:	85 c0                	test   %eax,%eax
   16261:	75 ec                	jne    1624f <csi_L+0x27>
		insert_line();
}
   16263:	90                   	nop
   16264:	c3                   	ret    

00016265 <csi_P>:

static void csi_P(unsigned int nr)
{
	if (nr > video_num_columns)
   16265:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   1626a:	39 44 24 04          	cmp    %eax,0x4(%esp)
   1626e:	76 0b                	jbe    1627b <csi_P+0x16>
		nr = video_num_columns;
   16270:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   16275:	89 44 24 04          	mov    %eax,0x4(%esp)
   16279:	eb 16                	jmp    16291 <csi_P+0x2c>
	else if (!nr)
   1627b:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   16280:	75 0f                	jne    16291 <csi_P+0x2c>
		nr = 1;
   16282:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
   16289:	00 
	while (nr--)
   1628a:	eb 05                	jmp    16291 <csi_P+0x2c>
		delete_char();
   1628c:	e8 b4 fe ff ff       	call   16145 <delete_char>
{
	if (nr > video_num_columns)
		nr = video_num_columns;
	else if (!nr)
		nr = 1;
	while (nr--)
   16291:	8b 44 24 04          	mov    0x4(%esp),%eax
   16295:	8d 50 ff             	lea    -0x1(%eax),%edx
   16298:	89 54 24 04          	mov    %edx,0x4(%esp)
   1629c:	85 c0                	test   %eax,%eax
   1629e:	75 ec                	jne    1628c <csi_P+0x27>
		delete_char();
}
   162a0:	90                   	nop
   162a1:	c3                   	ret    

000162a2 <csi_M>:

static void csi_M(unsigned int nr)
{
	if (nr > video_num_lines)
   162a2:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   162a7:	39 44 24 04          	cmp    %eax,0x4(%esp)
   162ab:	76 0b                	jbe    162b8 <csi_M+0x16>
		nr = video_num_lines;
   162ad:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   162b2:	89 44 24 04          	mov    %eax,0x4(%esp)
   162b6:	eb 16                	jmp    162ce <csi_M+0x2c>
	else if (!nr)
   162b8:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   162bd:	75 0f                	jne    162ce <csi_M+0x2c>
		nr=1;
   162bf:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
   162c6:	00 
	while (nr--)
   162c7:	eb 05                	jmp    162ce <csi_M+0x2c>
		delete_line();
   162c9:	e8 d8 fe ff ff       	call   161a6 <delete_line>
{
	if (nr > video_num_lines)
		nr = video_num_lines;
	else if (!nr)
		nr=1;
	while (nr--)
   162ce:	8b 44 24 04          	mov    0x4(%esp),%eax
   162d2:	8d 50 ff             	lea    -0x1(%eax),%edx
   162d5:	89 54 24 04          	mov    %edx,0x4(%esp)
   162d9:	85 c0                	test   %eax,%eax
   162db:	75 ec                	jne    162c9 <csi_M+0x27>
		delete_line();
}
   162dd:	90                   	nop
   162de:	c3                   	ret    

000162df <save_cur>:
static int saved_x=0;
static int saved_y=0;

static void save_cur(void)
{
	saved_x=x;
   162df:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   162e4:	a3 64 3e 02 00       	mov    %eax,0x23e64
	saved_y=y;
   162e9:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   162ee:	a3 68 3e 02 00       	mov    %eax,0x23e68
}
   162f3:	90                   	nop
   162f4:	c3                   	ret    

000162f5 <restore_cur>:

static void restore_cur(void)
{
	gotoxy(saved_x, saved_y);
   162f5:	a1 68 3e 02 00       	mov    0x23e68,%eax
   162fa:	89 c2                	mov    %eax,%edx
   162fc:	a1 64 3e 02 00       	mov    0x23e64,%eax
   16301:	52                   	push   %edx
   16302:	50                   	push   %eax
   16303:	e8 ae f6 ff ff       	call   159b6 <gotoxy>
   16308:	83 c4 08             	add    $0x8,%esp
}
   1630b:	90                   	nop
   1630c:	c3                   	ret    

0001630d <con_write>:

void con_write(struct tty_struct * tty)
{
   1630d:	83 ec 1c             	sub    $0x1c,%esp
	int nr;
	char c;

	nr = CHARS(tty->write_q);
   16310:	8b 44 24 20          	mov    0x20(%esp),%eax
   16314:	8b 90 44 04 00 00    	mov    0x444(%eax),%edx
   1631a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1631e:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   16324:	29 c2                	sub    %eax,%edx
   16326:	89 d0                	mov    %edx,%eax
   16328:	25 ff 03 00 00       	and    $0x3ff,%eax
   1632d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (nr--) {
   16331:	e9 a2 06 00 00       	jmp    169d8 <con_write+0x6cb>
		GETCH(tty->write_q,c);
   16336:	8b 44 24 20          	mov    0x20(%esp),%eax
   1633a:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   16340:	8b 54 24 20          	mov    0x20(%esp),%edx
   16344:	0f b6 84 02 50 04 00 	movzbl 0x450(%edx,%eax,1),%eax
   1634b:	00 
   1634c:	88 44 24 0b          	mov    %al,0xb(%esp)
   16350:	8b 44 24 20          	mov    0x20(%esp),%eax
   16354:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   1635a:	83 c0 01             	add    $0x1,%eax
   1635d:	25 ff 03 00 00       	and    $0x3ff,%eax
   16362:	89 c2                	mov    %eax,%edx
   16364:	8b 44 24 20          	mov    0x20(%esp),%eax
   16368:	89 90 48 04 00 00    	mov    %edx,0x448(%eax)
		switch(state) {
   1636e:	a1 04 3e 02 00       	mov    0x23e04,%eax
   16373:	83 f8 04             	cmp    $0x4,%eax
   16376:	0f 87 5c 06 00 00    	ja     169d8 <con_write+0x6cb>
   1637c:	8b 04 85 28 92 01 00 	mov    0x19228(,%eax,4),%eax
   16383:	ff e0                	jmp    *%eax
			case 0:
				if (c>31 && c<127) {
   16385:	80 7c 24 0b 1f       	cmpb   $0x1f,0xb(%esp)
   1638a:	7e 77                	jle    16403 <con_write+0xf6>
   1638c:	80 7c 24 0b 7f       	cmpb   $0x7f,0xb(%esp)
   16391:	74 70                	je     16403 <con_write+0xf6>
					if (x>=video_num_columns) {
   16393:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   16399:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   1639e:	39 c2                	cmp    %eax,%edx
   163a0:	72 2d                	jb     163cf <con_write+0xc2>
						x -= video_num_columns;
   163a2:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   163a8:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   163ad:	29 c2                	sub    %eax,%edx
   163af:	89 d0                	mov    %edx,%eax
   163b1:	a3 f4 3d 02 00       	mov    %eax,0x23df4
						pos -= video_size_row;
   163b6:	8b 15 f0 3d 02 00    	mov    0x23df0,%edx
   163bc:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   163c1:	29 c2                	sub    %eax,%edx
   163c3:	89 d0                	mov    %edx,%eax
   163c5:	a3 f0 3d 02 00       	mov    %eax,0x23df0
						lf();
   163ca:	e8 94 f9 ff ff       	call   15d63 <lf>
					}
					__asm__("movb attr,%%ah\n\t"
						"movw %%ax,%1\n\t"
						::"a" (c),"m" (*(short *)pos)
   163cf:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   163d4:	89 c2                	mov    %eax,%edx
					if (x>=video_num_columns) {
						x -= video_num_columns;
						pos -= video_size_row;
						lf();
					}
					__asm__("movb attr,%%ah\n\t"
   163d6:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
   163db:	8a 25 78 19 02 00    	mov    0x21978,%ah
   163e1:	66 89 02             	mov    %ax,(%edx)
						"movw %%ax,%1\n\t"
						::"a" (c),"m" (*(short *)pos)
						);
					pos += 2;
   163e4:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   163e9:	83 c0 02             	add    $0x2,%eax
   163ec:	a3 f0 3d 02 00       	mov    %eax,0x23df0
					x++;
   163f1:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   163f6:	83 c0 01             	add    $0x1,%eax
   163f9:	a3 f4 3d 02 00       	mov    %eax,0x23df4
   163fe:	e9 33 01 00 00       	jmp    16536 <con_write+0x229>
				} else if (c==27)
   16403:	80 7c 24 0b 1b       	cmpb   $0x1b,0xb(%esp)
   16408:	75 0f                	jne    16419 <con_write+0x10c>
					state=1;
   1640a:	c7 05 04 3e 02 00 01 	movl   $0x1,0x23e04
   16411:	00 00 00 
   16414:	e9 bf 05 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (c==10 || c==11 || c==12)
   16419:	80 7c 24 0b 0a       	cmpb   $0xa,0xb(%esp)
   1641e:	74 0e                	je     1642e <con_write+0x121>
   16420:	80 7c 24 0b 0b       	cmpb   $0xb,0xb(%esp)
   16425:	74 07                	je     1642e <con_write+0x121>
   16427:	80 7c 24 0b 0c       	cmpb   $0xc,0xb(%esp)
   1642c:	75 0a                	jne    16438 <con_write+0x12b>
					lf();
   1642e:	e8 30 f9 ff ff       	call   15d63 <lf>
   16433:	e9 fe 00 00 00       	jmp    16536 <con_write+0x229>
				else if (c==13)
   16438:	80 7c 24 0b 0d       	cmpb   $0xd,0xb(%esp)
   1643d:	75 0a                	jne    16449 <con_write+0x13c>
					cr();
   1643f:	e8 8f f9 ff ff       	call   15dd3 <cr>
   16444:	e9 8f 05 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (c==ERASE_CHAR(tty))
   16449:	0f be 54 24 0b       	movsbl 0xb(%esp),%edx
   1644e:	8b 44 24 20          	mov    0x20(%esp),%eax
   16452:	0f b6 40 13          	movzbl 0x13(%eax),%eax
   16456:	0f b6 c0             	movzbl %al,%eax
   16459:	39 c2                	cmp    %eax,%edx
   1645b:	75 0a                	jne    16467 <con_write+0x15a>
					del();
   1645d:	e8 91 f9 ff ff       	call   15df3 <del>
   16462:	e9 71 05 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (c==8) {
   16467:	80 7c 24 0b 08       	cmpb   $0x8,0xb(%esp)
   1646c:	75 2c                	jne    1649a <con_write+0x18d>
					if (x) {
   1646e:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   16473:	85 c0                	test   %eax,%eax
   16475:	0f 84 5d 05 00 00    	je     169d8 <con_write+0x6cb>
						x--;
   1647b:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   16480:	83 e8 01             	sub    $0x1,%eax
   16483:	a3 f4 3d 02 00       	mov    %eax,0x23df4
						pos -= 2;
   16488:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   1648d:	83 e8 02             	sub    $0x2,%eax
   16490:	a3 f0 3d 02 00       	mov    %eax,0x23df0
   16495:	e9 3e 05 00 00       	jmp    169d8 <con_write+0x6cb>
					}
				} else if (c==9) {
   1649a:	80 7c 24 0b 09       	cmpb   $0x9,0xb(%esp)
   1649f:	0f 85 81 00 00 00    	jne    16526 <con_write+0x219>
					c=8-(x&7);
   164a5:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   164aa:	83 e0 07             	and    $0x7,%eax
   164ad:	ba 08 00 00 00       	mov    $0x8,%edx
   164b2:	29 c2                	sub    %eax,%edx
   164b4:	89 d0                	mov    %edx,%eax
   164b6:	88 44 24 0b          	mov    %al,0xb(%esp)
					x += c;
   164ba:	0f be 54 24 0b       	movsbl 0xb(%esp),%edx
   164bf:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   164c4:	01 d0                	add    %edx,%eax
   164c6:	a3 f4 3d 02 00       	mov    %eax,0x23df4
					pos += c<<1;
   164cb:	0f be 44 24 0b       	movsbl 0xb(%esp),%eax
   164d0:	01 c0                	add    %eax,%eax
   164d2:	89 c2                	mov    %eax,%edx
   164d4:	a1 f0 3d 02 00       	mov    0x23df0,%eax
   164d9:	01 d0                	add    %edx,%eax
   164db:	a3 f0 3d 02 00       	mov    %eax,0x23df0
					if (x>video_num_columns) {
   164e0:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   164e6:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   164eb:	39 c2                	cmp    %eax,%edx
   164ed:	76 2d                	jbe    1651c <con_write+0x20f>
						x -= video_num_columns;
   164ef:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   164f5:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   164fa:	29 c2                	sub    %eax,%edx
   164fc:	89 d0                	mov    %edx,%eax
   164fe:	a3 f4 3d 02 00       	mov    %eax,0x23df4
						pos -= video_size_row;
   16503:	8b 15 f0 3d 02 00    	mov    0x23df0,%edx
   16509:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   1650e:	29 c2                	sub    %eax,%edx
   16510:	89 d0                	mov    %edx,%eax
   16512:	a3 f0 3d 02 00       	mov    %eax,0x23df0
						lf();
   16517:	e8 47 f8 ff ff       	call   15d63 <lf>
					}
					c=9;
   1651c:	c6 44 24 0b 09       	movb   $0x9,0xb(%esp)
   16521:	e9 b2 04 00 00       	jmp    169d8 <con_write+0x6cb>
				} else if (c==7)
   16526:	80 7c 24 0b 07       	cmpb   $0x7,0xb(%esp)
   1652b:	0f 85 a7 04 00 00    	jne    169d8 <con_write+0x6cb>
					sysbeep();
   16531:	e8 27 07 00 00       	call   16c5d <sysbeep>
				break;
   16536:	e9 9d 04 00 00       	jmp    169d8 <con_write+0x6cb>
			case 1:
				state=0;
   1653b:	c7 05 04 3e 02 00 00 	movl   $0x0,0x23e04
   16542:	00 00 00 
				if (c=='[')
   16545:	80 7c 24 0b 5b       	cmpb   $0x5b,0xb(%esp)
   1654a:	75 0f                	jne    1655b <con_write+0x24e>
					state=2;
   1654c:	c7 05 04 3e 02 00 02 	movl   $0x2,0x23e04
   16553:	00 00 00 
   16556:	e9 7d 04 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (c=='E')
   1655b:	80 7c 24 0b 45       	cmpb   $0x45,0xb(%esp)
   16560:	75 1b                	jne    1657d <con_write+0x270>
					gotoxy(0,y+1);
   16562:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   16567:	83 c0 01             	add    $0x1,%eax
   1656a:	83 ec 08             	sub    $0x8,%esp
   1656d:	50                   	push   %eax
   1656e:	6a 00                	push   $0x0
   16570:	e8 41 f4 ff ff       	call   159b6 <gotoxy>
   16575:	83 c4 10             	add    $0x10,%esp
   16578:	e9 5b 04 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (c=='M')
   1657d:	80 7c 24 0b 4d       	cmpb   $0x4d,0xb(%esp)
   16582:	75 0a                	jne    1658e <con_write+0x281>
					ri();
   16584:	e8 12 f8 ff ff       	call   15d9b <ri>
   16589:	e9 4a 04 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (c=='D')
   1658e:	80 7c 24 0b 44       	cmpb   $0x44,0xb(%esp)
   16593:	75 0a                	jne    1659f <con_write+0x292>
					lf();
   16595:	e8 c9 f7 ff ff       	call   15d63 <lf>
   1659a:	e9 39 04 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (c=='Z')
   1659f:	80 7c 24 0b 5a       	cmpb   $0x5a,0xb(%esp)
   165a4:	75 14                	jne    165ba <con_write+0x2ad>
					respond(tty);
   165a6:	83 ec 0c             	sub    $0xc,%esp
   165a9:	ff 74 24 2c          	pushl  0x2c(%esp)
   165ad:	e8 88 fa ff ff       	call   1603a <respond>
   165b2:	83 c4 10             	add    $0x10,%esp
   165b5:	e9 1e 04 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (x=='7')
   165ba:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   165bf:	83 f8 37             	cmp    $0x37,%eax
   165c2:	75 0a                	jne    165ce <con_write+0x2c1>
					save_cur();
   165c4:	e8 16 fd ff ff       	call   162df <save_cur>
   165c9:	e9 0a 04 00 00       	jmp    169d8 <con_write+0x6cb>
				else if (x=='8')
   165ce:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   165d3:	83 f8 38             	cmp    $0x38,%eax
   165d6:	0f 85 fc 03 00 00    	jne    169d8 <con_write+0x6cb>
					restore_cur();
   165dc:	e8 14 fd ff ff       	call   162f5 <restore_cur>
				break;
   165e1:	e9 f2 03 00 00       	jmp    169d8 <con_write+0x6cb>
			case 2:
				for(npar=0;npar<NPAR;npar++)
   165e6:	c7 05 08 3e 02 00 00 	movl   $0x0,0x23e08
   165ed:	00 00 00 
   165f0:	eb 1d                	jmp    1660f <con_write+0x302>
					par[npar]=0;
   165f2:	a1 08 3e 02 00       	mov    0x23e08,%eax
   165f7:	c7 04 85 20 3e 02 00 	movl   $0x0,0x23e20(,%eax,4)
   165fe:	00 00 00 00 
					save_cur();
				else if (x=='8')
					restore_cur();
				break;
			case 2:
				for(npar=0;npar<NPAR;npar++)
   16602:	a1 08 3e 02 00       	mov    0x23e08,%eax
   16607:	83 c0 01             	add    $0x1,%eax
   1660a:	a3 08 3e 02 00       	mov    %eax,0x23e08
   1660f:	a1 08 3e 02 00       	mov    0x23e08,%eax
   16614:	83 f8 0f             	cmp    $0xf,%eax
   16617:	76 d9                	jbe    165f2 <con_write+0x2e5>
					par[npar]=0;
				npar=0;
   16619:	c7 05 08 3e 02 00 00 	movl   $0x0,0x23e08
   16620:	00 00 00 
				state=3;
   16623:	c7 05 04 3e 02 00 03 	movl   $0x3,0x23e04
   1662a:	00 00 00 
				if ((ques=(c=='?')))
   1662d:	80 7c 24 0b 3f       	cmpb   $0x3f,0xb(%esp)
   16632:	0f 94 c0             	sete   %al
   16635:	0f b6 c0             	movzbl %al,%eax
   16638:	a3 60 3e 02 00       	mov    %eax,0x23e60
   1663d:	a1 60 3e 02 00       	mov    0x23e60,%eax
   16642:	85 c0                	test   %eax,%eax
   16644:	74 05                	je     1664b <con_write+0x33e>
					break;
   16646:	e9 8d 03 00 00       	jmp    169d8 <con_write+0x6cb>
			case 3:
				if (c==';' && npar<NPAR-1) {
   1664b:	80 7c 24 0b 3b       	cmpb   $0x3b,0xb(%esp)
   16650:	75 1c                	jne    1666e <con_write+0x361>
   16652:	a1 08 3e 02 00       	mov    0x23e08,%eax
   16657:	83 f8 0e             	cmp    $0xe,%eax
   1665a:	77 12                	ja     1666e <con_write+0x361>
					npar++;
   1665c:	a1 08 3e 02 00       	mov    0x23e08,%eax
   16661:	83 c0 01             	add    $0x1,%eax
   16664:	a3 08 3e 02 00       	mov    %eax,0x23e08
					break;
   16669:	e9 6a 03 00 00       	jmp    169d8 <con_write+0x6cb>
				} else if (c>='0' && c<='9') {
   1666e:	80 7c 24 0b 2f       	cmpb   $0x2f,0xb(%esp)
   16673:	7e 3a                	jle    166af <con_write+0x3a2>
   16675:	80 7c 24 0b 39       	cmpb   $0x39,0xb(%esp)
   1667a:	7f 33                	jg     166af <con_write+0x3a2>
					par[npar]=10*par[npar]+c-'0';
   1667c:	8b 0d 08 3e 02 00    	mov    0x23e08,%ecx
   16682:	a1 08 3e 02 00       	mov    0x23e08,%eax
   16687:	8b 14 85 20 3e 02 00 	mov    0x23e20(,%eax,4),%edx
   1668e:	89 d0                	mov    %edx,%eax
   16690:	c1 e0 02             	shl    $0x2,%eax
   16693:	01 d0                	add    %edx,%eax
   16695:	01 c0                	add    %eax,%eax
   16697:	89 c2                	mov    %eax,%edx
   16699:	0f be 44 24 0b       	movsbl 0xb(%esp),%eax
   1669e:	01 d0                	add    %edx,%eax
   166a0:	83 e8 30             	sub    $0x30,%eax
   166a3:	89 04 8d 20 3e 02 00 	mov    %eax,0x23e20(,%ecx,4)
					break;
   166aa:	e9 29 03 00 00       	jmp    169d8 <con_write+0x6cb>
				} else state=4;
   166af:	c7 05 04 3e 02 00 04 	movl   $0x4,0x23e04
   166b6:	00 00 00 
			case 4:
				state=0;
   166b9:	c7 05 04 3e 02 00 00 	movl   $0x0,0x23e04
   166c0:	00 00 00 
				switch(c) {
   166c3:	0f be 44 24 0b       	movsbl 0xb(%esp),%eax
   166c8:	83 e8 40             	sub    $0x40,%eax
   166cb:	83 f8 35             	cmp    $0x35,%eax
   166ce:	0f 87 04 03 00 00    	ja     169d8 <con_write+0x6cb>
   166d4:	8b 04 85 3c 92 01 00 	mov    0x1923c(,%eax,4),%eax
   166db:	ff e0                	jmp    *%eax
					case 'G': case '`':
						if (par[0]) par[0]--;
   166dd:	a1 20 3e 02 00       	mov    0x23e20,%eax
   166e2:	85 c0                	test   %eax,%eax
   166e4:	74 0d                	je     166f3 <con_write+0x3e6>
   166e6:	a1 20 3e 02 00       	mov    0x23e20,%eax
   166eb:	83 e8 01             	sub    $0x1,%eax
   166ee:	a3 20 3e 02 00       	mov    %eax,0x23e20
						gotoxy(par[0],y);
   166f3:	8b 15 f8 3d 02 00    	mov    0x23df8,%edx
   166f9:	a1 20 3e 02 00       	mov    0x23e20,%eax
   166fe:	83 ec 08             	sub    $0x8,%esp
   16701:	52                   	push   %edx
   16702:	50                   	push   %eax
   16703:	e8 ae f2 ff ff       	call   159b6 <gotoxy>
   16708:	83 c4 10             	add    $0x10,%esp
						break;
   1670b:	e9 c8 02 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'A':
						if (!par[0]) par[0]++;
   16710:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16715:	85 c0                	test   %eax,%eax
   16717:	75 0d                	jne    16726 <con_write+0x419>
   16719:	a1 20 3e 02 00       	mov    0x23e20,%eax
   1671e:	83 c0 01             	add    $0x1,%eax
   16721:	a3 20 3e 02 00       	mov    %eax,0x23e20
						gotoxy(x,y-par[0]);
   16726:	8b 15 f8 3d 02 00    	mov    0x23df8,%edx
   1672c:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16731:	29 c2                	sub    %eax,%edx
   16733:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   16738:	83 ec 08             	sub    $0x8,%esp
   1673b:	52                   	push   %edx
   1673c:	50                   	push   %eax
   1673d:	e8 74 f2 ff ff       	call   159b6 <gotoxy>
   16742:	83 c4 10             	add    $0x10,%esp
						break;
   16745:	e9 8e 02 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'B': case 'e':
						if (!par[0]) par[0]++;
   1674a:	a1 20 3e 02 00       	mov    0x23e20,%eax
   1674f:	85 c0                	test   %eax,%eax
   16751:	75 0d                	jne    16760 <con_write+0x453>
   16753:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16758:	83 c0 01             	add    $0x1,%eax
   1675b:	a3 20 3e 02 00       	mov    %eax,0x23e20
						gotoxy(x,y+par[0]);
   16760:	8b 15 20 3e 02 00    	mov    0x23e20,%edx
   16766:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   1676b:	01 c2                	add    %eax,%edx
   1676d:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   16772:	83 ec 08             	sub    $0x8,%esp
   16775:	52                   	push   %edx
   16776:	50                   	push   %eax
   16777:	e8 3a f2 ff ff       	call   159b6 <gotoxy>
   1677c:	83 c4 10             	add    $0x10,%esp
						break;
   1677f:	e9 54 02 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'C': case 'a':
						if (!par[0]) par[0]++;
   16784:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16789:	85 c0                	test   %eax,%eax
   1678b:	75 0d                	jne    1679a <con_write+0x48d>
   1678d:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16792:	83 c0 01             	add    $0x1,%eax
   16795:	a3 20 3e 02 00       	mov    %eax,0x23e20
						gotoxy(x+par[0],y);
   1679a:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   1679f:	8b 0d 20 3e 02 00    	mov    0x23e20,%ecx
   167a5:	8b 15 f4 3d 02 00    	mov    0x23df4,%edx
   167ab:	01 ca                	add    %ecx,%edx
   167ad:	83 ec 08             	sub    $0x8,%esp
   167b0:	50                   	push   %eax
   167b1:	52                   	push   %edx
   167b2:	e8 ff f1 ff ff       	call   159b6 <gotoxy>
   167b7:	83 c4 10             	add    $0x10,%esp
						break;
   167ba:	e9 19 02 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'D':
						if (!par[0]) par[0]++;
   167bf:	a1 20 3e 02 00       	mov    0x23e20,%eax
   167c4:	85 c0                	test   %eax,%eax
   167c6:	75 0d                	jne    167d5 <con_write+0x4c8>
   167c8:	a1 20 3e 02 00       	mov    0x23e20,%eax
   167cd:	83 c0 01             	add    $0x1,%eax
   167d0:	a3 20 3e 02 00       	mov    %eax,0x23e20
						gotoxy(x-par[0],y);
   167d5:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   167da:	8b 0d f4 3d 02 00    	mov    0x23df4,%ecx
   167e0:	8b 15 20 3e 02 00    	mov    0x23e20,%edx
   167e6:	29 d1                	sub    %edx,%ecx
   167e8:	89 ca                	mov    %ecx,%edx
   167ea:	83 ec 08             	sub    $0x8,%esp
   167ed:	50                   	push   %eax
   167ee:	52                   	push   %edx
   167ef:	e8 c2 f1 ff ff       	call   159b6 <gotoxy>
   167f4:	83 c4 10             	add    $0x10,%esp
						break;
   167f7:	e9 dc 01 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'E':
						if (!par[0]) par[0]++;
   167fc:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16801:	85 c0                	test   %eax,%eax
   16803:	75 0d                	jne    16812 <con_write+0x505>
   16805:	a1 20 3e 02 00       	mov    0x23e20,%eax
   1680a:	83 c0 01             	add    $0x1,%eax
   1680d:	a3 20 3e 02 00       	mov    %eax,0x23e20
						gotoxy(0,y+par[0]);
   16812:	8b 15 20 3e 02 00    	mov    0x23e20,%edx
   16818:	a1 f8 3d 02 00       	mov    0x23df8,%eax
   1681d:	01 d0                	add    %edx,%eax
   1681f:	83 ec 08             	sub    $0x8,%esp
   16822:	50                   	push   %eax
   16823:	6a 00                	push   $0x0
   16825:	e8 8c f1 ff ff       	call   159b6 <gotoxy>
   1682a:	83 c4 10             	add    $0x10,%esp
						break;
   1682d:	e9 a6 01 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'F':
						if (!par[0]) par[0]++;
   16832:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16837:	85 c0                	test   %eax,%eax
   16839:	75 0d                	jne    16848 <con_write+0x53b>
   1683b:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16840:	83 c0 01             	add    $0x1,%eax
   16843:	a3 20 3e 02 00       	mov    %eax,0x23e20
						gotoxy(0,y-par[0]);
   16848:	8b 15 f8 3d 02 00    	mov    0x23df8,%edx
   1684e:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16853:	29 c2                	sub    %eax,%edx
   16855:	89 d0                	mov    %edx,%eax
   16857:	83 ec 08             	sub    $0x8,%esp
   1685a:	50                   	push   %eax
   1685b:	6a 00                	push   $0x0
   1685d:	e8 54 f1 ff ff       	call   159b6 <gotoxy>
   16862:	83 c4 10             	add    $0x10,%esp
						break;
   16865:	e9 6e 01 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'd':
						if (par[0]) par[0]--;
   1686a:	a1 20 3e 02 00       	mov    0x23e20,%eax
   1686f:	85 c0                	test   %eax,%eax
   16871:	74 0d                	je     16880 <con_write+0x573>
   16873:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16878:	83 e8 01             	sub    $0x1,%eax
   1687b:	a3 20 3e 02 00       	mov    %eax,0x23e20
						gotoxy(x,par[0]);
   16880:	8b 15 20 3e 02 00    	mov    0x23e20,%edx
   16886:	a1 f4 3d 02 00       	mov    0x23df4,%eax
   1688b:	83 ec 08             	sub    $0x8,%esp
   1688e:	52                   	push   %edx
   1688f:	50                   	push   %eax
   16890:	e8 21 f1 ff ff       	call   159b6 <gotoxy>
   16895:	83 c4 10             	add    $0x10,%esp
						break;
   16898:	e9 3b 01 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'H': case 'f':
						if (par[0]) par[0]--;
   1689d:	a1 20 3e 02 00       	mov    0x23e20,%eax
   168a2:	85 c0                	test   %eax,%eax
   168a4:	74 0d                	je     168b3 <con_write+0x5a6>
   168a6:	a1 20 3e 02 00       	mov    0x23e20,%eax
   168ab:	83 e8 01             	sub    $0x1,%eax
   168ae:	a3 20 3e 02 00       	mov    %eax,0x23e20
						if (par[1]) par[1]--;
   168b3:	a1 24 3e 02 00       	mov    0x23e24,%eax
   168b8:	85 c0                	test   %eax,%eax
   168ba:	74 0d                	je     168c9 <con_write+0x5bc>
   168bc:	a1 24 3e 02 00       	mov    0x23e24,%eax
   168c1:	83 e8 01             	sub    $0x1,%eax
   168c4:	a3 24 3e 02 00       	mov    %eax,0x23e24
						gotoxy(par[1],par[0]);
   168c9:	8b 15 20 3e 02 00    	mov    0x23e20,%edx
   168cf:	a1 24 3e 02 00       	mov    0x23e24,%eax
   168d4:	83 ec 08             	sub    $0x8,%esp
   168d7:	52                   	push   %edx
   168d8:	50                   	push   %eax
   168d9:	e8 d8 f0 ff ff       	call   159b6 <gotoxy>
   168de:	83 c4 10             	add    $0x10,%esp
						break;
   168e1:	e9 f2 00 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'J':
						csi_J(par[0]);
   168e6:	a1 20 3e 02 00       	mov    0x23e20,%eax
   168eb:	83 ec 0c             	sub    $0xc,%esp
   168ee:	50                   	push   %eax
   168ef:	e8 35 f5 ff ff       	call   15e29 <csi_J>
   168f4:	83 c4 10             	add    $0x10,%esp
						break;
   168f7:	e9 dc 00 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'K':
						csi_K(par[0]);
   168fc:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16901:	83 ec 0c             	sub    $0xc,%esp
   16904:	50                   	push   %eax
   16905:	e8 b1 f5 ff ff       	call   15ebb <csi_K>
   1690a:	83 c4 10             	add    $0x10,%esp
						break;
   1690d:	e9 c6 00 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'L':
						csi_L(par[0]);
   16912:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16917:	83 ec 0c             	sub    $0xc,%esp
   1691a:	50                   	push   %eax
   1691b:	e8 08 f9 ff ff       	call   16228 <csi_L>
   16920:	83 c4 10             	add    $0x10,%esp
						break;
   16923:	e9 b0 00 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'M':
						csi_M(par[0]);
   16928:	a1 20 3e 02 00       	mov    0x23e20,%eax
   1692d:	83 ec 0c             	sub    $0xc,%esp
   16930:	50                   	push   %eax
   16931:	e8 6c f9 ff ff       	call   162a2 <csi_M>
   16936:	83 c4 10             	add    $0x10,%esp
						break;
   16939:	e9 9a 00 00 00       	jmp    169d8 <con_write+0x6cb>
					case 'P':
						csi_P(par[0]);
   1693e:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16943:	83 ec 0c             	sub    $0xc,%esp
   16946:	50                   	push   %eax
   16947:	e8 19 f9 ff ff       	call   16265 <csi_P>
   1694c:	83 c4 10             	add    $0x10,%esp
						break;
   1694f:	e9 84 00 00 00       	jmp    169d8 <con_write+0x6cb>
					case '@':
						csi_at(par[0]);
   16954:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16959:	83 ec 0c             	sub    $0xc,%esp
   1695c:	50                   	push   %eax
   1695d:	e8 89 f8 ff ff       	call   161eb <csi_at>
   16962:	83 c4 10             	add    $0x10,%esp
						break;
   16965:	eb 71                	jmp    169d8 <con_write+0x6cb>
					case 'm':
						csi_m();
   16967:	e8 fe f5 ff ff       	call   15f6a <csi_m>
						break;
   1696c:	eb 6a                	jmp    169d8 <con_write+0x6cb>
					case 'r':
						if (par[0]) par[0]--;
   1696e:	a1 20 3e 02 00       	mov    0x23e20,%eax
   16973:	85 c0                	test   %eax,%eax
   16975:	74 0d                	je     16984 <con_write+0x677>
   16977:	a1 20 3e 02 00       	mov    0x23e20,%eax
   1697c:	83 e8 01             	sub    $0x1,%eax
   1697f:	a3 20 3e 02 00       	mov    %eax,0x23e20
						if (!par[1]) par[1] = video_num_lines;
   16984:	a1 24 3e 02 00       	mov    0x23e24,%eax
   16989:	85 c0                	test   %eax,%eax
   1698b:	75 0a                	jne    16997 <con_write+0x68a>
   1698d:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   16992:	a3 24 3e 02 00       	mov    %eax,0x23e24
						if (par[0] < par[1] &&
   16997:	8b 15 20 3e 02 00    	mov    0x23e20,%edx
   1699d:	a1 24 3e 02 00       	mov    0x23e24,%eax
   169a2:	39 c2                	cmp    %eax,%edx
   169a4:	73 32                	jae    169d8 <con_write+0x6cb>
						    par[1] <= video_num_lines) {
   169a6:	8b 15 24 3e 02 00    	mov    0x23e24,%edx
   169ac:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
						csi_m();
						break;
					case 'r':
						if (par[0]) par[0]--;
						if (!par[1]) par[1] = video_num_lines;
						if (par[0] < par[1] &&
   169b1:	39 c2                	cmp    %eax,%edx
   169b3:	77 23                	ja     169d8 <con_write+0x6cb>
						    par[1] <= video_num_lines) {
							top=par[0];
   169b5:	a1 20 3e 02 00       	mov    0x23e20,%eax
   169ba:	a3 fc 3d 02 00       	mov    %eax,0x23dfc
							bottom=par[1];
   169bf:	a1 24 3e 02 00       	mov    0x23e24,%eax
   169c4:	a3 00 3e 02 00       	mov    %eax,0x23e00
						}
						break;
   169c9:	eb 0d                	jmp    169d8 <con_write+0x6cb>
					case 's':
						save_cur();
   169cb:	e8 0f f9 ff ff       	call   162df <save_cur>
						break;
   169d0:	eb 06                	jmp    169d8 <con_write+0x6cb>
					case 'u':
						restore_cur();
   169d2:	e8 1e f9 ff ff       	call   162f5 <restore_cur>
						break;
   169d7:	90                   	nop
{
	int nr;
	char c;

	nr = CHARS(tty->write_q);
	while (nr--) {
   169d8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   169dc:	8d 50 ff             	lea    -0x1(%eax),%edx
   169df:	89 54 24 0c          	mov    %edx,0xc(%esp)
   169e3:	85 c0                	test   %eax,%eax
   169e5:	0f 85 4b f9 ff ff    	jne    16336 <con_write+0x29>
						restore_cur();
						break;
				}
		}
	}
	set_cursor();
   169eb:	e8 e3 f5 ff ff       	call   15fd3 <set_cursor>
}
   169f0:	90                   	nop
   169f1:	83 c4 1c             	add    $0x1c,%esp
   169f4:	c3                   	ret    

000169f5 <con_init>:
 *
 * Reads the information preserved by setup.s to determine the current display
 * type and sets everything accordingly.
 */
void con_init(void)
{
   169f5:	53                   	push   %ebx
   169f6:	83 ec 10             	sub    $0x10,%esp
	register unsigned char a;
	char *display_desc = "????";
   169f9:	c7 44 24 0c 14 93 01 	movl   $0x19314,0xc(%esp)
   16a00:	00 
	char *display_ptr;

	video_num_columns = ORIG_VIDEO_COLS;
   16a01:	b8 06 00 09 00       	mov    $0x90006,%eax
   16a06:	0f b7 00             	movzwl (%eax),%eax
   16a09:	66 c1 e8 08          	shr    $0x8,%ax
   16a0d:	0f b7 c0             	movzwl %ax,%eax
   16a10:	a3 c8 3d 02 00       	mov    %eax,0x23dc8
	video_size_row = video_num_columns * 2;
   16a15:	a1 c8 3d 02 00       	mov    0x23dc8,%eax
   16a1a:	01 c0                	add    %eax,%eax
   16a1c:	a3 cc 3d 02 00       	mov    %eax,0x23dcc
	video_num_lines = ORIG_VIDEO_LINES;
   16a21:	c7 05 d0 3d 02 00 19 	movl   $0x19,0x23dd0
   16a28:	00 00 00 
	video_page = ORIG_VIDEO_PAGE;
   16a2b:	b8 04 00 09 00       	mov    $0x90004,%eax
   16a30:	0f b7 00             	movzwl (%eax),%eax
   16a33:	a2 d4 3d 02 00       	mov    %al,0x23dd4
	video_erase_char = 0x0720;
   16a38:	66 c7 05 e4 3d 02 00 	movw   $0x720,0x23de4
   16a3f:	20 07 
	
	if (ORIG_VIDEO_MODE == 7)			/* Is this a monochrome display? */
   16a41:	b8 06 00 09 00       	mov    $0x90006,%eax
   16a46:	0f b7 00             	movzwl (%eax),%eax
   16a49:	0f b7 c0             	movzwl %ax,%eax
   16a4c:	0f b6 c0             	movzbl %al,%eax
   16a4f:	83 f8 07             	cmp    $0x7,%eax
   16a52:	75 65                	jne    16ab9 <con_init+0xc4>
	{
		video_mem_start = 0xb0000;
   16a54:	c7 05 d8 3d 02 00 00 	movl   $0xb0000,0x23dd8
   16a5b:	00 0b 00 
		video_port_reg = 0x3b4;
   16a5e:	66 c7 05 e0 3d 02 00 	movw   $0x3b4,0x23de0
   16a65:	b4 03 
		video_port_val = 0x3b5;
   16a67:	66 c7 05 e2 3d 02 00 	movw   $0x3b5,0x23de2
   16a6e:	b5 03 
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   16a70:	b8 0a 00 09 00       	mov    $0x9000a,%eax
   16a75:	0f b7 00             	movzwl (%eax),%eax
   16a78:	0f b7 c0             	movzwl %ax,%eax
   16a7b:	0f b6 c0             	movzbl %al,%eax
   16a7e:	83 f8 10             	cmp    $0x10,%eax
   16a81:	74 1b                	je     16a9e <con_init+0xa9>
		{
			video_type = VIDEO_TYPE_EGAM;
   16a83:	c6 05 c4 3d 02 00 20 	movb   $0x20,0x23dc4
			video_mem_end = 0xb8000;
   16a8a:	c7 05 dc 3d 02 00 00 	movl   $0xb8000,0x23ddc
   16a91:	80 0b 00 
			display_desc = "EGAm";
   16a94:	c7 44 24 0c 19 93 01 	movl   $0x19319,0xc(%esp)
   16a9b:	00 
   16a9c:	eb 7e                	jmp    16b1c <con_init+0x127>
		}
		else
		{
			video_type = VIDEO_TYPE_MDA;
   16a9e:	c6 05 c4 3d 02 00 10 	movb   $0x10,0x23dc4
			video_mem_end	= 0xb2000;
   16aa5:	c7 05 dc 3d 02 00 00 	movl   $0xb2000,0x23ddc
   16aac:	20 0b 00 
			display_desc = "*MDA";
   16aaf:	c7 44 24 0c 1e 93 01 	movl   $0x1931e,0xc(%esp)
   16ab6:	00 
   16ab7:	eb 63                	jmp    16b1c <con_init+0x127>
		}
	}
	else								/* If not, it is color. */
	{
		video_mem_start = 0xb8000;
   16ab9:	c7 05 d8 3d 02 00 00 	movl   $0xb8000,0x23dd8
   16ac0:	80 0b 00 
		video_port_reg	= 0x3d4;
   16ac3:	66 c7 05 e0 3d 02 00 	movw   $0x3d4,0x23de0
   16aca:	d4 03 
		video_port_val	= 0x3d5;
   16acc:	66 c7 05 e2 3d 02 00 	movw   $0x3d5,0x23de2
   16ad3:	d5 03 
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   16ad5:	b8 0a 00 09 00       	mov    $0x9000a,%eax
   16ada:	0f b7 00             	movzwl (%eax),%eax
   16add:	0f b7 c0             	movzwl %ax,%eax
   16ae0:	0f b6 c0             	movzbl %al,%eax
   16ae3:	83 f8 10             	cmp    $0x10,%eax
   16ae6:	74 1b                	je     16b03 <con_init+0x10e>
		{
			video_type = VIDEO_TYPE_EGAC;
   16ae8:	c6 05 c4 3d 02 00 21 	movb   $0x21,0x23dc4
			video_mem_end = 0xbc000;
   16aef:	c7 05 dc 3d 02 00 00 	movl   $0xbc000,0x23ddc
   16af6:	c0 0b 00 
			display_desc = "EGAc";
   16af9:	c7 44 24 0c 23 93 01 	movl   $0x19323,0xc(%esp)
   16b00:	00 
   16b01:	eb 19                	jmp    16b1c <con_init+0x127>
		}
		else
		{
			video_type = VIDEO_TYPE_CGA;
   16b03:	c6 05 c4 3d 02 00 11 	movb   $0x11,0x23dc4
			video_mem_end = 0xba000;
   16b0a:	c7 05 dc 3d 02 00 00 	movl   $0xba000,0x23ddc
   16b11:	a0 0b 00 
			display_desc = "*CGA";
   16b14:	c7 44 24 0c 28 93 01 	movl   $0x19328,0xc(%esp)
   16b1b:	00 
		}
	}

	/* Let the user known what kind of display driver we are using */
	
	display_ptr = ((char *)video_mem_start) + video_size_row - 8;
   16b1c:	8b 15 cc 3d 02 00    	mov    0x23dcc,%edx
   16b22:	a1 d8 3d 02 00       	mov    0x23dd8,%eax
   16b27:	01 d0                	add    %edx,%eax
   16b29:	83 e8 08             	sub    $0x8,%eax
   16b2c:	89 44 24 08          	mov    %eax,0x8(%esp)
	while (*display_desc)
   16b30:	eb 20                	jmp    16b52 <con_init+0x15d>
	{
		*display_ptr++ = *display_desc++;
   16b32:	8b 44 24 08          	mov    0x8(%esp),%eax
   16b36:	8d 50 01             	lea    0x1(%eax),%edx
   16b39:	89 54 24 08          	mov    %edx,0x8(%esp)
   16b3d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   16b41:	8d 4a 01             	lea    0x1(%edx),%ecx
   16b44:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
   16b48:	0f b6 12             	movzbl (%edx),%edx
   16b4b:	88 10                	mov    %dl,(%eax)
		display_ptr++;
   16b4d:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
	}

	/* Let the user known what kind of display driver we are using */
	
	display_ptr = ((char *)video_mem_start) + video_size_row - 8;
	while (*display_desc)
   16b52:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16b56:	0f b6 00             	movzbl (%eax),%eax
   16b59:	84 c0                	test   %al,%al
   16b5b:	75 d5                	jne    16b32 <con_init+0x13d>
		display_ptr++;
	}
	
	/* Initialize the variables used for scrolling (mostly EGA/VGA)	*/
	
	origin	= video_mem_start;
   16b5d:	a1 d8 3d 02 00       	mov    0x23dd8,%eax
   16b62:	a3 e8 3d 02 00       	mov    %eax,0x23de8
	scr_end	= video_mem_start + video_num_lines * video_size_row;
   16b67:	8b 15 d0 3d 02 00    	mov    0x23dd0,%edx
   16b6d:	a1 cc 3d 02 00       	mov    0x23dcc,%eax
   16b72:	0f af d0             	imul   %eax,%edx
   16b75:	a1 d8 3d 02 00       	mov    0x23dd8,%eax
   16b7a:	01 d0                	add    %edx,%eax
   16b7c:	a3 ec 3d 02 00       	mov    %eax,0x23dec
	top	= 0;
   16b81:	c7 05 fc 3d 02 00 00 	movl   $0x0,0x23dfc
   16b88:	00 00 00 
	bottom	= video_num_lines;
   16b8b:	a1 d0 3d 02 00       	mov    0x23dd0,%eax
   16b90:	a3 00 3e 02 00       	mov    %eax,0x23e00

	gotoxy(ORIG_X,ORIG_Y);
   16b95:	b8 01 00 09 00       	mov    $0x90001,%eax
   16b9a:	0f b6 00             	movzbl (%eax),%eax
   16b9d:	0f b6 d0             	movzbl %al,%edx
   16ba0:	b8 00 00 09 00       	mov    $0x90000,%eax
   16ba5:	0f b6 00             	movzbl (%eax),%eax
   16ba8:	0f b6 c0             	movzbl %al,%eax
   16bab:	52                   	push   %edx
   16bac:	50                   	push   %eax
   16bad:	e8 04 ee ff ff       	call   159b6 <gotoxy>
   16bb2:	83 c4 08             	add    $0x8,%esp
	set_trap_gate(0x21,&keyboard_interrupt);
   16bb5:	b9 c0 55 00 00       	mov    $0x55c0,%ecx
   16bba:	bb c4 55 00 00       	mov    $0x55c4,%ebx
   16bbf:	ba c0 6c 01 00       	mov    $0x16cc0,%edx
   16bc4:	b8 00 00 08 00       	mov    $0x80000,%eax
   16bc9:	66 89 d0             	mov    %dx,%ax
   16bcc:	66 ba 00 8f          	mov    $0x8f00,%dx
   16bd0:	89 01                	mov    %eax,(%ecx)
   16bd2:	89 13                	mov    %edx,(%ebx)
	outb_p(inb_p(0x21)&0xfd,0x21);
   16bd4:	b8 21 00 00 00       	mov    $0x21,%eax
   16bd9:	89 c2                	mov    %eax,%edx
   16bdb:	ec                   	in     (%dx),%al
   16bdc:	eb 00                	jmp    16bde <con_init+0x1e9>
   16bde:	eb 00                	jmp    16be0 <con_init+0x1eb>
   16be0:	88 44 24 07          	mov    %al,0x7(%esp)
   16be4:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
   16be9:	0f b6 c0             	movzbl %al,%eax
   16bec:	25 fd 00 00 00       	and    $0xfd,%eax
   16bf1:	ba 21 00 00 00       	mov    $0x21,%edx
   16bf6:	ee                   	out    %al,(%dx)
   16bf7:	eb 00                	jmp    16bf9 <con_init+0x204>
   16bf9:	eb 00                	jmp    16bfb <con_init+0x206>
	a=inb_p(0x61);
   16bfb:	b8 61 00 00 00       	mov    $0x61,%eax
   16c00:	89 c2                	mov    %eax,%edx
   16c02:	ec                   	in     (%dx),%al
   16c03:	eb 00                	jmp    16c05 <con_init+0x210>
   16c05:	eb 00                	jmp    16c07 <con_init+0x212>
   16c07:	88 44 24 06          	mov    %al,0x6(%esp)
   16c0b:	0f b6 44 24 06       	movzbl 0x6(%esp),%eax
   16c10:	89 c3                	mov    %eax,%ebx
	outb_p(a|0x80,0x61);
   16c12:	89 d8                	mov    %ebx,%eax
   16c14:	83 c8 80             	or     $0xffffff80,%eax
   16c17:	0f b6 c0             	movzbl %al,%eax
   16c1a:	ba 61 00 00 00       	mov    $0x61,%edx
   16c1f:	ee                   	out    %al,(%dx)
   16c20:	eb 00                	jmp    16c22 <con_init+0x22d>
   16c22:	eb 00                	jmp    16c24 <con_init+0x22f>
	outb(a,0x61);
   16c24:	ba 61 00 00 00       	mov    $0x61,%edx
   16c29:	89 d8                	mov    %ebx,%eax
   16c2b:	ee                   	out    %al,(%dx)
}
   16c2c:	90                   	nop
   16c2d:	83 c4 10             	add    $0x10,%esp
   16c30:	5b                   	pop    %ebx
   16c31:	c3                   	ret    

00016c32 <sysbeepstop>:
/* from bsd-net-2: */

void sysbeepstop(void)
{
   16c32:	83 ec 10             	sub    $0x10,%esp
	/* disable counter 2 */
	outb(inb_p(0x61)&0xFC, 0x61);
   16c35:	b8 61 00 00 00       	mov    $0x61,%eax
   16c3a:	89 c2                	mov    %eax,%edx
   16c3c:	ec                   	in     (%dx),%al
   16c3d:	eb 00                	jmp    16c3f <sysbeepstop+0xd>
   16c3f:	eb 00                	jmp    16c41 <sysbeepstop+0xf>
   16c41:	88 44 24 0f          	mov    %al,0xf(%esp)
   16c45:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   16c4a:	0f b6 c0             	movzbl %al,%eax
   16c4d:	25 fc 00 00 00       	and    $0xfc,%eax
   16c52:	ba 61 00 00 00       	mov    $0x61,%edx
   16c57:	ee                   	out    %al,(%dx)
}
   16c58:	90                   	nop
   16c59:	83 c4 10             	add    $0x10,%esp
   16c5c:	c3                   	ret    

00016c5d <sysbeep>:

int beepcount = 0;

static void sysbeep(void)
{
   16c5d:	83 ec 10             	sub    $0x10,%esp
	/* enable counter 2 */
	outb_p(inb_p(0x61)|3, 0x61);
   16c60:	b8 61 00 00 00       	mov    $0x61,%eax
   16c65:	89 c2                	mov    %eax,%edx
   16c67:	ec                   	in     (%dx),%al
   16c68:	eb 00                	jmp    16c6a <sysbeep+0xd>
   16c6a:	eb 00                	jmp    16c6c <sysbeep+0xf>
   16c6c:	88 44 24 0f          	mov    %al,0xf(%esp)
   16c70:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   16c75:	83 c8 03             	or     $0x3,%eax
   16c78:	0f b6 c0             	movzbl %al,%eax
   16c7b:	ba 61 00 00 00       	mov    $0x61,%edx
   16c80:	ee                   	out    %al,(%dx)
   16c81:	eb 00                	jmp    16c83 <sysbeep+0x26>
   16c83:	eb 00                	jmp    16c85 <sysbeep+0x28>
	/* set command for counter 2, 2 byte write */
	outb_p(0xB6, 0x43);
   16c85:	b8 b6 00 00 00       	mov    $0xb6,%eax
   16c8a:	ba 43 00 00 00       	mov    $0x43,%edx
   16c8f:	ee                   	out    %al,(%dx)
   16c90:	eb 00                	jmp    16c92 <sysbeep+0x35>
   16c92:	eb 00                	jmp    16c94 <sysbeep+0x37>
	/* send 0x637 for 750 HZ */
	outb_p(0x37, 0x42);
   16c94:	b8 37 00 00 00       	mov    $0x37,%eax
   16c99:	ba 42 00 00 00       	mov    $0x42,%edx
   16c9e:	ee                   	out    %al,(%dx)
   16c9f:	eb 00                	jmp    16ca1 <sysbeep+0x44>
   16ca1:	eb 00                	jmp    16ca3 <sysbeep+0x46>
	outb(0x06, 0x42);
   16ca3:	b8 06 00 00 00       	mov    $0x6,%eax
   16ca8:	ba 42 00 00 00       	mov    $0x42,%edx
   16cad:	ee                   	out    %al,(%dx)
	/* 1/8 second */
	beepcount = HZ/8;	
   16cae:	c7 05 c0 3d 02 00 0c 	movl   $0xc,0x23dc0
   16cb5:	00 00 00 
}
   16cb8:	90                   	nop
   16cb9:	83 c4 10             	add    $0x10,%esp
   16cbc:	c3                   	ret    

00016cbd <mode>:
	...

00016cbe <leds>:
   16cbe:	02                   	.byte 0x2

00016cbf <e0>:
	...

00016cc0 <keyboard_interrupt>:
 *  con_int is the real interrupt routine that reads the
 *  keyboard scan-code and converts it into the appropriate
 *  ascii character(s).
 */
keyboard_interrupt:
	pushl %eax
   16cc0:	50                   	push   %eax
	pushl %ebx
   16cc1:	53                   	push   %ebx
	pushl %ecx
   16cc2:	51                   	push   %ecx
	pushl %edx
   16cc3:	52                   	push   %edx
	push %ds
   16cc4:	1e                   	push   %ds
	push %es
   16cc5:	06                   	push   %es
	movl $0x10,%eax
   16cc6:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
   16ccb:	8e d8                	mov    %eax,%ds
	mov %ax,%es
   16ccd:	8e c0                	mov    %eax,%es
	xor %al,%al		/* %eax is scan code */
   16ccf:	30 c0                	xor    %al,%al
	inb $0x60,%al
   16cd1:	e4 60                	in     $0x60,%al
	cmpb $0xe0,%al
   16cd3:	3c e0                	cmp    $0xe0,%al
	je set_e0
   16cd5:	74 3d                	je     16d14 <set_e0>
	cmpb $0xe1,%al
   16cd7:	3c e1                	cmp    $0xe1,%al
	je set_e1
   16cd9:	74 42                	je     16d1d <set_e1>
	call *key_table(,%eax,4)
   16cdb:	ff 14 85 82 70 01 00 	call   *0x17082(,%eax,4)
	movb $0,e0
   16ce2:	c6 05 bf 6c 01 00 00 	movb   $0x0,0x16cbf

00016ce9 <e0_e1>:
e0_e1:	inb $0x61,%al
   16ce9:	e4 61                	in     $0x61,%al
	jmp 1f
   16ceb:	eb 00                	jmp    16ced <e0_e1+0x4>
1:	jmp 1f
   16ced:	eb 00                	jmp    16cef <e0_e1+0x6>
1:	orb $0x80,%al
   16cef:	0c 80                	or     $0x80,%al
	jmp 1f
   16cf1:	eb 00                	jmp    16cf3 <e0_e1+0xa>
1:	jmp 1f
   16cf3:	eb 00                	jmp    16cf5 <e0_e1+0xc>
1:	outb %al,$0x61
   16cf5:	e6 61                	out    %al,$0x61
	jmp 1f
   16cf7:	eb 00                	jmp    16cf9 <e0_e1+0x10>
1:	jmp 1f
   16cf9:	eb 00                	jmp    16cfb <e0_e1+0x12>
1:	andb $0x7F,%al
   16cfb:	24 7f                	and    $0x7f,%al
	outb %al,$0x61
   16cfd:	e6 61                	out    %al,$0x61
	movb $0x20,%al
   16cff:	b0 20                	mov    $0x20,%al
	outb %al,$0x20
   16d01:	e6 20                	out    %al,$0x20
	pushl $0
   16d03:	6a 00                	push   $0x0
	call do_tty_interrupt
   16d05:	e8 87 ec ff ff       	call   15991 <do_tty_interrupt>
	addl $4,%esp
   16d0a:	83 c4 04             	add    $0x4,%esp
	pop %es
   16d0d:	07                   	pop    %es
	pop %ds
   16d0e:	1f                   	pop    %ds
	popl %edx
   16d0f:	5a                   	pop    %edx
	popl %ecx
   16d10:	59                   	pop    %ecx
	popl %ebx
   16d11:	5b                   	pop    %ebx
	popl %eax
   16d12:	58                   	pop    %eax
	iret
   16d13:	cf                   	iret   

00016d14 <set_e0>:
set_e0:	movb $1,e0
   16d14:	c6 05 bf 6c 01 00 01 	movb   $0x1,0x16cbf
	jmp e0_e1
   16d1b:	eb cc                	jmp    16ce9 <e0_e1>

00016d1d <set_e1>:
set_e1:	movb $2,e0
   16d1d:	c6 05 bf 6c 01 00 02 	movb   $0x2,0x16cbf
	jmp e0_e1
   16d24:	eb c3                	jmp    16ce9 <e0_e1>

00016d26 <put_queue>:
 * This routine fills the buffer with max 8 bytes, taken from
 * %ebx:%eax. (%edx is high). The bytes are written in the
 * order %al,%ah,%eal,%eah,%bl,%bh ... until %eax is zero.
 */
put_queue:
	pushl %ecx
   16d26:	51                   	push   %ecx
	pushl %edx
   16d27:	52                   	push   %edx
	movl table_list,%edx		# read-queue for console
   16d28:	8b 15 60 19 02 00    	mov    0x21960,%edx
	movl head(%edx),%ecx
   16d2e:	8b 4a 04             	mov    0x4(%edx),%ecx
1:	movb %al,buf(%edx,%ecx)
   16d31:	88 44 0a 10          	mov    %al,0x10(%edx,%ecx,1)
	incl %ecx
   16d35:	41                   	inc    %ecx
	andl $size-1,%ecx
   16d36:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
	cmpl tail(%edx),%ecx		# buffer full - discard everything
   16d3c:	3b 4a 08             	cmp    0x8(%edx),%ecx
	je 3f
   16d3f:	74 1b                	je     16d5c <put_queue+0x36>
	shrdl $8,%ebx,%eax
   16d41:	0f ac d8 08          	shrd   $0x8,%ebx,%eax
	je 2f
   16d45:	74 05                	je     16d4c <put_queue+0x26>
	shrl $8,%ebx
   16d47:	c1 eb 08             	shr    $0x8,%ebx
	jmp 1b
   16d4a:	eb e5                	jmp    16d31 <put_queue+0xb>
2:	movl %ecx,head(%edx)
   16d4c:	89 4a 04             	mov    %ecx,0x4(%edx)
	movl proc_list(%edx),%ecx
   16d4f:	8b 4a 0c             	mov    0xc(%edx),%ecx
	testl %ecx,%ecx
   16d52:	85 c9                	test   %ecx,%ecx
	je 3f
   16d54:	74 06                	je     16d5c <put_queue+0x36>
	movl $0,(%ecx)
   16d56:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
3:	popl %edx
   16d5c:	5a                   	pop    %edx
	popl %ecx
   16d5d:	59                   	pop    %ecx
	ret
   16d5e:	c3                   	ret    

00016d5f <ctrl>:

ctrl:	movb $0x04,%al
   16d5f:	b0 04                	mov    $0x4,%al
	jmp 1f
   16d61:	eb 02                	jmp    16d65 <alt+0x2>

00016d63 <alt>:
alt:	movb $0x10,%al
   16d63:	b0 10                	mov    $0x10,%al
1:	cmpb $0,e0
   16d65:	80 3d bf 6c 01 00 00 	cmpb   $0x0,0x16cbf
	je 2f
   16d6c:	74 02                	je     16d70 <alt+0xd>
	addb %al,%al
   16d6e:	00 c0                	add    %al,%al
2:	orb %al,mode
   16d70:	08 05 bd 6c 01 00    	or     %al,0x16cbd
	ret
   16d76:	c3                   	ret    

00016d77 <unctrl>:
unctrl:	movb $0x04,%al
   16d77:	b0 04                	mov    $0x4,%al
	jmp 1f
   16d79:	eb 02                	jmp    16d7d <unalt+0x2>

00016d7b <unalt>:
unalt:	movb $0x10,%al
   16d7b:	b0 10                	mov    $0x10,%al
1:	cmpb $0,e0
   16d7d:	80 3d bf 6c 01 00 00 	cmpb   $0x0,0x16cbf
	je 2f
   16d84:	74 02                	je     16d88 <unalt+0xd>
	addb %al,%al
   16d86:	00 c0                	add    %al,%al
2:	notb %al
   16d88:	f6 d0                	not    %al
	andb %al,mode
   16d8a:	20 05 bd 6c 01 00    	and    %al,0x16cbd
	ret
   16d90:	c3                   	ret    

00016d91 <lshift>:

lshift:
	orb $0x01,mode
   16d91:	80 0d bd 6c 01 00 01 	orb    $0x1,0x16cbd
	ret
   16d98:	c3                   	ret    

00016d99 <unlshift>:
unlshift:
	andb $0xfe,mode
   16d99:	80 25 bd 6c 01 00 fe 	andb   $0xfe,0x16cbd
	ret
   16da0:	c3                   	ret    

00016da1 <rshift>:
rshift:
	orb $0x02,mode
   16da1:	80 0d bd 6c 01 00 02 	orb    $0x2,0x16cbd
	ret
   16da8:	c3                   	ret    

00016da9 <unrshift>:
unrshift:
	andb $0xfd,mode
   16da9:	80 25 bd 6c 01 00 fd 	andb   $0xfd,0x16cbd
	ret
   16db0:	c3                   	ret    

00016db1 <caps>:

caps:	testb $0x80,mode
   16db1:	f6 05 bd 6c 01 00 80 	testb  $0x80,0x16cbd
	jne 1f
   16db8:	0f 85 8d 00 00 00    	jne    16e4b <cur2+0x28>
	xorb $4,leds
   16dbe:	80 35 be 6c 01 00 04 	xorb   $0x4,0x16cbe
	xorb $0x40,mode
   16dc5:	80 35 bd 6c 01 00 40 	xorb   $0x40,0x16cbd
	orb $0x80,mode
   16dcc:	80 0d bd 6c 01 00 80 	orb    $0x80,0x16cbd

00016dd3 <set_leds>:
set_leds:
	call kb_wait
   16dd3:	e8 aa 06 00 00       	call   17482 <kb_wait>
	movb $0xed,%al		/* set leds command */
   16dd8:	b0 ed                	mov    $0xed,%al
	outb %al,$0x60
   16dda:	e6 60                	out    %al,$0x60
	call kb_wait
   16ddc:	e8 a1 06 00 00       	call   17482 <kb_wait>
	movb leds,%al
   16de1:	a0 be 6c 01 00       	mov    0x16cbe,%al
	outb %al,$0x60
   16de6:	e6 60                	out    %al,$0x60
	ret
   16de8:	c3                   	ret    

00016de9 <uncaps>:
uncaps:	andb $0x7f,mode
   16de9:	80 25 bd 6c 01 00 7f 	andb   $0x7f,0x16cbd
	ret
   16df0:	c3                   	ret    

00016df1 <scroll>:
scroll:
	xorb $1,leds
   16df1:	80 35 be 6c 01 00 01 	xorb   $0x1,0x16cbe
	jmp set_leds
   16df8:	eb d9                	jmp    16dd3 <set_leds>

00016dfa <num>:
num:	xorb $2,leds
   16dfa:	80 35 be 6c 01 00 02 	xorb   $0x2,0x16cbe
	jmp set_leds
   16e01:	eb d0                	jmp    16dd3 <set_leds>

00016e03 <cursor>:
/*
 *  curosr-key/numeric keypad cursor keys are handled here.
 *  checking for numeric keypad etc.
 */
cursor:
	subb $0x47,%al
   16e03:	2c 47                	sub    $0x47,%al
	jb 1f
   16e05:	72 44                	jb     16e4b <cur2+0x28>
	cmpb $12,%al
   16e07:	3c 0c                	cmp    $0xc,%al
	ja 1f
   16e09:	77 40                	ja     16e4b <cur2+0x28>
	jne cur2		/* check for ctrl-alt-del */
   16e0b:	75 16                	jne    16e23 <cur2>
	testb $0x0c,mode
   16e0d:	f6 05 bd 6c 01 00 0c 	testb  $0xc,0x16cbd
	je cur2
   16e14:	74 0d                	je     16e23 <cur2>
	testb $0x30,mode
   16e16:	f6 05 bd 6c 01 00 30 	testb  $0x30,0x16cbd
	jne reboot
   16e1d:	0f 85 68 06 00 00    	jne    1748b <reboot>

00016e23 <cur2>:
cur2:	cmpb $0x01,e0		/* e0 forces cursor movement */
   16e23:	80 3d bf 6c 01 00 01 	cmpb   $0x1,0x16cbf
	je cur
   16e2a:	74 20                	je     16e4c <cur>
	testb $0x02,leds	/* not num-lock forces cursor */
   16e2c:	f6 05 be 6c 01 00 02 	testb  $0x2,0x16cbe
	je cur
   16e33:	74 17                	je     16e4c <cur>
	testb $0x03,mode	/* shift forces cursor */
   16e35:	f6 05 bd 6c 01 00 03 	testb  $0x3,0x16cbd
	jne cur
   16e3c:	75 0e                	jne    16e4c <cur>
	xorl %ebx,%ebx
   16e3e:	31 db                	xor    %ebx,%ebx
	movb num_table(%eax),%al
   16e40:	8a 80 66 6e 01 00    	mov    0x16e66(%eax),%al
	jmp put_queue
   16e46:	e9 db fe ff ff       	jmp    16d26 <put_queue>
1:	ret
   16e4b:	c3                   	ret    

00016e4c <cur>:

cur:	movb cur_table(%eax),%al
   16e4c:	8a 80 73 6e 01 00    	mov    0x16e73(%eax),%al
	cmpb $'9,%al
   16e52:	3c 39                	cmp    $0x39,%al
	ja ok_cur
   16e54:	77 02                	ja     16e58 <ok_cur>
	movb $'~,%ah
   16e56:	b4 7e                	mov    $0x7e,%ah

00016e58 <ok_cur>:
ok_cur:	shll $16,%eax
   16e58:	c1 e0 10             	shl    $0x10,%eax
	movw $0x5b1b,%ax
   16e5b:	66 b8 1b 5b          	mov    $0x5b1b,%ax
	xorl %ebx,%ebx
   16e5f:	31 db                	xor    %ebx,%ebx
	jmp put_queue
   16e61:	e9 c0 fe ff ff       	jmp    16d26 <put_queue>

00016e66 <num_table>:
   16e66:	37                   	aaa    
   16e67:	38 39                	cmp    %bh,(%ecx)
   16e69:	20 34 35 36 20 31 32 	and    %dh,0x32312036(,%esi,1)
   16e70:	33 30                	xor    (%eax),%esi
   16e72:	2c                   	.byte 0x2c

00016e73 <cur_table>:
   16e73:	48                   	dec    %eax
   16e74:	41                   	inc    %ecx
   16e75:	35 20 44 47 43       	xor    $0x43474420,%eax
   16e7a:	20 59 42             	and    %bl,0x42(%ecx)
   16e7d:	36 32 33             	xor    %ss:(%ebx),%dh

00016e80 <func>:

/*
 * this routine handles function keys
 */
func:
	pushl %eax
   16e80:	50                   	push   %eax
	pushl %ecx
   16e81:	51                   	push   %ecx
	pushl %edx
   16e82:	52                   	push   %edx
	call show_stat
   16e83:	e8 79 fd fe ff       	call   6c01 <show_stat>
	popl %edx
   16e88:	5a                   	pop    %edx
	popl %ecx
   16e89:	59                   	pop    %ecx
	popl %eax
   16e8a:	58                   	pop    %eax
	subb $0x3B,%al
   16e8b:	2c 3b                	sub    $0x3b,%al
	jb end_func
   16e8d:	72 21                	jb     16eb0 <end_func>
	cmpb $9,%al
   16e8f:	3c 09                	cmp    $0x9,%al
	jbe ok_func
   16e91:	76 0a                	jbe    16e9d <ok_func>
	subb $18,%al
   16e93:	2c 12                	sub    $0x12,%al
	cmpb $10,%al
   16e95:	3c 0a                	cmp    $0xa,%al
	jb end_func
   16e97:	72 17                	jb     16eb0 <end_func>
	cmpb $11,%al
   16e99:	3c 0b                	cmp    $0xb,%al
	ja end_func
   16e9b:	77 13                	ja     16eb0 <end_func>

00016e9d <ok_func>:
ok_func:
	cmpl $4,%ecx		/* check that there is enough room */
   16e9d:	83 f9 04             	cmp    $0x4,%ecx
	jl end_func
   16ea0:	7c 0e                	jl     16eb0 <end_func>
	movl func_table(,%eax,4),%eax
   16ea2:	8b 04 85 b1 6e 01 00 	mov    0x16eb1(,%eax,4),%eax
	xorl %ebx,%ebx
   16ea9:	31 db                	xor    %ebx,%ebx
	jmp put_queue
   16eab:	e9 76 fe ff ff       	jmp    16d26 <put_queue>

00016eb0 <end_func>:
end_func:
	ret
   16eb0:	c3                   	ret    

00016eb1 <func_table>:
   16eb1:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16eb4:	41                   	inc    %ecx
   16eb5:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16eb8:	42                   	inc    %edx
   16eb9:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ebc:	43                   	inc    %ebx
   16ebd:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ec0:	44                   	inc    %esp
   16ec1:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ec4:	45                   	inc    %ebp
   16ec5:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ec8:	46                   	inc    %esi
   16ec9:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ecc:	47                   	inc    %edi
   16ecd:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ed0:	48                   	dec    %eax
   16ed1:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ed4:	49                   	dec    %ecx
   16ed5:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ed8:	4a                   	dec    %edx
   16ed9:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16edc:	4b                   	dec    %ebx
   16edd:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   16ee0:	4c                   	dec    %esp

00016ee1 <key_map>:
   16ee1:	00 1b                	add    %bl,(%ebx)
   16ee3:	31 32                	xor    %esi,(%edx)
   16ee5:	33 34 35 36 37 38 39 	xor    0x39383736(,%esi,1),%esi
   16eec:	30 2d 3d 7f 09 71    	xor    %ch,0x71097f3d
   16ef2:	77 65                	ja     16f59 <shift_map+0x17>
   16ef4:	72 74                	jb     16f6a <shift_map+0x28>
   16ef6:	79 75                	jns    16f6d <shift_map+0x2b>
   16ef8:	69 6f 70 5b 5d 0d 00 	imul   $0xd5d5b,0x70(%edi),%ebp
   16eff:	61                   	popa   
   16f00:	73 64                	jae    16f66 <shift_map+0x24>
   16f02:	66 67 68 6a 6b       	addr16 pushw $0x6b6a
   16f07:	6c                   	insb   (%dx),%es:(%edi)
   16f08:	3b 27                	cmp    (%edi),%esp
   16f0a:	60                   	pusha  
   16f0b:	00 5c 7a 78          	add    %bl,0x78(%edx,%edi,2)
   16f0f:	63 76 62             	arpl   %si,0x62(%esi)
   16f12:	6e                   	outsb  %ds:(%esi),(%dx)
   16f13:	6d                   	insl   (%dx),%es:(%edi)
   16f14:	2c 2e                	sub    $0x2e,%al
   16f16:	2f                   	das    
   16f17:	00 2a                	add    %ch,(%edx)
   16f19:	00 20                	add    %ah,(%eax)
	...
   16f2b:	2d 00 00 00 2b       	sub    $0x2b000000,%eax
   16f30:	00 00                	add    %al,(%eax)
   16f32:	00 00                	add    %al,(%eax)
   16f34:	00 00                	add    %al,(%eax)
   16f36:	00 3c 00             	add    %bh,(%eax,%eax,1)
	...

00016f42 <shift_map>:
   16f42:	00 1b                	add    %bl,(%ebx)
   16f44:	21 40 23             	and    %eax,0x23(%eax)
   16f47:	24 25                	and    $0x25,%al
   16f49:	5e                   	pop    %esi
   16f4a:	26 2a 28             	sub    %es:(%eax),%ch
   16f4d:	29 5f 2b             	sub    %ebx,0x2b(%edi)
   16f50:	7f 09                	jg     16f5b <shift_map+0x19>
   16f52:	51                   	push   %ecx
   16f53:	57                   	push   %edi
   16f54:	45                   	inc    %ebp
   16f55:	52                   	push   %edx
   16f56:	54                   	push   %esp
   16f57:	59                   	pop    %ecx
   16f58:	55                   	push   %ebp
   16f59:	49                   	dec    %ecx
   16f5a:	4f                   	dec    %edi
   16f5b:	50                   	push   %eax
   16f5c:	7b 7d                	jnp    16fdb <alt_map+0x38>
   16f5e:	0d 00 41 53 44       	or     $0x44534100,%eax
   16f63:	46                   	inc    %esi
   16f64:	47                   	inc    %edi
   16f65:	48                   	dec    %eax
   16f66:	4a                   	dec    %edx
   16f67:	4b                   	dec    %ebx
   16f68:	4c                   	dec    %esp
   16f69:	3a 22                	cmp    (%edx),%ah
   16f6b:	7e 00                	jle    16f6d <shift_map+0x2b>
   16f6d:	7c 5a                	jl     16fc9 <alt_map+0x26>
   16f6f:	58                   	pop    %eax
   16f70:	43                   	inc    %ebx
   16f71:	56                   	push   %esi
   16f72:	42                   	inc    %edx
   16f73:	4e                   	dec    %esi
   16f74:	4d                   	dec    %ebp
   16f75:	3c 3e                	cmp    $0x3e,%al
   16f77:	3f                   	aas    
   16f78:	00 2a                	add    %ch,(%edx)
   16f7a:	00 20                	add    %ah,(%eax)
	...
   16f8c:	2d 00 00 00 2b       	sub    $0x2b000000,%eax
   16f91:	00 00                	add    %al,(%eax)
   16f93:	00 00                	add    %al,(%eax)
   16f95:	00 00                	add    %al,(%eax)
   16f97:	00 3e                	add    %bh,(%esi)
	...

00016fa3 <alt_map>:
   16fa3:	00 00                	add    %al,(%eax)
   16fa5:	00 40 00             	add    %al,0x0(%eax)
   16fa8:	24 00                	and    $0x0,%al
   16faa:	00 7b 5b             	add    %bh,0x5b(%ebx)
   16fad:	5d                   	pop    %ebp
   16fae:	7d 5c                	jge    1700c <do_self+0x8>
	...
   16fbc:	00 00                	add    %al,(%eax)
   16fbe:	7e 0d                	jle    16fcd <alt_map+0x2a>
	...
   16ff8:	00 7c 00 00          	add    %bh,0x0(%eax,%eax,1)
	...

00017004 <do_self>:
/*
 * do_self handles "normal" keys, ie keys that don't change meaning
 * and which have just one character returns.
 */
do_self:
	lea alt_map,%ebx
   17004:	8d 1d a3 6f 01 00    	lea    0x16fa3,%ebx
	testb $0x20,mode		/* alt-gr */
   1700a:	f6 05 bd 6c 01 00 20 	testb  $0x20,0x16cbd
	jne 1f
   17011:	75 15                	jne    17028 <do_self+0x24>
	lea shift_map,%ebx
   17013:	8d 1d 42 6f 01 00    	lea    0x16f42,%ebx
	testb $0x03,mode
   17019:	f6 05 bd 6c 01 00 03 	testb  $0x3,0x16cbd
	jne 1f
   17020:	75 06                	jne    17028 <do_self+0x24>
	lea key_map,%ebx
   17022:	8d 1d e1 6e 01 00    	lea    0x16ee1,%ebx
1:	movb (%ebx,%eax),%al
   17028:	8a 04 03             	mov    (%ebx,%eax,1),%al
	orb %al,%al
   1702b:	08 c0                	or     %al,%al
	je none
   1702d:	74 3d                	je     1706c <none>
	testb $0x4c,mode		/* ctrl or caps */
   1702f:	f6 05 bd 6c 01 00 4c 	testb  $0x4c,0x16cbd
	je 2f
   17036:	74 0a                	je     17042 <do_self+0x3e>
	cmpb $'a,%al
   17038:	3c 61                	cmp    $0x61,%al
	jb 2f
   1703a:	72 06                	jb     17042 <do_self+0x3e>
	cmpb $'},%al
   1703c:	3c 7d                	cmp    $0x7d,%al
	ja 2f
   1703e:	77 02                	ja     17042 <do_self+0x3e>
	subb $32,%al
   17040:	2c 20                	sub    $0x20,%al
2:	testb $0x0c,mode		/* ctrl */
   17042:	f6 05 bd 6c 01 00 0c 	testb  $0xc,0x16cbd
	je 3f
   17049:	74 0a                	je     17055 <do_self+0x51>
	cmpb $64,%al
   1704b:	3c 40                	cmp    $0x40,%al
	jb 3f
   1704d:	72 06                	jb     17055 <do_self+0x51>
	cmpb $64+32,%al
   1704f:	3c 60                	cmp    $0x60,%al
	jae 3f
   17051:	73 02                	jae    17055 <do_self+0x51>
	subb $64,%al
   17053:	2c 40                	sub    $0x40,%al
3:	testb $0x10,mode		/* left alt */
   17055:	f6 05 bd 6c 01 00 10 	testb  $0x10,0x16cbd
	je 4f
   1705c:	74 02                	je     17060 <do_self+0x5c>
	orb $0x80,%al
   1705e:	0c 80                	or     $0x80,%al
4:	andl $0xff,%eax
   17060:	25 ff 00 00 00       	and    $0xff,%eax
	xorl %ebx,%ebx
   17065:	31 db                	xor    %ebx,%ebx
	call put_queue
   17067:	e8 ba fc ff ff       	call   16d26 <put_queue>

0001706c <none>:
none:	ret
   1706c:	c3                   	ret    

0001706d <minus>:
/*
 * minus has a routine of it's own, as a 'E0h' before
 * the scan code for minus means that the numeric keypad
 * slash was pushed.
 */
minus:	cmpb $1,e0
   1706d:	80 3d bf 6c 01 00 01 	cmpb   $0x1,0x16cbf
	jne do_self
   17074:	75 8e                	jne    17004 <do_self>
	movl $'/,%eax
   17076:	b8 2f 00 00 00       	mov    $0x2f,%eax
	xorl %ebx,%ebx
   1707b:	31 db                	xor    %ebx,%ebx
	jmp put_queue
   1707d:	e9 a4 fc ff ff       	jmp    16d26 <put_queue>

00017082 <key_table>:
   17082:	6c                   	insb   (%dx),%es:(%edi)
   17083:	70 01                	jo     17086 <key_table+0x4>
   17085:	00 04 70             	add    %al,(%eax,%esi,2)
   17088:	01 00                	add    %eax,(%eax)
   1708a:	04 70                	add    $0x70,%al
   1708c:	01 00                	add    %eax,(%eax)
   1708e:	04 70                	add    $0x70,%al
   17090:	01 00                	add    %eax,(%eax)
   17092:	04 70                	add    $0x70,%al
   17094:	01 00                	add    %eax,(%eax)
   17096:	04 70                	add    $0x70,%al
   17098:	01 00                	add    %eax,(%eax)
   1709a:	04 70                	add    $0x70,%al
   1709c:	01 00                	add    %eax,(%eax)
   1709e:	04 70                	add    $0x70,%al
   170a0:	01 00                	add    %eax,(%eax)
   170a2:	04 70                	add    $0x70,%al
   170a4:	01 00                	add    %eax,(%eax)
   170a6:	04 70                	add    $0x70,%al
   170a8:	01 00                	add    %eax,(%eax)
   170aa:	04 70                	add    $0x70,%al
   170ac:	01 00                	add    %eax,(%eax)
   170ae:	04 70                	add    $0x70,%al
   170b0:	01 00                	add    %eax,(%eax)
   170b2:	04 70                	add    $0x70,%al
   170b4:	01 00                	add    %eax,(%eax)
   170b6:	04 70                	add    $0x70,%al
   170b8:	01 00                	add    %eax,(%eax)
   170ba:	04 70                	add    $0x70,%al
   170bc:	01 00                	add    %eax,(%eax)
   170be:	04 70                	add    $0x70,%al
   170c0:	01 00                	add    %eax,(%eax)
   170c2:	04 70                	add    $0x70,%al
   170c4:	01 00                	add    %eax,(%eax)
   170c6:	04 70                	add    $0x70,%al
   170c8:	01 00                	add    %eax,(%eax)
   170ca:	04 70                	add    $0x70,%al
   170cc:	01 00                	add    %eax,(%eax)
   170ce:	04 70                	add    $0x70,%al
   170d0:	01 00                	add    %eax,(%eax)
   170d2:	04 70                	add    $0x70,%al
   170d4:	01 00                	add    %eax,(%eax)
   170d6:	04 70                	add    $0x70,%al
   170d8:	01 00                	add    %eax,(%eax)
   170da:	04 70                	add    $0x70,%al
   170dc:	01 00                	add    %eax,(%eax)
   170de:	04 70                	add    $0x70,%al
   170e0:	01 00                	add    %eax,(%eax)
   170e2:	04 70                	add    $0x70,%al
   170e4:	01 00                	add    %eax,(%eax)
   170e6:	04 70                	add    $0x70,%al
   170e8:	01 00                	add    %eax,(%eax)
   170ea:	04 70                	add    $0x70,%al
   170ec:	01 00                	add    %eax,(%eax)
   170ee:	04 70                	add    $0x70,%al
   170f0:	01 00                	add    %eax,(%eax)
   170f2:	04 70                	add    $0x70,%al
   170f4:	01 00                	add    %eax,(%eax)
   170f6:	5f                   	pop    %edi
   170f7:	6d                   	insl   (%dx),%es:(%edi)
   170f8:	01 00                	add    %eax,(%eax)
   170fa:	04 70                	add    $0x70,%al
   170fc:	01 00                	add    %eax,(%eax)
   170fe:	04 70                	add    $0x70,%al
   17100:	01 00                	add    %eax,(%eax)
   17102:	04 70                	add    $0x70,%al
   17104:	01 00                	add    %eax,(%eax)
   17106:	04 70                	add    $0x70,%al
   17108:	01 00                	add    %eax,(%eax)
   1710a:	04 70                	add    $0x70,%al
   1710c:	01 00                	add    %eax,(%eax)
   1710e:	04 70                	add    $0x70,%al
   17110:	01 00                	add    %eax,(%eax)
   17112:	04 70                	add    $0x70,%al
   17114:	01 00                	add    %eax,(%eax)
   17116:	04 70                	add    $0x70,%al
   17118:	01 00                	add    %eax,(%eax)
   1711a:	04 70                	add    $0x70,%al
   1711c:	01 00                	add    %eax,(%eax)
   1711e:	04 70                	add    $0x70,%al
   17120:	01 00                	add    %eax,(%eax)
   17122:	04 70                	add    $0x70,%al
   17124:	01 00                	add    %eax,(%eax)
   17126:	04 70                	add    $0x70,%al
   17128:	01 00                	add    %eax,(%eax)
   1712a:	91                   	xchg   %eax,%ecx
   1712b:	6d                   	insl   (%dx),%es:(%edi)
   1712c:	01 00                	add    %eax,(%eax)
   1712e:	04 70                	add    $0x70,%al
   17130:	01 00                	add    %eax,(%eax)
   17132:	04 70                	add    $0x70,%al
   17134:	01 00                	add    %eax,(%eax)
   17136:	04 70                	add    $0x70,%al
   17138:	01 00                	add    %eax,(%eax)
   1713a:	04 70                	add    $0x70,%al
   1713c:	01 00                	add    %eax,(%eax)
   1713e:	04 70                	add    $0x70,%al
   17140:	01 00                	add    %eax,(%eax)
   17142:	04 70                	add    $0x70,%al
   17144:	01 00                	add    %eax,(%eax)
   17146:	04 70                	add    $0x70,%al
   17148:	01 00                	add    %eax,(%eax)
   1714a:	04 70                	add    $0x70,%al
   1714c:	01 00                	add    %eax,(%eax)
   1714e:	04 70                	add    $0x70,%al
   17150:	01 00                	add    %eax,(%eax)
   17152:	04 70                	add    $0x70,%al
   17154:	01 00                	add    %eax,(%eax)
   17156:	6d                   	insl   (%dx),%es:(%edi)
   17157:	70 01                	jo     1715a <key_table+0xd8>
   17159:	00 a1 6d 01 00 04    	add    %ah,0x400016d(%ecx)
   1715f:	70 01                	jo     17162 <key_table+0xe0>
   17161:	00 63 6d             	add    %ah,0x6d(%ebx)
   17164:	01 00                	add    %eax,(%eax)
   17166:	04 70                	add    $0x70,%al
   17168:	01 00                	add    %eax,(%eax)
   1716a:	b1 6d                	mov    $0x6d,%cl
   1716c:	01 00                	add    %eax,(%eax)
   1716e:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   17172:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   17176:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   1717a:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   1717e:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   17182:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   17186:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   1718a:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   1718e:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   17192:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   17196:	fa                   	cli    
   17197:	6d                   	insl   (%dx),%es:(%edi)
   17198:	01 00                	add    %eax,(%eax)
   1719a:	f1                   	icebp  
   1719b:	6d                   	insl   (%dx),%es:(%edi)
   1719c:	01 00                	add    %eax,(%eax)
   1719e:	03 6e 01             	add    0x1(%esi),%ebp
   171a1:	00 03                	add    %al,(%ebx)
   171a3:	6e                   	outsb  %ds:(%esi),(%dx)
   171a4:	01 00                	add    %eax,(%eax)
   171a6:	03 6e 01             	add    0x1(%esi),%ebp
   171a9:	00 04 70             	add    %al,(%eax,%esi,2)
   171ac:	01 00                	add    %eax,(%eax)
   171ae:	03 6e 01             	add    0x1(%esi),%ebp
   171b1:	00 03                	add    %al,(%ebx)
   171b3:	6e                   	outsb  %ds:(%esi),(%dx)
   171b4:	01 00                	add    %eax,(%eax)
   171b6:	03 6e 01             	add    0x1(%esi),%ebp
   171b9:	00 04 70             	add    %al,(%eax,%esi,2)
   171bc:	01 00                	add    %eax,(%eax)
   171be:	03 6e 01             	add    0x1(%esi),%ebp
   171c1:	00 03                	add    %al,(%ebx)
   171c3:	6e                   	outsb  %ds:(%esi),(%dx)
   171c4:	01 00                	add    %eax,(%eax)
   171c6:	03 6e 01             	add    0x1(%esi),%ebp
   171c9:	00 03                	add    %al,(%ebx)
   171cb:	6e                   	outsb  %ds:(%esi),(%dx)
   171cc:	01 00                	add    %eax,(%eax)
   171ce:	03 6e 01             	add    0x1(%esi),%ebp
   171d1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   171d5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   171d9:	00 04 70             	add    %al,(%eax,%esi,2)
   171dc:	01 00                	add    %eax,(%eax)
   171de:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   171e2:	80 6e 01 00          	subb   $0x0,0x1(%esi)
   171e6:	6c                   	insb   (%dx),%es:(%edi)
   171e7:	70 01                	jo     171ea <key_table+0x168>
   171e9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   171ed:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   171f1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   171f5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   171f9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   171fd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17201:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17205:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17209:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1720d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17211:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17215:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17219:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1721d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17221:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17225:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17229:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1722d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17231:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17235:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17239:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1723d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17241:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17245:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17249:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1724d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17251:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17255:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17259:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1725d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17261:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17265:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17269:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1726d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17271:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17275:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17279:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1727d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17281:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17285:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17289:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1728d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17291:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17295:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17299:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1729d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172a1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172a5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172a9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172ad:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172b1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172b5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172b9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172bd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172c1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172c5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172c9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172cd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172d1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172d5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172d9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172dd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172e1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172e5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172e9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172ed:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172f1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   172f5:	00 77 6d             	add    %dh,0x6d(%edi)
   172f8:	01 00                	add    %eax,(%eax)
   172fa:	6c                   	insb   (%dx),%es:(%edi)
   172fb:	70 01                	jo     172fe <key_table+0x27c>
   172fd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17301:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17305:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17309:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1730d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17311:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17315:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17319:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1731d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17321:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17325:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17329:	00 99 6d 01 00 6c    	add    %bl,0x6c00016d(%ecx)
   1732f:	70 01                	jo     17332 <key_table+0x2b0>
   17331:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17335:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17339:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1733d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17341:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17345:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17349:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1734d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17351:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17355:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17359:	00 a9 6d 01 00 6c    	add    %ch,0x6c00016d(%ecx)
   1735f:	70 01                	jo     17362 <key_table+0x2e0>
   17361:	00 7b 6d             	add    %bh,0x6d(%ebx)
   17364:	01 00                	add    %eax,(%eax)
   17366:	6c                   	insb   (%dx),%es:(%edi)
   17367:	70 01                	jo     1736a <key_table+0x2e8>
   17369:	00 e9                	add    %ch,%cl
   1736b:	6d                   	insl   (%dx),%es:(%edi)
   1736c:	01 00                	add    %eax,(%eax)
   1736e:	6c                   	insb   (%dx),%es:(%edi)
   1736f:	70 01                	jo     17372 <key_table+0x2f0>
   17371:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17375:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17379:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1737d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17381:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17385:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17389:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1738d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17391:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17395:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17399:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1739d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173a1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173a5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173a9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173ad:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173b1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173b5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173b9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173bd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173c1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173c5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173c9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173cd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173d1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173d5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173d9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173dd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173e1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173e5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173e9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173ed:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173f1:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173f5:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173f9:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   173fd:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17401:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17405:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17409:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1740d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17411:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17415:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17419:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1741d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17421:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17425:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17429:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1742d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17431:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17435:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17439:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1743d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17441:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17445:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17449:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1744d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17451:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17455:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17459:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1745d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17461:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17465:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17469:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1746d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17471:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17475:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   17479:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
   1747d:	00 6c 70 01          	add    %ch,0x1(%eax,%esi,2)
	...

00017482 <kb_wait>:
/*
 * kb_wait waits for the keyboard controller buffer to empty.
 * there is no timeout - if the buffer doesn't empty, we hang.
 */
kb_wait:
	pushl %eax
   17482:	50                   	push   %eax
1:	inb $0x64,%al
   17483:	e4 64                	in     $0x64,%al
	testb $0x02,%al
   17485:	a8 02                	test   $0x2,%al
	jne 1b
   17487:	75 fa                	jne    17483 <kb_wait+0x1>
	popl %eax
   17489:	58                   	pop    %eax
	ret
   1748a:	c3                   	ret    

0001748b <reboot>:
/*
 * This routine reboots the machine by asking the keyboard
 * controller to pulse the reset-line low.
 */
reboot:
	call kb_wait
   1748b:	e8 f2 ff ff ff       	call   17482 <kb_wait>
	movw $0x1234,0x472	/* don't do memory check */
   17490:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
   17497:	34 12 
	movb $0xfc,%al		/* pulse reset and A20 low */
   17499:	b0 fc                	mov    $0xfc,%al
	outb %al,$0x64
   1749b:	e6 64                	out    %al,$0x64

0001749d <die>:
die:	jmp die
   1749d:	eb fe                	jmp    1749d <die>

0001749f <init>:

extern void rs1_interrupt(void);
extern void rs2_interrupt(void);

static void init(int port)
{
   1749f:	83 ec 10             	sub    $0x10,%esp
	outb_p(0x80,port+3);	/* set DLAB of line control reg */
   174a2:	8b 44 24 14          	mov    0x14(%esp),%eax
   174a6:	8d 50 03             	lea    0x3(%eax),%edx
   174a9:	b8 80 00 00 00       	mov    $0x80,%eax
   174ae:	ee                   	out    %al,(%dx)
   174af:	eb 00                	jmp    174b1 <init+0x12>
   174b1:	eb 00                	jmp    174b3 <init+0x14>
	outb_p(0x30,port);	/* LS of divisor (48 -> 2400 bps */
   174b3:	b8 30 00 00 00       	mov    $0x30,%eax
   174b8:	8b 54 24 14          	mov    0x14(%esp),%edx
   174bc:	ee                   	out    %al,(%dx)
   174bd:	eb 00                	jmp    174bf <init+0x20>
   174bf:	eb 00                	jmp    174c1 <init+0x22>
	outb_p(0x00,port+1);	/* MS of divisor */
   174c1:	8b 44 24 14          	mov    0x14(%esp),%eax
   174c5:	8d 50 01             	lea    0x1(%eax),%edx
   174c8:	b8 00 00 00 00       	mov    $0x0,%eax
   174cd:	ee                   	out    %al,(%dx)
   174ce:	eb 00                	jmp    174d0 <init+0x31>
   174d0:	eb 00                	jmp    174d2 <init+0x33>
	outb_p(0x03,port+3);	/* reset DLAB */
   174d2:	8b 44 24 14          	mov    0x14(%esp),%eax
   174d6:	8d 50 03             	lea    0x3(%eax),%edx
   174d9:	b8 03 00 00 00       	mov    $0x3,%eax
   174de:	ee                   	out    %al,(%dx)
   174df:	eb 00                	jmp    174e1 <init+0x42>
   174e1:	eb 00                	jmp    174e3 <init+0x44>
	outb_p(0x0b,port+4);	/* set DTR,RTS, OUT_2 */
   174e3:	8b 44 24 14          	mov    0x14(%esp),%eax
   174e7:	8d 50 04             	lea    0x4(%eax),%edx
   174ea:	b8 0b 00 00 00       	mov    $0xb,%eax
   174ef:	ee                   	out    %al,(%dx)
   174f0:	eb 00                	jmp    174f2 <init+0x53>
   174f2:	eb 00                	jmp    174f4 <init+0x55>
	outb_p(0x0d,port+1);	/* enable all intrs but writes */
   174f4:	8b 44 24 14          	mov    0x14(%esp),%eax
   174f8:	8d 50 01             	lea    0x1(%eax),%edx
   174fb:	b8 0d 00 00 00       	mov    $0xd,%eax
   17500:	ee                   	out    %al,(%dx)
   17501:	eb 00                	jmp    17503 <init+0x64>
   17503:	eb 00                	jmp    17505 <init+0x66>
	(void)inb(port);	/* read data port to reset things (?) */
   17505:	8b 44 24 14          	mov    0x14(%esp),%eax
   17509:	89 c2                	mov    %eax,%edx
   1750b:	ec                   	in     (%dx),%al
   1750c:	88 44 24 0f          	mov    %al,0xf(%esp)
}
   17510:	90                   	nop
   17511:	83 c4 10             	add    $0x10,%esp
   17514:	c3                   	ret    

00017515 <rs_init>:

void rs_init(void)
{
   17515:	53                   	push   %ebx
   17516:	83 ec 10             	sub    $0x10,%esp
	set_intr_gate(0x24,rs1_interrupt);
   17519:	b9 d8 55 00 00       	mov    $0x55d8,%ecx
   1751e:	bb dc 55 00 00       	mov    $0x55dc,%ebx
   17523:	ba f0 75 01 00       	mov    $0x175f0,%edx
   17528:	b8 00 00 08 00       	mov    $0x80000,%eax
   1752d:	66 89 d0             	mov    %dx,%ax
   17530:	66 ba 00 8e          	mov    $0x8e00,%dx
   17534:	89 01                	mov    %eax,(%ecx)
   17536:	89 13                	mov    %edx,(%ebx)
	set_intr_gate(0x23,rs2_interrupt);
   17538:	b9 d0 55 00 00       	mov    $0x55d0,%ecx
   1753d:	bb d4 55 00 00       	mov    $0x55d4,%ebx
   17542:	ba f8 75 01 00       	mov    $0x175f8,%edx
   17547:	b8 00 00 08 00       	mov    $0x80000,%eax
   1754c:	66 89 d0             	mov    %dx,%ax
   1754f:	66 ba 00 8e          	mov    $0x8e00,%dx
   17553:	89 01                	mov    %eax,(%ecx)
   17555:	89 13                	mov    %edx,(%ebx)
	init(tty_table[1].read_q.data);
   17557:	a1 d0 00 02 00       	mov    0x200d0,%eax
   1755c:	50                   	push   %eax
   1755d:	e8 3d ff ff ff       	call   1749f <init>
   17562:	83 c4 04             	add    $0x4,%esp
	init(tty_table[2].read_q.data);
   17565:	a1 30 0d 02 00       	mov    0x20d30,%eax
   1756a:	50                   	push   %eax
   1756b:	e8 2f ff ff ff       	call   1749f <init>
   17570:	83 c4 04             	add    $0x4,%esp
	outb(inb_p(0x21)&0xE7,0x21);
   17573:	b8 21 00 00 00       	mov    $0x21,%eax
   17578:	89 c2                	mov    %eax,%edx
   1757a:	ec                   	in     (%dx),%al
   1757b:	eb 00                	jmp    1757d <rs_init+0x68>
   1757d:	eb 00                	jmp    1757f <rs_init+0x6a>
   1757f:	88 44 24 0f          	mov    %al,0xf(%esp)
   17583:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   17588:	0f b6 c0             	movzbl %al,%eax
   1758b:	25 e7 00 00 00       	and    $0xe7,%eax
   17590:	ba 21 00 00 00       	mov    $0x21,%edx
   17595:	ee                   	out    %al,(%dx)
}
   17596:	90                   	nop
   17597:	83 c4 10             	add    $0x10,%esp
   1759a:	5b                   	pop    %ebx
   1759b:	c3                   	ret    

0001759c <rs_write>:
 * set the interrupt register accordingly
 *
 *	void _rs_write(struct tty_struct * tty);
 */
void rs_write(struct tty_struct * tty)
{
   1759c:	83 ec 10             	sub    $0x10,%esp
	cli();
   1759f:	fa                   	cli    
	if (!EMPTY(tty->write_q))
   175a0:	8b 44 24 14          	mov    0x14(%esp),%eax
   175a4:	8b 90 44 04 00 00    	mov    0x444(%eax),%edx
   175aa:	8b 44 24 14          	mov    0x14(%esp),%eax
   175ae:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   175b4:	39 c2                	cmp    %eax,%edx
   175b6:	74 31                	je     175e9 <rs_write+0x4d>
		outb(inb_p(tty->write_q.data+1)|0x02,tty->write_q.data+1);
   175b8:	8b 44 24 14          	mov    0x14(%esp),%eax
   175bc:	8b 80 40 04 00 00    	mov    0x440(%eax),%eax
   175c2:	83 c0 01             	add    $0x1,%eax
   175c5:	89 c2                	mov    %eax,%edx
   175c7:	ec                   	in     (%dx),%al
   175c8:	eb 00                	jmp    175ca <rs_write+0x2e>
   175ca:	eb 00                	jmp    175cc <rs_write+0x30>
   175cc:	88 44 24 0f          	mov    %al,0xf(%esp)
   175d0:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   175d5:	83 c8 02             	or     $0x2,%eax
   175d8:	0f b6 c0             	movzbl %al,%eax
   175db:	8b 54 24 14          	mov    0x14(%esp),%edx
   175df:	8b 92 40 04 00 00    	mov    0x440(%edx),%edx
   175e5:	83 c2 01             	add    $0x1,%edx
   175e8:	ee                   	out    %al,(%dx)
	sti();
   175e9:	fb                   	sti    
}
   175ea:	90                   	nop
   175eb:	83 c4 10             	add    $0x10,%esp
   175ee:	c3                   	ret    
   175ef:	90                   	nop

000175f0 <rs1_interrupt>:
 * These are the actual interrupt routines. They look where
 * the interrupt is coming from, and take appropriate action.
 */
.align 2
rs1_interrupt:
	pushl $table_list+8
   175f0:	68 68 19 02 00       	push   $0x21968
	jmp rs_int
   175f5:	eb 06                	jmp    175fd <rs_int>
   175f7:	90                   	nop

000175f8 <rs2_interrupt>:
.align 2
rs2_interrupt:
	pushl $table_list+16
   175f8:	68 70 19 02 00       	push   $0x21970

000175fd <rs_int>:
rs_int:
	pushl %edx
   175fd:	52                   	push   %edx
	pushl %ecx
   175fe:	51                   	push   %ecx
	pushl %ebx
   175ff:	53                   	push   %ebx
	pushl %eax
   17600:	50                   	push   %eax
	push %es
   17601:	06                   	push   %es
	push %ds		/* as this is an interrupt, we cannot */
   17602:	1e                   	push   %ds
	pushl $0x10		/* know that bs is ok. Load it */
   17603:	6a 10                	push   $0x10
	pop %ds
   17605:	1f                   	pop    %ds
	pushl $0x10
   17606:	6a 10                	push   $0x10
	pop %es
   17608:	07                   	pop    %es
	movl 24(%esp),%edx
   17609:	8b 54 24 18          	mov    0x18(%esp),%edx
	movl (%edx),%edx
   1760d:	8b 12                	mov    (%edx),%edx
	movl rs_addr(%edx),%edx
   1760f:	8b 12                	mov    (%edx),%edx
	addl $2,%edx		/* interrupt ident. reg */
   17611:	83 c2 02             	add    $0x2,%edx

00017614 <rep_int>:
rep_int:
	xorl %eax,%eax
   17614:	31 c0                	xor    %eax,%eax
	inb %dx,%al
   17616:	ec                   	in     (%dx),%al
	testb $1,%al
   17617:	a8 01                	test   $0x1,%al
	jne end
   17619:	75 16                	jne    17631 <end>
	cmpb $6,%al		/* this shouldn't happen, but ... */
   1761b:	3c 06                	cmp    $0x6,%al
	ja end
   1761d:	77 12                	ja     17631 <end>
	movl 24(%esp),%ecx
   1761f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	pushl %edx
   17623:	52                   	push   %edx
	subl $2,%edx
   17624:	83 ea 02             	sub    $0x2,%edx
	call *jmp_table(,%eax,2)		/* NOTE! not *4, bit0 is 0 already */
   17627:	ff 14 45 3f 76 01 00 	call   *0x1763f(,%eax,2)
	popl %edx
   1762e:	5a                   	pop    %edx
	jmp rep_int
   1762f:	eb e3                	jmp    17614 <rep_int>

00017631 <end>:
end:	movb $0x20,%al
   17631:	b0 20                	mov    $0x20,%al
	outb %al,$0x20		/* EOI */
   17633:	e6 20                	out    %al,$0x20
	pop %ds
   17635:	1f                   	pop    %ds
	pop %es
   17636:	07                   	pop    %es
	popl %eax
   17637:	58                   	pop    %eax
	popl %ebx
   17638:	5b                   	pop    %ebx
	popl %ecx
   17639:	59                   	pop    %ecx
	popl %edx
   1763a:	5a                   	pop    %edx
	addl $4,%esp		# jump over _table_list entry
   1763b:	83 c4 04             	add    $0x4,%esp
	iret
   1763e:	cf                   	iret   

0001763f <jmp_table>:
   1763f:	50                   	push   %eax
   17640:	76 01                	jbe    17643 <jmp_table+0x4>
   17642:	00 8a 76 01 00 5c    	add    %cl,0x5c000176(%edx)
   17648:	76 01                	jbe    1764b <jmp_table+0xc>
   1764a:	00 56 76             	add    %dl,0x76(%esi)
   1764d:	01 00                	add    %eax,(%eax)
   1764f:	90                   	nop

00017650 <modem_status>:
jmp_table:
	.long modem_status,write_char,read_char,line_status

.align 2
modem_status:
	addl $6,%edx		/* clear intr by reading modem status reg */
   17650:	83 c2 06             	add    $0x6,%edx
	inb %dx,%al
   17653:	ec                   	in     (%dx),%al
	ret
   17654:	c3                   	ret    
   17655:	90                   	nop

00017656 <line_status>:

.align 2
line_status:
	addl $5,%edx		/* clear intr by reading line status reg. */
   17656:	83 c2 05             	add    $0x5,%edx
	inb %dx,%al
   17659:	ec                   	in     (%dx),%al
	ret
   1765a:	c3                   	ret    
   1765b:	90                   	nop

0001765c <read_char>:

.align 2
read_char:
	inb %dx,%al
   1765c:	ec                   	in     (%dx),%al
	movl %ecx,%edx
   1765d:	89 ca                	mov    %ecx,%edx
	subl $table_list,%edx
   1765f:	81 ea 60 19 02 00    	sub    $0x21960,%edx
	shrl $3,%edx
   17665:	c1 ea 03             	shr    $0x3,%edx
	movl (%ecx),%ecx		# read-queue
   17668:	8b 09                	mov    (%ecx),%ecx
	movl head(%ecx),%ebx
   1766a:	8b 59 04             	mov    0x4(%ecx),%ebx
	movb %al,buf(%ecx,%ebx)
   1766d:	88 44 19 10          	mov    %al,0x10(%ecx,%ebx,1)
	incl %ebx
   17671:	43                   	inc    %ebx
	andl $size-1,%ebx
   17672:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
	cmpl tail(%ecx),%ebx
   17678:	3b 59 08             	cmp    0x8(%ecx),%ebx
	je 1f
   1767b:	74 03                	je     17680 <read_char+0x24>
	movl %ebx,head(%ecx)
   1767d:	89 59 04             	mov    %ebx,0x4(%ecx)
1:	pushl %edx
   17680:	52                   	push   %edx
	call do_tty_interrupt
   17681:	e8 0b e3 ff ff       	call   15991 <do_tty_interrupt>
	addl $4,%esp
   17686:	83 c4 04             	add    $0x4,%esp
	ret
   17689:	c3                   	ret    

0001768a <write_char>:

.align 2
write_char:
	movl 4(%ecx),%ecx		# write-queue
   1768a:	8b 49 04             	mov    0x4(%ecx),%ecx
	movl head(%ecx),%ebx
   1768d:	8b 59 04             	mov    0x4(%ecx),%ebx
	subl tail(%ecx),%ebx
   17690:	2b 59 08             	sub    0x8(%ecx),%ebx
	andl $size-1,%ebx		# nr chars in queue
   17693:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
	je write_buffer_empty
   17699:	74 2d                	je     176c8 <write_buffer_empty>
	cmpl $startup,%ebx
   1769b:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
	ja 1f
   176a1:	77 0d                	ja     176b0 <write_char+0x26>
	movl proc_list(%ecx),%ebx	# wake up sleeping process
   176a3:	8b 59 0c             	mov    0xc(%ecx),%ebx
	testl %ebx,%ebx			# is there any?
   176a6:	85 db                	test   %ebx,%ebx
	je 1f
   176a8:	74 06                	je     176b0 <write_char+0x26>
	movl $0,(%ebx)
   176aa:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
1:	movl tail(%ecx),%ebx
   176b0:	8b 59 08             	mov    0x8(%ecx),%ebx
	movb buf(%ecx,%ebx),%al
   176b3:	8a 44 19 10          	mov    0x10(%ecx,%ebx,1),%al
	outb %al,%dx
   176b7:	ee                   	out    %al,(%dx)
	incl %ebx
   176b8:	43                   	inc    %ebx
	andl $size-1,%ebx
   176b9:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
	movl %ebx,tail(%ecx)
   176bf:	89 59 08             	mov    %ebx,0x8(%ecx)
	cmpl head(%ecx),%ebx
   176c2:	3b 59 04             	cmp    0x4(%ecx),%ebx
	je write_buffer_empty
   176c5:	74 01                	je     176c8 <write_buffer_empty>
	ret
   176c7:	c3                   	ret    

000176c8 <write_buffer_empty>:
.align 2
write_buffer_empty:
	movl proc_list(%ecx),%ebx	# wake up sleeping process
   176c8:	8b 59 0c             	mov    0xc(%ecx),%ebx
	testl %ebx,%ebx			# is there any?
   176cb:	85 db                	test   %ebx,%ebx
	je 1f
   176cd:	74 06                	je     176d5 <write_buffer_empty+0xd>
	movl $0,(%ebx)
   176cf:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
1:	incl %edx
   176d5:	42                   	inc    %edx
	inb %dx,%al
   176d6:	ec                   	in     (%dx),%al
	jmp 1f
   176d7:	eb 00                	jmp    176d9 <write_buffer_empty+0x11>
1:	jmp 1f
   176d9:	eb 00                	jmp    176db <write_buffer_empty+0x13>
1:	andb $0xd,%al		/* disable transmit interrupt */
   176db:	24 0d                	and    $0xd,%al
	outb %al,%dx
   176dd:	ee                   	out    %al,(%dx)
	ret
   176de:	c3                   	ret    

000176df <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
   176df:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
   176e0:	8b 44 24 08          	mov    0x8(%esp),%eax
   176e4:	64 8a 00             	mov    %fs:(%eax),%al
   176e7:	89 c3                	mov    %eax,%ebx
	return _v;
   176e9:	89 d8                	mov    %ebx,%eax
}
   176eb:	5b                   	pop    %ebx
   176ec:	c3                   	ret    

000176ed <get_fs_long>:
	__asm__ ("movw %%fs:%1,%0":"=r" (_v):"m" (*addr));
	return _v;
}

static inline unsigned long get_fs_long(const unsigned long *addr)
{
   176ed:	83 ec 10             	sub    $0x10,%esp
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
   176f0:	8b 44 24 14          	mov    0x14(%esp),%eax
   176f4:	64 8b 00             	mov    %fs:(%eax),%eax
   176f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return _v;
   176fb:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   176ff:	83 c4 10             	add    $0x10,%esp
   17702:	c3                   	ret    

00017703 <put_fs_byte>:

static inline void put_fs_byte(char val,char *addr)
{
   17703:	83 ec 04             	sub    $0x4,%esp
   17706:	8b 44 24 08          	mov    0x8(%esp),%eax
   1770a:	88 04 24             	mov    %al,(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
   1770d:	0f b6 04 24          	movzbl (%esp),%eax
   17711:	8b 54 24 0c          	mov    0xc(%esp),%edx
   17715:	64 88 02             	mov    %al,%fs:(%edx)
}
   17718:	90                   	nop
   17719:	83 c4 04             	add    $0x4,%esp
   1771c:	c3                   	ret    

0001771d <put_fs_long>:
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
   1771d:	8b 44 24 04          	mov    0x4(%esp),%eax
   17721:	8b 54 24 08          	mov    0x8(%esp),%edx
   17725:	64 89 02             	mov    %eax,%fs:(%edx)
}
   17728:	90                   	nop
   17729:	c3                   	ret    

0001772a <change_speed>:
	768, 576, 384, 192, 96,
	64, 48, 24, 12, 6, 3
};

static void change_speed(struct tty_struct * tty)
{
   1772a:	83 ec 10             	sub    $0x10,%esp
	unsigned short port,quot;

	if (!(port = tty->read_q.data))
   1772d:	8b 44 24 14          	mov    0x14(%esp),%eax
   17731:	8b 40 30             	mov    0x30(%eax),%eax
   17734:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
   17739:	66 83 7c 24 0e 00    	cmpw   $0x0,0xe(%esp)
   1773f:	74 66                	je     177a7 <change_speed+0x7d>
		return;
	quot = quotient[tty->termios.c_cflag & CBAUD];
   17741:	8b 44 24 14          	mov    0x14(%esp),%eax
   17745:	8b 40 08             	mov    0x8(%eax),%eax
   17748:	83 e0 0f             	and    $0xf,%eax
   1774b:	0f b7 84 00 80 19 02 	movzwl 0x21980(%eax,%eax,1),%eax
   17752:	00 
   17753:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	cli();
   17758:	fa                   	cli    
	outb_p(0x80,port+3);		/* set DLAB */
   17759:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
   1775e:	8d 50 03             	lea    0x3(%eax),%edx
   17761:	b8 80 00 00 00       	mov    $0x80,%eax
   17766:	ee                   	out    %al,(%dx)
   17767:	eb 00                	jmp    17769 <change_speed+0x3f>
   17769:	eb 00                	jmp    1776b <change_speed+0x41>
	outb_p(quot & 0xff,port);	/* LS of divisor */
   1776b:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   17770:	0f b6 c0             	movzbl %al,%eax
   17773:	0f b7 54 24 0e       	movzwl 0xe(%esp),%edx
   17778:	ee                   	out    %al,(%dx)
   17779:	eb 00                	jmp    1777b <change_speed+0x51>
   1777b:	eb 00                	jmp    1777d <change_speed+0x53>
	outb_p(quot >> 8,port+1);	/* MS of divisor */
   1777d:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   17782:	66 c1 e8 08          	shr    $0x8,%ax
   17786:	0f b7 c0             	movzwl %ax,%eax
   17789:	0f b7 54 24 0e       	movzwl 0xe(%esp),%edx
   1778e:	83 c2 01             	add    $0x1,%edx
   17791:	ee                   	out    %al,(%dx)
   17792:	eb 00                	jmp    17794 <change_speed+0x6a>
   17794:	eb 00                	jmp    17796 <change_speed+0x6c>
	outb(0x03,port+3);		/* reset DLAB */
   17796:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
   1779b:	8d 50 03             	lea    0x3(%eax),%edx
   1779e:	b8 03 00 00 00       	mov    $0x3,%eax
   177a3:	ee                   	out    %al,(%dx)
	sti();
   177a4:	fb                   	sti    
   177a5:	eb 01                	jmp    177a8 <change_speed+0x7e>
static void change_speed(struct tty_struct * tty)
{
	unsigned short port,quot;

	if (!(port = tty->read_q.data))
		return;
   177a7:	90                   	nop
	outb_p(0x80,port+3);		/* set DLAB */
	outb_p(quot & 0xff,port);	/* LS of divisor */
	outb_p(quot >> 8,port+1);	/* MS of divisor */
	outb(0x03,port+3);		/* reset DLAB */
	sti();
}
   177a8:	83 c4 10             	add    $0x10,%esp
   177ab:	c3                   	ret    

000177ac <flush>:

static void flush(struct tty_queue * queue)
{
	cli();
   177ac:	fa                   	cli    
	queue->head = queue->tail;
   177ad:	8b 44 24 04          	mov    0x4(%esp),%eax
   177b1:	8b 50 08             	mov    0x8(%eax),%edx
   177b4:	8b 44 24 04          	mov    0x4(%esp),%eax
   177b8:	89 50 04             	mov    %edx,0x4(%eax)
	sti();
   177bb:	fb                   	sti    
}
   177bc:	90                   	nop
   177bd:	c3                   	ret    

000177be <wait_until_sent>:

static void wait_until_sent(struct tty_struct * tty)
{
	/* do nothing - not implemented */
}
   177be:	90                   	nop
   177bf:	c3                   	ret    

000177c0 <send_break>:

static void send_break(struct tty_struct * tty)
{
	/* do nothing - not implemented */
}
   177c0:	90                   	nop
   177c1:	c3                   	ret    

000177c2 <get_termios>:

static int get_termios(struct tty_struct * tty, struct termios * termios)
{
   177c2:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	verify_area(termios, sizeof (*termios));
   177c5:	83 ec 08             	sub    $0x8,%esp
   177c8:	6a 24                	push   $0x24
   177ca:	ff 74 24 30          	pushl  0x30(%esp)
   177ce:	e8 d1 08 ff ff       	call   80a4 <verify_area>
   177d3:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i< (sizeof (*termios)) ; i++)
   177d6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   177dd:	00 
   177de:	eb 2c                	jmp    1780c <get_termios+0x4a>
		put_fs_byte( ((char *)&tty->termios)[i] , i+(char *)termios );
   177e0:	8b 54 24 0c          	mov    0xc(%esp),%edx
   177e4:	8b 44 24 24          	mov    0x24(%esp),%eax
   177e8:	01 c2                	add    %eax,%edx
   177ea:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   177ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
   177f2:	01 c8                	add    %ecx,%eax
   177f4:	0f b6 00             	movzbl (%eax),%eax
   177f7:	0f be c0             	movsbl %al,%eax
   177fa:	83 ec 08             	sub    $0x8,%esp
   177fd:	52                   	push   %edx
   177fe:	50                   	push   %eax
   177ff:	e8 ff fe ff ff       	call   17703 <put_fs_byte>
   17804:	83 c4 10             	add    $0x10,%esp
static int get_termios(struct tty_struct * tty, struct termios * termios)
{
	int i;

	verify_area(termios, sizeof (*termios));
	for (i=0 ; i< (sizeof (*termios)) ; i++)
   17807:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   1780c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17810:	83 f8 23             	cmp    $0x23,%eax
   17813:	76 cb                	jbe    177e0 <get_termios+0x1e>
		put_fs_byte( ((char *)&tty->termios)[i] , i+(char *)termios );
	return 0;
   17815:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1781a:	83 c4 1c             	add    $0x1c,%esp
   1781d:	c3                   	ret    

0001781e <set_termios>:

static int set_termios(struct tty_struct * tty, struct termios * termios)
{
   1781e:	53                   	push   %ebx
   1781f:	83 ec 10             	sub    $0x10,%esp
	int i;

	for (i=0 ; i< (sizeof (*termios)) ; i++)
   17822:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   17829:	00 
   1782a:	eb 25                	jmp    17851 <set_termios+0x33>
		((char *)&tty->termios)[i]=get_fs_byte(i+(char *)termios);
   1782c:	8b 54 24 18          	mov    0x18(%esp),%edx
   17830:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17834:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   17837:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1783b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1783f:	01 d0                	add    %edx,%eax
   17841:	50                   	push   %eax
   17842:	e8 98 fe ff ff       	call   176df <get_fs_byte>
   17847:	83 c4 04             	add    $0x4,%esp
   1784a:	88 03                	mov    %al,(%ebx)

static int set_termios(struct tty_struct * tty, struct termios * termios)
{
	int i;

	for (i=0 ; i< (sizeof (*termios)) ; i++)
   1784c:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
   17851:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17855:	83 f8 23             	cmp    $0x23,%eax
   17858:	76 d2                	jbe    1782c <set_termios+0xe>
		((char *)&tty->termios)[i]=get_fs_byte(i+(char *)termios);
	change_speed(tty);
   1785a:	ff 74 24 18          	pushl  0x18(%esp)
   1785e:	e8 c7 fe ff ff       	call   1772a <change_speed>
   17863:	83 c4 04             	add    $0x4,%esp
	return 0;
   17866:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1786b:	83 c4 10             	add    $0x10,%esp
   1786e:	5b                   	pop    %ebx
   1786f:	c3                   	ret    

00017870 <get_termio>:

static int get_termio(struct tty_struct * tty, struct termio * termio)
{
   17870:	83 ec 2c             	sub    $0x2c,%esp
	int i;
	struct termio tmp_termio;

	verify_area(termio, sizeof (*termio));
   17873:	83 ec 08             	sub    $0x8,%esp
   17876:	6a 12                	push   $0x12
   17878:	ff 74 24 40          	pushl  0x40(%esp)
   1787c:	e8 23 08 ff ff       	call   80a4 <verify_area>
   17881:	83 c4 10             	add    $0x10,%esp
	tmp_termio.c_iflag = tty->termios.c_iflag;
   17884:	8b 44 24 30          	mov    0x30(%esp),%eax
   17888:	8b 00                	mov    (%eax),%eax
   1788a:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
	tmp_termio.c_oflag = tty->termios.c_oflag;
   1788f:	8b 44 24 30          	mov    0x30(%esp),%eax
   17893:	8b 40 04             	mov    0x4(%eax),%eax
   17896:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	tmp_termio.c_cflag = tty->termios.c_cflag;
   1789b:	8b 44 24 30          	mov    0x30(%esp),%eax
   1789f:	8b 40 08             	mov    0x8(%eax),%eax
   178a2:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	tmp_termio.c_lflag = tty->termios.c_lflag;
   178a7:	8b 44 24 30          	mov    0x30(%esp),%eax
   178ab:	8b 40 0c             	mov    0xc(%eax),%eax
   178ae:	66 89 44 24 10       	mov    %ax,0x10(%esp)
	tmp_termio.c_line = tty->termios.c_line;
   178b3:	8b 44 24 30          	mov    0x30(%esp),%eax
   178b7:	0f b6 40 10          	movzbl 0x10(%eax),%eax
   178bb:	88 44 24 12          	mov    %al,0x12(%esp)
	for(i=0 ; i < NCC ; i++)
   178bf:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   178c6:	00 
   178c7:	eb 21                	jmp    178ea <get_termio+0x7a>
		tmp_termio.c_cc[i] = tty->termios.c_cc[i];
   178c9:	8b 54 24 30          	mov    0x30(%esp),%edx
   178cd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   178d1:	01 d0                	add    %edx,%eax
   178d3:	83 c0 11             	add    $0x11,%eax
   178d6:	0f b6 00             	movzbl (%eax),%eax
   178d9:	8d 4c 24 13          	lea    0x13(%esp),%ecx
   178dd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   178e1:	01 ca                	add    %ecx,%edx
   178e3:	88 02                	mov    %al,(%edx)
	tmp_termio.c_iflag = tty->termios.c_iflag;
	tmp_termio.c_oflag = tty->termios.c_oflag;
	tmp_termio.c_cflag = tty->termios.c_cflag;
	tmp_termio.c_lflag = tty->termios.c_lflag;
	tmp_termio.c_line = tty->termios.c_line;
	for(i=0 ; i < NCC ; i++)
   178e5:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   178ea:	83 7c 24 1c 07       	cmpl   $0x7,0x1c(%esp)
   178ef:	7e d8                	jle    178c9 <get_termio+0x59>
		tmp_termio.c_cc[i] = tty->termios.c_cc[i];
	for (i=0 ; i< (sizeof (*termio)) ; i++)
   178f1:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   178f8:	00 
   178f9:	eb 2c                	jmp    17927 <get_termio+0xb7>
		put_fs_byte( ((char *)&tmp_termio)[i] , i+(char *)termio );
   178fb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   178ff:	8b 44 24 34          	mov    0x34(%esp),%eax
   17903:	01 c2                	add    %eax,%edx
   17905:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   17909:	8d 4c 24 0a          	lea    0xa(%esp),%ecx
   1790d:	01 c8                	add    %ecx,%eax
   1790f:	0f b6 00             	movzbl (%eax),%eax
   17912:	0f be c0             	movsbl %al,%eax
   17915:	83 ec 08             	sub    $0x8,%esp
   17918:	52                   	push   %edx
   17919:	50                   	push   %eax
   1791a:	e8 e4 fd ff ff       	call   17703 <put_fs_byte>
   1791f:	83 c4 10             	add    $0x10,%esp
	tmp_termio.c_cflag = tty->termios.c_cflag;
	tmp_termio.c_lflag = tty->termios.c_lflag;
	tmp_termio.c_line = tty->termios.c_line;
	for(i=0 ; i < NCC ; i++)
		tmp_termio.c_cc[i] = tty->termios.c_cc[i];
	for (i=0 ; i< (sizeof (*termio)) ; i++)
   17922:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   17927:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1792b:	83 f8 11             	cmp    $0x11,%eax
   1792e:	76 cb                	jbe    178fb <get_termio+0x8b>
		put_fs_byte( ((char *)&tmp_termio)[i] , i+(char *)termio );
	return 0;
   17930:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17935:	83 c4 2c             	add    $0x2c,%esp
   17938:	c3                   	ret    

00017939 <set_termio>:

/*
 * This only works as the 386 is low-byt-first
 */
static int set_termio(struct tty_struct * tty, struct termio * termio)
{
   17939:	53                   	push   %ebx
   1793a:	83 ec 20             	sub    $0x20,%esp
	int i;
	struct termio tmp_termio;

	for (i=0 ; i< (sizeof (*termio)) ; i++)
   1793d:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   17944:	00 
   17945:	eb 25                	jmp    1796c <set_termio+0x33>
		((char *)&tmp_termio)[i]=get_fs_byte(i+(char *)termio);
   17947:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1794b:	8d 54 24 0a          	lea    0xa(%esp),%edx
   1794f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   17952:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   17956:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   1795a:	01 d0                	add    %edx,%eax
   1795c:	50                   	push   %eax
   1795d:	e8 7d fd ff ff       	call   176df <get_fs_byte>
   17962:	83 c4 04             	add    $0x4,%esp
   17965:	88 03                	mov    %al,(%ebx)
static int set_termio(struct tty_struct * tty, struct termio * termio)
{
	int i;
	struct termio tmp_termio;

	for (i=0 ; i< (sizeof (*termio)) ; i++)
   17967:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   1796c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   17970:	83 f8 11             	cmp    $0x11,%eax
   17973:	76 d2                	jbe    17947 <set_termio+0xe>
		((char *)&tmp_termio)[i]=get_fs_byte(i+(char *)termio);
	*(unsigned short *)&tty->termios.c_iflag = tmp_termio.c_iflag;
   17975:	8b 44 24 28          	mov    0x28(%esp),%eax
   17979:	0f b7 54 24 0a       	movzwl 0xa(%esp),%edx
   1797e:	66 89 10             	mov    %dx,(%eax)
	*(unsigned short *)&tty->termios.c_oflag = tmp_termio.c_oflag;
   17981:	8b 44 24 28          	mov    0x28(%esp),%eax
   17985:	8d 50 04             	lea    0x4(%eax),%edx
   17988:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
   1798d:	66 89 02             	mov    %ax,(%edx)
	*(unsigned short *)&tty->termios.c_cflag = tmp_termio.c_cflag;
   17990:	8b 44 24 28          	mov    0x28(%esp),%eax
   17994:	8d 50 08             	lea    0x8(%eax),%edx
   17997:	0f b7 44 24 0e       	movzwl 0xe(%esp),%eax
   1799c:	66 89 02             	mov    %ax,(%edx)
	*(unsigned short *)&tty->termios.c_lflag = tmp_termio.c_lflag;
   1799f:	8b 44 24 28          	mov    0x28(%esp),%eax
   179a3:	8d 50 0c             	lea    0xc(%eax),%edx
   179a6:	0f b7 44 24 10       	movzwl 0x10(%esp),%eax
   179ab:	66 89 02             	mov    %ax,(%edx)
	tty->termios.c_line = tmp_termio.c_line;
   179ae:	0f b6 54 24 12       	movzbl 0x12(%esp),%edx
   179b3:	8b 44 24 28          	mov    0x28(%esp),%eax
   179b7:	88 50 10             	mov    %dl,0x10(%eax)
	for(i=0 ; i < NCC ; i++)
   179ba:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   179c1:	00 
   179c2:	eb 21                	jmp    179e5 <set_termio+0xac>
		tty->termios.c_cc[i] = tmp_termio.c_cc[i];
   179c4:	8d 54 24 13          	lea    0x13(%esp),%edx
   179c8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   179cc:	01 d0                	add    %edx,%eax
   179ce:	0f b6 00             	movzbl (%eax),%eax
   179d1:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   179d5:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   179d9:	01 ca                	add    %ecx,%edx
   179db:	83 c2 11             	add    $0x11,%edx
   179de:	88 02                	mov    %al,(%edx)
	*(unsigned short *)&tty->termios.c_iflag = tmp_termio.c_iflag;
	*(unsigned short *)&tty->termios.c_oflag = tmp_termio.c_oflag;
	*(unsigned short *)&tty->termios.c_cflag = tmp_termio.c_cflag;
	*(unsigned short *)&tty->termios.c_lflag = tmp_termio.c_lflag;
	tty->termios.c_line = tmp_termio.c_line;
	for(i=0 ; i < NCC ; i++)
   179e0:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
   179e5:	83 7c 24 1c 07       	cmpl   $0x7,0x1c(%esp)
   179ea:	7e d8                	jle    179c4 <set_termio+0x8b>
		tty->termios.c_cc[i] = tmp_termio.c_cc[i];
	change_speed(tty);
   179ec:	ff 74 24 28          	pushl  0x28(%esp)
   179f0:	e8 35 fd ff ff       	call   1772a <change_speed>
   179f5:	83 c4 04             	add    $0x4,%esp
	return 0;
   179f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   179fd:	83 c4 20             	add    $0x20,%esp
   17a00:	5b                   	pop    %ebx
   17a01:	c3                   	ret    

00017a02 <tty_ioctl>:

int tty_ioctl(int dev, int cmd, int arg)
{
   17a02:	83 ec 1c             	sub    $0x1c,%esp
	struct tty_struct * tty;
	if (MAJOR(dev) == 5) {
   17a05:	8b 44 24 20          	mov    0x20(%esp),%eax
   17a09:	c1 e8 08             	shr    $0x8,%eax
   17a0c:	83 f8 05             	cmp    $0x5,%eax
   17a0f:	75 28                	jne    17a39 <tty_ioctl+0x37>
		dev=current->tty;
   17a11:	a1 40 f1 01 00       	mov    0x1f140,%eax
   17a16:	8b 80 68 02 00 00    	mov    0x268(%eax),%eax
   17a1c:	89 44 24 20          	mov    %eax,0x20(%esp)
		if (dev<0)
   17a20:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   17a25:	79 1a                	jns    17a41 <tty_ioctl+0x3f>
			panic("tty_ioctl: dev<0");
   17a27:	83 ec 0c             	sub    $0xc,%esp
   17a2a:	68 30 93 01 00       	push   $0x19330
   17a2f:	e8 9a 0d ff ff       	call   87ce <panic>
   17a34:	83 c4 10             	add    $0x10,%esp
   17a37:	eb 08                	jmp    17a41 <tty_ioctl+0x3f>
	} else
		dev=MINOR(dev);
   17a39:	81 64 24 20 ff 00 00 	andl   $0xff,0x20(%esp)
   17a40:	00 
	tty = dev + tty_table;
   17a41:	8b 44 24 20          	mov    0x20(%esp),%eax
   17a45:	69 c0 60 0c 00 00    	imul   $0xc60,%eax,%eax
   17a4b:	05 40 f4 01 00       	add    $0x1f440,%eax
   17a50:	89 44 24 0c          	mov    %eax,0xc(%esp)
	switch (cmd) {
   17a54:	8b 44 24 24          	mov    0x24(%esp),%eax
   17a58:	2d 01 54 00 00       	sub    $0x5401,%eax
   17a5d:	83 f8 1a             	cmp    $0x1a,%eax
   17a60:	0f 87 b0 02 00 00    	ja     17d16 <tty_ioctl+0x314>
   17a66:	8b 04 85 44 93 01 00 	mov    0x19344(,%eax,4),%eax
   17a6d:	ff e0                	jmp    *%eax
		case TCGETS:
			return get_termios(tty,(struct termios *) arg);
   17a6f:	8b 44 24 28          	mov    0x28(%esp),%eax
   17a73:	83 ec 08             	sub    $0x8,%esp
   17a76:	50                   	push   %eax
   17a77:	ff 74 24 18          	pushl  0x18(%esp)
   17a7b:	e8 42 fd ff ff       	call   177c2 <get_termios>
   17a80:	83 c4 10             	add    $0x10,%esp
   17a83:	e9 93 02 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TCSETSF:
			flush(&tty->read_q); /* fallthrough */
   17a88:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17a8c:	83 c0 30             	add    $0x30,%eax
   17a8f:	83 ec 0c             	sub    $0xc,%esp
   17a92:	50                   	push   %eax
   17a93:	e8 14 fd ff ff       	call   177ac <flush>
   17a98:	83 c4 10             	add    $0x10,%esp
		case TCSETSW:
			wait_until_sent(tty); /* fallthrough */
   17a9b:	83 ec 0c             	sub    $0xc,%esp
   17a9e:	ff 74 24 18          	pushl  0x18(%esp)
   17aa2:	e8 17 fd ff ff       	call   177be <wait_until_sent>
   17aa7:	83 c4 10             	add    $0x10,%esp
		case TCSETS:
			return set_termios(tty,(struct termios *) arg);
   17aaa:	8b 44 24 28          	mov    0x28(%esp),%eax
   17aae:	83 ec 08             	sub    $0x8,%esp
   17ab1:	50                   	push   %eax
   17ab2:	ff 74 24 18          	pushl  0x18(%esp)
   17ab6:	e8 63 fd ff ff       	call   1781e <set_termios>
   17abb:	83 c4 10             	add    $0x10,%esp
   17abe:	e9 58 02 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TCGETA:
			return get_termio(tty,(struct termio *) arg);
   17ac3:	8b 44 24 28          	mov    0x28(%esp),%eax
   17ac7:	83 ec 08             	sub    $0x8,%esp
   17aca:	50                   	push   %eax
   17acb:	ff 74 24 18          	pushl  0x18(%esp)
   17acf:	e8 9c fd ff ff       	call   17870 <get_termio>
   17ad4:	83 c4 10             	add    $0x10,%esp
   17ad7:	e9 3f 02 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TCSETAF:
			flush(&tty->read_q); /* fallthrough */
   17adc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17ae0:	83 c0 30             	add    $0x30,%eax
   17ae3:	83 ec 0c             	sub    $0xc,%esp
   17ae6:	50                   	push   %eax
   17ae7:	e8 c0 fc ff ff       	call   177ac <flush>
   17aec:	83 c4 10             	add    $0x10,%esp
		case TCSETAW:
			wait_until_sent(tty); /* fallthrough */
   17aef:	83 ec 0c             	sub    $0xc,%esp
   17af2:	ff 74 24 18          	pushl  0x18(%esp)
   17af6:	e8 c3 fc ff ff       	call   177be <wait_until_sent>
   17afb:	83 c4 10             	add    $0x10,%esp
		case TCSETA:
			return set_termio(tty,(struct termio *) arg);
   17afe:	8b 44 24 28          	mov    0x28(%esp),%eax
   17b02:	83 ec 08             	sub    $0x8,%esp
   17b05:	50                   	push   %eax
   17b06:	ff 74 24 18          	pushl  0x18(%esp)
   17b0a:	e8 2a fe ff ff       	call   17939 <set_termio>
   17b0f:	83 c4 10             	add    $0x10,%esp
   17b12:	e9 04 02 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TCSBRK:
			if (!arg) {
   17b17:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   17b1c:	75 1e                	jne    17b3c <tty_ioctl+0x13a>
				wait_until_sent(tty);
   17b1e:	83 ec 0c             	sub    $0xc,%esp
   17b21:	ff 74 24 18          	pushl  0x18(%esp)
   17b25:	e8 94 fc ff ff       	call   177be <wait_until_sent>
   17b2a:	83 c4 10             	add    $0x10,%esp
				send_break(tty);
   17b2d:	83 ec 0c             	sub    $0xc,%esp
   17b30:	ff 74 24 18          	pushl  0x18(%esp)
   17b34:	e8 87 fc ff ff       	call   177c0 <send_break>
   17b39:	83 c4 10             	add    $0x10,%esp
			}
			return 0;
   17b3c:	b8 00 00 00 00       	mov    $0x0,%eax
   17b41:	e9 d5 01 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TCXONC:
			return -EINVAL; /* not implemented */
   17b46:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17b4b:	e9 cb 01 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TCFLSH:
			if (arg==0)
   17b50:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   17b55:	75 15                	jne    17b6c <tty_ioctl+0x16a>
				flush(&tty->read_q);
   17b57:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17b5b:	83 c0 30             	add    $0x30,%eax
   17b5e:	83 ec 0c             	sub    $0xc,%esp
   17b61:	50                   	push   %eax
   17b62:	e8 45 fc ff ff       	call   177ac <flush>
   17b67:	83 c4 10             	add    $0x10,%esp
   17b6a:	eb 59                	jmp    17bc5 <tty_ioctl+0x1c3>
			else if (arg==1)
   17b6c:	83 7c 24 28 01       	cmpl   $0x1,0x28(%esp)
   17b71:	75 17                	jne    17b8a <tty_ioctl+0x188>
				flush(&tty->write_q);
   17b73:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17b77:	05 40 04 00 00       	add    $0x440,%eax
   17b7c:	83 ec 0c             	sub    $0xc,%esp
   17b7f:	50                   	push   %eax
   17b80:	e8 27 fc ff ff       	call   177ac <flush>
   17b85:	83 c4 10             	add    $0x10,%esp
   17b88:	eb 3b                	jmp    17bc5 <tty_ioctl+0x1c3>
			else if (arg==2) {
   17b8a:	83 7c 24 28 02       	cmpl   $0x2,0x28(%esp)
   17b8f:	75 2a                	jne    17bbb <tty_ioctl+0x1b9>
				flush(&tty->read_q);
   17b91:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17b95:	83 c0 30             	add    $0x30,%eax
   17b98:	83 ec 0c             	sub    $0xc,%esp
   17b9b:	50                   	push   %eax
   17b9c:	e8 0b fc ff ff       	call   177ac <flush>
   17ba1:	83 c4 10             	add    $0x10,%esp
				flush(&tty->write_q);
   17ba4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17ba8:	05 40 04 00 00       	add    $0x440,%eax
   17bad:	83 ec 0c             	sub    $0xc,%esp
   17bb0:	50                   	push   %eax
   17bb1:	e8 f6 fb ff ff       	call   177ac <flush>
   17bb6:	83 c4 10             	add    $0x10,%esp
   17bb9:	eb 0a                	jmp    17bc5 <tty_ioctl+0x1c3>
			} else
				return -EINVAL;
   17bbb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17bc0:	e9 56 01 00 00       	jmp    17d1b <tty_ioctl+0x319>
			return 0;
   17bc5:	b8 00 00 00 00       	mov    $0x0,%eax
   17bca:	e9 4c 01 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TIOCEXCL:
			return -EINVAL; /* not implemented */
   17bcf:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17bd4:	e9 42 01 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TIOCNXCL:
			return -EINVAL; /* not implemented */
   17bd9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17bde:	e9 38 01 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TIOCSCTTY:
			return -EINVAL; /* set controlling term NI */
   17be3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17be8:	e9 2e 01 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TIOCGPGRP:
			verify_area((void *) arg,4);
   17bed:	8b 44 24 28          	mov    0x28(%esp),%eax
   17bf1:	83 ec 08             	sub    $0x8,%esp
   17bf4:	6a 04                	push   $0x4
   17bf6:	50                   	push   %eax
   17bf7:	e8 a8 04 ff ff       	call   80a4 <verify_area>
   17bfc:	83 c4 10             	add    $0x10,%esp
			put_fs_long(tty->pgrp,(unsigned long *) arg);
   17bff:	8b 44 24 28          	mov    0x28(%esp),%eax
   17c03:	8b 54 24 0c          	mov    0xc(%esp),%edx
   17c07:	8b 52 24             	mov    0x24(%edx),%edx
   17c0a:	83 ec 08             	sub    $0x8,%esp
   17c0d:	50                   	push   %eax
   17c0e:	52                   	push   %edx
   17c0f:	e8 09 fb ff ff       	call   1771d <put_fs_long>
   17c14:	83 c4 10             	add    $0x10,%esp
			return 0;
   17c17:	b8 00 00 00 00       	mov    $0x0,%eax
   17c1c:	e9 fa 00 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TIOCSPGRP:
			tty->pgrp=get_fs_long((unsigned long *) arg);
   17c21:	8b 44 24 28          	mov    0x28(%esp),%eax
   17c25:	83 ec 0c             	sub    $0xc,%esp
   17c28:	50                   	push   %eax
   17c29:	e8 bf fa ff ff       	call   176ed <get_fs_long>
   17c2e:	83 c4 10             	add    $0x10,%esp
   17c31:	89 c2                	mov    %eax,%edx
   17c33:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17c37:	89 50 24             	mov    %edx,0x24(%eax)
			return 0;
   17c3a:	b8 00 00 00 00       	mov    $0x0,%eax
   17c3f:	e9 d7 00 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TIOCOUTQ:
			verify_area((void *) arg,4);
   17c44:	8b 44 24 28          	mov    0x28(%esp),%eax
   17c48:	83 ec 08             	sub    $0x8,%esp
   17c4b:	6a 04                	push   $0x4
   17c4d:	50                   	push   %eax
   17c4e:	e8 51 04 ff ff       	call   80a4 <verify_area>
   17c53:	83 c4 10             	add    $0x10,%esp
			put_fs_long(CHARS(tty->write_q),(unsigned long *) arg);
   17c56:	8b 44 24 28          	mov    0x28(%esp),%eax
   17c5a:	8b 54 24 0c          	mov    0xc(%esp),%edx
   17c5e:	8b 8a 44 04 00 00    	mov    0x444(%edx),%ecx
   17c64:	8b 54 24 0c          	mov    0xc(%esp),%edx
   17c68:	8b 92 48 04 00 00    	mov    0x448(%edx),%edx
   17c6e:	29 d1                	sub    %edx,%ecx
   17c70:	89 ca                	mov    %ecx,%edx
   17c72:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   17c78:	83 ec 08             	sub    $0x8,%esp
   17c7b:	50                   	push   %eax
   17c7c:	52                   	push   %edx
   17c7d:	e8 9b fa ff ff       	call   1771d <put_fs_long>
   17c82:	83 c4 10             	add    $0x10,%esp
			return 0;
   17c85:	b8 00 00 00 00       	mov    $0x0,%eax
   17c8a:	e9 8c 00 00 00       	jmp    17d1b <tty_ioctl+0x319>
		case TIOCINQ:
			verify_area((void *) arg,4);
   17c8f:	8b 44 24 28          	mov    0x28(%esp),%eax
   17c93:	83 ec 08             	sub    $0x8,%esp
   17c96:	6a 04                	push   $0x4
   17c98:	50                   	push   %eax
   17c99:	e8 06 04 ff ff       	call   80a4 <verify_area>
   17c9e:	83 c4 10             	add    $0x10,%esp
			put_fs_long(CHARS(tty->secondary),
   17ca1:	8b 44 24 28          	mov    0x28(%esp),%eax
   17ca5:	8b 54 24 0c          	mov    0xc(%esp),%edx
   17ca9:	8b 8a 54 08 00 00    	mov    0x854(%edx),%ecx
   17caf:	8b 54 24 0c          	mov    0xc(%esp),%edx
   17cb3:	8b 92 58 08 00 00    	mov    0x858(%edx),%edx
   17cb9:	29 d1                	sub    %edx,%ecx
   17cbb:	89 ca                	mov    %ecx,%edx
   17cbd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   17cc3:	83 ec 08             	sub    $0x8,%esp
   17cc6:	50                   	push   %eax
   17cc7:	52                   	push   %edx
   17cc8:	e8 50 fa ff ff       	call   1771d <put_fs_long>
   17ccd:	83 c4 10             	add    $0x10,%esp
				(unsigned long *) arg);
			return 0;
   17cd0:	b8 00 00 00 00       	mov    $0x0,%eax
   17cd5:	eb 44                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCSTI:
			return -EINVAL; /* not implemented */
   17cd7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17cdc:	eb 3d                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCGWINSZ:
			return -EINVAL; /* not implemented */
   17cde:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17ce3:	eb 36                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCSWINSZ:
			return -EINVAL; /* not implemented */
   17ce5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17cea:	eb 2f                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCMGET:
			return -EINVAL; /* not implemented */
   17cec:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17cf1:	eb 28                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCMBIS:
			return -EINVAL; /* not implemented */
   17cf3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17cf8:	eb 21                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCMBIC:
			return -EINVAL; /* not implemented */
   17cfa:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17cff:	eb 1a                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCMSET:
			return -EINVAL; /* not implemented */
   17d01:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17d06:	eb 13                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCGSOFTCAR:
			return -EINVAL; /* not implemented */
   17d08:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17d0d:	eb 0c                	jmp    17d1b <tty_ioctl+0x319>
		case TIOCSSOFTCAR:
			return -EINVAL; /* not implemented */
   17d0f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17d14:	eb 05                	jmp    17d1b <tty_ioctl+0x319>
		default:
			return -EINVAL;
   17d16:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}
}
   17d1b:	83 c4 1c             	add    $0x1c,%esp
   17d1e:	c3                   	ret    

00017d1f <get_fs_byte>:
static inline unsigned char get_fs_byte(const char * addr)
{
   17d1f:	53                   	push   %ebx
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
   17d20:	8b 44 24 08          	mov    0x8(%esp),%eax
   17d24:	64 8a 00             	mov    %fs:(%eax),%al
   17d27:	89 c3                	mov    %eax,%ebx
	return _v;
   17d29:	89 d8                	mov    %ebx,%eax
}
   17d2b:	5b                   	pop    %ebx
   17d2c:	c3                   	ret    

00017d2d <math_emulate>:
void math_emulate(long edi, long esi, long ebp, long sys_call_ret,
	long eax,long ebx,long ecx,long edx,
	unsigned short fs,unsigned short es,unsigned short ds,
	unsigned long eip,unsigned short cs,unsigned long eflags,
	unsigned short ss, unsigned long esp)
{
   17d2d:	56                   	push   %esi
   17d2e:	53                   	push   %ebx
   17d2f:	83 ec 34             	sub    $0x34,%esp
   17d32:	8b 74 24 60          	mov    0x60(%esp),%esi
   17d36:	8b 5c 24 64          	mov    0x64(%esp),%ebx
   17d3a:	8b 4c 24 68          	mov    0x68(%esp),%ecx
   17d3e:	8b 54 24 70          	mov    0x70(%esp),%edx
   17d42:	8b 44 24 78          	mov    0x78(%esp),%eax
   17d46:	66 89 74 24 1c       	mov    %si,0x1c(%esp)
   17d4b:	66 89 5c 24 18       	mov    %bx,0x18(%esp)
   17d50:	66 89 4c 24 14       	mov    %cx,0x14(%esp)
   17d55:	66 89 54 24 10       	mov    %dx,0x10(%esp)
   17d5a:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	unsigned char first, second;

/* 0x0007 means user code space */
	if (cs != 0x000F) {
   17d5f:	66 83 7c 24 10 0f    	cmpw   $0xf,0x10(%esp)
   17d65:	74 2b                	je     17d92 <math_emulate+0x65>
		printk("math_emulate: %04x:%08x\n\r",cs,eip);
   17d67:	8b 54 24 6c          	mov    0x6c(%esp),%edx
   17d6b:	0f b7 44 24 10       	movzwl 0x10(%esp),%eax
   17d70:	83 ec 04             	sub    $0x4,%esp
   17d73:	52                   	push   %edx
   17d74:	50                   	push   %eax
   17d75:	68 b0 93 01 00       	push   $0x193b0
   17d7a:	e8 8e 0a ff ff       	call   880d <printk>
   17d7f:	83 c4 10             	add    $0x10,%esp
		panic("Math emulation needed in kernel");
   17d82:	83 ec 0c             	sub    $0xc,%esp
   17d85:	68 cc 93 01 00       	push   $0x193cc
   17d8a:	e8 3f 0a ff ff       	call   87ce <panic>
   17d8f:	83 c4 10             	add    $0x10,%esp
	}
	first = get_fs_byte((char *)((*&eip)++));
   17d92:	8b 44 24 6c          	mov    0x6c(%esp),%eax
   17d96:	8d 50 01             	lea    0x1(%eax),%edx
   17d99:	89 54 24 6c          	mov    %edx,0x6c(%esp)
   17d9d:	83 ec 0c             	sub    $0xc,%esp
   17da0:	50                   	push   %eax
   17da1:	e8 79 ff ff ff       	call   17d1f <get_fs_byte>
   17da6:	83 c4 10             	add    $0x10,%esp
   17da9:	88 44 24 2f          	mov    %al,0x2f(%esp)
	second = get_fs_byte((char *)((*&eip)++));
   17dad:	8b 44 24 6c          	mov    0x6c(%esp),%eax
   17db1:	8d 50 01             	lea    0x1(%eax),%edx
   17db4:	89 54 24 6c          	mov    %edx,0x6c(%esp)
   17db8:	83 ec 0c             	sub    $0xc,%esp
   17dbb:	50                   	push   %eax
   17dbc:	e8 5e ff ff ff       	call   17d1f <get_fs_byte>
   17dc1:	83 c4 10             	add    $0x10,%esp
   17dc4:	88 44 24 2e          	mov    %al,0x2e(%esp)
	printk("%04x:%08x %02x %02x\n\r",cs,eip-2,first,second);
   17dc8:	0f b6 4c 24 2e       	movzbl 0x2e(%esp),%ecx
   17dcd:	0f b6 54 24 2f       	movzbl 0x2f(%esp),%edx
   17dd2:	8b 44 24 6c          	mov    0x6c(%esp),%eax
   17dd6:	8d 58 fe             	lea    -0x2(%eax),%ebx
   17dd9:	0f b7 44 24 10       	movzwl 0x10(%esp),%eax
   17dde:	83 ec 0c             	sub    $0xc,%esp
   17de1:	51                   	push   %ecx
   17de2:	52                   	push   %edx
   17de3:	53                   	push   %ebx
   17de4:	50                   	push   %eax
   17de5:	68 ec 93 01 00       	push   $0x193ec
   17dea:	e8 1e 0a ff ff       	call   880d <printk>
   17def:	83 c4 20             	add    $0x20,%esp
	current->signal |= 1<<(SIGFPE-1);
   17df2:	a1 40 f1 01 00       	mov    0x1f140,%eax
   17df7:	8b 15 40 f1 01 00    	mov    0x1f140,%edx
   17dfd:	8b 52 0c             	mov    0xc(%edx),%edx
   17e00:	80 ca 80             	or     $0x80,%dl
   17e03:	89 50 0c             	mov    %edx,0xc(%eax)
}
   17e06:	90                   	nop
   17e07:	83 c4 34             	add    $0x34,%esp
   17e0a:	5b                   	pop    %ebx
   17e0b:	5e                   	pop    %esi
   17e0c:	c3                   	ret    

00017e0d <math_error>:

void math_error(void)
{
	__asm__("fnclex");
   17e0d:	db e2                	fnclex 
	if (last_task_used_math)
   17e0f:	a1 e8 1e 02 00       	mov    0x21ee8,%eax
   17e14:	85 c0                	test   %eax,%eax
   17e16:	74 14                	je     17e2c <math_error+0x1f>
		last_task_used_math->signal |= 1<<(SIGFPE-1);
   17e18:	a1 e8 1e 02 00       	mov    0x21ee8,%eax
   17e1d:	8b 15 e8 1e 02 00    	mov    0x21ee8,%edx
   17e23:	8b 52 0c             	mov    0xc(%edx),%edx
   17e26:	80 ca 80             	or     $0x80,%dl
   17e29:	89 50 0c             	mov    %edx,0xc(%eax)
}
   17e2c:	90                   	nop
   17e2d:	c3                   	ret    

00017e2e <_exit>:

#define __LIBRARY__
#include <unistd.h>

void _exit(int exit_code)
{
   17e2e:	53                   	push   %ebx
	__asm__ __volatile__ ("int $0x80"::"a" (__NR_exit),"b" (exit_code));
   17e2f:	b8 01 00 00 00       	mov    $0x1,%eax
   17e34:	8b 54 24 08          	mov    0x8(%esp),%edx
   17e38:	89 d3                	mov    %edx,%ebx
   17e3a:	cd 80                	int    $0x80
}
   17e3c:	90                   	nop
   17e3d:	5b                   	pop    %ebx
   17e3e:	c3                   	ret    

00017e3f <open>:
#define __LIBRARY__
#include <unistd.h>
#include <stdarg.h>

int open(const char * filename, int flag, ...)
{
   17e3f:	53                   	push   %ebx
   17e40:	83 ec 10             	sub    $0x10,%esp
	register int res;
	va_list arg;

	va_start(arg,flag);
   17e43:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   17e47:	83 c0 04             	add    $0x4,%eax
   17e4a:	89 44 24 0c          	mov    %eax,0xc(%esp)
	__asm__("int $0x80"
   17e4e:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
		:"=a" (res)
		:"0" (__NR_open),"b" (filename),"c" (flag),
		"d" (va_arg(arg,int)));
   17e52:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)
   17e57:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17e5b:	83 e8 04             	sub    $0x4,%eax
   17e5e:	8b 10                	mov    (%eax),%edx
{
	register int res;
	va_list arg;

	va_start(arg,flag);
	__asm__("int $0x80"
   17e60:	b8 05 00 00 00       	mov    $0x5,%eax
   17e65:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   17e69:	cd 80                	int    $0x80
   17e6b:	89 c3                	mov    %eax,%ebx
		:"=a" (res)
		:"0" (__NR_open),"b" (filename),"c" (flag),
		"d" (va_arg(arg,int)));
	if (res>=0)
   17e6d:	85 db                	test   %ebx,%ebx
   17e6f:	78 04                	js     17e75 <open+0x36>
		return res;
   17e71:	89 d8                	mov    %ebx,%eax
   17e73:	eb 0e                	jmp    17e83 <open+0x44>
	errno = -res;
   17e75:	89 d8                	mov    %ebx,%eax
   17e77:	f7 d8                	neg    %eax
   17e79:	a3 68 5f 02 00       	mov    %eax,0x25f68
	return -1;
   17e7e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   17e83:	83 c4 10             	add    $0x10,%esp
   17e86:	5b                   	pop    %ebx
   17e87:	c3                   	ret    

00017e88 <close>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall1(int,close,int,fd)
   17e88:	53                   	push   %ebx
   17e89:	83 ec 10             	sub    $0x10,%esp
   17e8c:	b8 06 00 00 00       	mov    $0x6,%eax
   17e91:	8b 54 24 18          	mov    0x18(%esp),%edx
   17e95:	89 d3                	mov    %edx,%ebx
   17e97:	cd 80                	int    $0x80
   17e99:	89 44 24 0c          	mov    %eax,0xc(%esp)
   17e9d:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   17ea2:	78 06                	js     17eaa <close+0x22>
   17ea4:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17ea8:	eb 10                	jmp    17eba <close+0x32>
   17eaa:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17eae:	f7 d8                	neg    %eax
   17eb0:	a3 68 5f 02 00       	mov    %eax,0x25f68
   17eb5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17eba:	83 c4 10             	add    $0x10,%esp
   17ebd:	5b                   	pop    %ebx
   17ebe:	c3                   	ret    

00017ebf <write>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall3(int,write,int,fd,const char *,buf,off_t,count)
   17ebf:	53                   	push   %ebx
   17ec0:	83 ec 10             	sub    $0x10,%esp
   17ec3:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   17ec7:	b8 04 00 00 00       	mov    $0x4,%eax
   17ecc:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   17ed0:	8b 54 24 20          	mov    0x20(%esp),%edx
   17ed4:	cd 80                	int    $0x80
   17ed6:	89 44 24 0c          	mov    %eax,0xc(%esp)
   17eda:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   17edf:	78 06                	js     17ee7 <write+0x28>
   17ee1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17ee5:	eb 10                	jmp    17ef7 <write+0x38>
   17ee7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17eeb:	f7 d8                	neg    %eax
   17eed:	a3 68 5f 02 00       	mov    %eax,0x25f68
   17ef2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17ef7:	83 c4 10             	add    $0x10,%esp
   17efa:	5b                   	pop    %ebx
   17efb:	c3                   	ret    

00017efc <dup>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall1(int,dup,int,fd)
   17efc:	53                   	push   %ebx
   17efd:	83 ec 10             	sub    $0x10,%esp
   17f00:	b8 29 00 00 00       	mov    $0x29,%eax
   17f05:	8b 54 24 18          	mov    0x18(%esp),%edx
   17f09:	89 d3                	mov    %edx,%ebx
   17f0b:	cd 80                	int    $0x80
   17f0d:	89 44 24 0c          	mov    %eax,0xc(%esp)
   17f11:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   17f16:	78 06                	js     17f1e <dup+0x22>
   17f18:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17f1c:	eb 10                	jmp    17f2e <dup+0x32>
   17f1e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17f22:	f7 d8                	neg    %eax
   17f24:	a3 68 5f 02 00       	mov    %eax,0x25f68
   17f29:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17f2e:	83 c4 10             	add    $0x10,%esp
   17f31:	5b                   	pop    %ebx
   17f32:	c3                   	ret    

00017f33 <setsid>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall0(pid_t,setsid)
   17f33:	83 ec 10             	sub    $0x10,%esp
   17f36:	b8 42 00 00 00       	mov    $0x42,%eax
   17f3b:	cd 80                	int    $0x80
   17f3d:	89 44 24 0c          	mov    %eax,0xc(%esp)
   17f41:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   17f46:	78 06                	js     17f4e <setsid+0x1b>
   17f48:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17f4c:	eb 10                	jmp    17f5e <setsid+0x2b>
   17f4e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17f52:	f7 d8                	neg    %eax
   17f54:	a3 68 5f 02 00       	mov    %eax,0x25f68
   17f59:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17f5e:	83 c4 10             	add    $0x10,%esp
   17f61:	c3                   	ret    

00017f62 <execve>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall3(int,execve,const char *,file,char **,argv,char **,envp)
   17f62:	53                   	push   %ebx
   17f63:	83 ec 10             	sub    $0x10,%esp
   17f66:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   17f6a:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   17f6e:	8b 54 24 20          	mov    0x20(%esp),%edx
   17f72:	b8 0b 00 00 00       	mov    $0xb,%eax
   17f77:	cd 80                	int    $0x80
   17f79:	89 44 24 0c          	mov    %eax,0xc(%esp)
   17f7d:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   17f82:	78 06                	js     17f8a <execve+0x28>
   17f84:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17f88:	eb 10                	jmp    17f9a <execve+0x38>
   17f8a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17f8e:	f7 d8                	neg    %eax
   17f90:	a3 68 5f 02 00       	mov    %eax,0x25f68
   17f95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17f9a:	83 c4 10             	add    $0x10,%esp
   17f9d:	5b                   	pop    %ebx
   17f9e:	c3                   	ret    

00017f9f <waitpid>:

#define __LIBRARY__
#include <unistd.h>
#include <sys/wait.h>

_syscall3(pid_t,waitpid,pid_t,pid,int *,wait_stat,int,options)
   17f9f:	53                   	push   %ebx
   17fa0:	83 ec 10             	sub    $0x10,%esp
   17fa3:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   17fa7:	b8 07 00 00 00       	mov    $0x7,%eax
   17fac:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   17fb0:	8b 54 24 20          	mov    0x20(%esp),%edx
   17fb4:	cd 80                	int    $0x80
   17fb6:	89 44 24 0c          	mov    %eax,0xc(%esp)
   17fba:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   17fbf:	78 06                	js     17fc7 <waitpid+0x28>
   17fc1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17fc5:	eb 10                	jmp    17fd7 <waitpid+0x38>
   17fc7:	8b 44 24 0c          	mov    0xc(%esp),%eax
   17fcb:	f7 d8                	neg    %eax
   17fcd:	a3 68 5f 02 00       	mov    %eax,0x25f68
   17fd2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17fd7:	83 c4 10             	add    $0x10,%esp
   17fda:	5b                   	pop    %ebx
   17fdb:	c3                   	ret    

00017fdc <wait>:

pid_t wait(int * wait_stat)
{
	return waitpid(-1,wait_stat,0);
   17fdc:	6a 00                	push   $0x0
   17fde:	ff 74 24 08          	pushl  0x8(%esp)
   17fe2:	6a ff                	push   $0xffffffff
   17fe4:	e8 b6 ff ff ff       	call   17f9f <waitpid>
   17fe9:	83 c4 0c             	add    $0xc,%esp
}
   17fec:	c3                   	ret    
